{"id": "e7535d44-fb59-4c6a-a330-cf3487fcd57e", "solution": "import numpy as np\n\nclass AdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]))\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "AdaptiveSwarmGradientDescent", "description": "Adaptive Swarm Gradient Descent (ASGD): Combines swarm intelligence and gradient estimation to explore and exploit search space efficiently.", "configspace": "", "generation": 0, "fitness": 0.8264407036439114, "feedback": "The algorithm AdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.020. And the mean value of best solutions found was 0.133 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8041324604654931, 0.8227266579918504, 0.8524629924743906], "final_y": [0.1412466306774247, 0.13112094863304602, 0.12789490696654837]}, "mutation_prompt": null}
{"id": "29e94573-553e-45e1-af2f-c9678ae1b024", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * adaptive_factor  # Changed line\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.8  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]  # Added line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.5 * np.random.random(self.dim) * (neighborhood_best - swarm[i]))  # Changed line\n                velocity_scale = 0.5 + 0.5 * np.random.random()  # Added line\n                swarm[i] += velocity_scale * self.velocity[i]  # Changed line\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent (EASGD): Integrates adaptive velocity scaling and neighborhood-based learning for improved exploration and exploitation.", "configspace": "", "generation": 1, "fitness": 0.8518146486976933, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.852 with standard deviation 0.011. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "e7535d44-fb59-4c6a-a330-cf3487fcd57e", "metadata": {"aucs": [0.8377152286759844, 0.8535182478687787, 0.8642104695483168], "final_y": [0.12015705948588762, 0.11738535623180557, 0.12337905891115808]}, "mutation_prompt": null}
{"id": "1e6923ee-7858-4944-a591-ae257783d78b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.8 * np.random.random()  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.5 * np.random.random(self.dim) * (neighborhood_best - swarm[i]))\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent (EASGD) with Stochastic Social Coefficient: Introduces a dynamic stochastic social coefficient for better balance between exploration and exploitation.", "configspace": "", "generation": 2, "fitness": 0.8476100278095272, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.848 with standard deviation 0.010. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "29e94573-553e-45e1-af2f-c9678ae1b024", "metadata": {"aucs": [0.8414224166657921, 0.8393571803308415, 0.8620504864319481], "final_y": [0.13476913816336966, 0.13060384489279364, 0.12209069615988677]}, "mutation_prompt": null}
{"id": "feadc10a-c86b-49eb-bbc0-ee4e0b48dcb4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        dynamic_neighbors = np.random.randint(1, self.population_size // 2)  # Added line\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.8\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighbors = np.random.choice(self.population_size, dynamic_neighbors, replace=False)  # Changed line\n                neighborhood_best = personal_best[neighbors[np.argmin(personal_best_value[neighbors])]]  # Changed line\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.5 * np.random.random(self.dim) * (neighborhood_best - swarm[i]))\n\n                velocity_alignment = 0.6 * (global_best - swarm[i])  # Added line\n                swarm[i] += velocity_alignment + self.velocity[i]  # Changed line\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent with Dynamic Neighborhoods (EASGD-DN): Incorporates dynamic neighborhood-based learning and adaptive velocity alignment for refined solution quality and convergence speed.", "configspace": "", "generation": 3, "fitness": 0.8473566813863962, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.847 with standard deviation 0.023. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "29e94573-553e-45e1-af2f-c9678ae1b024", "metadata": {"aucs": [0.8160659839982785, 0.8575881015510429, 0.8684159586098671], "final_y": [0.1489415986463266, 0.126313403495959, 0.11622362080797188]}, "mutation_prompt": null}
{"id": "f1c86716-d4a5-4cac-befc-66eaa905fde9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor  # Changed line 1\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.5 * np.random.random(self.dim) * (neighborhood_best - swarm[i]))\n                velocity_scale = 0.4 + 0.6 * np.random.random()  # Changed line 2\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Improved Enhanced Adaptive Swarm Gradient Descent (IEASGD): Introduces dynamic social influence and refined adaptive velocity scaling for enhanced convergence.", "configspace": "", "generation": 4, "fitness": 0.8660367071172682, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.866 with standard deviation 0.014. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "29e94573-553e-45e1-af2f-c9678ae1b024", "metadata": {"aucs": [0.8661648870623431, 0.8486504193665471, 0.8832948149229147], "final_y": [0.12185806510931496, 0.12708959093989614, 0.11939168407956346]}, "mutation_prompt": null}
{"id": "3798ce98-d9ca-46df-8faf-fea540eca124", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.5 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                neighborhood_diversity = np.random.random()  # New line 1\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.5 * neighborhood_diversity * (neighborhood_best - swarm[i]))\n                velocity_scale = 0.4 + 0.6 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce neighborhood diversity factor to balance exploration and exploitation.", "configspace": "", "generation": 5, "fitness": 0.8386751260300684, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.839 with standard deviation 0.012. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "f1c86716-d4a5-4cac-befc-66eaa905fde9", "metadata": {"aucs": [0.8340244668375834, 0.8555483644230696, 0.8264525468295524], "final_y": [0.1346587861620674, 0.11876368719165631, 0.12151148768489106]}, "mutation_prompt": null}
{"id": "415ce9da-e874-4a47-aba7-a12d8e876531", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)  # Changed line 1\n            cognitive_coeff = 1.7 * adaptive_factor  # Changed line 2\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)  # Changed line 3\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.5 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) + \n                                    localized_influence)  # Changed line 4\n                velocity_scale = 0.4 + 0.6 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Optimized Enhanced Adaptive Swarm Gradient Descent (OEASGD): Incorporates dynamic inertia reduction and localized neighborhood search for improved convergence efficiency.", "configspace": "", "generation": 6, "fitness": 0.8973639117118112, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.897 with standard deviation 0.018. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "f1c86716-d4a5-4cac-befc-66eaa905fde9", "metadata": {"aucs": [0.8889717812357066, 0.8812574039569274, 0.9218625499427994], "final_y": [0.12026067339483781, 0.12714649855433524, 0.11071467459289008]}, "mutation_prompt": null}
{"id": "bb4a46cc-f825-45a2-a161-6a878526ef87", "solution": "import numpy as np\n\nclass HybridQuantumInspiredSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n        \n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.9 * adaptive_factor  # Changed line 1\n            cognitive_coeff = 1.5 + 0.5 * np.sin(adaptive_factor * np.pi)  # Changed line 2\n            social_coeff = 1.3 + 0.4 * np.cos(adaptive_factor * np.pi)  # Changed line 3\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                quantum_influence = np.random.uniform(-0.1, 0.1, self.dim) * adaptive_factor  # Changed line 4\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.5 * np.random.random(self.dim) * (np.mean(personal_best, axis=0) - swarm[i]) +  # Changed line 5\n                                    quantum_influence)  # Changed line 6\n                velocity_scale = 0.5 + 0.5 * np.random.random()  # Changed line 7\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "HybridQuantumInspiredSwarm", "description": "Hybrid Quantum-Inspired Adaptive Swarm Optimization: Integrates quantum superposition principles with adaptive swarm behavior to enhance exploration and exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.8881090974217094, "feedback": "The algorithm HybridQuantumInspiredSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.888 with standard deviation 0.022. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "415ce9da-e874-4a47-aba7-a12d8e876531", "metadata": {"aucs": [0.880469216244879, 0.8658720996791636, 0.9179859763410857], "final_y": [0.11817656749621075, 0.12482058901454018, 0.11007057129610398]}, "mutation_prompt": null}
{"id": "804b2c80-b5c7-4225-b11c-6422fcce62be", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.05, 0.05, self.dim)  # Changed line 1\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line 2\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()  # Changed line 3\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Adaptive Swarm Gradient Descent with Enhanced Neighborhood Exploration (ASGDE): Introduces dynamic neighborhood exploration and velocity scaling for improved search efficiency.", "configspace": "", "generation": 8, "fitness": 0.9282508374126385, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.928 with standard deviation 0.005. And the mean value of best solutions found was 0.111 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "415ce9da-e874-4a47-aba7-a12d8e876531", "metadata": {"aucs": [0.9214984597004842, 0.9311442868148718, 0.9321097657225593], "final_y": [0.11186869228242835, 0.11210895905418261, 0.11006670821152731]}, "mutation_prompt": null}
{"id": "5818810d-860e-4693-848a-22fcf06d45ad", "solution": "import numpy as np\n\nclass QuantumInspiredEnhancedSwarmDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.probability_amplitude = np.random.uniform(0, 1, (self.population_size, dim))  # Changed line 1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.05, 0.05, self.dim)\n                quantum_jump = np.random.choice([-1, 1], self.dim) * self.probability_amplitude[i]  # Changed line 2\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) + \n                                    localized_influence + \n                                    quantum_jump)  # Changed line 3\n                velocity_scale = 0.4 + 0.6 * np.random.random()  # Changed line 4\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n                    self.probability_amplitude[i] *= 1.05  # Changed line 5\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "QuantumInspiredEnhancedSwarmDescent", "description": "Quantum-Inspired Enhanced Swarm Descent (QIESD): Integrates quantum superposition and tunneling to enhance exploration in swarm-based optimization.", "configspace": "", "generation": 9, "fitness": 0.8488210340472776, "feedback": "The algorithm QuantumInspiredEnhancedSwarmDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.849 with standard deviation 0.068. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.025.", "error": "", "parent_id": "804b2c80-b5c7-4225-b11c-6422fcce62be", "metadata": {"aucs": [0.9073046198849105, 0.7533205272540135, 0.885837955002909], "final_y": [0.11732886624494576, 0.17275801193101592, 0.120978700209601]}, "mutation_prompt": null}
{"id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.05, 0.05, self.dim)  # Changed line 1\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line 2\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()  # Changed line 3\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Refined Enhanced Adaptive Swarm Gradient Descent with Dynamic Personal Best Adjustment: Integrates a small adjustment factor into personal best updates for optimized convergence.", "configspace": "", "generation": 10, "fitness": 0.9289544724499067, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.929 with standard deviation 0.005. And the mean value of best solutions found was 0.111 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "804b2c80-b5c7-4225-b11c-6422fcce62be", "metadata": {"aucs": [0.9257583027632765, 0.9359318228456417, 0.9251732917408018], "final_y": [0.11197807733287801, 0.11166870486982428, 0.1100455430096614]}, "mutation_prompt": null}
{"id": "41c5875f-384a-4b5c-b336-5199b66b0d2e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.adaptive_threshold = 0.1  # New line\n        self.grad_step_size = 0.01  # New line\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.4 * adaptive_factor  # Changed line\n            cognitive_coeff = 1.5 * adaptive_factor  # Changed line\n            social_coeff = 1.6 + 0.3 * adaptive_factor  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.02, 0.02, self.dim)  # Changed line\n               \n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.5 * np.random.random(self.dim) * (neighborhood_best - swarm[i]))  # Changed line\n\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                # Gradient-based local search step (New lines)\n                if np.random.random() < self.adaptive_threshold:\n                    gradient_step = np.clip(self.grad_step_size * np.sign(personal_best[i] - global_best), lb, ub)\n                    swarm[i] = np.clip(swarm[i] - gradient_step, lb, ub)\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Adaptive Inertia and Gradient-Based Local Search Integration enhances search efficiency by dynamically adjusting exploration and exploitation phases.", "configspace": "", "generation": 11, "fitness": 0.8346903514215022, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.835 with standard deviation 0.028. And the mean value of best solutions found was 0.132 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.8135744081080308, 0.8163789590570589, 0.8741176870994164], "final_y": [0.13822024013138856, 0.13708487407387848, 0.1200992802004186]}, "mutation_prompt": null}
{"id": "83ee1f37-1e42-4fdd-b98e-cb4a9693624a", "solution": "import numpy as np\n\nclass EnhancedStochasticSwarmDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 + 3 * int(np.sqrt(dim))  # Changed line 1\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.8 * (0.95 - adaptive_factor)  # Changed line 2\n            cognitive_coeff = 1.5 * adaptive_factor  # Changed line 3\n            social_coeff = 1.6 + 0.2 * adaptive_factor  # Changed line 4\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.03, 0.03, self.dim)  # Changed line 5\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.6 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line 6\n                                    localized_influence)\n                velocity_scale = 0.4 + 0.6 * np.random.random()  # Changed line 7\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line 8\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedStochasticSwarmDescent", "description": "Enhanced Stochastic Swarm Descent with Adaptive Velocity Damping: Introduces adaptive velocity damping and diversified exploration patterns to improve convergence stability and solution quality.", "configspace": "", "generation": 12, "fitness": 0.8987695745419657, "feedback": "The algorithm EnhancedStochasticSwarmDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.899 with standard deviation 0.010. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.9038824362148759, 0.9080758254864028, 0.8843504619246185], "final_y": [0.11819875557470261, 0.1134037680149883, 0.11260158022551292]}, "mutation_prompt": null}
{"id": "7b85912c-21f7-4754-8092-a83aaab16e96", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.05, 0.05, self.dim)  # Changed line 1\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line 2\n                                    localized_influence)\n                velocity_scale = 0.6 + 0.4 * np.random.random()  # Changed line 3\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce a refined velocity scale factor to enhance the swarm's dynamic range and convergence precision.", "configspace": "", "generation": 13, "fitness": 0.9138296021968598, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.914 with standard deviation 0.009. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.9037591142715762, 0.9255500539327806, 0.9121796383862228], "final_y": [0.11774159845778387, 0.109676860122358, 0.11044730825953353]}, "mutation_prompt": null}
{"id": "489120ca-a7bb-45cc-a5db-c35b70a962b5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 * (0.9 - adaptive_factor)  # Changed line\n            cognitive_coeff = 1.8 * adaptive_factor  # Changed line\n            social_coeff = 1.4 + 0.5 * adaptive_factor  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.6 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line\n                                    localized_influence)\n                velocity_scale = 0.6 + 0.4 * np.random.random()  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introducing Local Perturbation and Adaptive Social Influence for Enhanced Convergence in Swarm Optimization.", "configspace": "", "generation": 14, "fitness": 0.9148872743531324, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.915 with standard deviation 0.016. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.8941370420746177, 0.9179395671791114, 0.9325852138056682], "final_y": [0.1203814193076922, 0.11314313723757807, 0.11006923980212291]}, "mutation_prompt": null}
{"id": "078c410e-d545-4247-bd4f-60bee331e4c2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 * (0.8 - adaptive_factor)  # Changed line 1\n            cognitive_coeff = 1.9 * adaptive_factor  # Changed line 2\n            social_coeff = 1.6 + 0.2 * adaptive_factor  # Changed line 3\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n\n                # Multi-neighbor influence\n                neighbors = personal_best[np.random.choice(self.population_size, 2, replace=False)]\n                neighborhood_influence = np.mean(neighbors, axis=0) - swarm[i]  # Changed line 4\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.6 * np.random.random(self.dim) * neighborhood_influence +  # Changed line 5\n                                    np.random.uniform(-0.03, 0.03, self.dim))  # Changed line 6\n\n                velocity_scale = 0.4 + 0.6 * np.random.random()  # Changed line 7\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line 8\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Integrates Multi-Neighbor Adaptive Swarm Influence with Dynamic Velocity Adjustment for Enhanced Convergence.", "configspace": "", "generation": 15, "fitness": 0.8972645810780094, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.897 with standard deviation 0.027. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.8689775387602559, 0.889814540820514, 0.9330016636532582], "final_y": [0.12923367834245914, 0.12572250665308005, 0.11101845164495994]}, "mutation_prompt": null}
{"id": "8afc183d-3f88-4228-a343-547cb08cf6eb", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.05, 0.05, self.dim)  # Changed line 1\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line 2\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()  # Changed line 3\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                # Introduce Multi-swarm Interaction\n                if evaluations % (self.population_size * 5) == 0:  # Changed line\n                    for j in range(self.population_size):\n                        if personal_best_value[j] < global_best_value:\n                            global_best = personal_best[j]\n                            global_best_value = personal_best_value[j]\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce Multi-swarm Interaction to Enhance Exploration through Occasional Swarm Best Sharing.", "configspace": "", "generation": 16, "fitness": 0.9289288688624563, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.929 with standard deviation 0.005. And the mean value of best solutions found was 0.111 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.9257374906765705, 0.9358758241699965, 0.9251732917408018], "final_y": [0.1119566636649848, 0.11163338420043056, 0.1100455430096614]}, "mutation_prompt": null}
{"id": "ce4fc99a-9227-4321-8084-89e82d66d625", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.entropy_weight = 0.5  # Changed line 1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            entropy_factor = 1 - (np.var(personal_best_value) / np.mean(personal_best_value))  # Changed line 2\n            inertia_weight = 0.7 * (0.9 - adaptive_factor * self.entropy_weight)  # Changed line 3\n            cognitive_coeff = 1.7 * adaptive_factor * entropy_factor  # Changed line 4\n            social_coeff = 1.5 + 0.3 * adaptive_factor * entropy_factor  # Changed line 5\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.05, 0.05, self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random() \n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line 6\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "QuantumInspiredAdaptiveSwarm", "description": "Quantum-Inspired Adaptive Swarm with Entropy-Based Learning: Introduces quantum-inspired swarm dynamics and entropy-based parameter adjustment for enhanced exploration and exploitation balance.", "configspace": "", "generation": 17, "fitness": 0.9235333044191402, "feedback": "The algorithm QuantumInspiredAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.924 with standard deviation 0.012. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.9090743291109515, 0.9241887729039628, 0.9373368112425065], "final_y": [0.11734530317397551, 0.11201670464172775, 0.10999045494188764]}, "mutation_prompt": null}
{"id": "ac3401d3-7b5b-4ed2-8526-e228e5652451", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 * (0.9 - adaptive_factor)  # Changed line 1\n            cognitive_coeff = 1.5 * adaptive_factor  # Changed line 2\n            social_coeff = 2.0 - 0.5 * adaptive_factor  # Changed line 3\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)  # Changed line 4\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.5 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line 5\n                                    localized_influence)\n                velocity_scale = 0.6 + 0.4 * np.random.random()  # Changed line 6\n                mutation = np.random.normal(0, 0.1, self.dim) * adaptive_factor  # Changed line 7\n                swarm[i] += velocity_scale * self.velocity[i] + mutation  # Changed line 8\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line 9\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Integrated Local Search and Adaptive Mutation in Swarm Optimization: Combines localized search and adaptive mutation for enhanced exploration and convergence.", "configspace": "", "generation": 18, "fitness": 0.8911223046092998, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.891 with standard deviation 0.056. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.017.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.8151681173190823, 0.9111846838325763, 0.9470141126762407], "final_y": [0.149769488115572, 0.11693489242155142, 0.11000570543947352]}, "mutation_prompt": null}
{"id": "a3b92867-e3f0-4647-8830-93e5a6680d77", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.05, 0.05, self.dim)  # Changed line 1\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line 2\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * (1 - np.exp(-adaptive_factor * evaluations/self.budget))  # Changed line 3\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce a non-linear damping factor to enhance swarm diversity and convergence control.", "configspace": "", "generation": 19, "fitness": 0.8874528677120844, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.887 with standard deviation 0.010. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.878679099516685, 0.8830126717537975, 0.9006668318657707], "final_y": [0.11941325395079871, 0.11946441390683804, 0.11792072082013327]}, "mutation_prompt": null}
{"id": "c0ad0c48-5eea-49cc-99a7-f2ba8d4ba4b1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.9 * (0.5 + adaptive_factor)  # Changed line 1\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)  # Changed line 2\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.75 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line 3\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.3 * np.random.random()  # Changed line 4\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.92 * swarm[i] + 0.08 * personal_best[i]  # Changed line 5\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Advanced Enhanced Swarm Gradient Descent with Adaptive Inertia and Neighborhood Exploration for improved convergence.", "configspace": "", "generation": 20, "fitness": 0.8270513429655417, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.827 with standard deviation 0.006. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.8333918408349337, 0.8289638583836542, 0.8187983296780375], "final_y": [0.11568287722452464, 0.12380398804391113, 0.12879528342197688]}, "mutation_prompt": null}
{"id": "86abbff2-5fab-43bd-89ce-ace39c9358be", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.quantum_factor = np.random.uniform(0.9, 1.1, (self.population_size, dim))  # Added line\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = np.cos(np.pi * evaluations / (2 * self.budget))  # Changed line\n            inertia_weight = 0.5 + 0.4 * np.sin(evaluations / self.budget)  # Changed line\n            cognitive_coeff = 1.5 - 0.5 * adaptive_factor  # Changed line\n            social_coeff = 2.0 - 0.5 * adaptive_factor  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.tanh(np.random.uniform(-0.1, 0.1, self.dim))  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.6 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line\n                                    localized_influence)\n                \n                velocity_scale = self.quantum_factor[i]  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduced a Diversity-Promoting Quantum Swarm with Adaptive Exploration Factors to enhance convergence and solution quality.", "configspace": "", "generation": 21, "fitness": 0.8366984649893695, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.837 with standard deviation 0.074. And the mean value of best solutions found was 0.141 (0. is the best) with standard deviation 0.029.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.9043145129995168, 0.7337015581962283, 0.8720793237723632], "final_y": [0.11492481931353993, 0.18094585066260294, 0.126645687353646]}, "mutation_prompt": null}
{"id": "b1dbfc78-d83e-4fd4-baa8-6dfbb921238e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.05, 0.05, self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                \n                # Bayesian weight adjustment\n                bayesian_weight = 0.3 + 0.4 * np.random.beta(2, 5)  # Changed line 1\n                swarm[i] += bayesian_weight * self.velocity[i]      # Changed line 2\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Swarm Gradient Descent with Bayesian Inference: Incorporates Bayesian inference for adaptive weight adjustment, improving convergence efficiency.", "configspace": "", "generation": 22, "fitness": 0.8196492017934545, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.820 with standard deviation 0.027. And the mean value of best solutions found was 0.138 (0. is the best) with standard deviation 0.017.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.7829570286913176, 0.8480093056010548, 0.827981271087991], "final_y": [0.1613661374774179, 0.12910807897942422, 0.12325058835384795]}, "mutation_prompt": null}
{"id": "95f79642-96a7-43fe-901e-e09a34c79407", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 * (0.9 - adaptive_factor)  # Changed line 1\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)  # Changed line 2\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.3 * np.random.random()  # Changed line 3\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent with Localized Velocity Tuning: Introduces adaptive neighborhood influence and dynamic inertia adjustment for improved exploration.", "configspace": "", "generation": 23, "fitness": 0.8990226867488502, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.899 with standard deviation 0.015. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.9068806993821643, 0.8776007130705135, 0.9125866477938729], "final_y": [0.11816620665654132, 0.11871317493812372, 0.11323521364545464]}, "mutation_prompt": null}
{"id": "a6221e18-f2c1-450e-835a-d8d8c18163cd", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                quantum_exploration = np.random.normal(0, 0.1, self.dim)  # Changed line 1\n                self.velocity[i] = (inertia_weight * (self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i])) +  # Changed line 2\n                                    0.7 * np.random.random() * (neighborhood_best - swarm[i]) +\n                                    quantum_exploration)  # Changed line 3\n                swarm[i] += self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Integrated Quantum-Inspired Exploration with Enhanced Swarm Dynamics for Improved Search Diversity.", "configspace": "", "generation": 24, "fitness": 0.8190597207670861, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.819 with standard deviation 0.008. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.8126370590050479, 0.829683303072533, 0.8148588002236773], "final_y": [0.1300099622505264, 0.1253104579391272, 0.11504402495098676]}, "mutation_prompt": null}
{"id": "691fd3ff-b0d5-47ba-a73f-d108aedc0723", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.6 * adaptive_factor + 0.1  # Changed line\n            social_coeff = 1.7 - 0.2 * adaptive_factor  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.05, 0.05, self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    adaptive_factor * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line\n                                    localized_influence)\n                velocity_scale = 0.6 + 0.4 * np.random.random()  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Swarm Gradient Descent with Dynamic Neighborhood Adjustment: Balances global exploration and local exploitation by adaptive neighborhood influence.", "configspace": "", "generation": 25, "fitness": 0.9132825115903319, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.913 with standard deviation 0.006. And the mean value of best solutions found was 0.112 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.921974254326411, 0.9085939955059654, 0.909279284938619], "final_y": [0.11088489184786732, 0.11324151678598138, 0.11089787732320078]}, "mutation_prompt": null}
{"id": "6cef04f9-7c78-455e-a924-3a515874c206", "solution": "import numpy as np\n\nclass GradientEnhancedSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.8 * (0.9 - adaptive_factor)  # Changed line\n            cognitive_coeff = 1.8 * adaptive_factor  # Changed line\n            social_coeff = 1.6 + 0.4 * adaptive_factor  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.05, 0.05, self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = np.exp(-0.1 * evaluations / self.budget)  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]  # Changed line\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.98 * swarm[i] + 0.02 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "GradientEnhancedSwarm", "description": "Gradient Enhanced Adaptive Swarm with Exponential Velocity Scaling: Introduces an exponential decay in velocity scaling for improved exploration-exploitation balance.", "configspace": "", "generation": 26, "fitness": 0.8912453778261987, "feedback": "The algorithm GradientEnhancedSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.891 with standard deviation 0.019. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.9183119326111614, 0.8754680173673508, 0.879956183500084], "final_y": [0.11322345545999024, 0.12112159982068593, 0.11934087334429722]}, "mutation_prompt": null}
{"id": "391124f8-830a-496f-b52a-3e29145020b1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)  # Changed line 1\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = (0.5 + 0.5 * np.random.random()) * adaptive_factor  # Changed line 2\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent with Extended Exploration: Introduces a decay factor in velocity scale and dynamically updates neighborhood influence for improved convergence.", "configspace": "", "generation": 27, "fitness": 0.910216080072606, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.910 with standard deviation 0.014. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.9002423821438335, 0.929363735059274, 0.9010421230147106], "final_y": [0.12203225301437504, 0.11427984102813538, 0.11924651987059909]}, "mutation_prompt": null}
{"id": "aca6db95-4478-4ec5-95cf-e8793e69fc2e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.4 * adaptive_factor  # Changed line 1\n            cognitive_coeff = 1.5 * adaptive_factor  # Changed line 2\n            social_coeff = 1.7 + 0.2 * adaptive_factor  # Changed line 3\n\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.random(self.dim), np.random.random(self.dim), np.random.random(self.dim)  # Changed line 4\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)  # Changed line 5\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.6 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line 6\n                                    0.5 * r3 * (np.random.uniform(lb, ub, self.dim) - swarm[i]) +  # Changed line 7\n                                    localized_influence)\n                velocity_scale = 0.4 + 0.6 * np.random.random()  # Changed line 8\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.92 * swarm[i] + 0.08 * personal_best[i]  # Changed line 9\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Quantum-Inspired Adaptive Swarm Gradient Descent: Integrates a quantum-inspired exploration mechanism for enhanced diversity and convergence.", "configspace": "", "generation": 28, "fitness": 0.8310042014261777, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.831 with standard deviation 0.009. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.8261572184945979, 0.8435953436787705, 0.8232600421051648], "final_y": [0.14360220591858497, 0.14240225905678672, 0.13523666310548677]}, "mutation_prompt": null}
{"id": "5a0d52f6-514b-47c2-a1c1-1bee05d2db88", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.8 * (0.9 - adaptive_factor)  # Changed line\n            cognitive_coeff = 1.9 * adaptive_factor  # Changed line\n            social_coeff = 1.5 + 0.4 * adaptive_factor  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.5 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line\n                                    localized_influence)\n                velocity_scale = 0.6 + 0.4 * np.random.random()  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Convergence of Adaptive Swarm Gradient Descent with Dynamic Neighborhood Influence and Optimized Inertia.", "configspace": "", "generation": 29, "fitness": 0.9216262934242662, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.922 with standard deviation 0.019. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.8948714962042101, 0.9343819607061811, 0.9356254233624074], "final_y": [0.1169618043159193, 0.11166642483802458, 0.10999119605209617]}, "mutation_prompt": null}
{"id": "7b2b4cd2-6cbb-4e58-b3c0-348c15c619b6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)  # Changed line 1\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.5 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line 2\n                                    localized_influence)\n                # Sigmoid velocity scale adjustment\n                velocity_scale = 1 / (1 + np.exp(-np.random.random()))  # Changed line 3\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line 4\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Optimized Adaptive Swarm with Sigmoid Velocity Adjustment: Incorporates a sigmoid function for velocity scaling to enhance convergence precision.", "configspace": "", "generation": 30, "fitness": 0.8875378652091843, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.888 with standard deviation 0.004. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.8927325236358293, 0.8846457990439816, 0.885235272947742], "final_y": [0.11316534639090747, 0.11997708959813158, 0.11507917245122146]}, "mutation_prompt": null}
{"id": "9db29bc9-1b40-46c1-84d4-54b7ffc1cc62", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.05, 0.05, self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Quantum-inspired mutation\n                mutation_scale = 0.1 * np.random.random(self.dim) * (ub - lb)\n                quantum_mutation = np.random.uniform(-mutation_scale, mutation_scale)\n                swarm[i] += quantum_mutation  # New mutation integration\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Refined Enhanced Adaptive Swarm Gradient Descent with Quantum-Inspired Mutation: Introduces quantum-inspired mutation for diverse exploration and improved convergence.", "configspace": "", "generation": 31, "fitness": 0.8842429847711912, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.884 with standard deviation 0.041. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.8987255012634464, 0.8288897276993848, 0.9251137253507427], "final_y": [0.11909776129019867, 0.1395093851510959, 0.1137274804547801]}, "mutation_prompt": null}
{"id": "bdd748d0-42fb-4010-ab97-2397269c915c", "solution": "import numpy as np\n\nclass ImprovedMultiInfluenceSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.4 * adaptive_factor  # Changed line 1\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                stochastic_herd = np.random.uniform(-0.1, 0.1, self.dim)  # Changed line 2\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    stochastic_herd)  # Changed line 3\n                velocity_scale = 0.4 + 0.6 * np.random.random()  # Changed line 4\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line 5\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "ImprovedMultiInfluenceSwarmOptimization", "description": "Improved Multi-Influence Swarm Optimization with Adaptive Inertia and Neighborhood Dynamics: Enhances convergence by introducing stochastic herd influence and adaptive inertia for better global exploration.", "configspace": "", "generation": 32, "fitness": 0.8385372407491447, "feedback": "The algorithm ImprovedMultiInfluenceSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.839 with standard deviation 0.034. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.7899964542270088, 0.8603204341961603, 0.865294833824265], "final_y": [0.1299451942822869, 0.12906705523049888, 0.12029561991273541]}, "mutation_prompt": null}
{"id": "35e48b7c-53c4-437d-876e-aa474e83fd7f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.learning_rate = 0.1  # Changed line 1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n            self.learning_rate *= 0.99  # Changed line 2\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.05, 0.05, self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                \n                # Diversity boost\n                diversity = np.random.uniform(-0.1, 0.1, self.dim) * adaptive_factor  # Changed line 3\n                swarm[i] += self.learning_rate * (velocity_scale * self.velocity[i] + diversity)  # Changed line 4\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Dynamic Swarm Gradient Descent with Adaptive Learning Rate and Population Diversity Boost to refine convergence and solution quality.", "configspace": "", "generation": 33, "fitness": 0.7617380869160519, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.762 with standard deviation 0.032. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.7680737934512141, 0.79796995012716, 0.7191705171697818], "final_y": [0.1644613619751123, 0.15850619612355543, 0.19103396660959382]}, "mutation_prompt": null}
{"id": "f04d211f-37aa-4a39-a5f9-20053969f0d5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.3 * adaptive_factor  # Changed line\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.05, 0.05, self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Improved Enhanced Adaptive Swarm Gradient Descent with Dynamic Inertia Weight Adjustment: Implements a dynamic adjustment of inertia weight for enhanced convergence speed and accuracy.", "configspace": "", "generation": 34, "fitness": 0.8548685683238699, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.855 with standard deviation 0.029. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.8146702128337429, 0.8687093987417689, 0.8812260933960981], "final_y": [0.1406665302612642, 0.11395345276108204, 0.12040884731154322]}, "mutation_prompt": null}
{"id": "6c17869b-4f28-4121-bef7-77d0f0b51634", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.8 * (0.9 - adaptive_factor)  # Changed line 1\n            cognitive_coeff = 1.5 * adaptive_factor  # Changed line 2\n            social_coeff = 1.6 + 0.2 * adaptive_factor  # Changed line 3\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size // 2)]  # Changed line 4 \n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)  # Changed line 5\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.5 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line 6\n                                    localized_influence)\n                mutation_strength = np.random.normal(0, 0.1, self.dim)  # Changed line 7\n                swarm[i] += self.velocity[i] + mutation_strength\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line 8\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Swarm Gradient Descent with Dynamic Neighborhood and Adaptive Mutation: Improves convergence by incorporating dynamic neighborhood selection and adaptive mutation strategies.", "configspace": "", "generation": 35, "fitness": 0.9258637994773878, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.011. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.9224442319082892, 0.9144985028558699, 0.9406486636680044], "final_y": [0.11188191080497378, 0.11622970531387422, 0.11000419123548277]}, "mutation_prompt": null}
{"id": "324b2fa0-bd4a-4f9c-bb51-066db66d3c03", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.02, 0.02, self.dim)  # Changed line 1\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.4 + 0.6 * np.random.random()  # Changed line 2\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Further Enhanced Adaptive Swarm Gradient Descent with Improved Local Influence and Variable Velocity Scaling: A refined technique that adjusts influence range and velocity scaling for better adaptability in convergence.", "configspace": "", "generation": 36, "fitness": 0.8978422567779519, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.898 with standard deviation 0.012. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.8837593678458618, 0.895830756594894, 0.9139366458931001], "final_y": [0.12142639932310573, 0.11678756960881675, 0.11271084684144028]}, "mutation_prompt": null}
{"id": "379a9aef-bf85-4f3b-8285-0a425323730d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n        exploration_factor = 0.1  # Changed line 1\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor + 0.1  # Changed line 2\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-exploration_factor, exploration_factor, self.dim)  # Changed line 3\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.3 + 0.6 * np.random.random()  # Changed line 4\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line 5\n                    personal_best_value[i] = f_value\n\n                if evaluations % (self.population_size // 2) == 0:  # Changed line 6\n                    exploration_factor *= 0.9  # Changed line 7\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Advanced Dynamic Swarm Optimization with Neighborhood Influence and Adaptive Velocity Scaling: Enhances convergence with periodic local explorations and strategic velocity adjustments.", "configspace": "", "generation": 37, "fitness": 0.879768294330832, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.880 with standard deviation 0.017. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.8773348072025535, 0.8602549760942964, 0.901715099695646], "final_y": [0.12795569623695557, 0.12959792947997673, 0.12117186874456076]}, "mutation_prompt": null}
{"id": "008d4299-6f26-49e5-bad9-413983e9a3b9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - 0.5 * adaptive_factor)  # Changed line\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.05, 0.05, self.dim)  # Changed line 1\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line 2\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()  # Changed line 3\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent with Selective Inertia Weight: Utilizes dynamically adjusted inertia weight based on the iteration progress to enhance convergence efficiency.", "configspace": "", "generation": 38, "fitness": 0.9041540616575263, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.904 with standard deviation 0.036. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.8533367650083755, 0.922777104357497, 0.9363483156067064], "final_y": [0.1347627361338507, 0.1116462031880715, 0.1096199743741797]}, "mutation_prompt": null}
{"id": "6c93fd60-03c5-45fa-baa8-deccde99345e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 * (0.9 - adaptive_factor)  # Changed line 1\n            cognitive_coeff = 1.9 * adaptive_factor  # Changed line 2\n            social_coeff = 1.6 + 0.3 * adaptive_factor  # Changed line 3\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                gradient_attraction = 0.1 * (global_best - swarm[i])  # Changed line 4\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * gradient_attraction +  # Changed line 5\n                                    np.random.random(self.dim) * (neighborhood_best - swarm[i]))\n                velocity_scale = 0.6 + 0.4 * np.random.random()  # Changed line 6\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line 7\n                    personal_best_value[i] = f_value\n\n                # Local search enhancement\n                if evaluations < self.budget and np.random.rand() < 0.1:  # Changed line 8\n                    local_search_point = swarm[i] + np.random.normal(0, 0.1, self.dim)  # Changed line 9\n                    local_search_point = np.clip(local_search_point, lb, ub)  # Changed line 10\n                    f_local = func(local_search_point)\n                    evaluations += 1\n                    if f_local < f_value:\n                        swarm[i] = local_search_point\n                        f_value = f_local\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Refined Adaptive Swarm with Gradient Attraction and Local Search: Incorporates local search and gradient attraction to enhance convergence and precision.", "configspace": "", "generation": 39, "fitness": 0.8672860968047851, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.867 with standard deviation 0.010. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.8644283494564837, 0.8562360987850177, 0.8811938421728538], "final_y": [0.12818112342610644, 0.12919230655128844, 0.11615715666213378]}, "mutation_prompt": null}
{"id": "f582fdfb-c5cc-40d7-8a6d-088e9cf20367", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.1 * np.cos(np.pi * evaluations / self.budget)  # Changed line 1\n            cognitive_coeff = 2.0 * adaptive_factor  # Changed line 2\n            social_coeff = 1.8 + 0.2 * adaptive_factor  # Changed line 3\n\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.random(self.dim), np.random.random(self.dim), np.random.random(self.dim)  # Changed line 4\n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.05, 0.05, self.dim)\n                random_vector = np.random.uniform(-1, 1, self.dim)  # Changed line 5\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.6 * r3 * (neighborhood_best - swarm[i]) +  # Changed line 6\n                                    localized_influence +\n                                    0.1 * random_vector)  # Changed line 7\n                velocity_scale = 0.4 + 0.6 * np.random.random()  # Changed line 8\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.90 * swarm[i] + 0.10 * personal_best[i]  # Changed line 9\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Refined Swarm-Based Gradient Descent with Adaptive Exploration-Exploitation Balance: Introduces directional diversity and adaptive inertia reduction for enhanced convergence.", "configspace": "", "generation": 40, "fitness": 0.8956833997998043, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.896 with standard deviation 0.015. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.8949707064147707, 0.8771909905883517, 0.91488850239629], "final_y": [0.11548462813429772, 0.11622462770425068, 0.11187583986317773]}, "mutation_prompt": null}
{"id": "db00a854-39da-4209-99dd-d97f26b598b3", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Randomized Local Neighborhood Influence: Introduces variability in neighborhood influence for diversified search.", "configspace": "", "generation": 41, "fitness": 0.9294524806117085, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.929 with standard deviation 0.005. And the mean value of best solutions found was 0.111 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a97c84c0-10f2-455a-8082-f6837d0f8e59", "metadata": {"aucs": [0.9267324995470255, 0.9362666039452462, 0.9253583383428536], "final_y": [0.1117690087270562, 0.1116282873354596, 0.11003746681680682]}, "mutation_prompt": null}
{"id": "9c50a23f-f406-463a-abf1-6b500a485958", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.5 + 0.5 * np.sin(0.5 * evaluations)  # Changed line\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.sin(0.5 * evaluations)  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Swarm Optimization with Dynamic Learning Strategy and Adaptive Neighborhood Exploration: Introduces dynamically adjusted learning rates and adaptive neighborhood exploration to improve convergence.", "configspace": "", "generation": 42, "fitness": 0.8852923336628863, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.885 with standard deviation 0.022. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "db00a854-39da-4209-99dd-d97f26b598b3", "metadata": {"aucs": [0.8540839686385739, 0.9014380171032221, 0.9003550152468626], "final_y": [0.11717328963798568, 0.1163703007190452, 0.11245921958082006]}, "mutation_prompt": null}
{"id": "ec92c92a-6653-4535-80a6-bc381d68899c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.9 - 0.5 * adaptive_factor  # Changed line\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.3 + 0.7 * np.random.random()  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduced dynamic velocity scaling and adaptive inertia weight decay for improved convergence stability.", "configspace": "", "generation": 43, "fitness": 0.9102553195715327, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.910 with standard deviation 0.003. And the mean value of best solutions found was 0.112 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "db00a854-39da-4209-99dd-d97f26b598b3", "metadata": {"aucs": [0.912347118253968, 0.911759473563375, 0.9066593668972555], "final_y": [0.11259326075754172, 0.1126665403824173, 0.11217669303274747]}, "mutation_prompt": null}
{"id": "18a6ebb6-4cc2-4e8e-b8e3-8573b6ac922f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)\n                directional_mutation = np.random.normal(0, 0.1, self.dim)  # New line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence + directional_mutation)  # Modified line\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]  # Modified line\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Diversified Adaptive Swarm Gradient Descent with Directional Mutation: Introduces directional mutation for enhanced exploration and exploiting potential high-performing solutions.  ", "configspace": "", "generation": 44, "fitness": 0.9185933075702898, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.919 with standard deviation 0.015. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "db00a854-39da-4209-99dd-d97f26b598b3", "metadata": {"aucs": [0.8997980019538014, 0.9206400002668627, 0.9353419204902053], "final_y": [0.11981781767191635, 0.11237337870179354, 0.1099908919646908]}, "mutation_prompt": null}
{"id": "90dd6ef0-d98e-4344-9003-3bffcc13c667", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                global_acceleration = 1.0 + 0.1 * adaptive_factor  # New factor for global convergence\n                swarm[i] += global_acceleration * velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Randomized Local Neighborhood Influence and Accelerated Global Convergence: Incorporates adaptive global convergence factor for improved solution precision.", "configspace": "", "generation": 45, "fitness": 0.9058327156230179, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.906 with standard deviation 0.023. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "db00a854-39da-4209-99dd-d97f26b598b3", "metadata": {"aucs": [0.8739791124856638, 0.9210497610967252, 0.9224692732866647], "final_y": [0.12049706319083886, 0.1099999030383999, 0.109990530771652]}, "mutation_prompt": null}
{"id": "8b37af0d-a097-40f1-825c-69cbbdfff5b4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)  \n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                \n                if evaluations/self.budget < 0.5:  # Introduce adaptive mutation rate\n                    mutation = 0.1 * np.random.randn(self.dim)\n                else:\n                    mutation = 0.05 * np.random.randn(self.dim)\n                    \n                self.velocity[i] += mutation  # Apply mutation\n                \n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduces a dynamic neighborhood influence and adaptive mutation for enhanced exploration and exploitation balance.", "configspace": "", "generation": 46, "fitness": 0.9039404998740667, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.904 with standard deviation 0.022. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "db00a854-39da-4209-99dd-d97f26b598b3", "metadata": {"aucs": [0.8944839548534937, 0.8825340941078872, 0.9348034506608194], "final_y": [0.11284750898706475, 0.12263651626870942, 0.109663143383403]}, "mutation_prompt": null}
{"id": "52c53d63-55f4-47f3-8eb4-95f61c3edc1a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim) * adaptive_factor  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Adaptive Localized Influence: Adjusts the localized influence factor dynamically for improved local exploration.", "configspace": "", "generation": 47, "fitness": 0.9292322537900523, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.929 with standard deviation 0.005. And the mean value of best solutions found was 0.111 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "db00a854-39da-4209-99dd-d97f26b598b3", "metadata": {"aucs": [0.9267790647113101, 0.9358946944355838, 0.9250230022232628], "final_y": [0.11179167129329759, 0.1116863691621599, 0.11001275685336165]}, "mutation_prompt": null}
{"id": "5aa437f4-0021-42a2-b138-8180eda18661", "solution": "import numpy as np\n\nclass SynergisticSwarmHeatmapDiversification:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.4 * adaptive_factor\n            cognitive_coeff = 2.0 * adaptive_factor\n            social_coeff = 1.7 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_index = np.random.choice(range(self.population_size), p=self._softmax(personal_best_value))\n                neighborhood_best = personal_best[neighborhood_index]\n                distance_factor = np.random.uniform(0.0, 1.0, self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.6 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    0.5 * distance_factor * (global_best - personal_best[i]))\n                velocity_scale = 0.6 + 0.4 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value\n\n    def _softmax(self, values):\n        exp_values = np.exp(-values)\n        return exp_values / np.sum(exp_values)", "name": "SynergisticSwarmHeatmapDiversification", "description": "Synergistic Swarm with Heatmap-Inspired Diversification: Leverages multi-scale influence and dynamic neighborhood selection for enhanced exploration and convergence.", "configspace": "", "generation": 48, "fitness": 0.8363644121015703, "feedback": "The algorithm SynergisticSwarmHeatmapDiversification got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.836 with standard deviation 0.014. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "db00a854-39da-4209-99dd-d97f26b598b3", "metadata": {"aucs": [0.8524685058206155, 0.81748450654181, 0.8391402239422852], "final_y": [0.12692499559655945, 0.12925705723331005, 0.13110592979319258]}, "mutation_prompt": null}
{"id": "aeacece5-1e7a-464e-a49c-9278e90140c3", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + np.random.uniform(-0.25, 0.25)  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]  # Changed line\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Stochastic Velocity Scaling: Introduces stochastic scaling to improve exploration and convergence balance.", "configspace": "", "generation": 49, "fitness": 0.8905465319861983, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.891 with standard deviation 0.010. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "db00a854-39da-4209-99dd-d97f26b598b3", "metadata": {"aucs": [0.8783917333230892, 0.8894159422159609, 0.9038319204195447], "final_y": [0.11836735131106535, 0.12340453935060769, 0.11559632745844306]}, "mutation_prompt": null}
{"id": "bde5d296-af64-4ee1-b1f3-a3ee589405ac", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 2.0 * adaptive_factor  # Changed line\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n\n                neighborhood_indices = np.random.choice(range(self.population_size), 3, replace=False)  # Changed line\n                neighborhood_best = personal_best[neighborhood_indices[np.argmin(personal_best_value[neighborhood_indices])]]  # Changed line\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Random walk mutation added\n                if np.random.rand() < 0.1:  # Changed line\n                    swarm[i] += np.random.normal(0, 0.1, self.dim)  # Changed line\n                    swarm[i] = np.clip(swarm[i], lb, ub)  # Changed line\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Improved Adaptive Swarm with Dynamic Neighborhood and Random Walk Mutation: Enhances exploration by introducing dynamic neighborhood selection and random walk mutation for diversification.", "configspace": "", "generation": 50, "fitness": 0.9195154880706816, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.920 with standard deviation 0.013. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "db00a854-39da-4209-99dd-d97f26b598b3", "metadata": {"aucs": [0.9093869625398664, 0.9113289956457988, 0.9378305060263793], "final_y": [0.11225163402342664, 0.11758765272811944, 0.11011829633369274]}, "mutation_prompt": null}
{"id": "8f5b0853-922e-4d0a-8542-fe441648dd36", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.base_population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evaluations = 0\n        adaptive_factor = 1\n\n        while evaluations < self.budget:\n            self.population_size = int(self.base_population_size * adaptive_factor)  # Dynamic population\n            swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n            personal_best = swarm.copy()\n            personal_best_value = np.array([func(x) for x in swarm])\n            global_best = personal_best[np.argmin(personal_best_value)]\n            global_best_value = np.min(personal_best_value)\n\n            while evaluations < self.budget:\n                inertia_weight = 0.7 * (0.9 - adaptive_factor)\n                cognitive_coeff = 1.7 * adaptive_factor\n                social_coeff = 1.5 + 0.3 * adaptive_factor\n\n                for i in range(self.population_size):\n                    r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                    neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                    localized_influence = np.random.uniform(-0.1, 0.1, self.dim)\n                    mutation = np.random.normal(0, 0.1, self.dim)  # Mutated exploration\n                    self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                        cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                        social_coeff * r2 * (global_best - swarm[i]) +\n                                        0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                        localized_influence + mutation)\n                    velocity_scale = 0.5 + 0.5 * np.random.random()\n                    swarm[i] += velocity_scale * self.velocity[i]\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n                    # Evaluate and update personal best\n                    f_value = func(swarm[i])\n                    evaluations += 1\n                    if f_value < personal_best_value[i]:\n                        personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                        personal_best_value[i] = f_value\n\n                    # Update global best\n                    if f_value < global_best_value:\n                        global_best = swarm[i]\n                        global_best_value = f_value\n\n                    if evaluations >= self.budget:\n                        break\n\n                adaptive_factor = 1 - evaluations / self.budget  # Update adaptive factor\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Dynamic Population Size and Mutated Exploration: Introduces dynamic population size adjustment and mutation-based exploration for improved convergence.", "configspace": "", "generation": 51, "fitness": 0.9093773678289255, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.909 with standard deviation 0.011. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "db00a854-39da-4209-99dd-d97f26b598b3", "metadata": {"aucs": [0.8937613599979036, 0.9149737017184159, 0.9193970417704569], "final_y": [0.1199107185925048, 0.11622190621236528, 0.112162862570233]}, "mutation_prompt": null}
{"id": "8a9c767d-5e6b-4ba5-8763-a3bb5e4f713e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.4 + 0.6 * np.random.random()  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.85 * swarm[i] + 0.15 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Randomized Local Neighborhood Influence and Dynamic Personal Best Update: Introduces dynamic adjustments to personal best influence and velocity scaling for improved convergence.", "configspace": "", "generation": 52, "fitness": 0.8978357523890198, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.898 with standard deviation 0.003. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "db00a854-39da-4209-99dd-d97f26b598b3", "metadata": {"aucs": [0.9015804282145694, 0.8951069823382454, 0.8968198466142446], "final_y": [0.11704143684491985, 0.11879871589448832, 0.11050983210248766]}, "mutation_prompt": null}
{"id": "7d6c861a-89d9-48fc-976d-7926fc2c654f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n        \n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.8 * adaptive_factor  # Changed line\n            social_coeff = 1.4 + 0.4 * adaptive_factor  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                guided_random_walk = np.random.normal(0, 0.1, self.dim)  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    guided_random_walk)  # Changed line\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Guided Random Walk: Integrates guided random walks in velocity updates for improved exploration and exploitation balance.", "configspace": "", "generation": 53, "fitness": 0.8995088642402568, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.900 with standard deviation 0.039. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "db00a854-39da-4209-99dd-d97f26b598b3", "metadata": {"aucs": [0.8436922377095843, 0.9255158468315235, 0.9293185081796629], "final_y": [0.13501683250548002, 0.1117155825459667, 0.11102283156794102]}, "mutation_prompt": null}
{"id": "9889f519-84d7-4084-9e82-adfbff698abe", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.4 * np.random.rand()  # Modified line\n            cognitive_coeff = 1.5 + 0.5 * np.random.rand()  # Modified line\n            social_coeff = 1.5 + 0.5 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.05, 0.15, self.dim)  # Modified line\n                velocity_mutation = 0.1 * np.random.randn(self.dim)  # New line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.5 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Modified line\n                                    localized_influence + velocity_mutation)  # Modified line\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Modified line\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Adaptive Swarm with Dynamic Neighborhood Adjustment: Integrates dynamic neighborhood scaling and velocity mutation for enhanced exploration.", "configspace": "", "generation": 54, "fitness": 0.8741284212598273, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.874 with standard deviation 0.014. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "db00a854-39da-4209-99dd-d97f26b598b3", "metadata": {"aucs": [0.86474802288664, 0.8935637975537023, 0.8640734433391395], "final_y": [0.11359265301267718, 0.11254664797809588, 0.12264253273349068]}, "mutation_prompt": null}
{"id": "9e966033-9496-42ec-b29a-db4da3737424", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * np.random.uniform(0.8, 1.2) * (0.9 - adaptive_factor)  # Changed line\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Stochastic Inertia Scaling: Adjusts inertia dynamically for improved exploration-exploitation balance.", "configspace": "", "generation": 55, "fitness": 0.9105372733723015, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.911 with standard deviation 0.003. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "db00a854-39da-4209-99dd-d97f26b598b3", "metadata": {"aucs": [0.9103813474882005, 0.9148809194000074, 0.9063495532286968], "final_y": [0.11746344123316066, 0.11624034956641971, 0.11218275495480023]}, "mutation_prompt": null}
{"id": "6ee269e1-5d06-4c2b-a88b-0659778902da", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * adaptive_factor  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Adaptive Velocity Scaling: Introduces adaptive velocity scaling for improved convergence stability.", "configspace": "", "generation": 56, "fitness": 0.8717422001441361, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.872 with standard deviation 0.025. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "db00a854-39da-4209-99dd-d97f26b598b3", "metadata": {"aucs": [0.8410453384852086, 0.902489717802273, 0.8716915441449263], "final_y": [0.13590276893791442, 0.11937377482344957, 0.12435858504951713]}, "mutation_prompt": null}
{"id": "2a42ba93-29ab-41ca-b8d8-19dbb01fa517", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.random(self.dim), np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)  \n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * r3 * (neighborhood_best - swarm[i]) * adaptive_factor +  # Changed line\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i] + np.random.normal(0, 0.01, self.dim)  # Changed line\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Dynamic Attraction and Random Perturbation: Introduces random perturbations and adaptive attraction balancing local and global influences.", "configspace": "", "generation": 57, "fitness": 0.9062237699555888, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.906 with standard deviation 0.009. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "db00a854-39da-4209-99dd-d97f26b598b3", "metadata": {"aucs": [0.8937323025023031, 0.909919580549099, 0.9150194268153642], "final_y": [0.11359257688177449, 0.11573322365096861, 0.11382214516683653]}, "mutation_prompt": null}
{"id": "f2a81a24-092b-4d60-b6f6-7f24b9192f93", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.normal(0, 0.1, self.dim)  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Dynamic Neighborhood Influence: Introduces variability in neighborhood influence for more robust exploration.", "configspace": "", "generation": 58, "fitness": 0.8914248778609029, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.891 with standard deviation 0.040. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "db00a854-39da-4209-99dd-d97f26b598b3", "metadata": {"aucs": [0.8350968748921886, 0.9117673317582229, 0.927410426932297], "final_y": [0.1345269709073731, 0.11622523330493006, 0.11022187662866711]}, "mutation_prompt": null}
{"id": "5baa7250-7a56-4272-82cf-f1046bbce31a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.8 * (0.9 - adaptive_factor)  # Modified line\n            cognitive_coeff = 1.8 * adaptive_factor  # Modified line\n            social_coeff = 1.6 + 0.2 * adaptive_factor  # Modified line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_indices = np.random.choice(self.population_size, size=3, replace=False)  # Modified line\n                neighborhood_best = personal_best[neighborhood_indices[np.argmin(personal_best_value[neighborhood_indices])]]  # Modified line\n                fitness_based_influence = np.tanh(personal_best_value[i] - global_best_value) * np.random.random(self.dim)  # Modified line\n                \n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    fitness_based_influence)  # Modified line\n                velocity_scale = 0.6 + 0.4 * np.random.random()  # Modified line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Adaptive Swarm with Dynamic Neighborhood and Fitness-Based Learning for diversification and exploitation balance.", "configspace": "", "generation": 59, "fitness": 0.8996560984240339, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.900 with standard deviation 0.029. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "db00a854-39da-4209-99dd-d97f26b598b3", "metadata": {"aucs": [0.8611336599624778, 0.9080150935713477, 0.929819541738276], "final_y": [0.13342459821356834, 0.11997230967398287, 0.11276064926820195]}, "mutation_prompt": null}
{"id": "9959a344-e691-496e-94bb-cc910a895678", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                proximity_factor = 0.5 + 0.5 * np.random.random() * np.linalg.norm(global_best - swarm[i]) / np.linalg.norm(ub - lb)  # Changed line\n                swarm[i] += proximity_factor * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduce dynamic velocity scaling based on proximity to global best for focused convergence.", "configspace": "", "generation": 60, "fitness": 0.8713053839175444, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.871 with standard deviation 0.019. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "db00a854-39da-4209-99dd-d97f26b598b3", "metadata": {"aucs": [0.8442275938487913, 0.886510200394016, 0.883178357509826], "final_y": [0.13697245158716498, 0.12321651147460055, 0.1178939977593707]}, "mutation_prompt": null}
{"id": "854f08ba-06ed-4459-a853-2a62b0da56eb", "solution": "import numpy as np\n\nclass QuantumInspiredSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.4 * np.cos(adaptive_factor * np.pi)  # Changed line\n            cognitive_coeff = 1.7 * np.tan(adaptive_factor * np.pi / 2)  # Changed line\n            social_coeff = 1.5 + 0.5 * np.sin(adaptive_factor * np.pi / 2)  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n\n                quantum_state = np.random.uniform(-1, 1, self.dim)  # Changed line\n                quantum_influence = 0.5 * quantum_state * adaptive_factor  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    quantum_influence)  # Changed line\n\n                velocity_scale = 0.4 + 0.6 * np.random.random()  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "QuantumInspiredSwarm", "description": "Quantum-Inspired Adaptive Swarm: Introduces quantum superposition and entanglement principles for enhanced global exploration and diversity.", "configspace": "", "generation": 61, "fitness": 0.8739294568077409, "feedback": "The algorithm QuantumInspiredSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.874 with standard deviation 0.007. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "db00a854-39da-4209-99dd-d97f26b598b3", "metadata": {"aucs": [0.863590183467625, 0.8779710116153393, 0.8802271753402583], "final_y": [0.1166370511071032, 0.11507968522025624, 0.1168970989239243]}, "mutation_prompt": null}
{"id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim) * (1 + adaptive_factor)  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Dynamic Randomized Local Influence: Introduces dynamic scaling of localized influence for more adaptive exploration.", "configspace": "", "generation": 62, "fitness": 0.9296138703614399, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.930 with standard deviation 0.004. And the mean value of best solutions found was 0.111 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "db00a854-39da-4209-99dd-d97f26b598b3", "metadata": {"aucs": [0.9269936398252718, 0.9357824379412871, 0.926065533317761], "final_y": [0.11178758753756912, 0.11162948191592859, 0.10998970434506838]}, "mutation_prompt": null}
{"id": "de759519-7a5a-488a-9132-8fc8f6f13ebf", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n\n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim) * (1 + adaptive_factor)\n                quantum_factor = np.random.uniform(-0.05, 0.05, self.dim) * np.exp(-adaptive_factor)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence + quantum_factor)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "QuantumInspiredAdaptiveSwarm", "description": "Introducing Quantum-Inspired Evolutionary Dynamics in Swarm Optimization for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 63, "fitness": 0.9081596330251723, "feedback": "The algorithm QuantumInspiredAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.908 with standard deviation 0.017. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.8867288835796737, 0.9099431928921925, 0.9278068226036508], "final_y": [0.12023397254257162, 0.11623001998639026, 0.11209528578585681]}, "mutation_prompt": null}
{"id": "69ef3135-0cc8-4633-8a5a-49b302f23a90", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim) * (1 + adaptive_factor)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.75 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Slightly increase the influence of the neighborhood best on velocity update for enhanced exploration.", "configspace": "", "generation": 64, "fitness": 0.9083217883360762, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.908 with standard deviation 0.006. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.902764160287243, 0.906368218627667, 0.9158329860933184], "final_y": [0.12028593021379674, 0.116244122582145, 0.11002526511700506]}, "mutation_prompt": null}
{"id": "8621624b-97d4-4401-9d64-b28afdb7d204", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.7 - adaptive_factor)  # Changed line\n            cognitive_coeff = 1.8 * adaptive_factor  # Changed line\n            social_coeff = 1.6 + 0.2 * adaptive_factor  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.2, 0.2, self.dim) * (1 + adaptive_factor)  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.6 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random() * adaptive_factor  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.90 * swarm[i] + 0.10 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Improved Adaptive Swarm with Enhanced Neighborhood Exploration and Dynamic Constriction: Refines neighborhood influence and introduces dynamic velocity constriction for better convergence.", "configspace": "", "generation": 65, "fitness": 0.8899555221359986, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.890 with standard deviation 0.010. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.887018421504169, 0.8791859096264527, 0.9036622352773741], "final_y": [0.12094350806881049, 0.12560471766886583, 0.11403337945379355]}, "mutation_prompt": null}
{"id": "9c968ae1-c912-4d02-9c70-33e3013c8466", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        # Initialize chaotic sequence\n        chaotic_sequence = np.random.rand(self.population_size, self.dim)\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.9 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.9 * adaptive_factor  # Changed line\n            social_coeff = 1.3 + 0.4 * adaptive_factor  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim) * (1 + adaptive_factor)\n                chaotic_sequence[i] = 4 * chaotic_sequence[i] * (1 - chaotic_sequence[i])  # Logistic map update\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.8 * chaotic_sequence[i] * (neighborhood_best - swarm[i]) +  # Changed line\n                                    localized_influence)\n                velocity_scale = 0.6 + 0.4 * np.random.random()  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.96 * swarm[i] + 0.04 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Chaotic Perturbation: Integrates chaotic maps to introduce diversified exploration and improve convergence stability.  ", "configspace": "", "generation": 66, "fitness": 0.9282091185360444, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.928 with standard deviation 0.003. And the mean value of best solutions found was 0.111 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.9302659124593626, 0.930062754520832, 0.9242986886279385], "final_y": [0.10966901956243169, 0.11163608004930303, 0.11208926967839783]}, "mutation_prompt": null}
{"id": "54238f8f-27ec-499b-9cf0-70f883876e6b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 * (0.9 - adaptive_factor)  # Changed line\n            cognitive_coeff = 1.8 * adaptive_factor  # Changed line\n            social_coeff = 1.4 + 0.3 * adaptive_factor  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.08, 0.08, self.dim) * (1 + adaptive_factor)  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.75 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line\n                                    localized_influence)\n                velocity_scale = 0.55 + 0.45 * np.random.random()  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Optimized Balancing and Local Dynamics: Employs fine-tuned inertia and dynamic scaling of local influence for improved exploration.", "configspace": "", "generation": 67, "fitness": 0.9018056408873202, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.902 with standard deviation 0.008. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.9060249190654581, 0.8907727249582956, 0.9086192786382071], "final_y": [0.11697884104911194, 0.12139940183017361, 0.11236395620459982]}, "mutation_prompt": null}
{"id": "d1126026-d4e4-4f32-beab-43869a92a665", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.3 * adaptive_factor  # Changed line\n            cognitive_coeff = 1.5 + 0.5 * adaptive_factor  # Changed line\n            social_coeff = 1.4 + 0.4 * adaptive_factor  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                if evaluations < self.budget / 2:  # Changed block\n                    localized_influence = np.random.uniform(-0.2, 0.2, self.dim) * (1 + 2 * adaptive_factor)  # Changed line\n                else:\n                    localized_influence = np.random.uniform(-0.05, 0.05, self.dim) * adaptive_factor  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = swarm[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Dual-Phase Dynamic Influence: Integrates dual-phase localized influence for stronger initial exploration and focused final convergence.", "configspace": "", "generation": 68, "fitness": 0.8364966288092353, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.836 with standard deviation 0.003. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.8363765377288267, 0.8326175453832781, 0.840495803315601], "final_y": [0.12388521267338604, 0.12814718477290699, 0.1261432910713166]}, "mutation_prompt": null}
{"id": "4e8dce12-77b7-4a36-9307-fdbbe2bbdd15", "solution": "import numpy as np\n\nclass HybridSwarmGradientAccent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 * (0.9 - adaptive_factor)  # Changed line\n            cognitive_coeff = 1.5 * adaptive_factor  # Changed line\n            social_coeff = 1.4 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.15, 0.15, self.dim) * (1 + adaptive_factor)  # Changed line\n\n                gradient = np.random.uniform(-0.1, 0.1, self.dim)  # Introduced line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.6 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line\n                                    gradient + localized_influence)  # Changed line\n\n                velocity_scale = 0.6 + 0.4 * np.random.random()  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "HybridSwarmGradientAccent", "description": "Hybrid Particle Swarm with Adaptive Randomized Local Influence and Gradient Accent: Integrates gradient information into swarm behavior for more efficient convergence.", "configspace": "", "generation": 69, "fitness": 0.8869838388522645, "feedback": "The algorithm HybridSwarmGradientAccent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.887 with standard deviation 0.044. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.827795958339232, 0.9011439699136601, 0.9320115883039013], "final_y": [0.14238522605964876, 0.11889214798429437, 0.10976909415470992]}, "mutation_prompt": null}
{"id": "1ff7b535-6596-4492-9226-2ec7c145b940", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim) * (1 + adaptive_factor)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = (0.5 + 0.5 * np.random.random()) * adaptive_factor  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduces dynamic velocity scaling based on adaptive factor for enhanced exploration-exploitation balance.", "configspace": "", "generation": 70, "fitness": 0.9108847345161665, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.911 with standard deviation 0.013. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.9018104105410405, 0.9296883236005192, 0.9011554694069398], "final_y": [0.1215281147060493, 0.11414349195820717, 0.11915760909394368]}, "mutation_prompt": null}
{"id": "cc8ed030-20b5-4f73-b075-504cc4e69cd5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.8 * adaptive_factor  # Changed line\n            social_coeff = 1.5 + 0.4 * adaptive_factor  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_indices = np.random.choice(self.population_size, size=3)  # Changed line\n                neighborhood_best_value = np.inf\n                for idx in neighborhood_indices:  # Changed line\n                    if personal_best_value[idx] < neighborhood_best_value:  # Changed line\n                        neighborhood_best_value = personal_best_value[idx]  # Changed line\n                        neighborhood_best = personal_best[idx].copy()  # Changed line\n                \n                localized_influence = np.random.uniform(-0.2, 0.2, self.dim) * (1 + adaptive_factor)  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.4 * np.random.random()  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Adaptive Neighborhood Swarm with Enhanced Randomized Influence: Incorporates a dynamic neighborhood selection and scaled random influence for improved performance.", "configspace": "", "generation": 71, "fitness": 0.9107724966537897, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.911 with standard deviation 0.024. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.8781053171577106, 0.9183601006888265, 0.9358520721148319], "final_y": [0.1271660269915461, 0.11199691203910223, 0.10999263383900626]}, "mutation_prompt": null}
{"id": "1132e035-21ab-4135-b7ef-5b6cc7f62ce4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = (1.5 + 0.3 * adaptive_factor) * adaptive_factor # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim) * (1 + adaptive_factor)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Global Influence Scaling in Swarm Descent: Adjusts the global influence scaling with a dynamically adaptive factor for improved convergence efficiency.", "configspace": "", "generation": 72, "fitness": 0.9146009869626944, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.915 with standard deviation 0.009. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.9210239902453611, 0.9207176882231831, 0.9020612824195391], "final_y": [0.11334559089344975, 0.11465201629283395, 0.11790690570986018]}, "mutation_prompt": null}
{"id": "d16ffc75-86f4-4b15-af6e-a736bcff5214", "solution": "# Description: Introduces a Self-Adaptive Dynamic Velocity Scaling for Enhanced Exploration-Exploitation Balance.\n# Code:\nimport numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.8 * (0.9 - adaptive_factor)  # Changed line\n            cognitive_coeff = 1.8 * adaptive_factor  # Changed line\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim) * (1 + adaptive_factor)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.6 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random() * adaptive_factor  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduces a Self-Adaptive Dynamic Velocity Scaling for Enhanced Exploration-Exploitation Balance.", "configspace": "", "generation": 73, "fitness": 0.9166605870893657, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.917 with standard deviation 0.011. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.9025881608385428, 0.9168178574229375, 0.9305757430066169], "final_y": [0.11671470804149597, 0.11271490129738526, 0.11005342835683873]}, "mutation_prompt": null}
{"id": "8ba235ac-308d-4b45-8a73-4cd1b7154e3e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.momentum = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                r3 = np.random.random(self.dim)  # New line for momentum\n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim) * (1 + adaptive_factor)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                self.momentum[i] = 0.9 * self.momentum[i] + 0.1 * self.velocity[i]  # Updated line\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * (self.velocity[i] + 0.5 * r3 * self.momentum[i])  # Updated line\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Incorporates Adaptive Momentum and Neighborhood Diversity to Enhance Exploration and Convergence.", "configspace": "", "generation": 74, "fitness": 0.9032124490611185, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.903 with standard deviation 0.014. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.8874194285804783, 0.92092839855873, 0.9012895200441476], "final_y": [0.12251645389277666, 0.1144427592045264, 0.11609739874004021]}, "mutation_prompt": null}
{"id": "0516215c-6b38-45eb-9ad4-66cbb959f2be", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim) * (1 + adaptive_factor)  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    adaptive_factor * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Dynamic Randomized Local Influence and Modified Neighborhood Impact: Incorporates neighborhood influence adjustment based on adaptive factor for improved convergence.", "configspace": "", "generation": 75, "fitness": 0.9117672069400419, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.912 with standard deviation 0.021. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.8821329687831332, 0.9276136190733926, 0.9255550329636002], "final_y": [0.12011369643181691, 0.1118611104406485, 0.11004969760436689]}, "mutation_prompt": null}
{"id": "870f37c8-33d6-473d-9198-bbba84872664", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.3 * adaptive_factor\n            cognitive_coeff = 1.5 + 0.5 * adaptive_factor\n            social_coeff = 1.5 + 0.2 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.15, 0.15, self.dim) * (1 + adaptive_factor) \n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.6 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.6 + 0.4 * np.random.random() \n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Adaptive Swarm with Dynamic Neighborhood Exploration: Enhances diversity through dynamic neighborhood adjustments and balance between local and global influence.", "configspace": "", "generation": 76, "fitness": 0.8536633350473842, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.854 with standard deviation 0.030. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.8312386716451612, 0.8333688996331942, 0.8963824338637976], "final_y": [0.1175456068922518, 0.12830637131705536, 0.1152911406803796]}, "mutation_prompt": null}
{"id": "3654bdd8-775f-41dc-87ed-e58a7fb8b46f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.4 * adaptive_factor  # Changed line\n            cognitive_coeff = 1.5 + 0.5 * adaptive_factor  # Changed line\n            social_coeff = 1.5 + 0.5 * adaptive_factor  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.2, 0.2, self.dim) * (1 + adaptive_factor)  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.6 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line\n                                    localized_influence)\n                velocity_scale = 0.5 + adaptive_factor * 0.5 * np.random.random()  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced swarm dynamics using adaptive velocity scaling and probabilistic neighborhood influence.", "configspace": "", "generation": 77, "fitness": 0.862085501001156, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.862 with standard deviation 0.004. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.857068902701565, 0.8619524363783078, 0.8672351639235953], "final_y": [0.1251689281800118, 0.11424478148091777, 0.12194799462136541]}, "mutation_prompt": null}
{"id": "c878b012-7d98-40e9-8f50-65ae5a94fa90", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.4 * adaptive_factor\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.3 + 0.5 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.2, 0.2, self.dim) * (1.2 + adaptive_factor)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.6 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                \n                perturbation = np.random.normal(0, 0.01, self.dim)  # New line\n                swarm[i] += self.velocity[i] + perturbation  # Modified line\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.92 * swarm[i] + 0.08 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Advanced Dynamic Swarm Adaptation with Randomized Differential Perturbations for enhanced exploration and convergence efficiency.", "configspace": "", "generation": 78, "fitness": 0.8465778882707871, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.847 with standard deviation 0.008. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.8496595467359559, 0.8549551117179612, 0.8351190063584443], "final_y": [0.11538912162445514, 0.12171921191537971, 0.12459723524501998]}, "mutation_prompt": null}
{"id": "d3046df3-7108-4d3e-a14d-5ff16f71b03a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.9 * (1 - adaptive_factor) + 0.4 * adaptive_factor  # Changed line\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.2, 0.2, self.dim) * (1 + adaptive_factor)  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Fine-tuned Adaptive Swarm with Enhanced Local Perturbation: Incorporates a dynamic inertia weight and localized perturbation scaling for refined convergence. ", "configspace": "", "generation": 79, "fitness": 0.9119823940525063, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.912 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.892392778814426, 0.912557098349503, 0.9309973049935898], "final_y": [0.12007994052745308, 0.11232787910148301, 0.11062502052435408]}, "mutation_prompt": null}
{"id": "1026bd90-5e73-4491-9007-3c46646bf446", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.mutation_prob = 0.1  # New line\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best_idx = np.random.randint(self.population_size)  # Modified line\n                neighborhood_best = personal_best[neighborhood_best_idx]  # Modified line\n                localized_influence = (np.random.uniform(-0.1, 0.1, self.dim) * \n                                       (1 + adaptive_factor))\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                \n                if np.random.random() < self.mutation_prob:  # New line\n                    mutation_strength = (ub - lb) * 0.1 * adaptive_factor  # New line\n                    swarm[i] += np.random.uniform(-mutation_strength, mutation_strength, self.dim) # New line\n                \n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Modified line\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Swarm with Adaptive Mutation and Improved Neighborhood Dynamics: Introduces adaptive mutation based on performance feedback and improved neighborhood influence for better exploration-exploitation balance.", "configspace": "", "generation": 80, "fitness": 0.9109188096133907, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.911 with standard deviation 0.020. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.8854116407810448, 0.9132651240052753, 0.9340796640538521], "final_y": [0.12333871195408008, 0.11626606304046883, 0.11018252965528885]}, "mutation_prompt": null}
{"id": "6deb411b-40ec-4af5-9508-31130549f269", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.momentum = 0.9  # Added line for momentum initialization\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim) * (1 + adaptive_factor)\n                self.velocity[i] = (self.momentum * self.velocity[i] +  # Modified line for momentum update\n                                    inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Dynamic Randomized Local Influence and Momentum Update: Introduces a momentum term in the velocity update for improved convergence stability and speed.", "configspace": "", "generation": 81, "fitness": 0.8319522201063613, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.832 with standard deviation 0.032. And the mean value of best solutions found was 0.145 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.7871000744307772, 0.8490071837470531, 0.8597494021412533], "final_y": [0.1578380370962127, 0.14062609415482474, 0.13520017394557282]}, "mutation_prompt": null}
{"id": "546fb8c0-424c-4e46-9bb0-3dce8a2df2f5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                differential_influence = np.random.uniform(-0.2, 0.2, self.dim) * adaptive_factor  # Changed\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.5 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    differential_influence)  # Changed\n                velocity_scale = 0.6 + 0.4 * np.random.random()  # Changed\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Self-Adaptive Differential Influence: Introduces self-adaptive differential influence for improved exploration and convergence.", "configspace": "", "generation": 82, "fitness": 0.9058800524650588, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.906 with standard deviation 0.025. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.8724030043829333, 0.9137990947163117, 0.9314380582959314], "final_y": [0.12100717495562385, 0.11578224659446446, 0.11005817765241865]}, "mutation_prompt": null}
{"id": "6233ad50-e1eb-4020-9552-00d711896b6f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.5 + 0.5 * adaptive_factor # Modified line\n            social_coeff = 1.4 + 0.4 * adaptive_factor # Modified line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.05, 0.05, self.dim) * (1 + adaptive_factor) # Modified line\n                directional_perturbation = 0.6 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) # Modified line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    directional_perturbation + localized_influence) # Modified line\n                velocity_scale = 0.6 + 0.4 * np.random.random() # Modified line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i] # Modified line\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Adaptive Particle Swarm with Enhanced Directional Perturbation: Incorporates directional mutation based on the best neighboring particles to improve exploration capability.", "configspace": "", "generation": 83, "fitness": 0.904451130843707, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.904 with standard deviation 0.011. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.8897224672823002, 0.9094489602864506, 0.91418196496237], "final_y": [0.11704213274905706, 0.11622535862836303, 0.11008430420397253]}, "mutation_prompt": null}
{"id": "538f8a06-e069-42f5-aaf2-0292d7f7a845", "solution": "import numpy as np\n\nclass RefinedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                perturbation = np.random.normal(0, 0.1, self.dim) * adaptive_factor  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    perturbation)  # Changed line\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    mutation = np.random.uniform(-0.05, 0.05, self.dim) * (1 - adaptive_factor)  # Changed line\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i] + mutation  # Changed line\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "RefinedAdaptiveSwarmGradientDescent", "description": "Refined Adaptive Swarm with Enhanced Localized Exploration: Incorporates dynamic perturbation and adaptive mutation for improved convergence and exploration balance.", "configspace": "", "generation": 84, "fitness": 0.896205221574298, "feedback": "The algorithm RefinedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.896 with standard deviation 0.023. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.9051247600232317, 0.9190413221606851, 0.8644495825389771], "final_y": [0.11400480600837581, 0.11621916359673623, 0.12344971897350987]}, "mutation_prompt": null}
{"id": "b4cb7f2b-1ed0-4db5-a41f-527597c0e1e3", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim) * (1 + adaptive_factor)  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Targeted Influence Shift: Implements strategic perturbation in swarm velocity for refined exploration.", "configspace": "", "generation": 85, "fitness": 0.9296138703614399, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.930 with standard deviation 0.004. And the mean value of best solutions found was 0.111 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.9269936398252718, 0.9357824379412871, 0.926065533317761], "final_y": [0.11178758753756912, 0.11162948191592859, 0.10998970434506838]}, "mutation_prompt": null}
{"id": "6956071b-658d-4e8c-8000-b542961b2fc6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.72 - 0.4 * adaptive_factor  # Changed line\n            cognitive_coeff = 1.9 - 0.2 * adaptive_factor  # Changed line\n            social_coeff = 1.2 + 0.5 * adaptive_factor  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_indices = np.random.choice(self.population_size, size=3, replace=False)  # Changed line\n                neighborhood_best = personal_best[neighborhood_indices[np.argmin(personal_best_value[neighborhood_indices])]]  # Changed line\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim) * (1 + adaptive_factor)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.8 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line\n                                    localized_influence)\n                velocity_scale = 0.4 + 0.6 * np.random.random()  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Dynamic Randomized Local Influence and Adaptive Neighborhood Scaling: Incorporates adaptive neighborhood scaling to improve convergence speed and solution quality.", "configspace": "", "generation": 86, "fitness": 0.9002013401484511, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.900 with standard deviation 0.025. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.9211517821736565, 0.8653009732706175, 0.9141512650010791], "final_y": [0.11680205061497151, 0.13146794662963368, 0.1125441195002177]}, "mutation_prompt": null}
{"id": "e3e33062-89f6-48c7-a7b9-1b4ae1379677", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.8 * adaptive_factor  # Changed line\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim) * (1 + adaptive_factor)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Improved Cognitive and Social Influence Weighting: Refined the adaptive calculation of social and cognitive coefficients for enhanced convergence.", "configspace": "", "generation": 87, "fitness": 0.9217121230201751, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.922 with standard deviation 0.011. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.9061339196118026, 0.9332675760946956, 0.9257348733540269], "final_y": [0.11982011267851111, 0.11172611986876269, 0.10999378152246075]}, "mutation_prompt": null}
{"id": "48ac0c20-2ed8-43c4-8de9-91519c95b75c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n        self.momentum = np.zeros((self.population_size, dim))  # Added line\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.3 * adaptive_factor  # Changed line\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.5 * adaptive_factor  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.random(self.dim), np.random.random(self.dim), np.random.random(self.dim)  # Changed line\n\n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.2, 0.2, self.dim) * (1 + adaptive_factor)  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * (r3 * (neighborhood_best - swarm[i]) + localized_influence))  # Changed line\n\n                self.momentum[i] = 0.9 * self.momentum[i] + self.velocity[i]  # Added line\n                swarm[i] += self.momentum[i]  # Changed line\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Refined Adaptive Swarm with Dynamic Momentum and Progressive Neighborhood Influence: Incorporates velocity-based momentum and progressive neighborhood influence for enhanced convergence and exploration balance.", "configspace": "", "generation": 88, "fitness": 0.778778614838941, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.779 with standard deviation 0.041. And the mean value of best solutions found was 0.163 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.7250370238499828, 0.7871497639293069, 0.8241490567375331], "final_y": [0.1766307893435346, 0.16297553518267827, 0.14936745832034548]}, "mutation_prompt": null}
{"id": "4bc6aeab-6e00-4966-a323-5262008171e5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 + 0.5 * adaptive_factor  # Changed line\n            social_coeff = 1.5 + 0.5 * (1 - adaptive_factor)  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim) * (1 + adaptive_factor)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Time-Variant Acceleration Coefficients: Uses time-variant coefficients to adaptively balance exploration and exploitation.", "configspace": "", "generation": 89, "fitness": 0.9082598838900954, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.908 with standard deviation 0.009. And the mean value of best solutions found was 0.111 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.8950501213940821, 0.9163527734699122, 0.9133767568062917], "final_y": [0.11237159000725772, 0.11165491093263102, 0.11026220188557978]}, "mutation_prompt": null}
{"id": "b8493fad-2651-4310-9c9e-b6c15242f9ce", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 * (0.9 - adaptive_factor)  # Changed line\n            cognitive_coeff = 1.5 * adaptive_factor  # Changed line\n            social_coeff = 1.4 + 0.4 * adaptive_factor  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                guided_perturbation = global_best + adaptive_factor * np.random.uniform(-0.05, 0.05, self.dim)  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.6 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line\n                                    guided_perturbation)  # Changed line\n                velocity_scale = 0.6 + 0.4 * np.random.random()  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Guided Perturbation: Introduces adaptive guided perturbation based on dynamic scaling for improved exploration and convergence.", "configspace": "", "generation": 90, "fitness": 0.733835154086156, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.734 with standard deviation 0.025. And the mean value of best solutions found was 0.184 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.7100152680882474, 0.76890311738062, 0.7225870767896003], "final_y": [0.19378172922779335, 0.1702433386818767, 0.1891529131021361]}, "mutation_prompt": null}
{"id": "38e01f7a-066a-4b9a-b3d7-03d0614e5043", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n\n                neighborhood_best = personal_best[np.random.choice(np.arange(self.population_size), size=2, replace=False)].mean(axis=0)\n                localized_influence = np.random.uniform(-0.05, 0.05, self.dim) * (1 + adaptive_factor)  # Adjusted line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.65 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Adjusted line\n                                    localized_influence)\n                velocity_scale = 0.6 + 0.4 * np.random.random()  # Adjusted line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.90 * swarm[i] + 0.10 * personal_best[i]  # Adjusted line\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Dual-Influence Dynamics: Integrates dual-neighborhood influence and velocity adaptation to improve convergence and exploration balance.", "configspace": "", "generation": 91, "fitness": 0.9145794601704682, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.915 with standard deviation 0.012. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.9137893666219729, 0.90070803982787, 0.9292409740615618], "final_y": [0.11684245523689407, 0.11506908329969157, 0.11037696653912843]}, "mutation_prompt": null}
{"id": "504173c2-a5b6-4f19-9d20-d700150f5cc7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.2, 0.2, self.dim) * (1 + adaptive_factor)  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Improved Diversity Control: Introduces a wider range of random local influence for better diversification.", "configspace": "", "generation": 92, "fitness": 0.9288019716625135, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.929 with standard deviation 0.004. And the mean value of best solutions found was 0.111 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.9258838411439934, 0.9343270079017253, 0.926195065941822], "final_y": [0.11176817116034976, 0.1116416061403599, 0.11001127086009677]}, "mutation_prompt": null}
{"id": "91028b8f-a980-41e8-8918-6087d1ffa986", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 + 0.3 * adaptive_factor  # Changed line\n            cognitive_coeff = 1.5 + 0.2 * adaptive_factor  # Changed line\n            social_coeff = 1.4 + 0.4 * adaptive_factor  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                quantum_perturbation = np.tanh(swarm[i] - global_best) * adaptive_factor  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.6 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line\n                                    quantum_perturbation)  # Changed line\n                velocity_scale = 0.4 + 0.6 * np.random.random()  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm with Quantum-Inspired Perturbations: Incorporates quantum-inspired local search perturbations for better exploration-exploitation balance.", "configspace": "", "generation": 93, "fitness": 0.8452154754743127, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.845 with standard deviation 0.011. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.8331138235159379, 0.843257406373227, 0.8592751965337734], "final_y": [0.1193523123757454, 0.12179284425571013, 0.12034175541042358]}, "mutation_prompt": null}
{"id": "e3527b32-986c-4de9-a4e2-dcd06074f5be", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.5 + 0.4 * (0.9 - adaptive_factor)  # Changed line\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim) * (1 + adaptive_factor)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhance local exploration through adaptive inertia weight modulation to boost convergence speed.", "configspace": "", "generation": 94, "fitness": 0.9114063889150508, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.911 with standard deviation 0.018. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.9054508519996617, 0.8930256318998331, 0.9357426828456576], "final_y": [0.11532531576139393, 0.11686911081034013, 0.11014572896297192]}, "mutation_prompt": null}
{"id": "9ef16f2a-7ad3-46bd-940a-27034d6e31b6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n            oscillation_factor = np.sin(evaluations * np.pi / self.budget)  # New line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.choice(self.population_size, p=self.calculate_probabilities(personal_best_value))]  # Changed line\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim) * (1 + adaptive_factor)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence * oscillation_factor)  # Changed line\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value\n\n    def calculate_probabilities(self, values):  # New function\n        inv_values = 1.0 / (values + 1e-10)\n        return inv_values / np.sum(inv_values)", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Enhanced Adaptive Swarm Gradient Descent with Dynamic Topological Influence: Incorporates dynamic neighbor selection and adaptive oscillation to refine balance in exploration and exploitation.", "configspace": "", "generation": 95, "fitness": 0.9028678191699372, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.903 with standard deviation 0.003. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.8990014779318786, 0.9029266795406048, 0.906675300037328], "final_y": [0.1198248326359922, 0.11627298526024277, 0.11434853954675772]}, "mutation_prompt": null}
{"id": "6032227e-2b15-4373-8393-3e1455ee4823", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim) * (1 + adaptive_factor)  # Changed line\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.8 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +  # Changed line\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.4 * np.random.random()  # Changed line\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Changed line\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Optimizing swarm dynamics with adaptive inertia and exploration, focusing on strategic convergence.", "configspace": "", "generation": 96, "fitness": 0.9019462529457912, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.902 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.88840468180167, 0.8936021123070353, 0.9238319647286685], "final_y": [0.11812600887727964, 0.11413685835532206, 0.10970827278039452]}, "mutation_prompt": null}
{"id": "43362fd8-b18c-490c-ba9a-5278242238a9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor)\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim) * (1 + adaptive_factor)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                \n                # Quantum-inspired mutation\n                quantum_mutation = np.random.uniform(-0.2, 0.2, self.dim) * (1 - adaptive_factor)\n                swarm[i] += self.velocity[i] + quantum_mutation\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Hybrid Adaptive Swarm with Quantum-inspired Mutation: Integrates quantum-inspired mutation for enhanced exploration and convergence.", "configspace": "", "generation": 97, "fitness": 0.9091233480738324, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.909 with standard deviation 0.008. And the mean value of best solutions found was 0.112 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.9043716098371286, 0.9020601388432328, 0.9209382955411358], "final_y": [0.11179103543734703, 0.11459971542663472, 0.11043822011795412]}, "mutation_prompt": null}
{"id": "2aa985fe-5da1-45a1-853c-98182ec18ce2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.7 * (0.9 - adaptive_factor) * (1 - (global_best_value / np.max(personal_best_value)))  # Changed line\n            cognitive_coeff = 1.7 * adaptive_factor\n            social_coeff = 1.5 + 0.3 * adaptive_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.randint(self.population_size)]\n                localized_influence = np.random.uniform(-0.1, 0.1, self.dim) * (1 + adaptive_factor)\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.7 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.95 * swarm[i] + 0.05 * personal_best[i]\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduces adaptive inertia weight scaling based on the best performance to enhance exploration-exploitation balance.", "configspace": "", "generation": 98, "fitness": 0.913266209034337, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.913 with standard deviation 0.012. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.9012196619119917, 0.9293826976889765, 0.9091962675020424], "final_y": [0.12086326106504042, 0.11279452949439206, 0.11294364127886714]}, "mutation_prompt": null}
{"id": "2b90b335-9d29-455a-b4a9-f7f95da66773", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.velocity = np.zeros((self.population_size, dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_value = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        # Constraint on function evaluations\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_factor = 1 - evaluations / self.budget\n            inertia_weight = 0.6 * (0.9 - adaptive_factor)  # Reduced inertia for quicker convergence\n            cognitive_coeff = 1.5 * adaptive_factor\n            social_coeff = 1.7 + 0.2 * adaptive_factor  # Adjusted social coefficient\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.random(self.dim), np.random.random(self.dim)\n                \n                neighborhood_best = personal_best[np.random.choice(range(self.population_size), size=3)].mean(axis=0)  # Hybrid topology\n                localized_influence = np.random.uniform(-0.05, 0.05, self.dim) * (1 + adaptive_factor)  # Refined influence\n                # Mutation for exploration\n                mutation = np.random.normal(0, 0.1, self.dim) * adaptive_factor\n\n                self.velocity[i] = (inertia_weight * self.velocity[i] +\n                                    cognitive_coeff * r1 * (personal_best[i] - swarm[i]) +\n                                    social_coeff * r2 * (global_best - swarm[i]) +\n                                    0.5 * np.random.random(self.dim) * (neighborhood_best - swarm[i]) +\n                                    mutation + localized_influence)\n                velocity_scale = 0.5 + 0.5 * np.random.random()\n                swarm[i] += velocity_scale * self.velocity[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Evaluate and update personal best\n                f_value = func(swarm[i])\n                evaluations += 1\n                if f_value < personal_best_value[i]:\n                    personal_best[i] = 0.9 * swarm[i] + 0.1 * personal_best[i]  # Increased adaptation\n                    personal_best_value[i] = f_value\n\n                # Update global best\n                if f_value < global_best_value:\n                    global_best = swarm[i]\n                    global_best_value = f_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best, global_best_value", "name": "EnhancedAdaptiveSwarmGradientDescent", "description": "Introduces hybrid swarm topology and adaptive mutation to enhance convergence speed and solution quality.", "configspace": "", "generation": 99, "fitness": 0.913228992919399, "feedback": "The algorithm EnhancedAdaptiveSwarmGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.913 with standard deviation 0.024. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "c7e7546d-e6d6-4363-8122-9fb154b5ba33", "metadata": {"aucs": [0.8839930345017232, 0.9130868924227741, 0.9426070518336999], "final_y": [0.11537807197999173, 0.11704893491503676, 0.11003621756827275]}, "mutation_prompt": null}
