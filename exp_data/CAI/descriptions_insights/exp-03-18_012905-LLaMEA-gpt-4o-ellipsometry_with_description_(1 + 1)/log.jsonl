{"id": "0b6cb531-379c-42ae-b491-0491e6e0a354", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Pitch adjustment\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "A hybrid harmony search and differential evolution algorithm that combines global exploration with local exploitation to efficiently optimize black box functions within given budget constraints.", "configspace": "", "generation": 0, "fitness": 0.1869734850737718, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.187 with standard deviation 0.041. And the mean value of best solutions found was 0.302 (0. is the best) with standard deviation 0.318.", "error": "", "parent_id": null, "metadata": {"aucs": [0.23955574861062034, 0.18204228615541107, 0.13932242045528398], "final_y": [0.06757480468435928, 0.08709608939099321, 0.750946027055325]}, "mutation_prompt": null}
{"id": "48240291-4fa3-46a2-96f5-a9306213d002", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "A hybrid harmony search and differential evolution algorithm with adaptive pitch adjustment to optimize black box functions efficiently within budget constraints.", "configspace": "", "generation": 1, "fitness": 0.28432088132688055, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.284 with standard deviation 0.114. And the mean value of best solutions found was 0.288 (0. is the best) with standard deviation 0.405.", "error": "", "parent_id": "0b6cb531-379c-42ae-b491-0491e6e0a354", "metadata": {"aucs": [0.28086803719490316, 0.4257847633748343, 0.14630984341090425], "final_y": [0.00377296837570191, 0.0006788518764079074, 0.8609311089730469]}, "mutation_prompt": null}
{"id": "1e868ff3-7c5e-49ce-91bd-582875b8930d", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Integrate a learning factor adjustment to enhance the exploration-exploitation balance in the hybrid harmony and differential evolution algorithm.", "configspace": "", "generation": 2, "fitness": 0.30829346870765206, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.308 with standard deviation 0.090. And the mean value of best solutions found was 0.094 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "48240291-4fa3-46a2-96f5-a9306213d002", "metadata": {"aucs": [0.391069970518348, 0.18245986513396428, 0.3513505704706439], "final_y": [1.927497447651436e-07, 0.2817434961762621, 0.000585835560720372]}, "mutation_prompt": null}
{"id": "ef7b1c9e-d75c-4f72-824b-0517277eef97", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr * (1 - evaluations / self.budget), mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a decay factor to dynamically adjust the Crossover probability for improved exploration-exploitation trade-off.", "configspace": "", "generation": 3, "fitness": 0.18406644011450612, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.184 with standard deviation 0.043. And the mean value of best solutions found was 0.644 (0. is the best) with standard deviation 0.531.", "error": "", "parent_id": "1e868ff3-7c5e-49ce-91bd-582875b8930d", "metadata": {"aucs": [0.24343489950552555, 0.14327821300287347, 0.16548620783511936], "final_y": [0.0076524445568089934, 1.3080801548749315, 0.6158857158697094]}, "mutation_prompt": null}
{"id": "a642df26-3851-4a6a-b349-37607aa27805", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment with dynamic PAR\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        self.par = 0.1 + 0.2 * adapt_factor  # Dynamic adjustment \n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Integrate a dynamic adjustment to the pitch adjusting rate (PAR) for improved adaptability.", "configspace": "", "generation": 4, "fitness": 0.2752386875808751, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.275 with standard deviation 0.010. And the mean value of best solutions found was 0.011 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "1e868ff3-7c5e-49ce-91bd-582875b8930d", "metadata": {"aucs": [0.2836480028763583, 0.2611484337176563, 0.28091962614861077], "final_y": [0.008897474185715685, 0.012697260868280635, 0.012058517472573188]}, "mutation_prompt": null}
{"id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a dynamic adjustment to the pitch adjusting rate (PAR) based on remaining evaluations to enhance convergence.", "configspace": "", "generation": 5, "fitness": 0.4715158935595139, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.472 with standard deviation 0.054. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1e868ff3-7c5e-49ce-91bd-582875b8930d", "metadata": {"aucs": [0.4014044425226867, 0.4809451987594744, 0.5321980393963808], "final_y": [5.807346730291547e-07, 7.151236816521785e-08, 1.6416566766041994e-08]}, "mutation_prompt": null}
{"id": "ec8f9bfb-3c48-40be-987e-04bf9631cf55", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        random_factor = np.random.rand()  # Added random factor for exploration\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor * random_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Refine the dynamic adjustment of the pitch adjusting rate (PAR) by incorporating a random factor to enhance exploration capabilities.", "configspace": "", "generation": 6, "fitness": 0.2125386489088499, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.213 with standard deviation 0.079. And the mean value of best solutions found was 0.565 (0. is the best) with standard deviation 0.467.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.32329132362612145, 0.1649432592590997, 0.1493813638413286], "final_y": [0.00016872421842729394, 0.5519686475719721, 1.1437195511089777]}, "mutation_prompt": null}
{"id": "b507214c-b895-4b75-8c1f-101d55b8e3af", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Enhanced adaptive Pitch adjustment\n                        best_harmony = harmony_memory[np.argmin(harmony_fitness)]\n                        new_harmony[i] += np.random.uniform(-1, 1) * (best_harmony[i] - new_harmony[i]) * 0.01\n\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.8 - 0.3 * (evaluations / self.budget)  # Adaptive scaling factor\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation balance by incorporating adaptive mutation scaling and learning from the best harmonies.", "configspace": "", "generation": 7, "fitness": 0.23538917444956006, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.235 with standard deviation 0.173. And the mean value of best solutions found was 0.725 (0. is the best) with standard deviation 0.524.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.15127233074493307, 0.07913128584374529, 0.4757639067600018], "final_y": [1.2169595279140175, 0.9585885127936598, 2.618471235160102e-06]}, "mutation_prompt": null}
{"id": "329c4033-20e7-4e3c-995c-5907688e6f22", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment with stochastic weighting\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        stochastic_weight = np.random.uniform(0.9, 1.1)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor * stochastic_weight\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce stochastic weighting to further enhance adaptive pitch adjustment in Harmony Search.", "configspace": "", "generation": 8, "fitness": 0.22817707317530408, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.228 with standard deviation 0.071. And the mean value of best solutions found was 0.216 (0. is the best) with standard deviation 0.153.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.3285909511810715, 0.17763289260062265, 0.17830737574421807], "final_y": [0.00030225795638581354, 0.3119141350318964, 0.3349163797170632]}, "mutation_prompt": null}
{"id": "51371baf-6c47-4c91-bdab-b85887fa3fca", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Initial Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n        self.opposition_based_rate = 0.2\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n            \n            # Opposition-based learning\n            if np.random.rand() < self.opposition_based_rate:\n                new_harmony = func.bounds.ub + func.bounds.lb - new_harmony\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.3 + 0.7 * np.random.rand()  # Self-adaptive learning factor\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance solution diversity and convergence by introducing self-adaptive parameters and opposition-based learning.", "configspace": "", "generation": 9, "fitness": 0.3073580687291134, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.307 with standard deviation 0.147. And the mean value of best solutions found was 0.987 (0. is the best) with standard deviation 1.396.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.35943060499240365, 0.10726115666748048, 0.45538244452745613], "final_y": [1.4893485942453428e-05, 2.9621672824580663, 0.0001454397950590795]}, "mutation_prompt": null}
{"id": "e4d3c0f9-0020-40d9-8f78-75327a0b09b8", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                self.cr = 0.9 * (1 - evaluations / self.budget)  # Dynamic CR adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce dynamic crossover probability adjustment based on evaluations to improve exploration-exploitation balance.", "configspace": "", "generation": 10, "fitness": 0.1158588662876097, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.025. And the mean value of best solutions found was 2.952 (0. is the best) with standard deviation 1.985.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.14101012970330573, 0.08169244398532405, 0.12487402517419932], "final_y": [1.1873178711636134, 5.725363066986029, 1.944120317399429]}, "mutation_prompt": null}
{"id": "7a02fbd5-c7cd-4922-a1f0-68bbce8ee73b", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                self.cr = 0.9 * (1 - evaluations / self.budget) + 0.1  # Crossover probability adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Incorporate a dynamic crossover probability adaptation to improve exploration and exploitation balance.", "configspace": "", "generation": 11, "fitness": 0.26175481610335566, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.262 with standard deviation 0.092. And the mean value of best solutions found was 0.110 (0. is the best) with standard deviation 0.104.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.20788970478550683, 0.18557613992623945, 0.39179860359832075], "final_y": [0.08136071206558, 0.24915003500155034, 0.00037475837417998126]}, "mutation_prompt": null}
{"id": "b337e83f-b763-499b-9230-b082c89fb73e", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    adapt_factor = (1 - (evaluations / self.budget))**2  # Non-linear scaling for PAR\n                    if np.random.rand() < self.par * adapt_factor:\n                        # Adaptive Pitch adjustment\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a non-linear scaling of Pitch Adjusting Rate (PAR) for better exploration-exploitation balance.", "configspace": "", "generation": 12, "fitness": 0.19215651230580758, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.192 with standard deviation 0.029. And the mean value of best solutions found was 0.411 (0. is the best) with standard deviation 0.340.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.2086452214094211, 0.15100209964686273, 0.21682221586113892], "final_y": [0.1999788823081676, 0.8906008644399768, 0.1428665181765466]}, "mutation_prompt": null}
{"id": "bdfcbc8a-1e2e-4af1-9d2c-1a13b11e6e07", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n            # Dynamic adjustment of HMCR and PAR\n            self.hmcr = 0.9 * (1 - evaluations / self.budget) + 0.1\n            self.par = 0.4 * (1 - evaluations / self.budget) + 0.2\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a dynamic adjustment to both the pitch adjusting rate (PAR) and harmony memory considering rate (HMCR) based on remaining evaluations to improve convergence.", "configspace": "", "generation": 13, "fitness": 0.41043308029761927, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.410 with standard deviation 0.035. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.4116927189584033, 0.36728024905712087, 0.4523262728773336], "final_y": [1.0450297432110268e-06, 2.813193028036171e-06, 6.2538412171157615e-06]}, "mutation_prompt": null}
{"id": "cec969fb-7ef2-47a8-b30a-9693335dd796", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory with opposition-based learning\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        opposite_memory = func.bounds.lb + func.bounds.ub - harmony_memory[:self.harmony_memory_size//2]\n        harmony_memory[:self.harmony_memory_size//2] = opposite_memory\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce opposition-based learning to enhance exploration and convergence by initializing half of the harmony memory with opposite solutions.", "configspace": "", "generation": 14, "fitness": 0.3951599582911225, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.395 with standard deviation 0.057. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.3144902918762379, 0.44112555485283256, 0.4298640281442969], "final_y": [7.162141672767129e-05, 0.00012148481248474095, 1.5143424242681773e-08]}, "mutation_prompt": null}
{"id": "f18cbc13-054b-4bba-9f9a-76ecd1da4900", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n            \n            # Adjust PAR exponentially based on evaluations\n            self.par = 0.3 * np.exp(3 * evaluations / self.budget - 3) \n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Adjust the pitch adjusting rate (PAR) to increase exponentially to enhance exploitation as evaluations progress.", "configspace": "", "generation": 15, "fitness": 0.15796153104200192, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.158 with standard deviation 0.018. And the mean value of best solutions found was 0.869 (0. is the best) with standard deviation 0.528.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.1744041639813838, 0.16688597077415301, 0.1325944583704689], "final_y": [0.3661705672811657, 0.6435787771725812, 1.5984633626433058]}, "mutation_prompt": null}
{"id": "e3dc4bf9-5a34-4599-9ed7-f33a739a062d", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment with non-linear scaling\n                        adapt_factor = 1 - (evaluations / self.budget) ** 2\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Incorporate a non-linear scaling factor in pitch adjustment to dynamically enhance exploration.", "configspace": "", "generation": 16, "fitness": 0.3575029936636323, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.358 with standard deviation 0.110. And the mean value of best solutions found was 0.016 (0. is the best) with standard deviation 0.020.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.35968065338379074, 0.22217153048725524, 0.4906567971198509], "final_y": [0.004195772044615472, 0.044495509762834715, 2.1644396062605667e-08]}, "mutation_prompt": null}
{"id": "813f82a0-13aa-4ff7-b849-4539bf6fbe3c", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                self.cr = 0.9 - 0.4 * (evaluations / self.budget)  # Dynamic crossover probability\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance convergence by dynamically adjusting the crossover probability (CR) based on remaining evaluations.", "configspace": "", "generation": 17, "fitness": 0.21166230129557587, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.212 with standard deviation 0.074. And the mean value of best solutions found was 0.513 (0. is the best) with standard deviation 0.463.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.31526496388867453, 0.14561157698455385, 0.17411036301349925], "final_y": [1.6443912373222805e-05, 1.1219367611107727, 0.41558811556596215]}, "mutation_prompt": null}
{"id": "2e5f443e-0534-4936-a76e-295cb24ac64c", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.6 + 0.4 * (1 - evaluations / self.budget)  # Adjusted Learning factor\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Optimize the learning factor adjustment to strengthen the adaptive mechanism in differential evolution.", "configspace": "", "generation": 18, "fitness": 0.24917328028742391, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.249 with standard deviation 0.049. And the mean value of best solutions found was 0.096 (0. is the best) with standard deviation 0.125.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.28171856675817497, 0.18044861124028877, 0.285352662863808], "final_y": [0.00021569572650099937, 0.2719391508802805, 0.015498653881871898]}, "mutation_prompt": null}
{"id": "5760aeb6-f78e-449b-b1db-9dcfe99fd92c", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        # Introducing temperature-based adaptation\n                        temperature = np.exp(-evaluations/self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor * temperature\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce temperature-based adaptation to the pitch adjusting rate (PAR) for more effective convergence control.", "configspace": "", "generation": 19, "fitness": 0.3183362210541382, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.318 with standard deviation 0.164. And the mean value of best solutions found was 0.373 (0. is the best) with standard deviation 0.521.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.2667426860328691, 0.1482686707355152, 0.5399973063940303], "final_y": [0.008966354285065268, 1.1090667449664673, 1.8129490698137178e-07]}, "mutation_prompt": null}
{"id": "63251acf-9904-4cdf-ac2e-bd2ee7a5ddcb", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                self.cr = 0.9 * (1 - evaluations / self.budget)  # Dynamic crossover probability\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Implement dynamic adjustment to the crossover probability (cr) to potentially enhance solution diversity and convergence rate.", "configspace": "", "generation": 20, "fitness": 0.18406644011450612, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.184 with standard deviation 0.043. And the mean value of best solutions found was 0.644 (0. is the best) with standard deviation 0.531.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.24343489950552555, 0.14327821300287347, 0.16548620783511936], "final_y": [0.0076524445568089934, 1.3080801548749315, 0.6158857158697094]}, "mutation_prompt": null}
{"id": "f9455b34-2e44-40f8-8ea3-d3ac78f0245a", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                self.cr = 0.9 * (1 - evaluations / self.budget) + 0.1  # Dynamic CR adjustment\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a dynamic adjustment to the crossover probability (CR) based on remaining evaluations to enhance diversity.", "configspace": "", "generation": 21, "fitness": 0.26175481610335566, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.262 with standard deviation 0.092. And the mean value of best solutions found was 0.110 (0. is the best) with standard deviation 0.104.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.20788970478550683, 0.18557613992623945, 0.39179860359832075], "final_y": [0.08136071206558, 0.24915003500155034, 0.00037475837417998126]}, "mutation_prompt": null}
{"id": "8c66f455-3096-4003-87a3-7a226eb9a49c", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamic adjustment of harmony memory size\n            self.harmony_memory_size = int(10 + (self.budget - evaluations) / self.budget * 10)\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce dynamic adjustment of harmony memory size based on remaining evaluations to enhance diversity.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 14 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 14 is out of bounds for axis 0 with size 10')", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {}, "mutation_prompt": null}
{"id": "7c13739c-0b28-460f-b890-fe6f444fb9b8", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Adaptive harmony memory size reduction\n            current_memory_size = max(2, int(self.harmony_memory_size * (1 - evaluations / self.budget)))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Incorporate adaptive harmony memory size reduction to focus search efforts during later optimization stages.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {}, "mutation_prompt": null}
{"id": "d92df0e7-e170-4407-bef3-899dc117bca9", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr * np.random.rand(), mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce stochastic scaling factor adjustment for crossover probability based on iteration progress to enhance exploration-exploitation balance.", "configspace": "", "generation": 24, "fitness": 0.22828321853844954, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.228 with standard deviation 0.013. And the mean value of best solutions found was 0.203 (0. is the best) with standard deviation 0.075.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.21152185474069451, 0.23063105742269796, 0.24269674345195613], "final_y": [0.30312952729370896, 0.18073981215626886, 0.12372892596275191]}, "mutation_prompt": null}
{"id": "8369775d-839e-49cb-b46d-95255c1236ef", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Adjust harmony memory size adaptively\n            self.harmony_memory_size = max(5, int(10 * (1 - evaluations / self.budget)))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce an adaptive harmony memory size based on remaining evaluations to maintain diversity and enhance convergence.", "configspace": "", "generation": 25, "fitness": 0.21902597078989838, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.219 with standard deviation 0.058. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.208.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.16122476573732591, 0.29792551677716816, 0.19792762985520107], "final_y": [0.5035391315409362, 0.010459428084545865, 0.1443051694783229]}, "mutation_prompt": null}
{"id": "82f9a24e-0752-4017-b100-44d758d3265b", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                self.cr = 0.9 * (evaluations / self.budget)  # Dynamic adjustment of crossover probability\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce dynamic adjustment to crossover probability (CR) for better exploration and exploitation balance.", "configspace": "", "generation": 26, "fitness": 0.35397663149679737, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.354 with standard deviation 0.047. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.29038185481264756, 0.40197126779290937, 0.36957677188483506], "final_y": [0.00203211079846591, 0.00016206589293864425, 0.0011203715309905861]}, "mutation_prompt": null}
{"id": "6ba62f9b-80e1-4f5b-8019-c60d86eb66ca", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                self.cr = 0.9 * (1 - evaluations / self.budget) + 0.1  # Dynamic crossover probability adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce dynamic crossover probability adjustment based on remaining evaluations to balance exploration and exploitation.", "configspace": "", "generation": 27, "fitness": 0.26175481610335566, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.262 with standard deviation 0.092. And the mean value of best solutions found was 0.110 (0. is the best) with standard deviation 0.104.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.20788970478550683, 0.18557613992623945, 0.39179860359832075], "final_y": [0.08136071206558, 0.24915003500155034, 0.00037475837417998126]}, "mutation_prompt": null}
{"id": "da6c1d4d-c738-4e56-9d97-0bca6b5baffd", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                self.cr = 0.4 + 0.5 * (evaluations / self.budget)  # Adaptive CR adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Adaptively adjust the crossover probability (CR) based on remaining evaluations for enhanced solution diversity.", "configspace": "", "generation": 28, "fitness": 0.22716204103498502, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.227 with standard deviation 0.071. And the mean value of best solutions found was 0.269 (0. is the best) with standard deviation 0.293.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.32411333715613044, 0.19973619507800666, 0.15763659087081794], "final_y": [0.0038423819798115086, 0.12569318073274557, 0.677291753294612]}, "mutation_prompt": null}
{"id": "43b15d4a-2a87-40a6-ac43-19e52f34d66e", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size\n            self.harmony_memory_size = max(5, int(10 * (1 - evaluations / self.budget)))\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Dynamic harmony memory size adjustment based on remaining evaluations to balance exploration and exploitation.", "configspace": "", "generation": 29, "fitness": 0.2223959413044074, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.222 with standard deviation 0.056. And the mean value of best solutions found was 0.205 (0. is the best) with standard deviation 0.142.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.30197890969692365, 0.18008642432181843, 0.1851224898944801], "final_y": [0.008255952115893415, 0.3407833928339567, 0.2646543000804839]}, "mutation_prompt": null}
{"id": "64d76a15-d6c1-4e26-9d88-208437868e40", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce exploration enhancement by dynamically adjusting harmony memory size based on evaluations.", "configspace": "", "generation": 30, "fitness": 0.5141541361346559, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.514 with standard deviation 0.048. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "87cd4099-c0d4-4928-9e37-b7ad2a6bb11c", "metadata": {"aucs": [0.5541239576350143, 0.5416634041775723, 0.4466750465913809], "final_y": [4.0455715623019785e-07, 7.10118888303147e-06, 0.00017509560785004073]}, "mutation_prompt": null}
{"id": "d9dca346-1733-44b0-8bb1-a01214a1fdf7", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f ** 1.01 * (x2 - x3)  # Slight change in scaling factor with power\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance mutation strategy in Differential Evolution by adding dynamic scaling factor based on evaluation progress.", "configspace": "", "generation": 31, "fitness": 0.30796848716729003, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.308 with standard deviation 0.058. And the mean value of best solutions found was 0.013 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.22772809237387992, 0.33504434148562656, 0.36113302764236355], "final_y": [0.03224016436816725, 0.002018359250474359, 0.0034168390960241687]}, "mutation_prompt": null}
{"id": "3f32c1d3-b2a6-496a-8364-712c1c0b54c9", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * ((1 - evaluations / self.budget) ** 2)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Adjust the differential weight factor calculation to include a square component for enhanced exploration.", "configspace": "", "generation": 32, "fitness": 0.3257272196577112, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.326 with standard deviation 0.126. And the mean value of best solutions found was 0.092 (0. is the best) with standard deviation 0.120.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.1824363916278119, 0.48977448694292147, 0.3049707804024001], "final_y": [0.2615305668793276, 3.361120737382319e-06, 0.015483737796153975]}, "mutation_prompt": null}
{"id": "33279423-046b-4e9c-9805-44a529dc704e", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        adjustment_granularity = np.std(harmony_memory[:, i]) / 10  # New added line\n                        new_harmony[i] += np.random.uniform(-1, 1) * adjustment_granularity * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Integrate mutation diversity by altering pitch adjustment rate based on search space granularity.", "configspace": "", "generation": 33, "fitness": 0.2721272759144934, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.272 with standard deviation 0.107. And the mean value of best solutions found was 0.304 (0. is the best) with standard deviation 0.225.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.42299545901343816, 0.18851588152418952, 0.20487048720585255], "final_y": [0.000258377513630441, 0.5379974686773765, 0.37323761125164745]}, "mutation_prompt": null}
{"id": "6deb8b7d-23aa-42ba-84c8-fe021cedcadf", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.8 * (1 - evaluations / self.budget)  # Adjusted learning factor\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce adaptive differential weight adjustment for enhanced exploration and convergence.", "configspace": "", "generation": 34, "fitness": 0.20389179730616702, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.204 with standard deviation 0.022. And the mean value of best solutions found was 0.190 (0. is the best) with standard deviation 0.193.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.172989505953, 0.21953391819277812, 0.21915196777272294], "final_y": [0.4629645977883163, 0.03815357066937891, 0.07018335446472523]}, "mutation_prompt": null}
{"id": "88cf63ff-891c-4431-9e14-3a8a182528c6", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.3 * np.sin(evaluations / self.budget * np.pi)  # Adjusted learning factor\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce adaptive differential weight to enhance balancing exploration and exploitation.", "configspace": "", "generation": 35, "fitness": 0.3668045907109872, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.367 with standard deviation 0.023. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.38501670894563866, 0.33461992536322305, 0.38077713782409983], "final_y": [0.001662024116109345, 0.0012659368563464194, 0.0008745405039362567]}, "mutation_prompt": null}
{"id": "2d3987ed-f1de-4379-a1c9-bff4b3f973fd", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration by adjusting pitch adjustment rate over time for improved convergence.", "configspace": "", "generation": 36, "fitness": 0.3520149497532116, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.352 with standard deviation 0.072. And the mean value of best solutions found was 0.010 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.4123271645877433, 0.251571458868146, 0.3921462258037455], "final_y": [5.1765052056713815e-05, 0.028008980319592897, 0.0004768302499886957]}, "mutation_prompt": null}
{"id": "5b98e6bc-be6c-47c1-90b5-6eea1ab6fbf8", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)**2  # Modified adaptive factor for better convergence\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration by modifying adaptive pitch adjustment factor for improved convergence.", "configspace": "", "generation": 37, "fitness": 0.29687106713269984, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.297 with standard deviation 0.058. And the mean value of best solutions found was 0.030 (0. is the best) with standard deviation 0.032.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.3785492555787091, 0.26740134145433303, 0.24466260436505738], "final_y": [0.00015539923265988156, 0.014444537088077546, 0.07419490199917374]}, "mutation_prompt": null}
{"id": "f8ff8dca-2cd0-43aa-841e-7af18f175414", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par * (1 - evaluations / self.budget):\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce dynamic adjustment of Pitch Adjusting Rate based on evaluation progress to enhance exploitation.", "configspace": "", "generation": 38, "fitness": 0.25850453314999905, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.259 with standard deviation 0.053. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.132.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.19008676363520915, 0.265921273290205, 0.31950556252458295], "final_y": [0.3156360150172123, 0.059152216889239925, 0.016438420240242044]}, "mutation_prompt": null}
{"id": "3326cd90-6b90-482d-bb79-482043122b24", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                self.cr = 0.9 * np.tanh(evaluations / self.budget)  # Hyperbolic tangent adjustment\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Integrate a hyperbolic tangent function to dynamically adjust the crossover probability, enhancing the exploration-exploitation balance.", "configspace": "", "generation": 39, "fitness": 0.23289983268504003, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.233 with standard deviation 0.057. And the mean value of best solutions found was 0.231 (0. is the best) with standard deviation 0.235.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.3074807648301384, 0.1705163965258727, 0.220702336699109], "final_y": [0.004150868847556763, 0.5558253960277144, 0.1340774809416757]}, "mutation_prompt": null}
{"id": "3d096f51-6665-47e7-9b4f-87db5f81c991", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par * (1 - evaluations / self.budget):  # Adjusted PAR\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Adjusted the pitch adjustment rate (PAR) with a dynamic factor based on remaining evaluations to enhance local search capabilities.", "configspace": "", "generation": 40, "fitness": 0.25850453314999905, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.259 with standard deviation 0.053. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.132.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.19008676363520915, 0.265921273290205, 0.31950556252458295], "final_y": [0.3156360150172123, 0.059152216889239925, 0.016438420240242044]}, "mutation_prompt": null}
{"id": "887caac2-fdab-4fc1-9525-ab1b82609905", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                self.cr = 0.9 * (evaluations / self.budget)  # Dynamic Crossover probability adjustment\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration by dynamically adjusting the Crossover probability based on evaluations.", "configspace": "", "generation": 41, "fitness": 0.24045541835924164, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.240 with standard deviation 0.067. And the mean value of best solutions found was 0.269 (0. is the best) with standard deviation 0.295.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.3298996166121415, 0.16685238433581795, 0.22461425412976543], "final_y": [0.00232227047541909, 0.68037100724543, 0.1243059490575239]}, "mutation_prompt": null}
{"id": "78aa5019-f4bf-4249-bd70-3082b1093042", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploitation by adjusting the pitch adjustment rate dynamically based on evaluations.", "configspace": "", "generation": 42, "fitness": 0.3520149497532116, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.352 with standard deviation 0.072. And the mean value of best solutions found was 0.010 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.4123271645877433, 0.251571458868146, 0.3921462258037455], "final_y": [5.1765052056713815e-05, 0.028008980319592897, 0.0004768302499886957]}, "mutation_prompt": null}
{"id": "e2f5c7f0-8b86-4df0-b2b6-f9be8a0d45b5", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                # Adjust pitch adjusting rate dynamically based on evaluations progress\n                self.par = 0.3 + 0.2 * (1 - evaluations / self.budget)\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce adaptive exploration by dynamically adjusting harmony's pitch adjusting rate based on evaluations for improved convergence.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 38, 17, '                else:\\n', 38, 21)).", "error": "SyntaxError('invalid syntax', ('<string>', 38, 17, '                else:\\n', 38, 21))", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {}, "mutation_prompt": null}
{"id": "403e2a23-bb2b-4412-9116-eb1bb933808a", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Refine pitch adjustment and memory consideration to enhance exploration and exploitation balance.", "configspace": "", "generation": 44, "fitness": 0.2467254356768365, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.061. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.089.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.33309321462584085, 0.20101587493097584, 0.20606721747369283], "final_y": [0.007905445818263405, 0.21874638188641554, 0.1602152095377361]}, "mutation_prompt": null}
{"id": "18b7a34f-71fc-42de-83e3-382e85c9f3f2", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n        self.stagnation_threshold = 20\n\n    def __call__(self, func):\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        best_fitness = np.min(harmony_fitness)\n        stagnation_counter = 0\n        \n        while evaluations < self.budget:\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget) \n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n                if new_harmony_fitness < best_fitness:\n                    best_fitness = new_harmony_fitness\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter >= self.stagnation_threshold:\n                perturbation = np.random.uniform(low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim))\n                harmony_memory = np.clip(harmony_memory + perturbation * 0.1, func.bounds.lb, func.bounds.ub)\n                harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n                evaluations += self.harmony_memory_size\n\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance global exploration and exploitation balance by adaptive mutation scaling and incorporating a stagnation check.", "configspace": "", "generation": 45, "fitness": 0.22922048935660655, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.229 with standard deviation 0.037. And the mean value of best solutions found was 0.190 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.20551015423264296, 0.2820976778189517, 0.200053636018225], "final_y": [0.15109490588729035, 0.05043725341918447, 0.36947613218928893]}, "mutation_prompt": null}
{"id": "21a7dbe6-6b19-47ff-abef-666e59febf80", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                        self.par = 0.3 + 0.2 * (1 - evaluations / self.budget)  # Dynamic PAR adjustment\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance learning factor adjustment by coupling it with a dynamic pitch adjustment to better balance exploration and exploitation.", "configspace": "", "generation": 46, "fitness": 0.3130766068897496, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.313 with standard deviation 0.154. And the mean value of best solutions found was 1.219 (0. is the best) with standard deviation 1.723.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.46272006117547515, 0.374614865023142, 0.1018948944706316], "final_y": [5.7398553200461244e-05, 0.0013505348949124335, 3.654924519130618]}, "mutation_prompt": null}
{"id": "7f07a2b9-2ddc-4688-9878-b823809f3eec", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.8    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget) ** 1.5\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Integrate a more adaptive pitch adjustment factor and tune crossover probability for enhanced exploration.", "configspace": "", "generation": 47, "fitness": 0.2126360908798203, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.213 with standard deviation 0.066. And the mean value of best solutions found was 0.458 (0. is the best) with standard deviation 0.332.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.3064772193396328, 0.16989600154052587, 0.16153505175930227], "final_y": [0.00011639235485459747, 0.5965406367080897, 0.776669775852843]}, "mutation_prompt": null}
{"id": "a23d605d-2974-4667-8dd7-a2e56b4e3fa9", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - np.std(harmony_memory[:current_harmony_memory_size], axis=0).mean())  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration by adjusting Differential weight adaptation based on memory diversity.", "configspace": "", "generation": 48, "fitness": 0.18923200506813764, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.189 with standard deviation 0.033. And the mean value of best solutions found was 0.318 (0. is the best) with standard deviation 0.325.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.18924070809907334, 0.14906483977172325, 0.22939046733361634], "final_y": [0.11135672865038715, 0.7759515510169074, 0.06532938600985658]}, "mutation_prompt": null}
{"id": "ed167de9-906d-417c-8274-59d269ede5ce", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.05 * adapt_factor  # Modified line\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce an adaptive pitch adjustment strategy to enhance convergence by increasing the adaptation range.", "configspace": "", "generation": 49, "fitness": 0.27721780509011534, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.277 with standard deviation 0.012. And the mean value of best solutions found was 0.026 (0. is the best) with standard deviation 0.017.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.2938338076511896, 0.2677315057161098, 0.27008810190304655], "final_y": [0.0027685211722898104, 0.0322512106013855, 0.04229826861835933]}, "mutation_prompt": null}
{"id": "85d8fa53-7e90-4c15-afe8-e94260382181", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                self.cr = 0.9 * (1 - evaluations / self.budget)  # Dynamically decrease crossover probability\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration by dynamically decreasing the crossover probability over time.", "configspace": "", "generation": 50, "fitness": 0.15835046221036975, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.158 with standard deviation 0.013. And the mean value of best solutions found was 0.801 (0. is the best) with standard deviation 0.318.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.1404891489206005, 0.16197705308832666, 0.1725851846221821], "final_y": [1.2498731987280762, 0.609331240003001, 0.5451013577741537]}, "mutation_prompt": null}
{"id": "8545bed5-e051-4d9d-8ac3-f876c8070d4e", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        # Added adaptive noise factor based on fitness variance\n                        noise_factor = np.var(harmony_fitness) * np.random.randn()\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor + noise_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration by adding an adaptive noise factor proportional to the current harmony fitness variance.", "configspace": "", "generation": 51, "fitness": 0.3630813343743196, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.363 with standard deviation 0.113. And the mean value of best solutions found was 0.009 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.32685113786199294, 0.24668637317447883, 0.5157064920864871], "final_y": [0.0020867135733097573, 0.025743859830682652, 2.7602804615153207e-06]}, "mutation_prompt": null}
{"id": "c20e2822-3148-4b6f-9383-6e7a45e2fbce", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = np.exp(-0.02 * evaluations / self.budget)  # Self-adaptive factor\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce self-adaptive pitch adjustment to enhance convergence precision near optimal solutions.", "configspace": "", "generation": 52, "fitness": 0.4111269398295038, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.411 with standard deviation 0.114. And the mean value of best solutions found was 0.025 (0. is the best) with standard deviation 0.034.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.43857713670713583, 0.5351707214822463, 0.2596329612991293], "final_y": [0.00037157654287433244, 1.4840527492435452e-06, 0.07314139959690608]}, "mutation_prompt": null}
{"id": "99fe0fac-7815-464e-84dc-e90a19088be8", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget) ** 2  # Change: enhanced adaptation factor\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhanced adaptive pitch adjustment factor to improve local search capabilities over iterations.", "configspace": "", "generation": 53, "fitness": 0.29687106713269984, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.297 with standard deviation 0.058. And the mean value of best solutions found was 0.030 (0. is the best) with standard deviation 0.032.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.3785492555787091, 0.26740134145433303, 0.24466260436505738], "final_y": [0.00015539923265988156, 0.014444537088077546, 0.07419490199917374]}, "mutation_prompt": null}
{"id": "ee7f2e9b-1cd0-4e29-9a00-87a486129143", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                # Dynamic Crossover Probability\n                self.cr = 0.9 - 0.5 * (evaluations / self.budget)  # Adjust crossover probability dynamically\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Refine exploration by implementing dynamic crossover probability based on remaining evaluations.", "configspace": "", "generation": 54, "fitness": 0.15784323532493952, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.158 with standard deviation 0.012. And the mean value of best solutions found was 0.772 (0. is the best) with standard deviation 0.221.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.1448756614431589, 0.15399920298939196, 0.17465484154226774], "final_y": [1.0030764519526794, 0.8399032078577038, 0.47354994339097845]}, "mutation_prompt": null}
{"id": "f9a64a6d-6dad-41e1-945c-5853055692ed", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                # Change: Use weighted difference of three vectors for mutation to enhance diversity\n                mutant_vector = np.clip(mutant_vector, func.bounds.lb, func.bounds.ub)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance solution diversity by adjusting the mutation strategy in Differential Evolution to balance exploration and exploitation.", "configspace": "", "generation": 55, "fitness": 0.3520149497532116, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.352 with standard deviation 0.072. And the mean value of best solutions found was 0.010 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.4123271645877433, 0.251571458868146, 0.3921462258037455], "final_y": [5.1765052056713815e-05, 0.028008980319592897, 0.0004768302499886957]}, "mutation_prompt": null}
{"id": "89a8e283-cf62-4a90-9d60-e696e5e176b0", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                self.cr = 0.7 + 0.3 * (evaluations / self.budget)  # Dynamic crossover probability\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance convergence by dynamically adjusting the crossover probability based on evaluations.", "configspace": "", "generation": 56, "fitness": 0.19565523502862614, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.196 with standard deviation 0.020. And the mean value of best solutions found was 0.250 (0. is the best) with standard deviation 0.122.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.223502894951913, 0.18400435510026436, 0.17945845503370106], "final_y": [0.08208804211796292, 0.3028237758873295, 0.36576468069353874]}, "mutation_prompt": null}
{"id": "3db152b4-e8db-4d86-82a1-f41a5674f5c2", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        par_decay = self.par * (1 - evaluations / self.budget)  # Decay factor for par\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor * par_decay\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration by introducing a decay factor for pitch adjustment rate (par) to improve convergence.", "configspace": "", "generation": 57, "fitness": 0.2959780940490938, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.296 with standard deviation 0.043. And the mean value of best solutions found was 0.029 (0. is the best) with standard deviation 0.019.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.2573462180308498, 0.3553161223828466, 0.27527194173358505], "final_y": [0.05010621438779237, 0.003735041078914172, 0.03369695082754697]}, "mutation_prompt": null}
{"id": "b9e6e253-c598-4c25-99e8-c81ad70812fe", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                # Adaptive HMCR based on evaluations\n                adaptive_hmcr = self.hmcr - 0.4 * (evaluations / self.budget)\n                if np.random.rand() < adaptive_hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce adaptive harmony memory rate (hmcr) based on evaluations to balance exploration and exploitation.", "configspace": "", "generation": 58, "fitness": 0.29608635413231604, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.296 with standard deviation 0.110. And the mean value of best solutions found was 0.249 (0. is the best) with standard deviation 0.339.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.2828408945662726, 0.43675893134059895, 0.16865923649007653], "final_y": [0.018734059396961024, 0.0002691420891500705, 0.7275006004074263]}, "mutation_prompt": null}
{"id": "f68238a8-9dce-41f4-8bd8-3aeff31fcfd5", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                self.cr = 0.9 * (evaluations / self.budget) + 0.1  # Adaptive crossover probability\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance the mutation strategy by introducing an adaptive crossover probability.", "configspace": "", "generation": 59, "fitness": 0.3233730427595624, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.323 with standard deviation 0.051. And the mean value of best solutions found was 0.003 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.25351398072638154, 0.3749666454216761, 0.34163850213062963], "final_y": [0.006604168172847436, 0.0004438120911647148, 0.0007687103879637443]}, "mutation_prompt": null}
{"id": "0a95c6d4-9cc8-48aa-bd0d-776e0689580b", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment (new pitch adjustment)\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-0.5, 0.5) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce adaptive harmony memory reduction and new pitch adjustment mechanism for enhanced convergence.", "configspace": "", "generation": 60, "fitness": 0.4402900765547968, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.440 with standard deviation 0.085. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.3876243600194049, 0.37365907298787393, 0.5595867966571115], "final_y": [0.0006423729261929873, 0.004063005449457973, 3.208646279386959e-08]}, "mutation_prompt": null}
{"id": "98df6565-ee2b-4075-922c-8406fa1d5d6c", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                if np.std(harmony_memory) > 0.1:  # Adjust F based on diversity\n                    self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce adaptive mutation by adjusting differential weight based on the diversity of the population.", "configspace": "", "generation": 61, "fitness": 0.3520149497532116, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.352 with standard deviation 0.072. And the mean value of best solutions found was 0.010 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.4123271645877433, 0.251571458868146, 0.3921462258037455], "final_y": [5.1765052056713815e-05, 0.028008980319592897, 0.0004768302499886957]}, "mutation_prompt": null}
{"id": "449d19e9-cb68-4fa4-afc7-ea1550a7e32f", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                # Adjust hmcr based on evaluations\n                adaptive_hmcr = self.hmcr * (1 - evaluations / self.budget)\n                if np.random.rand() < adaptive_hmcr:  # Changed line\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Improve the exploration by introducing adaptivity in harmony memory considering rate (hmcr) based on evaluations.", "configspace": "", "generation": 62, "fitness": 0.27924677336036396, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.279 with standard deviation 0.109. And the mean value of best solutions found was 0.176 (0. is the best) with standard deviation 0.202.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.22635999161014442, 0.4317063088761528, 0.17967401959479468], "final_y": [0.06788034376994866, 0.0005039653454915594, 0.45952998391245264]}, "mutation_prompt": null}
{"id": "bfeff35f-b5f1-4c0a-a43a-a653039fb552", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        self.par = 0.3 + 0.2 * adapt_factor  # Adjust par based on adapt_factor\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance convergence by adjusting the pitch adjustment rate based on the exploration phase.", "configspace": "", "generation": 63, "fitness": 0.2574793575992041, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.257 with standard deviation 0.046. And the mean value of best solutions found was 0.096 (0. is the best) with standard deviation 0.124.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.19484660244316132, 0.2744654153138628, 0.3031260550405882], "final_y": [0.2714433716668894, 0.005735124269398714, 0.011508201691233793]}, "mutation_prompt": null}
{"id": "4d530bb9-22cb-4305-b31d-9ce35ac8edca", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                self.cr = 0.5 + 0.4 * (harmony_fitness.min() / (harmony_fitness.max() + 1e-8))  # Adaptive crossover\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration by introducing adaptive crossover probability based on the current best fitness.", "configspace": "", "generation": 64, "fitness": 0.2786913635650549, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.279 with standard deviation 0.055. And the mean value of best solutions found was 0.069 (0. is the best) with standard deviation 0.055.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.2249882489144911, 0.35366839328304245, 0.25741744849763126], "final_y": [0.13508518025685215, 0.0013711169606215239, 0.0701936777438432]}, "mutation_prompt": null}
{"id": "534f05a7-f9a9-440b-9658-c2435fb6f724", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment based on fitness improvement rate\n                        improvement_rate = np.abs(harmony_fitness - np.min(harmony_fitness)) / (np.max(harmony_fitness) - np.min(harmony_fitness) + 1e-9)\n                        adapt_factor = (1 - (evaluations / self.budget)) * improvement_rate.mean()\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance local search by adapting pitch adjustment rate based on fitness improvement rate.", "configspace": "", "generation": 65, "fitness": 0.42422331462981827, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.424 with standard deviation 0.009. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.43653461052785236, 0.41894018880990613, 0.4171951445516964], "final_y": [0.00010449659857334678, 0.000523486371261526, 4.417751158764532e-06]}, "mutation_prompt": null}
{"id": "fc8cd1d2-15d7-4d4e-9616-7a199e6279e7", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                perturbation = np.random.normal(0, 0.01, self.dim)  # Adding this line for perturbation\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector + perturbation, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Improve exploration by introducing a small random perturbation to the trial vector in the Differential Evolution step.", "configspace": "", "generation": 66, "fitness": 0.33947571730635556, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.339 with standard deviation 0.021. And the mean value of best solutions found was 0.003 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.3567455946660235, 0.3099537450432659, 0.3517278122097772], "final_y": [0.0021550380218976805, 0.005158036400780296, 0.002543922045230188]}, "mutation_prompt": null}
{"id": "9b951019-756b-4b1e-a880-1911161620b7", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Adjust differential weight based on diversity\n            diversity = np.mean(np.std(harmony_memory[:current_harmony_memory_size], axis=0))\n            self.f = 0.3 + 0.7 * (1 - diversity)\n\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce adaptive differential weight and memory consideration based on the diversity of the harmony memory.", "configspace": "", "generation": 67, "fitness": 0.2703163044901013, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.270 with standard deviation 0.061. And the mean value of best solutions found was 0.068 (0. is the best) with standard deviation 0.089.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.2626915098306948, 0.34843334653620917, 0.1998240571033999], "final_y": [0.0012345104224493087, 0.00873849944684813, 0.19286525353459444]}, "mutation_prompt": null}
{"id": "63ec46a8-f0f2-4bf5-a243-6ef123a9cc02", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        self.par = 0.3 * adapt_factor  # Adjust pitch adjusting rate adaptively\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce adaptively decreasing pitch adjustment rate to balance exploration-exploitation.", "configspace": "", "generation": 68, "fitness": 0.26483424578740744, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.265 with standard deviation 0.045. And the mean value of best solutions found was 0.078 (0. is the best) with standard deviation 0.060.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.20906862132950566, 0.26592854829678436, 0.3195055677359323], "final_y": [0.15953862010027897, 0.05777069554660543, 0.016438403625795298]}, "mutation_prompt": null}
{"id": "9415e809-bfb4-4092-afbb-fc0655520bc8", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Adaptive Harmony Memory Considering Rate\n            self.hmcr = 0.7 + 0.2 * (1 - evaluations / self.budget)\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce adaptive harmony memory considering rate (hmcr) based on evaluations to enhance exploration and exploitation balance.", "configspace": "", "generation": 69, "fitness": 0.27392403091680045, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.274 with standard deviation 0.080. And the mean value of best solutions found was 0.242 (0. is the best) with standard deviation 0.339.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.16260928069837455, 0.3136583049554542, 0.34550450709657266], "final_y": [0.7218126932358775, 0.002246201222951675, 0.0025289200295673196]}, "mutation_prompt": null}
{"id": "9db6150e-4b59-480b-8833-f069de78cf56", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        self.par = 0.3 + 0.2 * adapt_factor  # Dynamic adjustment of PAR\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration by adjusting the pitch adjusting rate dynamically based on evaluations.", "configspace": "", "generation": 70, "fitness": 0.3993221848597252, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.399 with standard deviation 0.068. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.3528485406075069, 0.35004337088665394, 0.4950746430850147], "final_y": [0.0016402860378512073, 0.00011205334160938914, 4.274636629991963e-05]}, "mutation_prompt": null}
{"id": "e6bc9f03-a621-4138-b085-704f1d95856a", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                decay_factor = 0.5 * (1 - evaluations / self.budget)  # New decay factor\n                self.f = 0.5 + decay_factor  # Adjusted learning factor with decay\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration by introducing a decay factor to the mutation strategy in Differential Evolution.", "configspace": "", "generation": 71, "fitness": 0.21571724277140547, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.216 with standard deviation 0.104. And the mean value of best solutions found was 1.126 (0. is the best) with standard deviation 1.225.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.1790482100756554, 0.11023691634963884, 0.35786660188892216], "final_y": [0.5480219890348009, 2.829865134199904, 0.001084245913213416]}, "mutation_prompt": null}
{"id": "cfaf2efa-b346-4e8a-b6b9-c7553def5b26", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-0.5, 0.5) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration by adapting pitch adjustment range based on remaining budget, improving convergence.", "configspace": "", "generation": 72, "fitness": 0.4402900765547968, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.440 with standard deviation 0.085. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.3876243600194049, 0.37365907298787393, 0.5595867966571115], "final_y": [0.0006423729261929873, 0.004063005449457973, 3.208646279386959e-08]}, "mutation_prompt": null}
{"id": "0c2d6d81-9f0b-45e1-8a64-f2f22177dac4", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                # Adjust differential weight to boost diversity in search\n                self.f = 0.5 + 0.4 * np.sin((evaluations/self.budget) * np.pi)  # Adjusted learning factor\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration by dynamically adjusting the differential weight to boost diversity in search.", "configspace": "", "generation": 73, "fitness": 0.3806173741754259, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.381 with standard deviation 0.044. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.439863940730824, 0.33446630070422756, 0.3675218810912262], "final_y": [0.00020590873796816022, 0.000983086134075445, 0.000752402471999614]}, "mutation_prompt": null}
{"id": "99b92a7e-4977-4001-8160-f545dc9d26bf", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                momentum = 0.1 * np.random.rand()  # Add a momentum component\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget) + momentum  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a momentum component to the differential weight for smoother transitions and improved convergence.", "configspace": "", "generation": 74, "fitness": 0.29756815636849726, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.298 with standard deviation 0.092. And the mean value of best solutions found was 0.107 (0. is the best) with standard deviation 0.149.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.3245698232361529, 0.17378190991324727, 0.39435273595609166], "final_y": [0.0008985239000304517, 0.31668780882583847, 0.0023771222526595614]}, "mutation_prompt": null}
{"id": "2c14f9d1-f103-46ea-8c1f-6bb5e274432d", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        while evaluations < self.budget:\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * np.random.rand() * (1 - evaluations / self.budget)  # Randomize learning factor\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            tournament_indices = np.random.choice(current_harmony_memory_size, 2, replace=False)\n            worst_idx = tournament_indices[np.argmax(harmony_fitness[tournament_indices])]  # Tournament selection\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration by adapting mutation strategy and integrating tournament selection to balance diversity and convergence.", "configspace": "", "generation": 75, "fitness": 0.4437607104921342, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.444 with standard deviation 0.080. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.5538487104353587, 0.36362809603846846, 0.4138053250025756], "final_y": [2.4433176609955433e-06, 0.00029878386344029886, 0.00016995655021044572]}, "mutation_prompt": null}
{"id": "30166111-5450-45f7-bffc-c2bfae1705ae", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                best_harmony = harmony_memory[np.argmin(harmony_fitness)]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget) + 0.5 * np.linalg.norm(best_harmony - new_harmony) / np.linalg.norm(func.bounds.ub - func.bounds.lb)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration by adapting Differential weight based on distance to best-found solution.", "configspace": "", "generation": 76, "fitness": 0.1375906490475354, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.138 with standard deviation 0.029. And the mean value of best solutions found was 1.574 (0. is the best) with standard deviation 1.020.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.17740418112654066, 0.10897276391739019, 0.12639500209867538], "final_y": [0.42007906590291666, 2.901313916085186, 1.400704471755634]}, "mutation_prompt": null}
{"id": "c3e7049f-da0e-45ba-a16b-f781a66e26c6", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    # Dynamic Pitch Adjusting Rate\n                    dynamic_par = self.par * np.exp(-evaluations / self.budget)\n                    if np.random.rand() < dynamic_par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Implement a dynamic harmony pitch adjusting rate (PAR) that decays exponentially with the number of evaluations.", "configspace": "", "generation": 77, "fitness": 0.2682017125174404, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.268 with standard deviation 0.044. And the mean value of best solutions found was 0.065 (0. is the best) with standard deviation 0.053.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.21229622342125676, 0.272240169560525, 0.32006874457053947], "final_y": [0.1390259433290788, 0.039110672878812806, 0.016107645595554696]}, "mutation_prompt": null}
{"id": "ec251aea-f0b3-45f8-b1a2-e3f63364b1ce", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                fitness_variance = np.var(harmony_fitness)\n                self.f = 0.5 + 0.5 * fitness_variance / (1 + fitness_variance)  # Adaptive mutation rate\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance diversity and balance exploration-exploitation by introducing adaptive mutation rate based on fitness variance.", "configspace": "", "generation": 78, "fitness": 0.2914022510640783, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.291 with standard deviation 0.073. And the mean value of best solutions found was 0.062 (0. is the best) with standard deviation 0.086.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.3342573210256483, 0.35192713850705304, 0.1880222936595335], "final_y": [0.0034839679430146643, 0.0001713151632312358, 0.18333500887284587]}, "mutation_prompt": null}
{"id": "fe311a18-b72c-4c1d-94c3-016ff4f51c04", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                adaptive_f = self.f * np.exp(-(evaluations/self.budget))  # Adaptive mutation scaling\n                mutant_vector = x1 + adaptive_f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce adaptive mutation scaling in differential evolution to enhance convergence speed.", "configspace": "", "generation": 79, "fitness": 0.45558695844428776, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.456 with standard deviation 0.113. And the mean value of best solutions found was 0.007 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.5546206151723214, 0.51443268465365, 0.29770757550689186], "final_y": [1.13530762266187e-06, 3.1541436715822334e-05, 0.02134633541408403]}, "mutation_prompt": null}
{"id": "3c84ff5a-25e1-446a-b139-acf1ec7fce17", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                self.cr = 0.9 - 0.4 * (evaluations / self.budget)  # Dynamic crossover probability\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Integrate a dynamic crossover probability to improve exploration and convergence balance.", "configspace": "", "generation": 80, "fitness": 0.24589875446940304, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.115. And the mean value of best solutions found was 0.409 (0. is the best) with standard deviation 0.290.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.40858794005470844, 0.16062773798827146, 0.16848058536522925], "final_y": [0.0008053965892525928, 0.6510644546675275, 0.5743565119985947]}, "mutation_prompt": null}
{"id": "b7b0f4b6-dea9-4ed0-89e6-fefd208fe5ff", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        # Change made here:\n                        self.par = 0.3 + 0.7 * (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration by dynamically adjusting pitch adjustment rate based on evaluations.", "configspace": "", "generation": 81, "fitness": 0.36993952004276087, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.370 with standard deviation 0.046. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.3483791477132785, 0.4339776257193271, 0.32746178669567694], "final_y": [0.002790046500468746, 3.2190322777405764e-05, 0.004302554139569343]}, "mutation_prompt": null}
{"id": "fe4823db-fe54-4346-adb8-800ebcd56761", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        # Modified line for Gaussian perturbation\n                        new_harmony[i] += np.random.normal(0, 0.01 * adapt_factor * (func.bounds.ub[i] - func.bounds.lb[i]))\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance pitch adjustment by using a Gaussian perturbation for a finer exploration.", "configspace": "", "generation": 82, "fitness": 0.382871585317967, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.383 with standard deviation 0.042. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.38651832314416845, 0.32945654198148133, 0.4326398908282514], "final_y": [0.0003222658218208473, 0.0018553803135041552, 2.1295269949679534e-07]}, "mutation_prompt": null}
{"id": "1ff35073-fa66-4f31-a06d-4ff41c7aea10", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        dynamic_par = self.par * adapt_factor\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * dynamic_par\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                self.cr = 0.9 * (1 - (evaluations / self.budget)) + 0.1  # Self-adaptive crossover probability\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance adaptive behavior by dynamically adjusting pitch adjustment rate and integrating self-adaptive crossover probability in DE.", "configspace": "", "generation": 83, "fitness": 0.2573804853118459, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.257 with standard deviation 0.101. And the mean value of best solutions found was 0.321 (0. is the best) with standard deviation 0.365.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.1621644628914808, 0.2123258417813909, 0.3976511512626659], "final_y": [0.8314489860737913, 0.13192009221995432, 0.0010898376769580625]}, "mutation_prompt": null}
{"id": "4258ef26-78d9-4c72-9717-8a1f5da8062a", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget) ** 2  # Changed line: squared decay for adapt factor\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration by introducing a dynamic pitch adjustment scaling based on the remaining budget.", "configspace": "", "generation": 84, "fitness": 0.29687106713269984, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.297 with standard deviation 0.058. And the mean value of best solutions found was 0.030 (0. is the best) with standard deviation 0.032.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.3785492555787091, 0.26740134145433303, 0.24466260436505738], "final_y": [0.00015539923265988156, 0.014444537088077546, 0.07419490199917374]}, "mutation_prompt": null}
{"id": "e04bc799-8542-4825-bc11-95b05d57038b", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                self.cr = 0.9 - 0.4 * (evaluations / self.budget)  # Adaptive crossover probability\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce adaptive crossover probability to enhance exploration and exploitation balance.", "configspace": "", "generation": 85, "fitness": 0.24589875446940304, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.115. And the mean value of best solutions found was 0.409 (0. is the best) with standard deviation 0.290.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.40858794005470844, 0.16062773798827146, 0.16848058536522925], "final_y": [0.0008053965892525928, 0.6510644546675275, 0.5743565119985947]}, "mutation_prompt": null}
{"id": "89ed9661-1927-4a51-b338-686a23b47b67", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                self.cr = 0.9 - 0.4 * (evaluations / self.budget)  # Dynamic crossover probability adjustment\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a dynamic crossover probability adjustment to enhance exploration and exploitation balance.", "configspace": "", "generation": 86, "fitness": 0.24589875446940304, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.115. And the mean value of best solutions found was 0.409 (0. is the best) with standard deviation 0.290.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.40858794005470844, 0.16062773798827146, 0.16848058536522925], "final_y": [0.0008053965892525928, 0.6510644546675275, 0.5743565119985947]}, "mutation_prompt": null}
{"id": "bd552c2e-4aca-4066-943c-527a3daa1b2e", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()  # Probabilistic learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration by introducing a probabilistic learning factor adjustment in the Differential Evolution phase.", "configspace": "", "generation": 87, "fitness": 0.3962140629162279, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.396 with standard deviation 0.060. And the mean value of best solutions found was 0.007 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.31149183288021565, 0.4455318613653505, 0.4316184945031176], "final_y": [0.020696553760957498, 0.0001422989059108579, 0.0003120064198544462]}, "mutation_prompt": null}
{"id": "8b27d284-68fd-46dd-aae1-2d511d8d0af3", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                self.cr = 0.5 + 0.5 * (np.var(harmony_fitness[:current_harmony_memory_size]) / np.mean(harmony_fitness[:current_harmony_memory_size]))  # Dynamic crossover probability adjustment\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration by introducing a dynamic crossover probability adjustment based on fitness variance in the harmony memory.", "configspace": "", "generation": 88, "fitness": 0.4164753944495656, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.416 with standard deviation 0.030. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.38265478079751947, 0.4551082827054481, 0.41166311984572923], "final_y": [0.0005445234939581852, 0.0003243895301239508, 0.000562771085766919]}, "mutation_prompt": null}
{"id": "287ca16f-d546-4295-8a11-d9f3670bde09", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment with sinusoidal modulation\n                        sinusoidal_modulation = np.sin(np.pi * evaluations / self.budget)\n                        adapt_factor = 1 - (evaluations / self.budget) * sinusoidal_modulation\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce adaptive pitch adjustment by incorporating a sinusoidal modulation factor to enhance exploration capabilities.", "configspace": "", "generation": 89, "fitness": 0.24871904001269418, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.249 with standard deviation 0.044. And the mean value of best solutions found was 0.101 (0. is the best) with standard deviation 0.101.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.25989951412480106, 0.19037053606386334, 0.29588706984941815], "final_y": [0.04671232338257123, 0.24266917765164628, 0.014512571204975358]}, "mutation_prompt": null}
{"id": "1115ffc1-2bf7-4f89-829f-3b17de90ec70", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                self.cr = 0.9 * (1 - evaluations / self.budget) + 0.1  # Dynamic crossover probability adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a dynamic crossover probability adjustment based on evaluations to enhance exploration and exploitation balance.", "configspace": "", "generation": 90, "fitness": 0.2328166288456461, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.233 with standard deviation 0.043. And the mean value of best solutions found was 0.157 (0. is the best) with standard deviation 0.189.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.23635050439071503, 0.28407934907051335, 0.1780200330757099], "final_y": [0.04470950303998675, 0.003338824368110759, 0.4227090137881543]}, "mutation_prompt": null}
{"id": "fc55ffc1-eddc-4154-aaf0-9bc0ff9214fb", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.7 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Refine the mutation factor to improve exploration capabilities in the HybridHarmonyDifferentialEvolution algorithm.", "configspace": "", "generation": 91, "fitness": 0.304298748019332, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.304 with standard deviation 0.092. And the mean value of best solutions found was 0.086 (0. is the best) with standard deviation 0.116.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.31573089605610827, 0.4106797486031004, 0.18648559939878728], "final_y": [0.005944288152074749, 0.001087183646964819, 0.2500728254409279]}, "mutation_prompt": null}
{"id": "ccc44715-5492-4744-b4e3-d11f9a33c635", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                self.cr = 0.6 + 0.4 * (evaluations / self.budget)     # Adaptive crossover probability\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce adaptive crossover probability to improve exploration and exploitation balance.", "configspace": "", "generation": 92, "fitness": 0.21990847339586997, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.220 with standard deviation 0.064. And the mean value of best solutions found was 0.478 (0. is the best) with standard deviation 0.635.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.22641183002609488, 0.1383420806045229, 0.29497150955699214], "final_y": [0.04091787053374232, 1.3760378956957504, 0.018471853087118264]}, "mutation_prompt": null}
{"id": "887c5f9d-e17f-4d73-a97b-3899370c2666", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration by dynamically adjusting pitch adjustment rate based on evaluations.", "configspace": "", "generation": 93, "fitness": 0.3520149497532116, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.352 with standard deviation 0.072. And the mean value of best solutions found was 0.010 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.4123271645877433, 0.251571458868146, 0.3921462258037455], "final_y": [5.1765052056713815e-05, 0.028008980319592897, 0.0004768302499886957]}, "mutation_prompt": null}
{"id": "983499d5-b20e-41e3-8030-96b0981f7a00", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 3))  # Adjusted from 5 to 3\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Incorporate adaptive harmony memory size scaling to enhance exploration-exploitation balance.", "configspace": "", "generation": 94, "fitness": 0.26179378675503867, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.262 with standard deviation 0.006. And the mean value of best solutions found was 0.031 (0. is the best) with standard deviation 0.022.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.25327052355418445, 0.26740973677134805, 0.2647010999395836], "final_y": [0.04101159217036548, 0.0003650199208571538, 0.051522492664170264]}, "mutation_prompt": null}
{"id": "905a41c2-c6ac-41c2-b54d-ab54c8567ab8", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - np.sqrt(evaluations / self.budget))  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance adaptation by refining the learning factor to linearly depend on the square root of evaluation progress.", "configspace": "", "generation": 95, "fitness": 0.4836231385676175, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.484 with standard deviation 0.161. And the mean value of best solutions found was 0.003 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.2579343094086305, 0.6198171555655612, 0.5731179507286608], "final_y": [0.008656581517378147, 5.208175193111463e-09, 1.281542635325554e-06]}, "mutation_prompt": null}
{"id": "5c491def-11ca-4c55-8dfb-3c06fe1d210e", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.3 * (1 - evaluations / self.budget)  # Convergence-driven adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a convergence-driven adaptive strategy for dynamic differential weight adjustment.", "configspace": "", "generation": 96, "fitness": 0.2371566831010217, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.237 with standard deviation 0.076. And the mean value of best solutions found was 0.440 (0. is the best) with standard deviation 0.610.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.2468849527652065, 0.13906708888772534, 0.3255180076501333], "final_y": [0.017611115038464832, 1.3031311004285386, 0.0005173273248722729]}, "mutation_prompt": null}
{"id": "96c5e804-b326-4aad-9ed6-5cbec7a26b71", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, int(self.harmony_memory_size * (1 - (evaluations / self.budget))))  # Adjusted line\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce adaptive harmony memory size to improve exploration and exploitation balance.", "configspace": "", "generation": 97, "fitness": 0.1578110289150347, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.158 with standard deviation 0.010. And the mean value of best solutions found was 0.804 (0. is the best) with standard deviation 0.230.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.1639124861766884, 0.1438157285537246, 0.16570487201469108], "final_y": [0.7102005318566205, 1.1207791272286178, 0.5803256794202616]}, "mutation_prompt": null}
{"id": "e1cee315-34f0-49ae-85e0-840ab155a933", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                self.cr = 0.9 - 0.4 * (evaluations / self.budget)  # Adaptive crossover probability\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration by adjusting crossover probability dynamically based on evaluations.", "configspace": "", "generation": 98, "fitness": 0.48234075314815844, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.482 with standard deviation 0.046. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.4468749514444187, 0.45313794318425615, 0.5470093648158005], "final_y": [2.5204282599830016e-05, 1.9197603187352692e-05, 1.8670470584144517e-05]}, "mutation_prompt": null}
{"id": "1b00e917-ce80-41c9-bb57-53b3ca990778", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjusting Rate\n        self.f = 0.5     # Differential weight\n        self.cr = 0.9    # Crossover probability\n\n    def __call__(self, func):\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(\n            low=func.bounds.lb, high=func.bounds.ub, size=(self.harmony_memory_size, self.dim)\n        )\n        harmony_fitness = np.array([func(hm) for hm in harmony_memory])\n        evaluations = self.harmony_memory_size\n        \n        # Optimization loop\n        while evaluations < self.budget:\n            # Dynamically adjust harmony memory size based on evaluations\n            current_harmony_memory_size = max(5, self.harmony_memory_size - int((evaluations / self.budget) * 5))\n            \n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Memory consideration\n                    new_harmony[i] = harmony_memory[np.random.randint(current_harmony_memory_size), i]\n                    if np.random.rand() < self.par:\n                        # Adaptive Pitch adjustment\n                        adapt_factor = 1 - (evaluations / self.budget)\n                        new_harmony[i] += np.random.uniform(-1, 1) * (func.bounds.ub[i] - func.bounds.lb[i]) * 0.01 * adapt_factor\n                else:\n                    # Random selection\n                    new_harmony[i] = np.random.uniform(func.bounds.lb[i], func.bounds.ub[i])\n\n            new_harmony = np.clip(new_harmony, func.bounds.lb, func.bounds.ub)\n            new_harmony_fitness = func(new_harmony)\n            evaluations += 1\n\n            # Differential Evolution\n            if evaluations < self.budget:\n                idxs = np.random.choice(current_harmony_memory_size, 3, replace=False)\n                x1, x2, x3 = harmony_memory[idxs]\n                self.f = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Learning factor adjustment\n                self.cr = 0.9 * (evaluations / self.budget)  # Adaptive crossover adjustment\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, new_harmony)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Select the best solution\n                if trial_fitness < new_harmony_fitness:\n                    new_harmony, new_harmony_fitness = trial_vector, trial_fitness\n\n            # Update harmony memory if new harmony is better\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(harmony_fitness)\n        return harmony_memory[best_idx]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce adaptive crossover probability adjustment to enhance solution diversity.", "configspace": "", "generation": 99, "fitness": 0.1356547059716795, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.136 with standard deviation 0.012. And the mean value of best solutions found was 1.527 (0. is the best) with standard deviation 0.421.", "error": "", "parent_id": "64d76a15-d6c1-4e26-9d88-208437868e40", "metadata": {"aucs": [0.1341939115105547, 0.12149468131411478, 0.151275525090369], "final_y": [1.4404713972400234, 2.0809751858604417, 1.059964367437439]}, "mutation_prompt": null}
