{"id": "d8cfedbf-7dd7-4485-8ecd-1906ca872f4d", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                # Apply Simulated Annealing for exploitation\n                if np.random.rand() < np.exp(-(score - global_best_score) / self.temperature):\n                    if score < global_best_score:\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSOSA", "description": "A novel hybrid metaheuristic combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) to efficiently explore and exploit search spaces for black-box optimization problems.", "configspace": "", "generation": 0, "fitness": 0.21355062839146954, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.214 with standard deviation 0.021. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.063.", "error": "", "parent_id": null, "metadata": {"aucs": [0.22851012932240633, 0.2289699991091626, 0.1831717567428397], "final_y": [0.08380205140393618, 0.1058188283726997, 0.22803423363764386]}, "mutation_prompt": null}
{"id": "154acd53-e187-4bc5-a776-2695172a8a5d", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Dynamic inertia weight adjustment\n                inertia = self.inertia_weight * (0.5 + np.random.rand() / 2) * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                score = func(particles[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                if np.random.rand() < np.exp(-(score - global_best_score) / self.temperature):\n                    if score < global_best_score:\n                        global_best_position, global_best_score = particles[i], score\n                # Introduce random jumps\n                if np.random.rand() < 0.1:\n                    particles[i] = np.random.uniform(lb, ub, self.dim)\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by dynamically adjusting inertia and introducing random jumps for improved exploration.", "configspace": "", "generation": 1, "fitness": 0.2110399438207321, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.211 with standard deviation 0.023. And the mean value of best solutions found was 0.282 (0. is the best) with standard deviation 0.217.", "error": "", "parent_id": "d8cfedbf-7dd7-4485-8ecd-1906ca872f4d", "metadata": {"aucs": [0.22400554783116478, 0.2301326531163136, 0.17898163051471794], "final_y": [0.24232481763500852, 0.03774217945118173, 0.5659791734469436]}, "mutation_prompt": null}
{"id": "f3b0e2e0-dfd0-48c8-90d1-1a2bb48d47c1", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                # Apply Simulated Annealing for exploitation\n                if np.random.rand() < np.exp(-(score - global_best_score) / self.temperature):\n                    if score < global_best_score:\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "A refined hybrid metaheuristic combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) with adaptive inertia to enhance search efficiency in black-box optimization problems.", "configspace": "", "generation": 2, "fitness": 0.21737733820780678, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.217 with standard deviation 0.033. And the mean value of best solutions found was 0.086 (0. is the best) with standard deviation 0.060.", "error": "", "parent_id": "d8cfedbf-7dd7-4485-8ecd-1906ca872f4d", "metadata": {"aucs": [0.26322322974754875, 0.18550841571795063, 0.20340036915792092], "final_y": [0.014383735256230552, 0.16186816309457602, 0.08239557682008332]}, "mutation_prompt": null}
{"id": "c2dd37ff-c3b7-44c9-9688-c0bc56d2e57d", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.1 * np.random.uniform(-2, 2, self.dim)  # Enhanced exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                # Apply Simulated Annealing for exploitation\n                if np.random.rand() < np.exp(-(score - global_best_score) / self.temperature):\n                    if score < global_best_score:\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Improved HybridPSOSA with dynamic population size adjustment and enhanced velocity update rules for better exploration-exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.22386534484476198, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.224 with standard deviation 0.018. And the mean value of best solutions found was 0.102 (0. is the best) with standard deviation 0.028.", "error": "", "parent_id": "f3b0e2e0-dfd0-48c8-90d1-1a2bb48d47c1", "metadata": {"aucs": [0.20832950814000495, 0.21419768020225283, 0.24906884619202818], "final_y": [0.14007196156125104, 0.09502200790753494, 0.07167576395853585]}, "mutation_prompt": null}
{"id": "a44db520-1323-49c2-9869-00f1e043e8e3", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by adjusting velocity update rules and personal best position strategy for improved exploration-exploitation.", "configspace": "", "generation": 4, "fitness": 0.28123336087949147, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.281 with standard deviation 0.014. And the mean value of best solutions found was 0.036 (0. is the best) with standard deviation 0.020.", "error": "", "parent_id": "c2dd37ff-c3b7-44c9-9688-c0bc56d2e57d", "metadata": {"aucs": [0.2714111824888148, 0.271790052870718, 0.3004988472789416], "final_y": [0.041508452599182365, 0.05772925403943972, 0.00955031933674791]}, "mutation_prompt": null}
{"id": "009c749d-17ca-474c-85d1-efb4d00881c2", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * (1 - evaluations/self.budget) * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduced a dynamic social constant that decreases over time to balance exploration and exploitation.", "configspace": "", "generation": 5, "fitness": 0.24369972303735787, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.043. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.116.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.24246670727537434, 0.19227301739738034, 0.29635944443931894], "final_y": [0.06551301004954872, 0.28359557551076425, 0.01716562449445154]}, "mutation_prompt": null}
{"id": "2bda5400-f3a8-43e8-aa03-f3d6aedad162", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                # Dynamic adjustment of cognitive and social constants\n                cognitive = (self.cognitive_constant + np.random.rand()) * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = (self.social_constant + np.random.rand()) * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA with dynamic cognitive and social constants for improved convergence and optimization.", "configspace": "", "generation": 6, "fitness": 0.22882565348963657, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.229 with standard deviation 0.020. And the mean value of best solutions found was 0.061 (0. is the best) with standard deviation 0.039.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.20472445700628905, 0.22844646257012713, 0.25330604089249353], "final_y": [0.1019886151014442, 0.00856913221090501, 0.07338192790885656]}, "mutation_prompt": null}
{"id": "de49f011-0e4e-44e1-bece-cd958d0064be", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * (0.5 + np.random.rand(self.dim)) * (global_best_position - particle)  # Adjusted line\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by adding a dynamic social constant adjustment for improved convergence stability.", "configspace": "", "generation": 7, "fitness": 0.21894169062336866, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.219 with standard deviation 0.014. And the mean value of best solutions found was 0.155 (0. is the best) with standard deviation 0.058.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.20562289545905443, 0.23762769821877128, 0.21357447819228026], "final_y": [0.17357414095834353, 0.07643376862135323, 0.21611268910389633]}, "mutation_prompt": null}
{"id": "75a8f582-d6f4-436d-9d1f-5a4ba61687a4", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim) + np.random.normal(0, 0.1, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by incorporating Gaussian noise for finer exploration-exploitation balancing.", "configspace": "", "generation": 8, "fitness": 0.22885785589564425, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.229 with standard deviation 0.024. And the mean value of best solutions found was 0.112 (0. is the best) with standard deviation 0.056.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.2216121250786447, 0.20316494840478205, 0.26179649420350604], "final_y": [0.12862150872878939, 0.1710093785124371, 0.036215469636141036]}, "mutation_prompt": null}
{"id": "8d544ead-c8d4-4a9c-8adf-3e76969d7dbb", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim) * np.log(1 + 0.5 * evaluations/self.budget)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Adaptive velocity update for improved convergence in the Enhanced HybridPSOSA.", "configspace": "", "generation": 9, "fitness": 0.26422455739839157, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.264 with standard deviation 0.022. And the mean value of best solutions found was 0.029 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.27283488283786483, 0.2859267217974981, 0.23391206755981175], "final_y": [0.023690031087307523, 0.016091027663687932, 0.0459687884994501]}, "mutation_prompt": null}
{"id": "d9af4b34-17f9-4e4c-a25a-19c13c77c5dd", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.1 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Improved HybridPSOSA by enhancing velocity perturbation for better exploitation. ", "configspace": "", "generation": 10, "fitness": 0.23742091216737207, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.237 with standard deviation 0.020. And the mean value of best solutions found was 0.070 (0. is the best) with standard deviation 0.032.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.2102481924982127, 0.25932443329924315, 0.2426901107046604], "final_y": [0.10089303964338477, 0.02588949895849511, 0.08426869647594185]}, "mutation_prompt": null}
{"id": "74217ecd-e8cb-43cf-8756-07182c01ec76", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.6  # Adjusted social constant\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Slightly increased the social constant to boost the influence of the global best position for enhanced convergence.", "configspace": "", "generation": 11, "fitness": 0.23051424549798086, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.231 with standard deviation 0.023. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.075.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.24813781687320313, 0.19754213114274866, 0.2458627884779908], "final_y": [0.026330785309724537, 0.20903740878662166, 0.10295297535802617]}, "mutation_prompt": null}
{"id": "4c569127-ec54-4e13-bfd4-a40bd68b5543", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Refined HybridPSOSA by implementing chaotic local search with dynamic weight adjustments for enhanced exploration-exploitation balance.", "configspace": "", "generation": 12, "fitness": 0.22962543420553472, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.230 with standard deviation 0.021. And the mean value of best solutions found was 0.092 (0. is the best) with standard deviation 0.040.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.21376206439427847, 0.21627824184927502, 0.25883599637305066], "final_y": [0.1155320118615739, 0.12495623827530997, 0.03586426270920761]}, "mutation_prompt": null}
{"id": "9b50efe6-7e34-46d6-a342-58b683f231a9", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.7  # Adjusted cognitive constant for improved strategy\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by fine-tuning the cognitive constant for better balancing exploration and exploitation.", "configspace": "", "generation": 13, "fitness": 0.22651012634599277, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.227 with standard deviation 0.024. And the mean value of best solutions found was 0.064 (0. is the best) with standard deviation 0.025.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.22270062018705294, 0.19952678919309674, 0.2573029696578286], "final_y": [0.0935099365460624, 0.0642915505471973, 0.032914553739592955]}, "mutation_prompt": null}
{"id": "977a0a7b-9b29-4024-ad1c-49ec424c9632", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.0 + np.random.rand() * 1.0  # Dynamic cognitive constant\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA with a dynamic cognitive constant for improved personal best convergence.", "configspace": "", "generation": 14, "fitness": 0.2438436090731895, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.009. And the mean value of best solutions found was 0.080 (0. is the best) with standard deviation 0.059.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.23799014800734009, 0.256574528013072, 0.23696615119915643], "final_y": [0.163179623898719, 0.03140111790202975, 0.0467922171439402]}, "mutation_prompt": null}
{"id": "e1350d4e-b5ab-4415-8366-0f046cc3293d", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n            # Adaptively update cognitive and social constants\n            self.cognitive_constant = 1.5 * (1 - evaluations / self.budget)\n            self.social_constant = 1.5 * (evaluations / self.budget)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by introducing adaptive cognitive and social constants for improved convergence balance.", "configspace": "", "generation": 15, "fitness": 0.2660331419706644, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.266 with standard deviation 0.009. And the mean value of best solutions found was 0.027 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.2547000231174321, 0.26565551717863667, 0.27774388561592445], "final_y": [0.03006944400510616, 0.021245006195694374, 0.029519576456239753]}, "mutation_prompt": null}
{"id": "0350da9c-829d-4607-9d52-d04a617c4fa5", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = np.random.uniform(1.0, 2.0) * self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = np.random.uniform(1.0, 2.0) * self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA with improved velocity update using adaptive cognitive and social factors for better convergence.", "configspace": "", "generation": 16, "fitness": 0.20834019284181082, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.208 with standard deviation 0.018. And the mean value of best solutions found was 0.276 (0. is the best) with standard deviation 0.044.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.1914809292843931, 0.20020833293896534, 0.23333131630207404], "final_y": [0.27353694920722693, 0.3318931182687758, 0.22301738900606546]}, "mutation_prompt": null}
{"id": "bbeea194-b229-4feb-9970-a9aebc1107fb", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                self.cognitive_constant = 1.5 + 0.5 * np.random.rand()  # Adjusted line\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduce a dynamic cognitive constant adjustment to enhance local search adaptability.", "configspace": "", "generation": 17, "fitness": 0.21231252625064742, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.212 with standard deviation 0.028. And the mean value of best solutions found was 0.091 (0. is the best) with standard deviation 0.060.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.191389137985013, 0.19345413847361104, 0.2520943022933182], "final_y": [0.15747925504292376, 0.10408692393798306, 0.011483487372659308]}, "mutation_prompt": null}
{"id": "2ecb69df-9077-4c3b-949e-4819cc141db3", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.7  # Adjusted cognitive constant\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by adapting the cognitive constant for improved convergence dynamics.", "configspace": "", "generation": 18, "fitness": 0.2645988234918316, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.265 with standard deviation 0.009. And the mean value of best solutions found was 0.030 (0. is the best) with standard deviation 0.017.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.27328832698640615, 0.26872309739085976, 0.25178504609822894], "final_y": [0.011528283882985883, 0.02593961246182476, 0.05225899937223296]}, "mutation_prompt": null}
{"id": "95610ba4-0755-43e2-b931-519bd423f9bf", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-1, 1, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Refined HybridPSOSA by reducing velocity perturbation to enhance local search and stability.", "configspace": "", "generation": 19, "fitness": 0.2438663590516917, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.030. And the mean value of best solutions found was 0.045 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.26909288819747534, 0.20175893806531897, 0.2607472508922808], "final_y": [0.033920487721544726, 0.03687480132096636, 0.06454231075274645]}, "mutation_prompt": null}
{"id": "60d6ad62-7e5b-41e8-a330-9d04e0d91f9a", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-3, 3, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Improved exploration by adjusting the random factor in the velocity update.", "configspace": "", "generation": 20, "fitness": 0.22753358265899126, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.228 with standard deviation 0.016. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.22234005850380412, 0.21142140674367127, 0.2488392827294984], "final_y": [0.1273709029288174, 0.11507989560553758, 0.09545215426386926]}, "mutation_prompt": null}
{"id": "d4a77bc5-e7e1-4119-adba-8fe47795c36e", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n            # Adaptive adjustment for social constant\n            self.social_constant = 1.5 + 0.5 * (1 - evaluations / self.budget)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduce adaptive social constant adjustment to enhance convergence by adapting to optimization problem dynamics.", "configspace": "", "generation": 21, "fitness": 0.24140606488653724, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.241 with standard deviation 0.010. And the mean value of best solutions found was 0.080 (0. is the best) with standard deviation 0.042.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.23366693529862836, 0.23535899869136256, 0.25519226066962075], "final_y": [0.03710333839227587, 0.1376078184772515, 0.0648705192021516]}, "mutation_prompt": null}
{"id": "4c8931b0-b7b7-42f8-bc96-01cd7fa49ff8", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= (0.9 + 0.1 * self.temperature * np.random.rand())  # Adaptive cooling rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduce adaptive cooling rate to improve convergence by adjusting the exploration-exploitation balance dynamically.", "configspace": "", "generation": 22, "fitness": 0.24592269941413422, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.028. And the mean value of best solutions found was 0.073 (0. is the best) with standard deviation 0.072.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.2714172260835299, 0.20670412165570629, 0.25964675050316643], "final_y": [0.026157752220840998, 0.17487881783218656, 0.018968065657053477]}, "mutation_prompt": null}
{"id": "6803dcb1-a49e-43fb-99c8-27188ecbff34", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.98)  # Fine-tuned decay\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Fine-tune the inertia weight decay strategy for enhanced convergence and balance between exploration and exploitation.", "configspace": "", "generation": 23, "fitness": 0.2382492157033894, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.238 with standard deviation 0.031. And the mean value of best solutions found was 0.099 (0. is the best) with standard deviation 0.116.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.28054391624910713, 0.22848625001983247, 0.20571748084122854], "final_y": [0.0246654349057003, 0.01026730053419497, 0.2621808745866803]}, "mutation_prompt": null}
{"id": "8538e258-0508-4c88-8df7-3d5851f70857", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                # Dynamic adaptation of social constant\n                dynamic_social_constant = self.social_constant * (1 - evaluations / self.budget)\n                social = dynamic_social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by introducing a dynamic social constant adaptation to balance exploration and exploitation.", "configspace": "", "generation": 24, "fitness": 0.24369972303735787, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.043. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.116.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.24246670727537434, 0.19227301739738034, 0.29635944443931894], "final_y": [0.06551301004954872, 0.28359557551076425, 0.01716562449445154]}, "mutation_prompt": null}
{"id": "7e2a865a-0aee-480b-a42e-f44146588091", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                # Adaptive cognitive and social constants\n                cognitive = (self.cognitive_constant + 0.1) * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = (self.social_constant + 0.1) * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA with adaptive cognitive and social constants for improved exploration-exploitation balance.", "configspace": "", "generation": 25, "fitness": 0.23531252481400847, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.235 with standard deviation 0.028. And the mean value of best solutions found was 0.090 (0. is the best) with standard deviation 0.037.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.23402006668606357, 0.20144298992002152, 0.27047451783594034], "final_y": [0.08055719363204639, 0.13953409635021322, 0.05129174904920678]}, "mutation_prompt": null}
{"id": "f1249263-02f1-4c7e-9eee-3390c5e5c809", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score - 1e-5:  # Strategy change for updating the global best with adaptive threshold\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Refine global best update strategy by adding an adaptive threshold to enhance convergence precision.", "configspace": "", "generation": 26, "fitness": 0.22962543420553472, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.230 with standard deviation 0.021. And the mean value of best solutions found was 0.092 (0. is the best) with standard deviation 0.040.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.21376206439427847, 0.21627824184927502, 0.25883599637305066], "final_y": [0.1155320118615739, 0.12495623827530997, 0.03586426270920761]}, "mutation_prompt": null}
{"id": "3db0ebc3-7d18-4a08-aa34-b51d1bd2c94c", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n            # New: Adaptive social constant adjustment\n            self.social_constant = max(1.0, self.social_constant * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Improved HybridPSOSA with adaptive social constant adjustment for enhanced convergence.", "configspace": "", "generation": 27, "fitness": 0.2567256727865352, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.257 with standard deviation 0.033. And the mean value of best solutions found was 0.043 (0. is the best) with standard deviation 0.026.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.21815654169544585, 0.25347652622151085, 0.2985439504426489], "final_y": [0.06884605479143414, 0.05172333795052987, 0.00805312140794736]}, "mutation_prompt": null}
{"id": "2f63afd5-0f12-4eeb-95d0-1db7ae3a0132", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n        prev_global_best_score = global_best_score\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Adjust social constant based on improvement\n            if global_best_score < prev_global_best_score:\n                self.social_constant = min(2.0, self.social_constant + 0.05)\n            else:\n                self.social_constant = max(1.0, self.social_constant - 0.05)\n            prev_global_best_score = global_best_score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Improved HybridPSOSA by introducing adaptive social constant adjustment based on global best score trends for enhanced convergence.", "configspace": "", "generation": 28, "fitness": 0.24452483112532641, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.014. And the mean value of best solutions found was 0.062 (0. is the best) with standard deviation 0.035.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.2488265563579647, 0.22577815285518832, 0.25896978416282623], "final_y": [0.025170211053823208, 0.10867009560955415, 0.050918989159301924]}, "mutation_prompt": null}
{"id": "46f91897-535f-438a-b608-fcbfa5a54540", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.6  # Adjusted cognitive constant\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Slightly adjust cognitive constant to improve exploration and convergence balance.", "configspace": "", "generation": 29, "fitness": 0.24695300095976602, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.036. And the mean value of best solutions found was 0.067 (0. is the best) with standard deviation 0.060.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.23903659917164521, 0.20696463777300012, 0.29485776593465274], "final_y": [0.03552945408333053, 0.15008066340775328, 0.014362297416250077]}, "mutation_prompt": null}
{"id": "0ba1f1f0-fba4-45d2-81ab-ef72edfd1aad", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)  # Adjusted exploration\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n            # Adaptive adjustment for cognitive and social constants\n            self.cognitive_constant = 1.5 + 0.5 * (global_best_score / np.mean(personal_best_scores))\n            self.social_constant = 1.5 + 0.5 * (1 - global_best_score / np.mean(personal_best_scores))\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Improved Enhanced HybridPSOSA with adaptive cognitive and social constants for dynamic balance between exploration and exploitation.", "configspace": "", "generation": 30, "fitness": 0.22645613803719955, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.226 with standard deviation 0.018. And the mean value of best solutions found was 0.066 (0. is the best) with standard deviation 0.041.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.2228359089826556, 0.20631905133180117, 0.2502134537971419], "final_y": [0.11420577222884393, 0.014807105621426593, 0.06756186945205553]}, "mutation_prompt": null}
{"id": "c4586638-faa7-4eda-92da-f03deeeca218", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by integrating temperature-dependent velocity scaling for improved convergence.", "configspace": "", "generation": 31, "fitness": 0.30087932286815244, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.301 with standard deviation 0.018. And the mean value of best solutions found was 0.006 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "a44db520-1323-49c2-9869-00f1e043e8e3", "metadata": {"aucs": [0.31241719281436975, 0.27555185107539937, 0.3146689247146882], "final_y": [0.00687402847782703, 0.008280997575350734, 0.0019173997703411723]}, "mutation_prompt": null}
{"id": "4821d962-cd0d-45bb-af25-b7ae390e182c", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = (self.cognitive_constant * np.random.rand(self.dim) * \n                             (personal_best_positions[i] - particle) * \n                             np.random.uniform(0.8, 1.2))  # Adaptive cognitive constant\n                social = (self.social_constant * np.random.rand(self.dim) * \n                          (global_best_position - particle) * \n                          np.random.uniform(0.8, 1.2))  # Adaptive social constant\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA with adaptive cognitive and social constants for improved exploration and exploitation balance.", "configspace": "", "generation": 32, "fitness": 0.2788970385757326, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.279 with standard deviation 0.011. And the mean value of best solutions found was 0.014 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "c4586638-faa7-4eda-92da-f03deeeca218", "metadata": {"aucs": [0.2683487730833183, 0.2745294469075785, 0.2938128957363011], "final_y": [0.02187095187679169, 0.006195541489138662, 0.014324356605867753]}, "mutation_prompt": null}
{"id": "4312e980-1e4f-48f7-8692-4ed892befec8", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            iteration_progress = evaluations / self.budget  # Calculate iteration progress\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = (self.social_constant + 0.5 * iteration_progress) * np.random.rand(self.dim) * (global_best_position - particle)  # Adjusted social constant\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced convergence by adjusting social constant dynamically based on iteration progress.", "configspace": "", "generation": 33, "fitness": 0.2800741683538211, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.280 with standard deviation 0.009. And the mean value of best solutions found was 0.014 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "c4586638-faa7-4eda-92da-f03deeeca218", "metadata": {"aucs": [0.27770123304940164, 0.2702505640051015, 0.2922707080069601], "final_y": [0.014640321987373963, 0.012975583609196043, 0.012988208741345292]}, "mutation_prompt": null}
{"id": "2310ffe9-ff91-4c2a-88f2-c9adf92e0123", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n            # Dynamically adjust cognitive and social constants\n            self.cognitive_constant = 1.5 + 0.5 * np.cos(evaluations / self.budget * np.pi)\n            self.social_constant = 1.5 + 0.5 * np.sin(evaluations / self.budget * np.pi)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by adjusting cognitive and social constants dynamically for improved convergence.", "configspace": "", "generation": 34, "fitness": 0.2752224375914674, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.275 with standard deviation 0.012. And the mean value of best solutions found was 0.020 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "c4586638-faa7-4eda-92da-f03deeeca218", "metadata": {"aucs": [0.28406400602990434, 0.2588553930103549, 0.2827479137341431], "final_y": [0.011162374667195558, 0.0204969332582187, 0.028219856954749822]}, "mutation_prompt": null}
{"id": "168b8ee0-667a-4e0a-89cb-e78fd5dc0f3c", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= (self.cooling_rate - 0.0005 * (evaluations / self.budget))  # Dynamically adjust cooling rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by introducing dynamic cooling rate adjustment based on iteration count for improved convergence.", "configspace": "", "generation": 35, "fitness": 0.3007367119053749, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.301 with standard deviation 0.017. And the mean value of best solutions found was 0.008 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "c4586638-faa7-4eda-92da-f03deeeca218", "metadata": {"aucs": [0.3114082837018243, 0.27712837520709566, 0.3136734768072047], "final_y": [0.007585689269430341, 0.01207969356030123, 0.005214922425701228]}, "mutation_prompt": null}
{"id": "db862959-3c26-408e-bc56-d32817070a4d", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.6  # Adjusted initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Fine-tuned inertia weight and velocity scaling to improve convergence balance.", "configspace": "", "generation": 36, "fitness": 0.29854253053005025, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.299 with standard deviation 0.005. And the mean value of best solutions found was 0.007 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "c4586638-faa7-4eda-92da-f03deeeca218", "metadata": {"aucs": [0.30577201956927935, 0.29282527310091166, 0.2970302989199597], "final_y": [0.0029534384084605693, 0.0037372563500075585, 0.014859381170440675]}, "mutation_prompt": null}
{"id": "cdf9a918-1f6c-488d-b4b0-b0c6d90fcd30", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.7  # Adjusted social constant for better convergence\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by fine-tuning the social constant for improved convergence.", "configspace": "", "generation": 37, "fitness": 0.2770068707579744, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.277 with standard deviation 0.011. And the mean value of best solutions found was 0.018 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "c4586638-faa7-4eda-92da-f03deeeca218", "metadata": {"aucs": [0.2856143365364182, 0.26162882080041905, 0.28377745493708595], "final_y": [0.009138074230864926, 0.016486934980639245, 0.028278193746362926]}, "mutation_prompt": null}
{"id": "604ec79d-40ee-46a8-a22c-1ec99ef2efaa", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive_constant = self.cognitive_constant * (1 - evaluations / self.budget)  # Dynamic cognitive scaling\n                cognitive = cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by adjusting the cognitive constant dynamically based on iteration for better exploration.", "configspace": "", "generation": 38, "fitness": 0.29684195707864225, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.297 with standard deviation 0.030. And the mean value of best solutions found was 0.026 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "c4586638-faa7-4eda-92da-f03deeeca218", "metadata": {"aucs": [0.33969585218841913, 0.2722972662186013, 0.2785327528289063], "final_y": [0.007107788085176158, 0.029860161722503772, 0.041690799599080196]}, "mutation_prompt": null}
{"id": "1f12d601-01b4-4eb0-8bac-39a2cd7df1ef", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by adjusting the cooling rate for temperature-dependent velocity scaling to improve convergence.", "configspace": "", "generation": 39, "fitness": 0.31845538525769196, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.318 with standard deviation 0.022. And the mean value of best solutions found was 0.008 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "c4586638-faa7-4eda-92da-f03deeeca218", "metadata": {"aucs": [0.2913100310366815, 0.3188732618288833, 0.345182862907511], "final_y": [0.01596401086181027, 0.006532260980142427, 0.0005666395719837783]}, "mutation_prompt": null}
{"id": "d7bb5ae3-c205-4c94-8073-3a9778741dff", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight non-linearly\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99**2)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by introducing non-linear inertia weight decay for improved exploration-exploitation balance.", "configspace": "", "generation": 40, "fitness": 0.30995341206375654, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.310 with standard deviation 0.011. And the mean value of best solutions found was 0.005 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "1f12d601-01b4-4eb0-8bac-39a2cd7df1ef", "metadata": {"aucs": [0.29503170640556764, 0.3143623562799114, 0.32046617350579065], "final_y": [0.0028674409353250108, 0.00547584363976104, 0.007058558171738844]}, "mutation_prompt": null}
{"id": "6b2478d6-f6e4-4eda-bd59-047698773b6e", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n        global_update_counter = 0  # Added counter for adaptive global update\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    global_update_counter += 1  # Increment counter when personal best improves\n                    # Adaptive update for global best\n                    if global_update_counter > 5 and score < global_best_score:\n                        global_best_position, global_best_score = particles[i], score\n                        global_update_counter = 0  # Reset counter after update\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA with improved global best update by employing an adaptive global update frequency based on exploration-exploitation dynamics.", "configspace": "", "generation": 41, "fitness": 0.2979548891300157, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.298 with standard deviation 0.015. And the mean value of best solutions found was 0.016 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "1f12d601-01b4-4eb0-8bac-39a2cd7df1ef", "metadata": {"aucs": [0.28284406294312336, 0.3188732618288833, 0.29214734261804043], "final_y": [0.019689891362347743, 0.006532260980142427, 0.020824220305934022]}, "mutation_prompt": null}
{"id": "42fc94d7-dd75-43e9-9e6b-143539c8d2aa", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        global_best_memory = global_best_score  # Initialize memory for global best\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_memory:  # Strategy change for updating the global best\n                        global_best_memory = score  # Update memory\n                        if score < global_best_score:  # Confirm improvement\n                            global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced global best updating by incorporating a memory factor to confirm improvements over multiple iterations.", "configspace": "", "generation": 42, "fitness": 0.31845538525769196, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.318 with standard deviation 0.022. And the mean value of best solutions found was 0.008 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "1f12d601-01b4-4eb0-8bac-39a2cd7df1ef", "metadata": {"aucs": [0.2913100310366815, 0.3188732618288833, 0.345182862907511], "final_y": [0.01596401086181027, 0.006532260980142427, 0.0005666395719837783]}, "mutation_prompt": null}
{"id": "ef41bd0e-40b5-4dd5-be03-1cf2a45704b1", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle + 0.01 * np.random.randn(self.dim))  # Added random noise\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduced a small random perturbation to the cognitive component to enhance exploration and avoid local minima.", "configspace": "", "generation": 43, "fitness": 0.2822401687589259, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.282 with standard deviation 0.015. And the mean value of best solutions found was 0.014 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "1f12d601-01b4-4eb0-8bac-39a2cd7df1ef", "metadata": {"aucs": [0.26978134554347255, 0.27341753198930563, 0.30352162874399946], "final_y": [0.012132252476368186, 0.024002253945882908, 0.005470720137358363]}, "mutation_prompt": null}
{"id": "ea8ad092-6361-4d81-ab7f-4dc45c25291e", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.8  # Adjusted cognitive constant\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position, global_best_score = particles[i], score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by increasing cognitive constant to improve personal exploration efficacy.", "configspace": "", "generation": 44, "fitness": 0.3007959584311821, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.301 with standard deviation 0.012. And the mean value of best solutions found was 0.005 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "1f12d601-01b4-4eb0-8bac-39a2cd7df1ef", "metadata": {"aucs": [0.31785430961071637, 0.28932857775961085, 0.29520498792321914], "final_y": [0.0030918991478417193, 0.00456289055854312, 0.008488733458375348]}, "mutation_prompt": null}
{"id": "33ade7df-730c-451f-9e2c-e70a775d04c2", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by introducing random perturbations during global best updates to promote exploration and avoid local optima.", "configspace": "", "generation": 45, "fitness": 0.3276684231475084, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.328 with standard deviation 0.010. And the mean value of best solutions found was 0.004 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "1f12d601-01b4-4eb0-8bac-39a2cd7df1ef", "metadata": {"aucs": [0.34017246324082295, 0.31614283326615156, 0.3266899729355507], "final_y": [0.0024115957678991916, 0.006023827359836874, 0.003255642765563222]}, "mutation_prompt": null}
{"id": "4ab85fe5-6b26-4311-a354-f0a797e81f7f", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5  # Initialize social constant\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                self.social_constant = 1.5 + 0.5 * np.random.rand()  # Add dynamic social constant\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Adaptive HybridPSOSA with dynamic social constant to balance exploration and exploitation effectively.", "configspace": "", "generation": 46, "fitness": 0.24229144976006, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.242 with standard deviation 0.077. And the mean value of best solutions found was 0.499 (0. is the best) with standard deviation 0.692.", "error": "", "parent_id": "33ade7df-730c-451f-9e2c-e70a775d04c2", "metadata": {"aucs": [0.1371218835638922, 0.2702138346349269, 0.31953863108136094], "final_y": [1.4777993658536441, 0.014049038003087502, 0.006540084977060266]}, "mutation_prompt": null}
{"id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Integrate adaptive exploration by adjusting the social constant dynamically to enhance diversity and ability to escape local optima.", "configspace": "", "generation": 47, "fitness": 0.3448160585029582, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.345 with standard deviation 0.029. And the mean value of best solutions found was 0.004 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "33ade7df-730c-451f-9e2c-e70a775d04c2", "metadata": {"aucs": [0.3861974512694958, 0.31961780588983846, 0.32863291834954034], "final_y": [0.0009650614027376267, 0.002163782244419808, 0.008234750094542997]}, "mutation_prompt": null}
{"id": "9c74de5a-8213-4aba-935a-1babda156446", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n            self.cognitive_constant = max(1.0, self.cognitive_constant * 0.99)  # Adaptive cognitive constant\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduce a dynamic adjustment to the cognitive constant for improved local search adaptation.", "configspace": "", "generation": 48, "fitness": 0.27906375396110505, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.279 with standard deviation 0.006. And the mean value of best solutions found was 0.017 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.28658037647151624, 0.27933425804939427, 0.27127662736240465], "final_y": [0.010324227158837164, 0.015114927834459608, 0.02589129073502298]}, "mutation_prompt": null}
{"id": "72e84686-8490-4ecf-a4e7-a772b56d4b60", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.02 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Reduced scaling factor\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.005, 0.005, self.dim)  # Adjusted perturbation range\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance convergence by introducing dynamic damping in velocity updates and adaptive mutation in global best position updates.", "configspace": "", "generation": 49, "fitness": 0.3266230282429681, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.327 with standard deviation 0.006. And the mean value of best solutions found was 0.006 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.33147705147248985, 0.3298966773802947, 0.3184953558761199], "final_y": [0.006500100014017766, 0.005300008942083085, 0.0062406043890667]}, "mutation_prompt": null}
{"id": "f4828e50-a123-498a-8625-ca0ee653e94f", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * np.cos(0.1))  # Non-linear decay using cosine function\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduce non-linear inertia weight decay for better exploration-exploitation balance.", "configspace": "", "generation": 50, "fitness": 0.2833642368089884, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.283 with standard deviation 0.007. And the mean value of best solutions found was 0.017 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.27308625788839647, 0.289221071704334, 0.28778538083423477], "final_y": [0.01727602069149494, 0.021265760026718768, 0.011953912989469026]}, "mutation_prompt": null}
{"id": "a2a01d8f-369f-4920-81a8-6e51d6a52d7f", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        perturbation = np.random.uniform(-0.01, 0.01, self.dim) * (1 - evaluations / self.budget)  # Dynamic perturbation\n                        global_best_position = particles[i] + perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance global best update strategy by introducing dynamic perturbation based on evaluation progress.", "configspace": "", "generation": 51, "fitness": 0.2914137948446503, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.291 with standard deviation 0.003. And the mean value of best solutions found was 0.017 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.288406109773381, 0.2899595194740605, 0.29587575528650933], "final_y": [0.020955390355671826, 0.015263600238771673, 0.015067842219456644]}, "mutation_prompt": null}
{"id": "728e4bc2-d379-4f24-9143-50dede26ce2b", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = (self.inertia_weight + np.random.uniform(-0.05, 0.05)) * velocities[i]  # Randomized inertia weight perturbation\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.02, 0.02, self.dim)  # Additional global best perturbation step\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance adaptive exploration by introducing a randomized inertia weight perturbation and additional global best perturbation step.", "configspace": "", "generation": 52, "fitness": 0.3108328304769868, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.311 with standard deviation 0.013. And the mean value of best solutions found was 0.006 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.3273191330494398, 0.3086555739305086, 0.296523784451012], "final_y": [0.004741016333532221, 0.005337891903781143, 0.00802326137107466]}, "mutation_prompt": null}
{"id": "7ccd7785-f63a-4724-82cf-71e200bc6a47", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n            self.cognitive_constant = max(0.5, self.cognitive_constant * 0.97)  # Dynamic cognitive constant\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduce a dynamic cognitive constant to better balance exploration and exploitation while adjusting personal best updates.", "configspace": "", "generation": 53, "fitness": 0.3305266522765867, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.331 with standard deviation 0.009. And the mean value of best solutions found was 0.004 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.32272245853928916, 0.34370197630356203, 0.3251555219869089], "final_y": [0.005195417133961709, 0.001804580257449824, 0.004801264715688419]}, "mutation_prompt": null}
{"id": "5f28c7c8-3292-4285-a039-9a225d079c74", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature\n                \n                # Selective Velocity Reset\n                if np.random.rand() < 0.1:\n                    velocities[i] = np.random.uniform(-1, 1, self.dim)\n                \n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.97)  # Slightly faster decay\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced the balance between exploration and exploitation by dynamically adjusting the inertia weight and introducing selective velocity reset to improve convergence.", "configspace": "", "generation": 54, "fitness": 0.26889379287482656, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.269 with standard deviation 0.026. And the mean value of best solutions found was 0.040 (0. is the best) with standard deviation 0.030.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.27297093055913535, 0.2349254701152942, 0.2987849779500501], "final_y": [0.021500542890623715, 0.08171623004470419, 0.015903945397433596]}, "mutation_prompt": null}
{"id": "643a84bb-35ad-4916-8ff2-fed8e5044f7f", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n            self.cognitive_constant = max(1.0, self.cognitive_constant * 0.99)  # Adaptive cognitive constant\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduce a dynamic adjustment to the cognitive constant to enhance local search capabilities.", "configspace": "", "generation": 55, "fitness": 0.27682959222888354, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.277 with standard deviation 0.007. And the mean value of best solutions found was 0.016 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.27757687912717877, 0.2847655020372981, 0.2681463955221738], "final_y": [0.011111293487202788, 0.009154183896233245, 0.029087946395793925]}, "mutation_prompt": null}
{"id": "76903f17-ac90-41cc-a715-0e368980e93c", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.97 + 0.03 * np.random.rand())  # Non-linear adaptation\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance global search capability by introducing stochastic perturbations in velocity updates and leveraging non-linear inertia adaptation.", "configspace": "", "generation": 56, "fitness": 0.27995167452001835, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.280 with standard deviation 0.010. And the mean value of best solutions found was 0.023 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.28569329706105895, 0.2652474610642661, 0.28891426543473], "final_y": [0.01424687191869402, 0.03456681666657173, 0.01884533713346437]}, "mutation_prompt": null}
{"id": "3054b311-87f4-430d-a5ac-9b89c19d115c", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n            self.cooling_rate = max(0.85, self.cooling_rate * 0.99)  # Adaptive cooling rate\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance convergence by introducing an adaptive cooling rate that increases cooling as convergence stabilizes.", "configspace": "", "generation": 57, "fitness": 0.28559585499928325, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.286 with standard deviation 0.021. And the mean value of best solutions found was 0.023 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.2774501678395618, 0.31442607075764817, 0.26491132640063975], "final_y": [0.025474375177235685, 0.005489735943066723, 0.036993975419474606]}, "mutation_prompt": null}
{"id": "cb0565b6-0d4a-4c4d-b2e4-e2da9fedcbba", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5  # Dynamic cognitive constant\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            self.cognitive_constant = max(0.7, self.cognitive_constant * 0.97)  # Adaptive cognitive constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance exploration by dynamically adjusting cognitive constant and introducing mutation to avoid premature convergence.", "configspace": "", "generation": 58, "fitness": 0.29579644543195216, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.296 with standard deviation 0.011. And the mean value of best solutions found was 0.009 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.30442519542896573, 0.302033748346898, 0.28093039251999274], "final_y": [0.007613959741089071, 0.007333318992138842, 0.012346237228480229]}, "mutation_prompt": null}
{"id": "8403024f-c131-4db2-8bd7-7a37a0841a1b", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            self.cognitive_constant = max(1.0, self.cognitive_constant * 1.02)  # Adaptive cognitive constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance adaptive exploration and exploitation by introducing a dynamic cognitive constant adjustment and improved velocity scaling.", "configspace": "", "generation": 59, "fitness": 0.3040691429610938, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.304 with standard deviation 0.013. And the mean value of best solutions found was 0.010 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.3162001552460527, 0.286606301075372, 0.3094009725618566], "final_y": [0.0079829531270938, 0.011929288740572584, 0.010062947019119167]}, "mutation_prompt": null}
{"id": "4a786ddc-dabb-401a-b2d6-b92051765935", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            self.cognitive_constant = max(1.2, self.cognitive_constant * 0.97)  # Adaptive cognitive constant\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduce a dynamic cognitive constant to balance exploration and exploitation throughout the optimization process.", "configspace": "", "generation": 60, "fitness": 0.2910570695294355, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.291 with standard deviation 0.033. And the mean value of best solutions found was 0.021 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.2736160459748108, 0.33702972407395104, 0.2625254385395447], "final_y": [0.025646016107402424, 0.004617417735745456, 0.031409487762600344]}, "mutation_prompt": null}
{"id": "797310e7-e5ce-4956-8cba-70a05b7aba63", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.1 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Modifying velocity update\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature with a more adaptive schedule\n            self.temperature *= self.cooling_rate + 0.005 * (1 - evaluations / self.budget)\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduce an adaptive cooling schedule for the temperature and modify velocity update to include an additional random component for enhanced exploration.", "configspace": "", "generation": 61, "fitness": 0.2830530001985241, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.283 with standard deviation 0.020. And the mean value of best solutions found was 0.020 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.2775889887605455, 0.2615882073244825, 0.30998180451054425], "final_y": [0.023069210860796364, 0.02515959115376621, 0.010531361036910224]}, "mutation_prompt": null}
{"id": "618e4103-f702-46fc-82d9-7bc51f2b3b5b", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature * 0.95  # Added velocity damping factor\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, 0.5 + (self.inertia_weight - 0.5) * 0.99)  # Slightly different inertia weight adjustment\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance particle exploration and convergence by incorporating a velocity damping factor and a dynamic inertia weight adjustment.", "configspace": "", "generation": 62, "fitness": 0.325452941032967, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.325 with standard deviation 0.001. And the mean value of best solutions found was 0.008 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.32549545056331775, 0.32427892050573803, 0.3265844520298453], "final_y": [0.01118078857211809, 0.003554669383643036, 0.008637283365344903]}, "mutation_prompt": null}
{"id": "3c335967-0cec-4bb2-8419-4fbf36870d26", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                inertia = self.inertia_weight * velocities[i]\n                dynamic_cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + dynamic_cognitive * self.temperature + social + 0.05 * np.random.uniform(-2, 2, self.dim))\n                if evaluations % 10 == 0:  # Adaptive velocity scaling\n                    velocities[i] *= 0.9\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                score = func(particles[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)\n                        global_best_score = score\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduce adaptive velocity scaling and dynamic cognitive component to improve convergence by enhancing exploration-exploitation balance.", "configspace": "", "generation": 63, "fitness": 0.2803832762337594, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.280 with standard deviation 0.009. And the mean value of best solutions found was 0.018 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.2935421968114996, 0.2723914444296477, 0.2752161874601309], "final_y": [0.00819219606139511, 0.019441184649626297, 0.026636881054203674]}, "mutation_prompt": null}
{"id": "c8bf96fd-fab5-42d4-81a7-b11bba93b5f4", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocity_scaling = (0.1 + 0.9 * evaluations / self.budget)  # New dynamic velocity scaling factor\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature * velocity_scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance exploration by using a dynamic velocity scaling factor to further diversify search directions.", "configspace": "", "generation": 64, "fitness": 0.19161067397058004, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.192 with standard deviation 0.055. And the mean value of best solutions found was 0.826 (0. is the best) with standard deviation 0.962.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.2378948002126644, 0.22238913220651213, 0.11454808949256357], "final_y": [0.06398043537958815, 0.23166537012519892, 2.182773775750147]}, "mutation_prompt": null}
{"id": "7aa3f356-c0cb-4c43-bc57-8bb0f99c8e89", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.02, 0.02, self.dim)  # Increased range of random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Integrate adaptive exploration by adjusting the social constant dynamically to enhance diversity and ability to escape local optima, with improved random perturbation for global best update.", "configspace": "", "generation": 65, "fitness": 0.30136280844417124, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.301 with standard deviation 0.019. And the mean value of best solutions found was 0.009 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.2777494385329453, 0.30170208721056924, 0.3246368995889992], "final_y": [0.009630881898230113, 0.014023099062518227, 0.0024103686406484978]}, "mutation_prompt": null}
{"id": "54ea7f9d-7a45-438d-be30-406977de2b78", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            if np.random.rand() < 0.1:  # Inserted particle regrouping condition\n                particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduce random particle regrouping to enhance exploration and mitigate premature convergence.", "configspace": "", "generation": 66, "fitness": 0.272141761333684, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.272 with standard deviation 0.013. And the mean value of best solutions found was 0.038 (0. is the best) with standard deviation 0.022.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.2785769101996367, 0.25426383281999554, 0.28358454098141983], "final_y": [0.01813397124983625, 0.06807022743686177, 0.027430138068315842]}, "mutation_prompt": null}
{"id": "f7915421-91fd-4c8e-a588-2042f27aaf15", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            avg_score = np.mean(personal_best_scores)  # Calculate average score\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                self.cognitive_constant = 1.5 * (personal_best_scores[i] / avg_score)  # Dynamic cognitive constant\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduce a dynamic cognitive constant that adjusts based on the performance compared to the average population score to refine exploration.", "configspace": "", "generation": 67, "fitness": 0.2714683589521117, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.271 with standard deviation 0.013. And the mean value of best solutions found was 0.030 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.2543735026292502, 0.28682907200378793, 0.273202502223297], "final_y": [0.03222277385529654, 0.01898756340840893, 0.03863822438174636]}, "mutation_prompt": null}
{"id": "a53e5718-045d-4fdf-ab5b-b40122cbde0c", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature + np.random.normal(0, 0.1, self.dim)  # Added Gaussian noise\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduce velocity diversity by incorporating a Gaussian noise component to enhance exploration and convergence.", "configspace": "", "generation": 68, "fitness": 0.2753272325560227, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.275 with standard deviation 0.026. And the mean value of best solutions found was 0.040 (0. is the best) with standard deviation 0.025.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.261229822534106, 0.3115844575126192, 0.25316741762134287], "final_y": [0.032147726070415945, 0.013324950105584512, 0.07428205709443302]}, "mutation_prompt": null}
{"id": "3ba2149a-2d99-4f23-8f1b-05f7c49e163a", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                velocities[i] *= 1.05  # Adaptive velocity scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.02, 0.02, self.dim)  # Refined random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance global exploration by incorporating adaptive velocity scaling and refined global best updating for improved convergence.", "configspace": "", "generation": 69, "fitness": 0.2993222574962795, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.299 with standard deviation 0.006. And the mean value of best solutions found was 0.008 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.29213870363974437, 0.29805082326830423, 0.3077772455807899], "final_y": [0.005423598717137369, 0.006879443292706084, 0.010703361936182897]}, "mutation_prompt": null}
{"id": "81b94391-b15e-4fa4-892c-6f4ca5ab9c64", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            self.cognitive_constant = max(0.8, self.cognitive_constant * 1.02)  # Adaptive cognitive constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Integrate dynamic cognitive constant adjustment to enhance local search optimization capability.", "configspace": "", "generation": 70, "fitness": 0.27816343636941604, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.278 with standard deviation 0.032. And the mean value of best solutions found was 0.028 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.27336913237880966, 0.3193103627447912, 0.24181081398464732], "final_y": [0.028819388088924966, 0.007383795561025059, 0.0463610405122264]}, "mutation_prompt": null}
{"id": "eb9d9da2-7c36-4c91-ba98-8ad6955fc058", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position with additional perturbation\n                particles[i] = np.clip(particle + velocities[i] + np.random.normal(0, 0.001, self.dim), lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance local search capability by introducing an additional small random perturbation in particle position updates.", "configspace": "", "generation": 71, "fitness": 0.2881957151210402, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.288 with standard deviation 0.003. And the mean value of best solutions found was 0.016 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.28482773629862734, 0.2873784145285344, 0.2923809945359588], "final_y": [0.013658569621758185, 0.024229049463704397, 0.010902500735478266]}, "mutation_prompt": null}
{"id": "979dd581-6f7a-4002-bdfe-01ce4b80db3e", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.07 * np.random.normal(0, 1, self.dim)) * self.temperature  # Adjusted perturbation\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.normal(0, 0.005, self.dim)  # Adjusted random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance local search capability by introducing a mutation-based perturbation and improving velocity update strategy.", "configspace": "", "generation": 72, "fitness": 0.28698799698448024, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.287 with standard deviation 0.011. And the mean value of best solutions found was 0.010 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.2811737968606405, 0.30243910652163675, 0.27735108757116345], "final_y": [0.01691762634749495, 0.006845030820428473, 0.007408522212333697]}, "mutation_prompt": null}
{"id": "50ec64a8-e05a-4a76-a0a9-e73bcfc5718f", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = (self.cognitive_constant + 0.05) * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)\n                    personal_best_scores[i] = score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduce mutation in personal best update and adjust the cognitive component for enhanced exploration.", "configspace": "", "generation": 73, "fitness": 0.3298441316274506, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.330 with standard deviation 0.016. And the mean value of best solutions found was 0.005 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.33792279571203077, 0.343686553620387, 0.3079230455499339], "final_y": [0.003940478023791006, 0.0071671751090592725, 0.004629510685868508]}, "mutation_prompt": null}
{"id": "88d41f85-b866-48ba-a7c1-35e739a4ead9", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = (self.cognitive_constant * np.random.rand(self.dim) * \n                             (personal_best_positions[i] - particle) + \n                             np.random.uniform(-0.01, 0.01, self.dim))  # Added perturbation to cognitive component\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance global exploration by introducing a perturbation to the cognitive component, aiding in diversification and escape from local minima.", "configspace": "", "generation": 74, "fitness": 0.3229370561163167, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.323 with standard deviation 0.007. And the mean value of best solutions found was 0.007 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.3300884071804535, 0.31407948364775684, 0.3246432775207396], "final_y": [0.0027952424943834056, 0.012410509103483802, 0.005106489442132755]}, "mutation_prompt": null}
{"id": "6b294edd-e422-4354-8cff-1d0ebc500b65", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.05, 0.05, self.dim)  # Increased randomness range\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance the global best perturbation strategy by increasing the randomness range to escape local optima more effectively.", "configspace": "", "generation": 75, "fitness": 0.3206043311571429, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.321 with standard deviation 0.020. And the mean value of best solutions found was 0.004 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.30165605808570906, 0.34802762840142376, 0.31212930698429575], "final_y": [0.006104806069745963, 0.00041109866149844824, 0.004542068687541725]}, "mutation_prompt": null}
{"id": "4e229ace-5178-4dc1-80a9-300f5683bc7e", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + \n                                 0.05 * np.random.uniform(-2, 2, self.dim) +\n                                 0.1 * np.random.uniform(-1, 1, self.dim) * velocities[global_best_index]) * self.temperature  # New stochastic component based on best velocity\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduce stochastic velocity adjustments based on the best particle's velocity to improve exploration.", "configspace": "", "generation": 76, "fitness": 0.290880194552123, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.291 with standard deviation 0.024. And the mean value of best solutions found was 0.011 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.3193910010755512, 0.29253321757856465, 0.26071636500225315], "final_y": [0.007430822439423655, 0.009749233021979971, 0.016578429726068832]}, "mutation_prompt": null}
{"id": "f6ffcaf1-3d6e-4614-8680-3cc7f2d0b808", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                score = func(particles[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:\n                        global_best_position = particles[i]\n                        global_best_score = score\n\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.9, self.social_constant * 0.97)  # Adaptive social constant\n            self.cognitive_constant = max(0.9, self.cognitive_constant * 1.01)  # Adaptive cognitive constant\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n            if evaluations % (self.budget // 3) == 0:  # Restart mechanism\n                np.random.shuffle(personal_best_positions)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance convergence by dynamically adjusting cognitive and social constants, and integrate a restart mechanism to escape local optima.", "configspace": "", "generation": 77, "fitness": 0.27528054578220335, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.275 with standard deviation 0.008. And the mean value of best solutions found was 0.020 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.28685236657942825, 0.267538807637419, 0.27145046312976284], "final_y": [0.019443817533784047, 0.017216685673409577, 0.02300921990662381]}, "mutation_prompt": null}
{"id": "4f151f22-ab93-4752-82fb-8408113d9f61", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                    personal_best_scores[i] = score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Introduced random perturbation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance convergence by incorporating a stochastic perturbation into personal best updates.", "configspace": "", "generation": 78, "fitness": 0.30851441228923815, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.309 with standard deviation 0.014. And the mean value of best solutions found was 0.013 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.3133894888184364, 0.28918750752180655, 0.32296624052747147], "final_y": [0.016446383658989865, 0.014545808555417108, 0.008099757293895999]}, "mutation_prompt": null}
{"id": "f48a477b-1b00-4616-a10f-2dfc0f2f3386", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim) + np.random.uniform(-0.005, 0.005, self.dim)  # Introduced additional random mutation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduce small random mutations to global best position to explore nearby solutions and improve convergence.", "configspace": "", "generation": 79, "fitness": 0.3553904895998734, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.355 with standard deviation 0.020. And the mean value of best solutions found was 0.004 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "db9de1e7-3d18-4729-9f44-8a0e5214be9e", "metadata": {"aucs": [0.3818337540444098, 0.34905632241678386, 0.3352813923384267], "final_y": [0.0012281520233527366, 0.0046534546944086794, 0.006885199973146015]}, "mutation_prompt": null}
{"id": "976b2afd-a7ef-49bf-b74a-0bb40d9431b1", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.1 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Enhanced dynamic mutation\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Reduced random mutation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.35, self.inertia_weight * 0.99)  # Slightly more adaptive inertia\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Integrate dynamic particle mutation and adaptive inertia for enhanced exploration and convergence.", "configspace": "", "generation": 80, "fitness": 0.2915765384478874, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.292 with standard deviation 0.011. And the mean value of best solutions found was 0.012 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "f48a477b-1b00-4616-a10f-2dfc0f2f3386", "metadata": {"aucs": [0.2851521711088262, 0.30732705556793727, 0.2822503886668988], "final_y": [0.009743581875435699, 0.01012120070358126, 0.015691807327360398]}, "mutation_prompt": null}
{"id": "dd24a927-29ed-48f2-bd91-a609a8a367e8", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim) + np.random.uniform(-0.005, 0.005, self.dim)  # Introduced additional random mutation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n            self.cognitive_constant = max(0.5, self.cognitive_constant * 0.98)  # New adaptive cognitive constant\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Adaptive update of cognitive and social components to balance exploration and exploitation.", "configspace": "", "generation": 81, "fitness": 0.26546991737962666, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.265 with standard deviation 0.053. And the mean value of best solutions found was 0.102 (0. is the best) with standard deviation 0.125.", "error": "", "parent_id": "f48a477b-1b00-4616-a10f-2dfc0f2f3386", "metadata": {"aucs": [0.19440183525162769, 0.31999969433727526, 0.28200822254997704], "final_y": [0.2778748445837236, 0.005141762660121615, 0.022578083674759573]}, "mutation_prompt": null}
{"id": "4cd07bd1-2e0c-49dc-8e35-4a0f35291679", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n\n        neighborhood_radius = 0.1  # Added neighborhood influence\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                \n                # Introduced neighborhood influence\n                neighborhood_best_position = self.find_neighborhood_best(particles, personal_best_scores, i, neighborhood_radius)\n                velocities[i] += 0.1 * np.random.rand(self.dim) * (neighborhood_best_position - particle)\n\n                score = func(particles[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim)\n                        global_best_score = score\n\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position\n    \n    def find_neighborhood_best(self, particles, scores, index, radius):\n        distances = np.linalg.norm(particles - particles[index], axis=1)\n        neighbors = np.where((distances < radius) & (distances > 0))[0]\n        if len(neighbors) > 0:\n            best_neighbor_idx = neighbors[np.argmin(scores[neighbors])]\n            return particles[best_neighbor_idx]\n        else:\n            return particles[index]", "name": "HybridPSOSA", "description": "HybridPSOSA with adaptive mutation and neighborhood influence to enhance global exploration and convergence efficiency.", "configspace": "", "generation": 82, "fitness": 0.3018178045669704, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.302 with standard deviation 0.040. And the mean value of best solutions found was 0.014 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "f48a477b-1b00-4616-a10f-2dfc0f2f3386", "metadata": {"aucs": [0.2513810047481384, 0.3042357000425384, 0.34983670891023433], "final_y": [0.026470875384384546, 0.015632935859521652, 0.001041497957609117]}, "mutation_prompt": null}
{"id": "00c06249-eb41-4bec-9c13-af6c30b6f1a5", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            iteration_ratio = evaluations / self.budget\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = (1.5 + iteration_ratio) * np.random.rand(self.dim) * (personal_best_positions[i] - particle)  # Adjust cognitive constant\n                social = (1.5 - iteration_ratio) * np.random.rand(self.dim) * (global_best_position - particle)  # Adjust social constant\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim) + np.random.uniform(-0.005, 0.005, self.dim)  # Introduced additional random mutation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance exploration by dynamically adjusting cognitive and social constants based on iteration count.", "configspace": "", "generation": 83, "fitness": 0.2841078552693119, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.284 with standard deviation 0.030. And the mean value of best solutions found was 0.029 (0. is the best) with standard deviation 0.028.", "error": "", "parent_id": "f48a477b-1b00-4616-a10f-2dfc0f2f3386", "metadata": {"aucs": [0.24956781659647986, 0.2808364329550074, 0.32191931625644854], "final_y": [0.06752294764437759, 0.017539636558064845, 0.0032825648540343575]}, "mutation_prompt": null}
{"id": "6588b113-7c54-4ac8-b29c-37b57c71bcf4", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim) + np.random.uniform(-0.005, 0.005, self.dim)  # Introduced additional random mutation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99 * (1 + 0.01 * (global_best_score / np.mean(personal_best_scores))))\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduce simple adaptive inertia weight adjustment for balancing exploration and exploitation in the search process.", "configspace": "", "generation": 84, "fitness": 0.2932903100460409, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.293 with standard deviation 0.014. And the mean value of best solutions found was 0.012 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "f48a477b-1b00-4616-a10f-2dfc0f2f3386", "metadata": {"aucs": [0.3092682594909313, 0.2755879037413693, 0.29501476690582207], "final_y": [0.005607931150714016, 0.01751340695345657, 0.014069172850446557]}, "mutation_prompt": null}
{"id": "e65555ca-9252-4e45-872b-479f0e66e5ec", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim) + np.random.uniform(-0.005, 0.005, self.dim)  # Introduced additional random mutation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= 0.92 + 0.08 * (evaluations / self.budget)  # Dynamic cooling rate adjustment\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced exploration by varying the cooling rate dynamically based on the evaluation progress to balance exploration and exploitation.", "configspace": "", "generation": 85, "fitness": 0.3184179848936051, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.318 with standard deviation 0.009. And the mean value of best solutions found was 0.004 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "f48a477b-1b00-4616-a10f-2dfc0f2f3386", "metadata": {"aucs": [0.314175022079889, 0.33046063223604083, 0.3106183003648856], "final_y": [0.0052293474718021335, 0.003368619018949726, 0.0027042478532291764]}, "mutation_prompt": null}
{"id": "9ee6c534-d528-4dbe-99d2-8e870eb304d5", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim) + np.random.uniform(-0.005, 0.005, self.dim)  # Introduced additional random mutation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n            self.cognitive_constant *= 1.01  # New line: Dynamic cognitive constant\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance exploration by using a dynamic cognitive constant that increases over time.", "configspace": "", "generation": 86, "fitness": 0.3275224013806178, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.328 with standard deviation 0.010. And the mean value of best solutions found was 0.007 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "f48a477b-1b00-4616-a10f-2dfc0f2f3386", "metadata": {"aucs": [0.3311086507634503, 0.3374269837684587, 0.3140315696099444], "final_y": [0.010522276547886105, 0.0014911849629879387, 0.00873116334207403]}, "mutation_prompt": null}
{"id": "8326ab59-d447-4861-9806-f47d7c353d7a", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(lb, ub, (self.population_size, self.dim))  # Changed line\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim) + np.random.uniform(-0.005, 0.005, self.dim)  # Introduced additional random mutation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance exploration by introducing diversity in velocity initialization for improved convergence.", "configspace": "", "generation": 87, "fitness": 0.25372963941030974, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.254 with standard deviation 0.017. And the mean value of best solutions found was 0.025 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": "f48a477b-1b00-4616-a10f-2dfc0f2f3386", "metadata": {"aucs": [0.25288021375025227, 0.23296698878586475, 0.27534171569481214], "final_y": [0.021769763633587784, 0.04850157634389694, 0.005487381112617776]}, "mutation_prompt": null}
{"id": "fbdb511c-a3f3-4135-87c7-b62dbe150ffc", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.1 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Adjusted mutation amplitude\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    noise = np.random.uniform(-0.01, 0.01, self.dim)  # Added noise to personal best update\n                    personal_best_positions[i], personal_best_scores[i] = particles[i] + noise, score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim) + np.random.uniform(-0.005, 0.005, self.dim)  # Introduced additional random mutation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance the mutation strategy by adding noise to the personal best update and adjust velocity more aggressively.", "configspace": "", "generation": 88, "fitness": 0.2551038184960452, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.255 with standard deviation 0.014. And the mean value of best solutions found was 0.029 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "f48a477b-1b00-4616-a10f-2dfc0f2f3386", "metadata": {"aucs": [0.25790518238235804, 0.2711807934303453, 0.23622547967543228], "final_y": [0.05000789633201419, 0.019866989419013725, 0.01568896856632819]}, "mutation_prompt": null}
{"id": "54b86383-a228-4d0f-a3a2-25c68cc2c871", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim) + np.random.uniform(-0.005, 0.005, self.dim) + np.sin(np.random.uniform(0, np.pi, self.dim) * 0.01)  # Sinusoidal perturbation added\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance global convergence by adding sinusoidal perturbation to global best position.", "configspace": "", "generation": 89, "fitness": 0.29607844252958254, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.296 with standard deviation 0.018. And the mean value of best solutions found was 0.016 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "f48a477b-1b00-4616-a10f-2dfc0f2f3386", "metadata": {"aucs": [0.28112591153314104, 0.321854798524271, 0.2852546175313355], "final_y": [0.02045938763543505, 0.012668947722965895, 0.014492419194767228]}, "mutation_prompt": null}
{"id": "a3964830-46e2-4d9d-94b4-8a4aeeece3da", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim) + np.random.uniform(-0.005, 0.005, self.dim)  # Introduced additional random mutation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = 0.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)  # Sine wave adjustment\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Adaptive inertia weight adjustment using a sine wave for dynamic exploration-exploitation balance.", "configspace": "", "generation": 90, "fitness": 0.27737187735984925, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.277 with standard deviation 0.022. And the mean value of best solutions found was 0.025 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "f48a477b-1b00-4616-a10f-2dfc0f2f3386", "metadata": {"aucs": [0.2729438946006555, 0.2527308276899298, 0.30644090978896243], "final_y": [0.02643476303299416, 0.043501451785808026, 0.005870486570534443]}, "mutation_prompt": null}
{"id": "0ff4c576-2e48-4fcf-9e76-28b5fbaadeaf", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim) * (1 - score/global_best_score)  # Introduced dynamic mutation range\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduce a dynamic mutation range to the global best position to enhance exploration and convergence.", "configspace": "", "generation": 91, "fitness": 0.28644228886334266, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.286 with standard deviation 0.072. And the mean value of best solutions found was 0.050 (0. is the best) with standard deviation 0.041.", "error": "", "parent_id": "f48a477b-1b00-4616-a10f-2dfc0f2f3386", "metadata": {"aucs": [0.3849868776274503, 0.2583295784275139, 0.21601041053506376], "final_y": [0.0015802731654225783, 0.04657394525133343, 0.10266224478624995]}, "mutation_prompt": null}
{"id": "08cd31db-34d8-470c-80c1-e60440c635df", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.normal(0, 0.01, self.dim)  # Introduced Gaussian noise\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance global best position adjustment with Gaussian noise to improve convergence stability.", "configspace": "", "generation": 92, "fitness": 0.2745113184376704, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.275 with standard deviation 0.015. And the mean value of best solutions found was 0.028 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "f48a477b-1b00-4616-a10f-2dfc0f2f3386", "metadata": {"aucs": [0.26791222409494275, 0.29586888596360295, 0.2597528452544655], "final_y": [0.02199525596987415, 0.01546027124669217, 0.047633748993996784]}, "mutation_prompt": null}
{"id": "39af933e-1af0-4392-afaa-f99f85a01142", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature * (1 + 0.01 * (global_best_score - personal_best_scores[i]))  # Added adaptive learning rate\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim) + np.random.uniform(-0.005, 0.005, self.dim)  # Introduced additional random mutation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Introduce an adaptive learning rate to refine velocity updates for enhanced convergence.", "configspace": "", "generation": 93, "fitness": 0.31167645585023546, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.312 with standard deviation 0.006. And the mean value of best solutions found was 0.008 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "f48a477b-1b00-4616-a10f-2dfc0f2f3386", "metadata": {"aucs": [0.3130451784643441, 0.3041028733940089, 0.31788131569235334], "final_y": [0.006757398028349459, 0.009720388941710498, 0.006336082209371493]}, "mutation_prompt": null}
{"id": "4449549f-5dd0-440d-af74-42db7295ef3e", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive_progress = (global_best_score - personal_best_scores[i]) / (global_best_score + 1e-9)\n                cognitive = (self.cognitive_constant + cognitive_progress) * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social_progress = (global_best_score - score) / (global_best_score + 1e-9)\n                social = (self.social_constant + social_progress) * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim) + np.random.uniform(-0.005, 0.005, self.dim)  # Introduced additional random mutation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance convergence by dynamically adjusting the cognitive and social constants based on progress towards the global best.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'score' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'score' referenced before assignment\")", "parent_id": "f48a477b-1b00-4616-a10f-2dfc0f2f3386", "metadata": {}, "mutation_prompt": null}
{"id": "d165c835-1b79-4fc5-bee7-565aedbc3cce", "solution": "# Description: Enhanced HybridPSOSA with adaptive cognitive component and dynamic mutation for improved exploration.\n# Code: \nimport numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature\n\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                score = func(particles[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:\n                        global_best_position = particles[i] + np.random.uniform(-0.02, 0.02, self.dim)  # Increased mutation range\n                        global_best_score = score\n            \n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n            self.cognitive_constant = max(1.0, self.cognitive_constant * 1.01)  # Adaptive cognitive component\n \n        return global_best_position", "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA with adaptive cognitive component and dynamic mutation for improved exploration.", "configspace": "", "generation": 95, "fitness": 0.2970138701653637, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.297 with standard deviation 0.016. And the mean value of best solutions found was 0.014 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "f48a477b-1b00-4616-a10f-2dfc0f2f3386", "metadata": {"aucs": [0.31803162032110144, 0.2945045331807361, 0.27850545699425344], "final_y": [0.004671822043924034, 0.014654251038911657, 0.023474647368698122]}, "mutation_prompt": null}
{"id": "b30478ec-f543-469e-a9a5-2fa42ef661b0", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                self.cognitive_constant = max(0.5, 1.5 * (1 - (global_best_score - personal_best_scores[i]) / global_best_score)) # Dynamic cognitive update\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim) if np.random.rand() < 0.5 else particles[i] # Selective mutation based on chance\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance convergence by dynamically adjusting the cognitive constant and selectively applying mutations based on improvement likelihood.", "configspace": "", "generation": 96, "fitness": 0.23362434059321127, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.234 with standard deviation 0.007. And the mean value of best solutions found was 0.088 (0. is the best) with standard deviation 0.035.", "error": "", "parent_id": "f48a477b-1b00-4616-a10f-2dfc0f2f3386", "metadata": {"aucs": [0.22320405461119064, 0.2375501720939195, 0.24011879507452372], "final_y": [0.09644324402841911, 0.04151330892317922, 0.12623804016858314]}, "mutation_prompt": null}
{"id": "5d71e0a9-157e-4285-aeb6-5f343e56d567", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92\n        self.velocity_limit = 0.2 * (func.bounds.ub - func.bounds.lb)  # New adaptive velocity limit\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            diversity_factor = np.std(personal_best_scores) / (np.mean(personal_best_scores) + 1e-9)  # New diversity mechanism\n            for i, particle in enumerate(particles):\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)\n                velocities[i] = np.clip(velocities[i], -self.velocity_limit, self.velocity_limit)  # Apply adaptive velocity limit\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                score = func(particles[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim) * diversity_factor  # Integrate diversity factor\n                        global_best_score = score\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance exploration and convergence by introducing adaptive velocity limits and a diversity mechanism to prevent premature convergence.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "f48a477b-1b00-4616-a10f-2dfc0f2f3386", "metadata": {}, "mutation_prompt": null}
{"id": "47068d57-34d8-4904-bb06-2c5aa1c20267", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95  # Adjusted cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = np.clip(particle + velocities[i], lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.02, 0.02, self.dim)  # Refined mutation strategy\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance exploration by refining mutation strategy and adjust cooling rate for better convergence.", "configspace": "", "generation": 98, "fitness": 0.28297978263384155, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.283 with standard deviation 0.017. And the mean value of best solutions found was 0.014 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "f48a477b-1b00-4616-a10f-2dfc0f2f3386", "metadata": {"aucs": [0.2657494769238884, 0.27725779921615057, 0.3059320717614856], "final_y": [0.01824008715392609, 0.011987744350903596, 0.010741782574759237]}, "mutation_prompt": null}
{"id": "e3da3efb-26c4-4e1e-abe7-16b7e63a5cc4", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, int(budget / 50))  # Dynamic population size\n        self.inertia_weight = 0.7  # Initial inertia weight\n        self.cognitive_constant = 1.3  # Adjusted cognitive constant\n        self.social_constant = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Changed cooling rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i, particle in enumerate(particles):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_constant * np.random.rand(self.dim) * (personal_best_positions[i] - particle)\n                social = self.social_constant * np.random.rand(self.dim) * (global_best_position - particle)\n                velocities[i] = (inertia + cognitive + social + 0.05 * np.random.uniform(-2, 2, self.dim)) * self.temperature  # Integrated temperature-dependent scaling\n                # Update position\n                particles[i] = particle + velocities[i]\n                if np.any(particles[i] < lb) or np.any(particles[i] > ub):  # Boundary reflection\n                    particles[i] = np.clip(lb + (ub - lb) * np.random.rand(self.dim), lb, ub)\n                # Evaluate new position\n                score = func(particles[i])\n                evaluations += 1\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i], personal_best_scores[i] = particles[i], score\n                    if score < global_best_score:  # Strategy change for updating the global best\n                        global_best_position = particles[i] + np.random.uniform(-0.01, 0.01, self.dim) + np.random.uniform(-0.005, 0.005, self.dim)  # Introduced additional random mutation\n                        global_best_score = score\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            self.social_constant = max(0.8, self.social_constant * 0.98)  # Adaptive social constant\n            # Update inertia weight adaptively\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        return global_best_position", "name": "HybridPSOSA", "description": "Enhance exploration by introducing stochastic boundary reflection and optimizing cognitive constant dynamics.", "configspace": "", "generation": 99, "fitness": 0.3086972003559066, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.309 with standard deviation 0.008. And the mean value of best solutions found was 0.011 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "f48a477b-1b00-4616-a10f-2dfc0f2f3386", "metadata": {"aucs": [0.29897316948203057, 0.30886069198651833, 0.3182577395991709], "final_y": [0.01499238243631961, 0.004081266097410472, 0.012525574173264623]}, "mutation_prompt": null}
