{"id": "f4e5e534-b171-489c-a550-cb4b34f5af63", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for _ in range(self.budget):\n            candidate_solution = current_solution + np.random.normal(0, self.step_size, self.dim)\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            self.temperature *= self.cooling_rate\n            \n            # Adaptive step size adjustment\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "The algorithm combines simulated annealing with an adaptive step size mechanism to efficiently explore the search space and escape local minima, leveraging temperature-based acceptance for diverse solutions.", "configspace": "", "generation": 0, "fitness": 0.07051222883966542, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.071 with standard deviation 0.070. And the mean value of best solutions found was 0.888 (0. is the best) with standard deviation 0.107.", "error": "", "parent_id": null, "metadata": {"aucs": [0.16763506293978447, 0.0068627454463033866, 0.037038878132908404], "final_y": [0.7393752655640993, 0.9880564006441733, 0.9357219761876872]}, "mutation_prompt": null}
{"id": "66d246d4-0145-4daf-84cb-2ff608b5bda5", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for _ in range(self.budget):\n            candidate_solution = current_solution + np.random.normal(0, self.step_size, self.dim)\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            self.temperature *= self.cooling_rate\n            self.cooling_rate *= 0.999  # Dynamically adjust cooling rate\n            \n            # Adaptive step size adjustment\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhanced acceptance and exploration by introducing a dynamic cooling rate to improve adaptability in varying landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: ZeroDivisionError('float division by zero').", "error": "ZeroDivisionError('float division by zero')", "parent_id": "f4e5e534-b171-489c-a550-cb4b34f5af63", "metadata": {}, "mutation_prompt": null}
{"id": "573d191f-0277-4229-8a5e-8f4d8686028d", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.99  # Changed from 0.95 to 0.99\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for _ in range(self.budget):\n            candidate_solution = current_solution + np.random.normal(0, self.step_size, self.dim)\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            self.temperature *= self.cooling_rate\n            \n            # Adaptive step size adjustment\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "The algorithm refines Adaptive Simulated Annealing by enhancing the cooling schedule for more effective exploration-exploitation balance, maintaining adaptive step size for improved solution quality.", "configspace": "", "generation": 2, "fitness": 0.07051222883966542, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.071 with standard deviation 0.070. And the mean value of best solutions found was 0.888 (0. is the best) with standard deviation 0.107.", "error": "", "parent_id": "f4e5e534-b171-489c-a550-cb4b34f5af63", "metadata": {"aucs": [0.16763506293978447, 0.0068627454463033866, 0.037038878132908404], "final_y": [0.7393752655640993, 0.9880564006441733, 0.9357219761876872]}, "mutation_prompt": null}
{"id": "c2a919df-4bc1-412a-88ce-85dd1055a815", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for _ in range(self.budget):\n            candidate_solution = current_solution + np.random.normal(0, self.step_size, self.dim)\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            # Dynamic cooling rate\n            self.temperature *= self.cooling_rate * (0.9 + 0.2 * np.random.rand())\n            \n            # Adaptive step size adjustment\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introducing a dynamic cooling rate with adaptive adjustments to enhance exploration and convergence efficiency in the Adaptive Simulated Annealing algorithm.", "configspace": "", "generation": 3, "fitness": 0.0704779243796249, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.070 with standard deviation 0.070. And the mean value of best solutions found was 0.888 (0. is the best) with standard deviation 0.107.", "error": "", "parent_id": "f4e5e534-b171-489c-a550-cb4b34f5af63", "metadata": {"aucs": [0.16771341976554976, 0.007033002008522082, 0.036687351364802834], "final_y": [0.7392707519426689, 0.987752894389755, 0.9363171820020363]}, "mutation_prompt": null}
{"id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for _ in range(self.budget):\n            # Introduce Levy flight for exploration\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            self.temperature *= self.cooling_rate\n            \n            # Adaptive step size adjustment\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "The algorithm enhances exploration by introducing Levy flights combined with adaptive step size, maintaining efficient search and robustness against local minima.", "configspace": "", "generation": 4, "fitness": 0.16654084812341596, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.167 with standard deviation 0.069. And the mean value of best solutions found was 0.746 (0. is the best) with standard deviation 0.094.", "error": "", "parent_id": "f4e5e534-b171-489c-a550-cb4b34f5af63", "metadata": {"aucs": [0.1843624355475426, 0.07496479997465777, 0.2402953088480475], "final_y": [0.7173657932030071, 0.8733114334740256, 0.6484392707344021]}, "mutation_prompt": null}
{"id": "a0d81833-2cd0-4b40-84aa-d366e0435543", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / (temperature + 1e-9))  # Adjusted for better stability\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            self.temperature *= self.cooling_rate ** (1 + (best_cost - current_cost) / (best_cost + 1e-9))  # Adaptive cooling\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "The algorithm incorporates adaptive temperature scaling and a modified acceptance criterion to enhance convergence and solution quality.", "configspace": "", "generation": 5, "fitness": 0.16654084812341596, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.167 with standard deviation 0.069. And the mean value of best solutions found was 0.746 (0. is the best) with standard deviation 0.094.", "error": "", "parent_id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "metadata": {"aucs": [0.1843624355475426, 0.07496479997465777, 0.2402953088480475], "final_y": [0.7173657932030071, 0.8733114334740256, 0.6484392707344021]}, "mutation_prompt": null}
{"id": "c89b664c-7fbf-44a2-b3fc-4feca69a2912", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            self.temperature *= (0.9 + 0.1 * np.random.rand())  # Dynamic cooling rate\n            \n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.2, self.initial_step_size)  # Adjusted factor\n            else:\n                self.step_size = max(self.step_size * 0.85, self.min_step_size)  # Adjusted factor\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Integrating dynamic cooling with adaptive step size and Levy flights to enhance exploration and convergence in complex landscapes.", "configspace": "", "generation": 6, "fitness": 0.07557844544182779, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.076 with standard deviation 0.077. And the mean value of best solutions found was 0.881 (0. is the best) with standard deviation 0.117.", "error": "", "parent_id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "metadata": {"aucs": [0.18378185933954028, 0.007121791384780085, 0.03583168560116301], "final_y": [0.7181339221475223, 0.987594837273325, 0.9377634116987673]}, "mutation_prompt": null}
{"id": "76ab7891-4a75-4326-a6a8-3d133507ea95", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95 - (dim * 0.001)  # Adaptive cooling based on dimension\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for _ in range(self.budget):\n            # Enhanced Levy flight scaling for exploration\n            levy_flight = np.random.standard_cauchy(self.dim) * self.step_size * (self.temperature ** 0.5)\n            candidate_solution = current_solution + levy_flight\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            self.temperature *= self.cooling_rate\n            \n            # Adaptive step size adjustment\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n        \n        return best_solution", "name": "EnhancedAdaptiveSimulatedAnnealing", "description": "Enhanced Adaptive Simulated Annealing uses dimension-based adaptive cooling and improved Levy flight scaling for better exploration and exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.1503978062522298, "feedback": "The algorithm EnhancedAdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.150 with standard deviation 0.084. And the mean value of best solutions found was 0.772 (0. is the best) with standard deviation 0.120.", "error": "", "parent_id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "metadata": {"aucs": [0.1808822425990535, 0.036190710458413045, 0.23412046569922285], "final_y": [0.7218930311268859, 0.936968371875548, 0.6557130545699159]}, "mutation_prompt": null}
{"id": "2d35707c-10e6-44a1-9eb0-293416cb43f1", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            # Adaptive temperature scaling\n            self.temperature *= self.cooling_rate * (1 + 0.5 * (best_cost - current_cost))\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "The algorithm incorporates adaptive temperature scaling based on progress in addition to Levy flights and adaptive step size to improve convergence by dynamically adjusting the exploration-exploitation balance.", "configspace": "", "generation": 8, "fitness": 0.16654084812341596, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.167 with standard deviation 0.069. And the mean value of best solutions found was 0.746 (0. is the best) with standard deviation 0.094.", "error": "", "parent_id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "metadata": {"aucs": [0.1843624355475426, 0.07496479997465777, 0.2402953088480475], "final_y": [0.7173657932030071, 0.8733114334740256, 0.6484392707344021]}, "mutation_prompt": null}
{"id": "d1d7cfed-262d-44a5-a12d-7525829eb5cf", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for _ in range(self.budget):\n            # Enhanced Levy flight for broader exploration\n            levy_flight = np.random.standard_cauchy(self.dim) * np.random.uniform(0.5, 1.5)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            # Dynamic temperature update\n            self.temperature *= (self.cooling_rate + 0.01 * np.random.rand())\n\n            # Adaptive step size adjustment\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "The algorithm improves convergence by integrating a dynamic temperature update mechanism and enhancing the Levy flight strategy for broader exploration.", "configspace": "", "generation": 9, "fitness": 0.12498121084051106, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.125 with standard deviation 0.080. And the mean value of best solutions found was 0.807 (0. is the best) with standard deviation 0.121.", "error": "", "parent_id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "metadata": {"aucs": [0.17619841982170892, 0.012469602519265544, 0.18627561018055872], "final_y": [0.7280404263019806, 0.9780907362891734, 0.7148260874367247]}, "mutation_prompt": null}
{"id": "e614b832-2872-40ef-8617-b6e263325440", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for _ in range(self.budget):\n            # Introduce Levy flight for exploration\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            self.temperature *= self.cooling_rate * (1.05 if candidate_cost < current_cost else 0.95)\n            \n            # Adaptive step size adjustment\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "The algorithm introduces a dynamic cooling rate adjustment based on the improvement rate to enhance convergence speed while maintaining robustness against local minima.", "configspace": "", "generation": 10, "fitness": 0.16654084812341596, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.167 with standard deviation 0.069. And the mean value of best solutions found was 0.746 (0. is the best) with standard deviation 0.094.", "error": "", "parent_id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "metadata": {"aucs": [0.1843624355475426, 0.07496479997465777, 0.2402953088480475], "final_y": [0.7173657932030071, 0.8733114334740256, 0.6484392707344021]}, "mutation_prompt": null}
{"id": "862917e1-ba1b-435c-9371-30d7a304080f", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n\n        a = 0.5  # Chaotic sequence parameter\n        x = 0.7  # Initial chaotic sequence value\n        \n        for _ in range(self.budget):\n            x = a * x * (1 - x)  # Logistic map for chaotic sequence\n            chaos_factor = np.full(self.dim, x)\n\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * chaos_factor * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            self.temperature *= self.cooling_rate\n            \n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "The algorithm improves exploration by introducing chaotic sequences for better diversity, maintaining robust search and adaptability to locate global optima.", "configspace": "", "generation": 11, "fitness": 0.12755059320246964, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.128 with standard deviation 0.087. And the mean value of best solutions found was 0.805 (0. is the best) with standard deviation 0.131.", "error": "", "parent_id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "metadata": {"aucs": [0.16782327947104536, 0.006899304622252189, 0.20792919551411138], "final_y": [0.7391242744434351, 0.98799123589515, 0.6874682806887634]}, "mutation_prompt": null}
{"id": "33c8f040-82bb-4406-96be-eee3b13dff12", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for _ in range(self.budget):\n            # Introduce Levy flight for exploration\n            levy_flight = np.random.standard_cauchy(self.dim)\n            # Add adaptive Gaussian perturbation\n            gaussian_perturbation = np.random.normal(0, self.step_size, self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size + gaussian_perturbation\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            self.temperature *= self.cooling_rate\n            \n            # Adaptive step size adjustment\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "The algorithm incorporates adaptive Gaussian perturbations alongside Levy flights for enhanced local search refinement, improving convergence and solution quality.", "configspace": "", "generation": 12, "fitness": 0.08099961402921962, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.081 with standard deviation 0.073. And the mean value of best solutions found was 0.872 (0. is the best) with standard deviation 0.111.", "error": "", "parent_id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "metadata": {"aucs": [0.18023907095639824, 0.007395812953506331, 0.0553639581777543], "final_y": [0.7227254933203882, 0.9871068245183732, 0.9052716318479584]}, "mutation_prompt": null}
{"id": "a39698cf-4ec8-48b3-a140-3af8d0e0f470", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for _ in range(self.budget):\n            # Introduce Levy flight for exploration\n            levy_flight = np.random.standard_cauchy(self.dim)\n            gaussian_perturbation = np.random.normal(0, self.step_size, self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size + gaussian_perturbation\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            self.temperature *= self.cooling_rate\n            \n            # Adaptive step size adjustment\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introduce Gaussian perturbation alongside Levy flights for a balanced exploration-exploitation trade-off.", "configspace": "", "generation": 13, "fitness": 0.08099961402921962, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.081 with standard deviation 0.073. And the mean value of best solutions found was 0.872 (0. is the best) with standard deviation 0.111.", "error": "", "parent_id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "metadata": {"aucs": [0.18023907095639824, 0.007395812953506331, 0.0553639581777543], "final_y": [0.7227254933203882, 0.9871068245183732, 0.9052716318479584]}, "mutation_prompt": null}
{"id": "e0cc19ae-e614-49b7-8d80-9410c9b31c08", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.97  # Changed line: Adjusted cooling rate for slower temperature decay\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for _ in range(self.budget):\n            # Introduce Levy flight for exploration\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            self.temperature *= self.cooling_rate\n            \n            # Adaptive step size adjustment\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "The algorithm enhances exploration by introducing Levy flights combined with adaptive step size and annealing schedule modification, improving robustness against local minima.", "configspace": "", "generation": 14, "fitness": 0.16654084812341596, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.167 with standard deviation 0.069. And the mean value of best solutions found was 0.746 (0. is the best) with standard deviation 0.094.", "error": "", "parent_id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "metadata": {"aucs": [0.1843624355475426, 0.07496479997465777, 0.2402953088480475], "final_y": [0.7173657932030071, 0.8733114334740256, 0.6484392707344021]}, "mutation_prompt": null}
{"id": "1ea1b904-8641-4757-b1ae-cab502f1a502", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for i in range(self.budget):\n            # Dynamic cooling schedule\n            self.temperature *= 1 / (1 + 0.01 * i)\n            \n            # Introduce Levy flight for exploration\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n            \n            # Stochastic step size scaling\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * np.random.uniform(1.05, 1.15), self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * np.random.uniform(0.85, 0.95), self.min_step_size)\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introduce a dynamic cooling schedule and stochastic step size scaling to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: ZeroDivisionError('float division by zero').", "error": "ZeroDivisionError('float division by zero')", "parent_id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "metadata": {}, "mutation_prompt": null}
{"id": "e085f6ae-4229-4df2-98b9-bfb158fc2dad", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for _ in range(self.budget):\n            # Introduce Levy flight for exploration\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            self.temperature *= self.cooling_rate + 0.01 * np.random.rand()  # Line changed for dynamic cooling rate adjustment\n            \n            # Adaptive step size adjustment\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "The algorithm enhances exploration by introducing Levy flights combined with adaptive step size and dynamic cooling rate adjustment, maintaining efficient search and robustness against local minima.", "configspace": "", "generation": 16, "fitness": 0.0814101328930537, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.081 with standard deviation 0.076. And the mean value of best solutions found was 0.872 (0. is the best) with standard deviation 0.114.", "error": "", "parent_id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "metadata": {"aucs": [0.18895098337376204, 0.019447729704236028, 0.03583168560116301], "final_y": [0.7114589990279354, 0.9657330120196477, 0.9377634116987673]}, "mutation_prompt": null}
{"id": "be31cd77-e828-44d9-b985-a249fc14f613", "solution": "import numpy as np\n\nclass RefinedAdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.visited_solutions = set()\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for _ in range(self.budget):\n            # Introduce Gaussian perturbation for refined local search\n            perturbation = np.random.normal(0, self.step_size, self.dim)\n            candidate_solution = current_solution + perturbation\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            # Avoid revisiting solutions\n            candidate_tuple = tuple(candidate_solution)\n            if candidate_tuple in self.visited_solutions:\n                continue\n            self.visited_solutions.add(candidate_tuple)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            self.temperature *= self.cooling_rate\n            \n            # Adaptive step size adjustment with memory\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n\n            # Dynamic temperature update\n            if candidate_cost < best_cost:\n                self.temperature *= 0.9\n        \n        return best_solution", "name": "RefinedAdaptiveSimulatedAnnealing", "description": "The algorithm introduces dynamic temperature adaptation and incorporates Gaussian perturbations for enhanced local search, coupled with a memory mechanism to avoid revisiting poor solutions.", "configspace": "", "generation": 17, "fitness": 0.07051222883966542, "feedback": "The algorithm RefinedAdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.071 with standard deviation 0.070. And the mean value of best solutions found was 0.888 (0. is the best) with standard deviation 0.107.", "error": "", "parent_id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "metadata": {"aucs": [0.16763506293978447, 0.0068627454463033866, 0.037038878132908404], "final_y": [0.7393752655640993, 0.9880564006441733, 0.9357219761876872]}, "mutation_prompt": null}
{"id": "1af868e5-4f7a-42c9-a51d-dfeac373f9be", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.9  # Modified to improve convergence\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for _ in range(self.budget):\n            # Introduce Levy flight for exploration\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            self.temperature *= self.cooling_rate\n            \n            # Adaptive step size adjustment\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "The algorithm boosts exploration by integrating Levy flights with adaptive step size and dynamic cooling rates, enhancing search efficiency and solution quality.", "configspace": "", "generation": 18, "fitness": 0.16654084812341596, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.167 with standard deviation 0.069. And the mean value of best solutions found was 0.746 (0. is the best) with standard deviation 0.094.", "error": "", "parent_id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "metadata": {"aucs": [0.1843624355475426, 0.07496479997465777, 0.2402953088480475], "final_y": [0.7173657932030071, 0.8733114334740256, 0.6484392707344021]}, "mutation_prompt": null}
{"id": "a15d1c71-d50d-423e-90cf-9a1695a12a8a", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.9  # Slightly adjusted cooling rate\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.max_temperature = 100.0\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            self.temperature = max(self.temperature * self.cooling_rate, 1e-3)  # Dynamic temperature schedule\n            \n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "This algorithm enhances the exploration with Lvy flights and adaptive step sizes, incorporating a dynamic temperature schedule for robust optimization against local minima.", "configspace": "", "generation": 19, "fitness": 0.16654084812341596, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.167 with standard deviation 0.069. And the mean value of best solutions found was 0.746 (0. is the best) with standard deviation 0.094.", "error": "", "parent_id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "metadata": {"aucs": [0.1843624355475426, 0.07496479997465777, 0.2402953088480475], "final_y": [0.7173657932030071, 0.8733114334740256, 0.6484392707344021]}, "mutation_prompt": null}
{"id": "875a5431-23d9-43db-8d13-81657135acc7", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for i in range(self.budget):\n            # Use non-uniform mutation for exploration\n            mutation = np.random.normal(0, self.step_size, self.dim)\n            candidate_solution = current_solution + mutation\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            # Dynamic temperature adaptation\n            self.temperature *= self.cooling_rate\n            self.temperature = max(0.01, self.temperature * (1 - (i / self.budget)))\n\n            # Adaptive step size adjustment\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "The algorithm introduces dynamic temperature adaptation based on search progress and uses non-uniform mutation inspired by differential evolution for improved balance between exploration and exploitation.", "configspace": "", "generation": 20, "fitness": 0.07051222883966542, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.071 with standard deviation 0.070. And the mean value of best solutions found was 0.888 (0. is the best) with standard deviation 0.107.", "error": "", "parent_id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "metadata": {"aucs": [0.16763506293978447, 0.0068627454463033866, 0.037038878132908404], "final_y": [0.7393752655640993, 0.9880564006441733, 0.9357219761876872]}, "mutation_prompt": null}
{"id": "959cec6f-50cb-4e97-9360-eb74c32d7253", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.9  # Modified cooling rate\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for _ in range(self.budget):\n            # Introduce Levy flight for exploration\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            self.temperature *= self.cooling_rate\n            \n            # Adaptive step size adjustment\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhanced exploration by integrating Levy flights with adaptive step size and dynamic temperature adjustment for robustness.", "configspace": "", "generation": 21, "fitness": 0.16654084812341596, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.167 with standard deviation 0.069. And the mean value of best solutions found was 0.746 (0. is the best) with standard deviation 0.094.", "error": "", "parent_id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "metadata": {"aucs": [0.1843624355475426, 0.07496479997465777, 0.2402953088480475], "final_y": [0.7173657932030071, 0.8733114334740256, 0.6484392707344021]}, "mutation_prompt": null}
{"id": "aa05e22a-276d-4189-901d-f9ecce85a859", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for i in range(self.budget):\n            if i % 5 == 0:  # Change: Explore with Gaussian perturbation every 5 iterations\n                perturbation = np.random.normal(0, self.step_size, self.dim)\n            else:\n                perturbation = np.random.standard_cauchy(self.dim)\n                \n            candidate_solution = current_solution + perturbation * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            self.temperature *= self.cooling_rate\n            \n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "The algorithm integrates adaptive multi-scale search by periodically adjusting step sizes and using Gaussian perturbations for diverse exploration.", "configspace": "", "generation": 22, "fitness": 0.13848267901178857, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.138 with standard deviation 0.097. And the mean value of best solutions found was 0.791 (0. is the best) with standard deviation 0.142.", "error": "", "parent_id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "metadata": {"aucs": [0.16988783437593025, 0.007579882513274572, 0.23798032014616088], "final_y": [0.7363750467487145, 0.986778878780857, 0.6511596993815143]}, "mutation_prompt": null}
{"id": "9fd26ff7-d3df-4cfe-9f1a-8abd85ae1d20", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.temperature_reset_threshold = 0.1  # New line\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for _ in range(self.budget):\n            # Introduce Levy flight for exploration\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            self.temperature *= self.cooling_rate\n            \n            # Adaptive step size adjustment\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n            \n            # Implement temperature reset mechanism\n            if self.temperature < self.temperature_reset_threshold:  # Modified line\n                self.temperature = 1.0  # Modified line\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "The algorithm improves exploitation by implementing a temperature reset mechanism, enhancing search robustness against stagnation.", "configspace": "", "generation": 23, "fitness": 0.16654084812341596, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.167 with standard deviation 0.069. And the mean value of best solutions found was 0.746 (0. is the best) with standard deviation 0.094.", "error": "", "parent_id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "metadata": {"aucs": [0.1843624355475426, 0.07496479997465777, 0.2402953088480475], "final_y": [0.7173657932030071, 0.8733114334740256, 0.6484392707344021]}, "mutation_prompt": null}
{"id": "dfda7a63-cb15-4012-a0c5-b4c7a51474bb", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.99  # Changed cooling rate\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.alpha = 1.5  # Levy flight parameter\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for _ in range(self.budget):\n            # Introduce Levy flight for exploration\n            levy_flight = np.random.standard_cauchy(self.dim) ** self.alpha  # Added alpha to Levy flight\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            self.temperature *= self.cooling_rate\n            \n            # Adaptive step size adjustment\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "The algorithm integrates adaptive Levy flights and dynamic cooling to enhance exploration and convergence efficiency.", "configspace": "", "generation": 24, "fitness": 0.07005977156116235, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.070 with standard deviation 0.070. And the mean value of best solutions found was 0.888 (0. is the best) with standard deviation 0.107.", "error": "", "parent_id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "metadata": {"aucs": [0.16724029795213646, 0.006629843592499074, 0.036309173138851514], "final_y": [0.7396796831340087, 0.988117404093826, 0.9366304198170278]}, "mutation_prompt": null}
{"id": "ea452122-e881-4075-a9bf-820a17f1bdcb", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Modified cooling rate\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        \n        for _ in range(self.budget):\n            # Introduce Levy flight for exploration\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n            \n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n                \n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n\n            self.temperature *= self.cooling_rate\n            \n            # Adaptive step size adjustment\n            if candidate_cost < current_cost or np.random.rand() < 0.1:  # Added random chance for diversification\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n        \n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "The algorithm enhances exploration by introducing Levy flights combined with adaptive step size and improved temperature decay, maintaining efficient search and robustness against local minima.", "configspace": "", "generation": 25, "fitness": 0.09483693321841853, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.095 with standard deviation 0.067. And the mean value of best solutions found was 0.849 (0. is the best) with standard deviation 0.098.", "error": "", "parent_id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "metadata": {"aucs": [0.18917168576899146, 0.0543904206582112, 0.040948693228052946], "final_y": [0.7111748343799105, 0.9063522612675041, 0.9291318068273502]}, "mutation_prompt": null}
{"id": "47988bad-a40e-466d-a901-0c5328d077ba", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n\n        for _ in range(self.budget):\n            # Introduce Levy flight for exploration\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions.sort(key=func)\n                    elite_solutions = elite_solutions[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature *= self.cooling_rate\n            \n            # Adaptive step size with dynamic learning rate\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n\n            # Introduce elite solution influence\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Combines Levy flights with dynamic learning rates and elite solutions to enhance search precision and convergence speed.", "configspace": "", "generation": 26, "fitness": 0.17544287807125325, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.175 with standard deviation 0.069. And the mean value of best solutions found was 0.734 (0. is the best) with standard deviation 0.093.", "error": "", "parent_id": "2373f37d-7ed4-47fb-90c1-922f1a806e96", "metadata": {"aucs": [0.19087376749051332, 0.08380933203211516, 0.25164553469113127], "final_y": [0.7088767671286216, 0.8588531436404393, 0.6352246858228934]}, "mutation_prompt": null}
{"id": "60bd04d8-c466-40bf-b80e-11eee3d95494", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n\n        for _ in range(self.budget):\n            # Introduce Levy flight for exploration\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions.sort(key=func)\n                    elite_solutions = elite_solutions[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature *= (0.95 + 0.05 * np.random.rand())  # Dynamic cooling schedule adjustment\n            \n            # Adaptive step size with dynamic learning rate\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n\n            # Introduce elite solution influence\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0) + 0.01 * np.random.randn(self.dim)  # Add noise to elite influence\n                current_solution = (current_solution + influence) / 2\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhances AdaptiveSimulatedAnnealing by introducing a dynamic cooling schedule and adaptive elite updating, improving convergence and solution quality.", "configspace": "", "generation": 27, "fitness": 0.11807193326109766, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.118 with standard deviation 0.074. And the mean value of best solutions found was 0.782 (0. is the best) with standard deviation 0.113.", "error": "", "parent_id": "47988bad-a40e-466d-a901-0c5328d077ba", "metadata": {"aucs": [0.1995294990144275, 0.02115101200155045, 0.13353528876731502], "final_y": [0.6751588604334715, 0.9381178567191784, 0.7323334315748018]}, "mutation_prompt": null}
{"id": "317a1981-8e25-4af0-8bee-95a5f4203e7b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.diversity_threshold = 0.01  # Added to maintain diversity\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n\n        for _ in range(self.budget):\n            # Introduce Gaussian perturbation for multi-modal search\n            perturbation = np.random.normal(0, 1, self.dim)\n            candidate_solution = current_solution + perturbation * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions.sort(key=func)\n                    elite_solutions = elite_solutions[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature *= self.cooling_rate\n            \n            # Adaptive step size with dynamic learning rate\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n\n            # Introduce elite solution influence with diversity preservation\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                diversity = np.linalg.norm(influence - current_solution)\n                if diversity > self.diversity_threshold:\n                    current_solution = (current_solution + influence) / 2\n\n        return best_solution", "name": "EnhancedAdaptiveSimulatedAnnealing", "description": "Enhances AdaptiveSimulatedAnnealing with a multi-modal search strategy using Gaussian perturbations and a diversity preservation mechanism for improved exploration and convergence.", "configspace": "", "generation": 28, "fitness": 0.07171282609184937, "feedback": "The algorithm EnhancedAdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.072 with standard deviation 0.070. And the mean value of best solutions found was 0.886 (0. is the best) with standard deviation 0.107.", "error": "", "parent_id": "47988bad-a40e-466d-a901-0c5328d077ba", "metadata": {"aucs": [0.1684806244729834, 0.0072402516484365576, 0.03941760215412815], "final_y": [0.7382438447921137, 0.9873820280619396, 0.9316993775705598]}, "mutation_prompt": null}
{"id": "50121379-7f2a-4fc8-9a85-a372013e364f", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n\n        for _ in range(self.budget):\n            # Introduce Levy flight for exploration\n            levy_flight = np.random.standard_cauchy(self.dim)\n            gaussian_noise = np.random.normal(0, 0.1, self.dim)  # Added Gaussian perturbation\n            candidate_solution = current_solution + (levy_flight + gaussian_noise) * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions.sort(key=func)\n                    elite_solutions = elite_solutions[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature *= self.cooling_rate\n            \n            # Adaptive step size with dynamic learning rate\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n\n            # Introduce elite solution influence\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhances exploration by adding Gaussian perturbation to the Levy flight for better convergence.", "configspace": "", "generation": 29, "fitness": 0.0995333365230094, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.100 with standard deviation 0.073. And the mean value of best solutions found was 0.843 (0. is the best) with standard deviation 0.110.", "error": "", "parent_id": "47988bad-a40e-466d-a901-0c5328d077ba", "metadata": {"aucs": [0.19174693563967815, 0.012763800773706646, 0.09408927315564342], "final_y": [0.7077992127618129, 0.9775432842315387, 0.8441066374593527]}, "mutation_prompt": null}
{"id": "3940b5a1-56a3-43b5-8e0c-50aa7b8475df", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n\n        for _ in range(self.budget):\n            # Introduce Levy flight for exploration\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions.sort(key=func)\n                    elite_solutions = elite_solutions[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature *= self.cooling_rate\n            \n            # Adaptive step size with dynamic learning rate\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n\n            # Introduce elite solution influence\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n            \n            # Dynamically adapt elite fraction based on convergence speed\n            self.elite_fraction = min(0.5, max(0.1, self.elite_fraction * (1 + 0.01 * (best_cost - current_cost) / self.budget)))\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhances convergence by adapting elite fraction dynamically and leveraging historical performance data.", "configspace": "", "generation": 30, "fitness": 0.17544287807125325, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.175 with standard deviation 0.069. And the mean value of best solutions found was 0.734 (0. is the best) with standard deviation 0.093.", "error": "", "parent_id": "47988bad-a40e-466d-a901-0c5328d077ba", "metadata": {"aucs": [0.19087376749051332, 0.08380933203211516, 0.25164553469113127], "final_y": [0.7088767671286216, 0.8588531436404393, 0.6352246858228934]}, "mutation_prompt": null}
{"id": "6bbcdad4-501d-4548-bb1b-cbf87471cebb", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9  # New parameter to introduce momentum\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)  # Initialize previous solution\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution  # Capture the current solution before update\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions.sort(key=func)\n                    elite_solutions = elite_solutions[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature *= self.cooling_rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9, self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Momentum update\n            current_solution += self.momentum_factor * (current_solution - prev_solution)\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhances adaptive search by incorporating momentum from historical solutions to improve convergence speed.", "configspace": "", "generation": 31, "fitness": 0.22843064707137248, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.228 with standard deviation 0.059. And the mean value of best solutions found was 0.665 (0. is the best) with standard deviation 0.069.", "error": "", "parent_id": "47988bad-a40e-466d-a901-0c5328d077ba", "metadata": {"aucs": [0.21145748826191624, 0.16572058773305087, 0.3081138652191503], "final_y": [0.6828962112107391, 0.7395842684540967, 0.5735059108622509]}, "mutation_prompt": null}
{"id": "21944afb-77d3-4ed1-b462-5b826d998e40", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9 \n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim) \n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution  \n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions.sort(key=func)\n                    elite_solutions = elite_solutions[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature *= self.cooling_rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.2, self.initial_step_size)  # Changed factor\n            else:\n                self.step_size = max(self.step_size * 0.85, self.min_step_size)  # Changed factor\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            current_solution += self.momentum_factor * (current_solution - prev_solution)\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Integrates stochastic gradient descent to refine local exploration by adjusting step sizes dynamically.", "configspace": "", "generation": 32, "fitness": 0.17719479082053566, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.177 with standard deviation 0.093. And the mean value of best solutions found was 0.737 (0. is the best) with standard deviation 0.126.", "error": "", "parent_id": "6bbcdad4-501d-4548-bb1b-cbf87471cebb", "metadata": {"aucs": [0.1941612018284491, 0.05530189681387876, 0.2821212738192791], "final_y": [0.7047045203675448, 0.9048594594216709, 0.6011735842497286]}, "mutation_prompt": null}
{"id": "764418ba-8186-4cd2-8368-83fe55b265db", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9  # New parameter to introduce momentum\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)  # Initialize previous solution\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution  # Capture the current solution before update\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions.sort(key=func)\n                    elite_solutions = elite_solutions[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature *= self.cooling_rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)  # Change\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Momentum update\n            current_solution += self.momentum_factor * (current_solution - prev_solution)\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introducing dynamic step size adaptation based on the temperature to improve exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": 0.3513397525312561, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.351 with standard deviation 0.104. And the mean value of best solutions found was 0.539 (0. is the best) with standard deviation 0.094.", "error": "", "parent_id": "6bbcdad4-501d-4548-bb1b-cbf87471cebb", "metadata": {"aucs": [0.49720758718174796, 0.2620662962894559, 0.2947453741225644], "final_y": [0.4073657072133321, 0.6225327829582349, 0.587630073161529]}, "mutation_prompt": null}
{"id": "764fcf96-7eb9-44ec-b6c2-d83fc418ff80", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim)\n            dual_step_size = self.step_size * (1 + np.random.rand())  # Change 1\n            candidate_solution = current_solution + levy_flight * dual_step_size  # Change 2\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions.sort(key=func)\n                    elite_solutions = elite_solutions[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature *= self.cooling_rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            current_solution += self.momentum_factor * (current_solution - prev_solution)  # Change 3\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introduced a dual-step size strategy to enhance exploration-exploitation dynamics.", "configspace": "", "generation": 34, "fitness": 0.3127135587716606, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.313 with standard deviation 0.099. And the mean value of best solutions found was 0.577 (0. is the best) with standard deviation 0.100.", "error": "", "parent_id": "764418ba-8186-4cd2-8368-83fe55b265db", "metadata": {"aucs": [0.28802046666946957, 0.4448220229587482, 0.20529818668676414], "final_y": [0.594759249278013, 0.44722424963464147, 0.6903889829553593]}, "mutation_prompt": null}
{"id": "84285d67-1620-4793-8203-f91ab0cbf5cb", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature *= self.cooling_rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Incorporating an adaptive elite updating mechanism and enhanced momentum dynamics to refine exploration and exploitation balance.", "configspace": "", "generation": 35, "fitness": 0.5027175251991101, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.503 with standard deviation 0.049. And the mean value of best solutions found was 0.402 (0. is the best) with standard deviation 0.035.", "error": "", "parent_id": "764418ba-8186-4cd2-8368-83fe55b265db", "metadata": {"aucs": [0.5698562731254246, 0.4528131149097365, 0.4854831875621689], "final_y": [0.354912517977116, 0.4389097293845703, 0.41176993577106547]}, "mutation_prompt": null}
{"id": "0de4ff6b-7400-49bc-9cb4-a5b50ebbb4ef", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature *= self.cooling_rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.01:  # 1% chance of restart\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introducing diversity-preserving mechanisms and adaptive restart strategy to enhance global exploration and convergence.", "configspace": "", "generation": 36, "fitness": 0.7776705919846472, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.778 with standard deviation 0.124. And the mean value of best solutions found was 0.243 (0. is the best) with standard deviation 0.056.", "error": "", "parent_id": "84285d67-1620-4793-8203-f91ab0cbf5cb", "metadata": {"aucs": [0.9426092809075466, 0.7479051216700545, 0.6424973733763403], "final_y": [0.171481918584244, 0.25120163621712166, 0.30688043087257433]}, "mutation_prompt": null}
{"id": "b8eb06a9-28dd-45fd-84fb-4e989eb5cd1a", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature *= self.cooling_rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introducing a temperature-dependent adaptive restart strategy to enhance global exploration and convergence.", "configspace": "", "generation": 37, "fitness": 0.9035907915311375, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.904 with standard deviation 0.066. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0de4ff6b-7400-49bc-9cb4-a5b50ebbb4ef", "metadata": {"aucs": [0.9736321329406956, 0.9214626407600945, 0.8156776008926224], "final_y": [0.1654721706576523, 0.16593402082700226, 0.1665626254596908]}, "mutation_prompt": null}
{"id": "5e1d3470-aada-40d7-bb56-5bc6f2cbca3f", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.2  # Increased elite fraction\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:max(1, int(self.elite_fraction * len(elite_solutions)))]  # Elite size correction\n\n            self.temperature *= self.cooling_rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.05, self.initial_step_size)  # Slightly adjusted step scaling\n            else:\n                self.step_size = max(self.step_size * 0.85 * (1 + self.temperature), self.min_step_size)  # Slightly adjusted step scaling\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Integrates dynamic elite selection and adaptive step size adjustment to improve local convergence and stability.", "configspace": "", "generation": 38, "fitness": 0.8100089958119726, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.810 with standard deviation 0.129. And the mean value of best solutions found was 0.229 (0. is the best) with standard deviation 0.056.", "error": "", "parent_id": "b8eb06a9-28dd-45fd-84fb-4e989eb5cd1a", "metadata": {"aucs": [0.6479928855802186, 0.9640053308540604, 0.8180287710016387], "final_y": [0.3026856267913658, 0.1652954092257265, 0.21977009960272287]}, "mutation_prompt": null}
{"id": "f98356ce-80aa-46d3-a87b-efa7d583ac93", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature *= self.cooling_rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                influence_scale = np.random.rand() * self.temperature  # Adaptive scaling of influence\n                current_solution = (current_solution + influence_scale * influence) / (1 + influence_scale)\n\n            # Enhancing momentum to depend on temperature\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introducing adaptive elite influence scaling and stochastic step size adaptation for enhanced exploration.", "configspace": "", "generation": 39, "fitness": 0.5130028395944909, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.513 with standard deviation 0.032. And the mean value of best solutions found was 0.366 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "b8eb06a9-28dd-45fd-84fb-4e989eb5cd1a", "metadata": {"aucs": [0.47627117274869346, 0.554185888022533, 0.5085514580122463], "final_y": [0.38417954978795965, 0.33312663604959636, 0.38034746308141154]}, "mutation_prompt": null}
{"id": "a211ce5e-8160-4afe-aacd-e6549b1a7f81", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            acceptance_prob = self._acceptance_probability(current_cost, candidate_cost, self.temperature)\n            if acceptance_prob > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature *= self.cooling_rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                # Modulating step size based on acceptance probability (changed line)\n                self.step_size = max(self.step_size * 0.9 * acceptance_prob, self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introducing a step size modulation based on acceptance probability to enhance local search capabilities.", "configspace": "", "generation": 40, "fitness": 0.897743146411699, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.898 with standard deviation 0.013. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b8eb06a9-28dd-45fd-84fb-4e989eb5cd1a", "metadata": {"aucs": [0.8901827144660561, 0.8865238043308, 0.916522920438241], "final_y": [0.16630980070740098, 0.1658149342177354, 0.16524251506900178]}, "mutation_prompt": null}
{"id": "4dd36062-a0fd-4052-b610-a1443c99bb97", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature *= self.cooling_rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Fine-tune the momentum factor to be dynamically adjusted based on convergence speed, improving exploration-exploitation balance.", "configspace": "", "generation": 41, "fitness": 0.9326210405708002, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.933 with standard deviation 0.014. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b8eb06a9-28dd-45fd-84fb-4e989eb5cd1a", "metadata": {"aucs": [0.9531128404621692, 0.9225647785924296, 0.922185502657802], "final_y": [0.16612274245230263, 0.16615971506593152, 0.16523309772035466]}, "mutation_prompt": null}
{"id": "e3bbfb53-ffd6-4528-8e71-84629a7564fa", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature *= self.cooling_rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Incorporate a minor temperature-dependent adjustment to the step size during exploration to enhance convergence.", "configspace": "", "generation": 42, "fitness": 0.9358562284223694, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.936 with standard deviation 0.015. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4dd36062-a0fd-4052-b610-a1443c99bb97", "metadata": {"aucs": [0.9551292889788505, 0.9345421441306443, 0.9178972521576134], "final_y": [0.16617604007857123, 0.16602020546310103, 0.1653806627810449]}, "mutation_prompt": null}
{"id": "02db5f52-a4fe-4ca0-90a3-81ee62329a24", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature *= self.cooling_rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance the algorithm by introducing a temperature-dependent scaling factor to the levy flight step for improved exploratory capability.", "configspace": "", "generation": 43, "fitness": 0.9399866523879415, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.940 with standard deviation 0.022. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e3bbfb53-ffd6-4528-8e71-84629a7564fa", "metadata": {"aucs": [0.9698043503174328, 0.9345005541050978, 0.9156550527412938], "final_y": [0.16560851781194952, 0.1656440825540193, 0.1653551076682056]}, "mutation_prompt": null}
{"id": "aa78342a-6d85-42c8-a211-dc5374b84a35", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95  # This line remains unchanged\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for i in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature *= self.cooling_rate * (1 - i / self.budget)  # Change in this line for adaptive cooling\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introduce an adaptive cooling schedule by making the cooling rate vary with the iteration count to enhance convergence.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: ZeroDivisionError('float division by zero').", "error": "ZeroDivisionError('float division by zero')", "parent_id": "02db5f52-a4fe-4ca0-90a3-81ee62329a24", "metadata": {}, "mutation_prompt": null}
{"id": "bcdfe0fa-950b-47a5-aa6b-c7326b58c888", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature *= self.cooling_rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                influence_factor = 0.5 + 0.5 * (1 - self.temperature)  # Adaptive influence factor\n                current_solution = (current_solution + influence_factor * influence) / (1 + influence_factor)\n\n            self.momentum_factor = 0.9 * (1 - self.temperature)\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            self.step_size *= (1 + 0.01 * self.temperature)\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introduce an adaptive elite influence factor to better balance exploration and exploitation, enhancing convergence.", "configspace": "", "generation": 45, "fitness": 0.9370770380379475, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.937 with standard deviation 0.031. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "02db5f52-a4fe-4ca0-90a3-81ee62329a24", "metadata": {"aucs": [0.9772384599216618, 0.9011477787487184, 0.9328448754434624], "final_y": [0.16558645450709286, 0.1669769660758068, 0.1653371088376513]}, "mutation_prompt": null}
{"id": "7ea85c38-3794-46a3-9722-09351ade81ba", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature *= self.cooling_rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            self.momentum_factor = 0.9 * (1 - self.temperature)\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            self.elite_fraction = max(0.05, min(0.2, self.elite_fraction * (1 - self.temperature / 2)))  # Adjust elite fraction\n            self.cooling_rate = max(0.90, min(0.99, self.cooling_rate * (1 - 0.001 * current_cost)))  # Adjust cooling rate\n\n            self.step_size *= (1 + 0.01 * self.temperature)\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance the algorithm by dynamically adjusting the elite fraction and cooling rate based on current performance for improved balance between exploration and exploitation.", "configspace": "", "generation": 46, "fitness": 0.8776532293260685, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.878 with standard deviation 0.047. And the mean value of best solutions found was 0.194 (0. is the best) with standard deviation 0.020.", "error": "", "parent_id": "02db5f52-a4fe-4ca0-90a3-81ee62329a24", "metadata": {"aucs": [0.840926223227061, 0.8474911240083021, 0.9445423407428428], "final_y": [0.20824906467915172, 0.2096423983990111, 0.16560080861976068]}, "mutation_prompt": null}
{"id": "8deb0157-503f-4a44-815b-2126dd8fe350", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature *= self.cooling_rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.2, self.initial_step_size)  # Adjusted increase factor\n            else:\n                self.step_size = max(self.step_size * 0.85 * (1 + self.temperature), self.min_step_size)  # Adjusted decrease factor\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            self.momentum_factor = 0.9 * (1 - self.temperature)\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            if np.random.rand() < 0.01 + 0.05 * (1 - self.temperature):  # Adjusted restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            self.step_size *= (1 + 0.015 * self.temperature)  # Adjusted step size scaling factor\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Incorporate an elite-guided adaptive step size adjustment to enhance exploration and exploitation balance.", "configspace": "", "generation": 47, "fitness": 0.7494722953798183, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.749 with standard deviation 0.119. And the mean value of best solutions found was 0.192 (0. is the best) with standard deviation 0.024.", "error": "", "parent_id": "02db5f52-a4fe-4ca0-90a3-81ee62329a24", "metadata": {"aucs": [0.752402282607303, 0.6027936865052613, 0.8932209170268905], "final_y": [0.22480566264125723, 0.18334865882486495, 0.1685543387478461]}, "mutation_prompt": null}
{"id": "f55160c6-dae4-4f45-acae-1f8b2f64816f", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * self.cooling_rate, 0.01)  # Ensures temperature doesn't drop to zero\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introduce a lower bound on the cooling rate to ensure a non-zero temperature, preventing stagnation.", "configspace": "", "generation": 48, "fitness": 0.940720597069881, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.941 with standard deviation 0.024. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "02db5f52-a4fe-4ca0-90a3-81ee62329a24", "metadata": {"aucs": [0.9726585615780655, 0.9335405904092504, 0.9159626392223271], "final_y": [0.16564876480034185, 0.1661725270963642, 0.16504553881303785]}, "mutation_prompt": null}
{"id": "82cbf345-14bc-4f6c-8607-a0ed9ca3818d", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * self.cooling_rate, 0.01)  # Ensures temperature doesn't drop to zero\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):  # Modified restart probability\n                perturbation = np.random.normal(0, 0.1, self.dim)  # Perturbation near elite solutions\n                current_solution = np.mean(elite_solutions, axis=0) + perturbation\n                current_solution = np.clip(current_solution, func.bounds.lb, func.bounds.ub)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance adaptive restart by boosting exploration when close to existing elite solutions.", "configspace": "", "generation": 49, "fitness": 0.6775960731006393, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.678 with standard deviation 0.151. And the mean value of best solutions found was 0.296 (0. is the best) with standard deviation 0.082.", "error": "", "parent_id": "f55160c6-dae4-4f45-acae-1f8b2f64816f", "metadata": {"aucs": [0.8582504735959549, 0.48755974745603947, 0.6869779982499238], "final_y": [0.20530106918593038, 0.40443671689891203, 0.279690040260243]}, "mutation_prompt": null}
{"id": "984804bb-b8dd-4413-a846-8ec51119aa28", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introduce a dynamic cooling rate adjustment based on recent cost improvements for more adaptive exploration.", "configspace": "", "generation": 50, "fitness": 0.9479278100161888, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.948 with standard deviation 0.007. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "f55160c6-dae4-4f45-acae-1f8b2f64816f", "metadata": {"aucs": [0.9573595541866101, 0.9401710283009823, 0.9462528475609738], "final_y": [0.16737571712747257, 0.16561766302804437, 0.16529284390643728]}, "mutation_prompt": null}
{"id": "41482928-69bd-452a-b093-884e9cc99f8e", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        best_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            # Reflecting the solution if it hits the boundary\n            candidate_solution = np.where(candidate_solution < func.bounds.lb, 2 * func.bounds.lb - candidate_solution, candidate_solution)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            self.momentum_factor = 0.9 * (1 - self.temperature)\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            self.step_size *= (1 + 0.01 * self.temperature)\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance exploration by incorporating adaptive boundary reflection and an improved elite selection mechanism.", "configspace": "", "generation": 51, "fitness": 0.9479278100161888, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.948 with standard deviation 0.007. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "984804bb-b8dd-4413-a846-8ec51119aa28", "metadata": {"aucs": [0.9573595541866101, 0.9401710283009823, 0.9462528475609738], "final_y": [0.16737571712747257, 0.16561766302804437, 0.16529284390643728]}, "mutation_prompt": null}
{"id": "92f98b4d-53b9-46b0-a9d0-3d3398b3a4e0", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size\n                current_solution += mutation\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introduce a dynamic population size and adaptive mutation for enhanced exploration and exploitation balance.", "configspace": "", "generation": 52, "fitness": 0.9534599285125193, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.953 with standard deviation 0.020. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "984804bb-b8dd-4413-a846-8ec51119aa28", "metadata": {"aucs": [0.9262444736686712, 0.9746634674797356, 0.9594718443891506], "final_y": [0.16521742142690454, 0.16543860079047124, 0.1656844528350485]}, "mutation_prompt": null}
{"id": "a898811b-6fd1-4c6f-8b23-60ad0b3bbfe9", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.9  # Faster cooling to encourage exploration\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.8  # Adjusted momentum factor\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 7  # Increased population size for diversity\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * self.cooling_rate, 0.01)\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.2, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.85 * (1 + self.temperature), self.min_step_size)  # Adjusted decay\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2.5  # More elite influence\n\n            self.momentum_factor = 0.8 * (1 - self.temperature)\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            if np.random.rand() < 0.01 + 0.03 * (1 - self.temperature):  # Lower restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            self.step_size *= (1 + 0.02 * self.temperature)  # Increased step size adaptation\n            \n            if np.random.rand() < 0.07 * self.temperature:  # More frequent mutation\n                mutation = np.random.randn(self.dim) * self.step_size\n                current_solution += mutation\n\n            # Local search enhancement\n            if np.random.rand() < 0.1:\n                neighborhood = current_solution + np.random.uniform(-self.step_size, self.step_size, self.dim)\n                neighborhood = np.clip(neighborhood, func.bounds.lb, func.bounds.ub)\n                neighborhood_cost = func(neighborhood)\n                if neighborhood_cost < current_cost:\n                    current_solution = neighborhood\n                    current_cost = neighborhood_cost\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introduce adaptive population diversity and enhanced local search for improved solution refinement.", "configspace": "", "generation": 53, "fitness": 0.6911663284359905, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.691 with standard deviation 0.128. And the mean value of best solutions found was 0.234 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "92f98b4d-53b9-46b0-a9d0-3d3398b3a4e0", "metadata": {"aucs": [0.5119400214412668, 0.8056743796136376, 0.7558845842530671], "final_y": [0.2403542858277422, 0.221628480530478, 0.24141644939661666]}, "mutation_prompt": null}
{"id": "d448a47c-4706-4ef5-89c3-86794a351917", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n        self.dynamic_learning_rate = 0.2  # New dynamic learning rate\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            self.momentum_factor = 0.9 * (1 - self.temperature)\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size\n                current_solution += mutation\n\n            # Introduce evolutionary strategy concept\n            if np.random.rand() < self.dynamic_learning_rate:\n                self.dynamic_learning_rate *= np.exp(0.1 * (best_cost - current_cost))\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Integrate dynamic learning rates and evolutionary strategies to enhance adaptive exploration and exploitation balance.", "configspace": "", "generation": 54, "fitness": 0.8674502139025876, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.867 with standard deviation 0.060. And the mean value of best solutions found was 0.181 (0. is the best) with standard deviation 0.022.", "error": "", "parent_id": "92f98b4d-53b9-46b0-a9d0-3d3398b3a4e0", "metadata": {"aucs": [0.8215123994817546, 0.9521838593091431, 0.8286543829168649], "final_y": [0.21182184566201057, 0.16509436249328746, 0.1671548149871117]}, "mutation_prompt": null}
{"id": "89717cf2-19f1-4553-986d-5d4f156a8e1d", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.01 + 0.03 * (1 - self.temperature):  # Fine-grained restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.02 * self.temperature)  # Refined mutation scaling\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size\n                current_solution += mutation\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Implement fine-grained restart and refined mutation strategies for improved adaptability and exploration.", "configspace": "", "generation": 55, "fitness": 0.9194381795294615, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.919 with standard deviation 0.035. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "92f98b4d-53b9-46b0-a9d0-3d3398b3a4e0", "metadata": {"aucs": [0.9098194987006538, 0.9660407725393081, 0.8824542673484225], "final_y": [0.1653940455918197, 0.1672789238030188, 0.16666820425590323]}, "mutation_prompt": null}
{"id": "cf178841-42fd-46b6-a01f-78f9a20d1a2c", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5 + int(self.temperature * 5)  # Adjusting population size dynamically\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            self.momentum_factor = 0.9 * (1 - self.temperature)\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            self.step_size *= (1 + 0.01 * self.temperature)\n\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size * self.temperature  # Dynamic scaling for mutation\n                current_solution += mutation\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance exploration by adjusting population size and adding dynamic temperature-dependent mutation scaling.", "configspace": "", "generation": 56, "fitness": 0.901217045040128, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.901 with standard deviation 0.066. And the mean value of best solutions found was 0.184 (0. is the best) with standard deviation 0.025.", "error": "", "parent_id": "92f98b4d-53b9-46b0-a9d0-3d3398b3a4e0", "metadata": {"aucs": [0.8083332888205237, 0.9505428555767007, 0.9447749907231596], "final_y": [0.21884501002079482, 0.1652724051800576, 0.1664694849214231]}, "mutation_prompt": null}
{"id": "5f5a301f-ece5-47ae-83ff-e3a1cae9c378", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.04 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size\n                current_solution += mutation\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introduce a dynamic restart strategy to enhance escaping from local optima and improve exploration.", "configspace": "", "generation": 57, "fitness": 0.951424168548895, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.951 with standard deviation 0.017. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "92f98b4d-53b9-46b0-a9d0-3d3398b3a4e0", "metadata": {"aucs": [0.9275749627333112, 0.9673465161935199, 0.9593510267198537], "final_y": [0.16568106139569783, 0.1659556715075744, 0.16506350674883907]}, "mutation_prompt": null}
{"id": "c7726df4-014e-4d6e-816f-2376e9d41d7d", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  \n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.8 * (1 + self.temperature), self.min_step_size)  # Reduced step size change\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            self.momentum_factor = 0.85 * (1 - self.temperature)  # Slightly reduced momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            diversity_factor = np.std(population, axis=0)  # New diversity factor\n            current_solution += diversity_factor * levy_flight * 0.05  \n\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):  \n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size\n                current_solution += mutation\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Integrate diversity enhancement and dynamic elite selection to improve convergence in simulated annealing.", "configspace": "", "generation": 58, "fitness": 0.9333137100469014, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.933 with standard deviation 0.018. And the mean value of best solutions found was 0.173 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "92f98b4d-53b9-46b0-a9d0-3d3398b3a4e0", "metadata": {"aucs": [0.9207414508885593, 0.9209726514414048, 0.9582270278107404], "final_y": [0.18408099496090202, 0.16756851371683967, 0.16760676226163207]}, "mutation_prompt": null}
{"id": "730757f8-e5b9-42e9-a684-ecaff4aaa6d5", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + 0.8 * influence) / 1.8  # Changed elite influence factor\n\n            self.momentum_factor = 0.9 * (1 - self.temperature)\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):\n                current_solution = np.clip(prev_solution + np.random.randn(self.dim) * 0.1, func.bounds.lb, func.bounds.ub)  # Modified restart\n\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size\n                current_solution += mutation\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introduce adaptive elitism and diversity-promoting initialization for enhanced solution quality and robustness.", "configspace": "", "generation": 59, "fitness": 0.6607765097075574, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.661 with standard deviation 0.070. And the mean value of best solutions found was 0.295 (0. is the best) with standard deviation 0.039.", "error": "", "parent_id": "92f98b4d-53b9-46b0-a9d0-3d3398b3a4e0", "metadata": {"aucs": [0.6783290229337406, 0.7363663618007239, 0.5676341443882076], "final_y": [0.28123441792954806, 0.25526200042986735, 0.34752143489838616]}, "mutation_prompt": null}
{"id": "b4b2843c-5d1c-4680-89bb-c8a0e64cf511", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0) + 0.05 * np.random.randn(self.dim)  # Enhance elite influence\n                current_solution = (current_solution + influence) / 2\n\n            self.momentum_factor = 0.9 * (1 - self.temperature)\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size\n                current_solution += mutation\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance Adaptive Simulated Annealing by introducing a memory-based elite locality search to refine solutions.", "configspace": "", "generation": 60, "fitness": 0.9154266587910986, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.915 with standard deviation 0.053. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "92f98b4d-53b9-46b0-a9d0-3d3398b3a4e0", "metadata": {"aucs": [0.9374728238042184, 0.9663357061420144, 0.842471446427063], "final_y": [0.16594484634714046, 0.16519323018388854, 0.16644862997025267]}, "mutation_prompt": null}
{"id": "fcb4209e-bf0d-42e8-8467-6b2d8f0e8c3b", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on diversity of elite solutions\n            diversity_factor = np.std(elite_solutions) / np.mean(elite_solutions) if np.mean(elite_solutions) != 0 else 1\n            self.step_size *= (1 + 0.01 * self.temperature * diversity_factor)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size\n                current_solution += mutation\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introduce dynamic scaling of step size based on diversity for improved convergence and exploration.", "configspace": "", "generation": 61, "fitness": 0.9083769530528895, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.908 with standard deviation 0.083. And the mean value of best solutions found was 0.184 (0. is the best) with standard deviation 0.026.", "error": "", "parent_id": "92f98b4d-53b9-46b0-a9d0-3d3398b3a4e0", "metadata": {"aucs": [0.7909743159582432, 0.9769282780880341, 0.957228265112391], "final_y": [0.22008672457414635, 0.16530510880766847, 0.16604917416672982]}, "mutation_prompt": null}
{"id": "b6fdf028-cbe6-4eff-b9f4-601de88f317d", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n        self.secondary_temperature = 0.5  # New secondary temperature for local search enhancement\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)\n            self.secondary_temperature *= 0.98  # New cooling for secondary temperature\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            self.momentum_factor = 0.9 * (1 - self.temperature)\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.secondary_temperature  # Use secondary temperature\n\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size\n                current_solution += mutation\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhanced Adaptive Simulated Annealing with dual-temperature mechanism for improved local and global search balance.", "configspace": "", "generation": 62, "fitness": 0.9449033117006088, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.945 with standard deviation 0.020. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "92f98b4d-53b9-46b0-a9d0-3d3398b3a4e0", "metadata": {"aucs": [0.9274175438620402, 0.9724965000623467, 0.9347958911774394], "final_y": [0.1652562281773935, 0.16620030509819606, 0.16645634988482683]}, "mutation_prompt": null}
{"id": "3c811bd3-ca4c-46af-803d-2a2572edb3ed", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introduce adaptive mutation scaling with the inverse of the temperature for improved convergence.", "configspace": "", "generation": 63, "fitness": 0.9544262489237397, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.954 with standard deviation 0.021. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "92f98b4d-53b9-46b0-a9d0-3d3398b3a4e0", "metadata": {"aucs": [0.9262453605866038, 0.977543937384706, 0.9594894487999097], "final_y": [0.165217432468175, 0.16527678231430432, 0.16567947448945108]}, "mutation_prompt": null}
{"id": "79c11a1e-0fb2-4017-8722-1b84bed05af0", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                influence_weight = 0.5 * (1 + self.temperature)  # Dynamic elite influence based on temperature\n                current_solution = (current_solution + influence * influence_weight) / (1 + influence_weight)\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introduce dynamic elite influence based on temperature to refine solution adaptation and convergence.", "configspace": "", "generation": 64, "fitness": 0.8774532937288995, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.877 with standard deviation 0.093. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "3c811bd3-ca4c-46af-803d-2a2572edb3ed", "metadata": {"aucs": [0.9177720053349295, 0.9661336167323327, 0.7484542591194364], "final_y": [0.1666518415072329, 0.1673457124039497, 0.17985139629924007]}, "mutation_prompt": null}
{"id": "8830f54b-75f6-4d3d-ba49-91384b30a48c", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0) * (1 - self.temperature)  # Modified elite influence\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.01 + 0.04 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance convergence by modifying the elite solution influence to consider the temperature.", "configspace": "", "generation": 65, "fitness": 0.9294927465128365, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.929 with standard deviation 0.010. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3c811bd3-ca4c-46af-803d-2a2572edb3ed", "metadata": {"aucs": [0.9320387848454716, 0.9397538093056823, 0.9166856453873555], "final_y": [0.16591143867477298, 0.16690397561270376, 0.16675925258614455]}, "mutation_prompt": null}
{"id": "f435fc38-f348-4ee0-a546-69c94831d19d", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introduce adaptive mutation scaling with inverse temperature and improved restart strategy for enhanced exploration.", "configspace": "", "generation": 66, "fitness": 0.9554840067036291, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.955 with standard deviation 0.022. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3c811bd3-ca4c-46af-803d-2a2572edb3ed", "metadata": {"aucs": [0.9262453605866038, 0.977543937384706, 0.9626627221395777], "final_y": [0.165217432468175, 0.16527678231430432, 0.16505053903796407]}, "mutation_prompt": null}
{"id": "a3e5a528-883a-4591-9e52-10b7190a770f", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01) \n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 3  # Adjusted influence weight\n\n            self.momentum_factor = 0.9 * (1 - self.temperature) \n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            if np.random.rand() < 0.01 + 0.03 * (1 - self.temperature):  # Adjusted restart probability\n                current_solution = elite_solutions[np.random.randint(len(elite_solutions))]  # Elite-driven restart\n                current_cost = func(current_solution)\n\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature \n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introduce an elite-driven restart strategy and adaptive population size for improved convergence.", "configspace": "", "generation": 67, "fitness": 0.3638779960536671, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.364 with standard deviation 0.051. And the mean value of best solutions found was 0.521 (0. is the best) with standard deviation 0.049.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.41772728496606437, 0.3787842635075528, 0.29512243968738416], "final_y": [0.47038023872875234, 0.5049702956631955, 0.5865563082748423]}, "mutation_prompt": null}
{"id": "4536b4e3-d2d6-4175-92da-eb0d8cd5a032", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Enhanced cooling rate for better convergence\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 7  # Adjusted population size for better diversity\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (self.cooling_rate - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance the cooling schedule and population dynamics for improved convergence and exploration balance.", "configspace": "", "generation": 68, "fitness": 0.9309878065883216, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.931 with standard deviation 0.025. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.9586992735595165, 0.8977001726024539, 0.9365639736029944], "final_y": [0.16621819951302463, 0.17093392441819433, 0.16624766057132934]}, "mutation_prompt": null}
{"id": "75162423-2a31-4668-b301-da3bc49509e6", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.015 + 0.025 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhanced strategy by refining the adaptive restart probability to efficiently balance exploration and exploitation.", "configspace": "", "generation": 69, "fitness": 0.8464042199914849, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.846 with standard deviation 0.083. And the mean value of best solutions found was 0.190 (0. is the best) with standard deviation 0.029.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.8032112132785514, 0.9619981798713076, 0.7740032668245955], "final_y": [0.23048550133462642, 0.1680321852126213, 0.17087664800074842]}, "mutation_prompt": null}
{"id": "4625f5d5-6516-4051-83b8-8fc44feda032", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature) + (best_cost - current_cost) / best_cost  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Incorporate elite-driven exploration and enhanced momentum to boost convergence.", "configspace": "", "generation": 70, "fitness": 0.7943259363910807, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.794 with standard deviation 0.135. And the mean value of best solutions found was 0.221 (0. is the best) with standard deviation 0.077.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.92530490006021, 0.608858532543956, 0.848814376569076], "final_y": [0.1656265159614706, 0.329585294213122, 0.16732886382751655]}, "mutation_prompt": null}
{"id": "a69ef02e-7bc3-42f9-a3e8-cd3e5275c291", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)**2), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introduce feedback-based cooling rate adjustment for improved convergence speed.", "configspace": "", "generation": 71, "fitness": 0.9181301464665174, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.918 with standard deviation 0.048. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.9266905880560249, 0.9726175730878648, 0.8550822782556623], "final_y": [0.16530509212448674, 0.1653994364678053, 0.16656554985748884]}, "mutation_prompt": null}
{"id": "3408c0da-aba6-421b-9071-7a0d66fd0983", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < (0.02 + 0.03 * (1 - self.temperature)) * self.temperature:  # Enhanced restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhanced adaptive restart strategy by allowing temperature-dependent adjustment for better exploration.", "configspace": "", "generation": 72, "fitness": 0.718727792275891, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.719 with standard deviation 0.107. And the mean value of best solutions found was 0.272 (0. is the best) with standard deviation 0.052.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.6732760643677582, 0.8658242240229461, 0.6170830884369687], "final_y": [0.2942191561996875, 0.20020389036826758, 0.32149990730482636]}, "mutation_prompt": null}
{"id": "ca619bae-7252-4d74-b060-394bf3c7ada9", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / (temperature + 1e-9))  # Improved stability by adding epsilon\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.8 * (1 - self.temperature)  # Further adjusted momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Fine-tuned adaptive momentum and acceptance probability for improved convergence in simulated annealing.", "configspace": "", "generation": 73, "fitness": 0.9464127063979948, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.946 with standard deviation 0.021. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.9277835721591694, 0.9763936854460497, 0.935060861588765], "final_y": [0.16526936566052353, 0.16543826783360804, 0.16609721894765594]}, "mutation_prompt": null}
{"id": "ff9ae114-4d26-4abd-a4cd-ca47c7ab8d16", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.2 * self.temperature)  # Adjusted levy flight scaling\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:max(1, int(self.elite_fraction * len(elite_solutions)))]  # Enhanced elite selection\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance elite selection and introduce adaptive levy flight scaling for improved exploration.", "configspace": "", "generation": 74, "fitness": 0.9097806968422569, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.910 with standard deviation 0.081. And the mean value of best solutions found was 0.184 (0. is the best) with standard deviation 0.026.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.795085606840961, 0.9766293371804233, 0.9576271465053867], "final_y": [0.22002539503972807, 0.16538824481852787, 0.16598603018695213]}, "mutation_prompt": null}
{"id": "46fe169c-9f9a-4165-b1c9-9f0a5ea86c33", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_normal(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Adjusted the levy flight distribution to enhance exploration capabilities.", "configspace": "", "generation": 75, "fitness": 0.9135118043391227, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.914 with standard deviation 0.036. And the mean value of best solutions found was 0.179 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.8637053734062374, 0.9479889700650883, 0.9288410695460423], "final_y": [0.204655602405872, 0.16500703595036237, 0.16614598922512802]}, "mutation_prompt": null}
{"id": "fde6b575-a055-4970-ad30-fd9f18eb69d4", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n        self.restart_interval = 100  # Introduced restart interval\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n        iteration = 0\n\n        for _ in range(self.budget):\n            iteration += 1\n\n            perturbation = np.random.normal(0, 1, self.dim) * (1 + 0.05 * self.temperature)  # Diversified perturbation\n            candidate_solution = current_solution + perturbation * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.2, self.initial_step_size * (1 + 0.05 * self.temperature))  # Adjusted step size increase\n            else:\n                self.step_size = max(self.step_size * 0.8, self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            self.momentum_factor = 0.9 * (1 - self.temperature)\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            if iteration % self.restart_interval == 0:  # Periodic re-initialization\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            self.step_size *= (1 + 0.01 * self.temperature)\n\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Integrate adaptive annealing with diversified perturbation and periodic re-initialization for robust global search.", "configspace": "", "generation": 76, "fitness": 0.6537839279230956, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.654 with standard deviation 0.074. And the mean value of best solutions found was 0.252 (0. is the best) with standard deviation 0.059.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.5654670929808535, 0.7476089627801686, 0.6482757280082645], "final_y": [0.33276139085207335, 0.19209705179355696, 0.22986566230468697]}, "mutation_prompt": null}
{"id": "7ad6f8fd-60cf-492c-90e8-49517afe2f7a", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.93 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Fine-tune the cooling rate adjustment to enhance convergence speed and solution quality.", "configspace": "", "generation": 77, "fitness": 0.8644971963254774, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.864 with standard deviation 0.100. And the mean value of best solutions found was 0.198 (0. is the best) with standard deviation 0.045.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.7345956679159285, 0.9764425686586728, 0.8824533524018308], "final_y": [0.2615604609959089, 0.16581640919287421, 0.16672479358836034]}, "mutation_prompt": null}
{"id": "3c7ff07d-6b31-4400-9635-bf93ee810b2e", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature)\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                levy_flight += (influence - current_solution)  # Added elite-guided component\n            \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introduce an elite-guided levy flight to enhance convergence towards high-quality solutions.", "configspace": "", "generation": 78, "fitness": 0.900199049964656, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.900 with standard deviation 0.076. And the mean value of best solutions found was 0.185 (0. is the best) with standard deviation 0.027.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.7941254809298612, 0.9671965770871239, 0.9392750918769828], "final_y": [0.2225780065902686, 0.1654834694864895, 0.16587251715150486]}, "mutation_prompt": null}
{"id": "9db94e85-a8cb-4172-ad80-5321a1f81007", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            self.momentum_factor = 0.9 * (1 - self.temperature)\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            if len(elite_solutions) > 3 and np.std([func(sol) for sol in elite_solutions[-3:]]) < 1e-6:  # Modified restart trigger\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            self.step_size *= (1 + 0.01 * self.temperature)\n\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature\n                current_solution = current_solution + mutation * 0.5  # Elitism in mutation\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance exploration by introducing elitism in mutation and refining restart trigger based on performance plateauing.", "configspace": "", "generation": 79, "fitness": 0.6818558565870999, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.682 with standard deviation 0.050. And the mean value of best solutions found was 0.288 (0. is the best) with standard deviation 0.025.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.6671277812893297, 0.7492447890638639, 0.6291949994081061], "final_y": [0.29692374974834934, 0.25462803995302097, 0.31372008272102236]}, "mutation_prompt": null}
{"id": "08ceb012-04e4-4a0c-9ef3-cb2c502d136f", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature with enhanced rate\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / (self.temperature * 0.5)  # Adjusted mutation scaling\n                current_solution += mutation * np.random.choice([-1, 1], size=self.dim)  # Added diversity\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance diversity by implementing a temperature-dependent elite replacement and dynamic mutation rate adjustment.", "configspace": "", "generation": 80, "fitness": 0.8691589643556327, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.869 with standard deviation 0.120. And the mean value of best solutions found was 0.201 (0. is the best) with standard deviation 0.050.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.9261354999498812, 0.9792538524641586, 0.702087540652858], "final_y": [0.16519278568714624, 0.16504146038314094, 0.2718014647385738]}, "mutation_prompt": null}
{"id": "2d47ce36-7f31-4696-af88-68adeea30048", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / (self.temperature ** 0.5)  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Refine mutation strategy by tuning the mutation's temperature dependence to enhance exploration without compromising convergence speed.", "configspace": "", "generation": 81, "fitness": 0.9554840067036291, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.955 with standard deviation 0.022. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.9262453605866038, 0.977543937384706, 0.9626627221395777], "final_y": [0.165217432468175, 0.16527678231430432, 0.16505053903796407]}, "mutation_prompt": null}
{"id": "0f802a58-d306-4dd9-8dce-5722fe7d66ed", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0) * (1.0 + 0.1 * self.temperature)  # Adaptive elite influence\n\n            current_solution = (current_solution + influence) / 2\n\n            self.momentum_factor = 0.9 * (1 - self.temperature)\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            if np.random.rand() < 0.02 + 0.05 * (1 - self.temperature):  # Variable restart threshold\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance exploration by incorporating an adaptive elite influence factor and a variable restart threshold.", "configspace": "", "generation": 82, "fitness": 0.9435473295105257, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.944 with standard deviation 0.011. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.9297471283288667, 0.9453571925595045, 0.9555376676432058], "final_y": [0.1653671050635186, 0.16643347031699174, 0.1654850814192964]}, "mutation_prompt": null}
{"id": "e443062d-1215-4f02-aa24-9a119cdaa814", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * (self.step_size / (self.temperature + 1e-10))  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance temperature-dependent mutation scaling for improved exploration.", "configspace": "", "generation": 83, "fitness": 0.9554840067036291, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.955 with standard deviation 0.022. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.9262453605866038, 0.977543937384706, 0.9626627221395777], "final_y": [0.165217432468175, 0.16527678231430432, 0.16505053903796407]}, "mutation_prompt": null}
{"id": "2842147b-96a7-453f-93a3-ae148fed5c3e", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Elite crossover\n            if len(elite_solutions) > 1:\n                elite_1, elite_2 = np.random.choice(elite_solutions, 2, replace=False)\n                crossover_solution = (elite_1 + elite_2) / 2\n                candidate_cost = func(crossover_solution)\n                if candidate_cost < current_cost:\n                    current_solution = crossover_solution\n                    current_cost = candidate_cost\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introduce elite solution crossover and fitness-proportional step size adjustment for improved exploitation and diversity.", "configspace": "", "generation": 84, "fitness": 0.9554840067036291, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.955 with standard deviation 0.022. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.9262453605866038, 0.977543937384706, 0.9626627221395777], "final_y": [0.165217432468175, 0.16527678231430432, 0.16505053903796407]}, "mutation_prompt": null}
{"id": "bfa990ae-a7e8-4ad2-9009-b5745430efe0", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                elite_scaling = np.random.uniform(0.8, 1.2)  # Added dynamic elite influence scaling\n                current_solution = (current_solution + elite_scaling * influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n                self.temperature = 1.0  # Added adaptive temperature reset\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance exploration by incorporating dynamic elite influence scaling and adaptive temperature reset for improved convergence.", "configspace": "", "generation": 85, "fitness": 0.4639660991541003, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.464 with standard deviation 0.025. And the mean value of best solutions found was 0.404 (0. is the best) with standard deviation 0.036.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.4653099390465115, 0.4942079658317867, 0.4323803925840026], "final_y": [0.4320617104056872, 0.3527317094829848, 0.42647449774385704]}, "mutation_prompt": null}
{"id": "5af2bd07-2e9e-4c67-beb3-a7dbe4e6de9c", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * (1.1 + 0.05 * self.temperature), self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Optimize step size update by scaling with temperature-dependent factor for improved convergence.", "configspace": "", "generation": 86, "fitness": 0.9554840067036291, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.955 with standard deviation 0.022. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.9262453605866038, 0.977543937384706, 0.9626627221395777], "final_y": [0.165217432468175, 0.16527678231430432, 0.16505053903796407]}, "mutation_prompt": null}
{"id": "2ab4f3d7-7e5b-4ea8-ad07-10502fbe0465", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.15 * self.temperature)  # Modified scaling factor\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence_factor = min(1, np.exp((best_cost - current_cost) / self.temperature))  # New influence factor\n                influence = np.mean(elite_solutions, axis=0) * influence_factor\n                current_solution = (current_solution + influence) / 2\n\n            self.momentum_factor = 0.9 * (1 - self.temperature)\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / (self.temperature + 0.1)  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance adaptive mutation and introduce dynamic elite influence based on convergence speed.", "configspace": "", "generation": 87, "fitness": 0.551307212755609, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.551 with standard deviation 0.024. And the mean value of best solutions found was 0.341 (0. is the best) with standard deviation 0.031.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.5410446825958503, 0.5289720896133014, 0.5839048660576756], "final_y": [0.31192109502757304, 0.384654008293686, 0.32622269491358713]}, "mutation_prompt": null}
{"id": "0b81f99a-993f-490e-8e36-53ed4cac13f0", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.9 - 0.02 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.15, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.85 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance exploration by refining adaptive mutation scaling and restart strategy for better convergence.", "configspace": "", "generation": 88, "fitness": 0.8775039146100342, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.878 with standard deviation 0.109. And the mean value of best solutions found was 0.200 (0. is the best) with standard deviation 0.048.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.7250307239074496, 0.9735826248027301, 0.9338983951199226], "final_y": [0.26771298134613386, 0.16584678053730706, 0.16627487498677607]}, "mutation_prompt": null}
{"id": "de7d941e-9d20-4143-987a-5e0a91ed1210", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = int(5 * (1 + self.temperature))  # Introduced dynamic population size adaptation\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            self.momentum_factor = 0.9 * (1 - self.temperature)\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introduce dynamic population size adaptation based on temperature for improved exploration.", "configspace": "", "generation": 89, "fitness": 0.9010880513036407, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.901 with standard deviation 0.065. And the mean value of best solutions found was 0.183 (0. is the best) with standard deviation 0.025.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.8088521273871584, 0.9503977329706116, 0.9440142935531524], "final_y": [0.21877234401226786, 0.16527883721664505, 0.16583667473391894]}, "mutation_prompt": null}
{"id": "3086abf8-7b1d-43f8-b976-bcb3e912a2b0", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = int(5 * (1 + self.temperature))  # Adjusted dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance exploration by adjusting population size dynamically based on temperature while refining elite influence.", "configspace": "", "generation": 90, "fitness": 0.9010880513036407, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.901 with standard deviation 0.065. And the mean value of best solutions found was 0.183 (0. is the best) with standard deviation 0.025.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.8088521273871584, 0.9503977329706116, 0.9440142935531524], "final_y": [0.21877234401226786, 0.16527883721664505, 0.16583667473391894]}, "mutation_prompt": null}
{"id": "fe3de5d7-dc65-444e-b91b-d7b5bd5e7892", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + 1.1 * influence) / 2  # Adjust influence weighting\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / (0.9 * self.temperature)  # Adjust mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introduce enhanced elite solution influence and adaptive mutation to improve exploratory capabilities.", "configspace": "", "generation": 91, "fitness": 0.7189294631255548, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.719 with standard deviation 0.021. And the mean value of best solutions found was 0.217 (0. is the best) with standard deviation 0.031.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.6992491002601787, 0.7098000869775813, 0.7477392021389044], "final_y": [0.21743696040024119, 0.2547819397837121, 0.17904695269774862]}, "mutation_prompt": null}
{"id": "85f08e11-6141-4038-a8c3-818b861c93f2", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost/2)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / (self.temperature + 0.1)  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance adaptive cooling and mutation strategies based on progress to improve convergence.", "configspace": "", "generation": 92, "fitness": 0.9474198610135534, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.947 with standard deviation 0.019. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.9298923162710128, 0.9740870858885217, 0.9382801808811256], "final_y": [0.16539360500660805, 0.16541414201189109, 0.16664617949097815]}, "mutation_prompt": null}
{"id": "28d32b78-952a-4a97-9174-669bb307e94f", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = max(5, int(self.budget / 200))  # Introduced adaptive population size based on budget\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Introduce adaptive population size scaling based on current performance to improve solution diversity.", "configspace": "", "generation": 93, "fitness": 0.9506007399783973, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.951 with standard deviation 0.015. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.9670896560077857, 0.9312711910494056, 0.9534413728780009], "final_y": [0.1652676143655446, 0.16635014319345398, 0.1667710252193021]}, "mutation_prompt": null}
{"id": "3c53aa53-9bbd-4454-9ee4-68fe3d240d30", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = int(5 + 5 * self.temperature)  # Modified dynamic population size adaptation\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance dynamic population size adaptation based on temperature to improve exploration balance.", "configspace": "", "generation": 94, "fitness": 0.9010880513036407, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.901 with standard deviation 0.065. And the mean value of best solutions found was 0.183 (0. is the best) with standard deviation 0.025.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.8088521273871584, 0.9503977329706116, 0.9440142935531524], "final_y": [0.21877234401226786, 0.16527883721664505, 0.16583667473391894]}, "mutation_prompt": null}
{"id": "3c89c6ab-85bd-4128-a6fa-33c8154e050e", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.025 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / (0.8 * self.temperature)  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Fine-tune the mutation scaling factor and restart probability to enhance convergence speed and accuracy.", "configspace": "", "generation": 95, "fitness": 0.9534660829262726, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.953 with standard deviation 0.021. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.9250615363971074, 0.9747698242546221, 0.960566888127088], "final_y": [0.1655096361552847, 0.16576291095424311, 0.16508704707271527]}, "mutation_prompt": null}
{"id": "bc531c53-9234-45d1-b568-6eaffd5c562a", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature  # Adjusted mutation scaling\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance elite selection by normalizing elite contribution and preventing stagnation.  ", "configspace": "", "generation": 96, "fitness": 0.9554840067036291, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.955 with standard deviation 0.022. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.9262453605866038, 0.977543937384706, 0.9626627221395777], "final_y": [0.165217432468175, 0.16527678231430432, 0.16505053903796407]}, "mutation_prompt": null}
{"id": "2be7d7d0-f7e7-4c6b-aecc-e56889add5f2", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  \n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            self.momentum_factor = 0.9 * (1 - self.temperature)  \n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Modified adaptive restart strategy\n            if np.random.rand() < 0.04 + 0.03 / (1 + self.temperature):  \n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Refined mutation scaling based on temperature\n            if np.random.rand() < 0.03 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / np.sqrt(self.temperature)  \n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance adaptive restart strategy and mutation scaling to improve convergence speed and solution quality.", "configspace": "", "generation": 97, "fitness": 0.9507269412282997, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.951 with standard deviation 0.020. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.9252486846311744, 0.9727518510400891, 0.9541802880136357], "final_y": [0.16551292385962968, 0.16591965169139378, 0.16515186112431146]}, "mutation_prompt": null}
{"id": "02a86fce-e222-4437-9c5f-ad6797d940a8", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = 5  # Introduced dynamic population size\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            # Modifying the levy flight with a temperature-dependent scaling factor\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature) \n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)  # Adjusted cooling rate\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.1, self.initial_step_size)\n            else:\n                self.step_size = max(self.step_size * 0.9 * (1 + self.temperature), self.min_step_size)\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence * self.temperature) / (1 + self.temperature)  # Changed line\n\n            # Enhancing momentum to depend on temperature\n            self.momentum_factor = 0.9 * (1 - self.temperature)  # Modified momentum factor\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            # Adaptive restart strategy\n            if np.random.rand() < 0.02 + 0.03 * (1 - self.temperature):  # Modified restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            # Adjust step size based on temperature for enhanced exploration\n            self.step_size *= (1 + 0.01 * self.temperature)\n            \n            # Dynamic mutation based on temperature\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / (self.temperature + 0.1)  # Changed line\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance adaptive mutation and elite influence with temperature-dependent scaling for improved convergence.", "configspace": "", "generation": 98, "fitness": 0.608905527173743, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.609 with standard deviation 0.094. And the mean value of best solutions found was 0.300 (0. is the best) with standard deviation 0.027.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.5286346320114049, 0.7409082580896842, 0.5571736914201397], "final_y": [0.31031801216081834, 0.2622193040063081, 0.3262226948936987]}, "mutation_prompt": null}
{"id": "808e6652-6e99-4561-acb3-8c2a8dec573a", "solution": "import numpy as np\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.initial_step_size = 0.1\n        self.step_size = self.initial_step_size\n        self.min_step_size = 1e-9\n        self.elite_fraction = 0.1\n        self.momentum_factor = 0.9\n\n    def _acceptance_probability(self, cost, new_cost, temperature):\n        if new_cost < cost:\n            return 1.0\n        return np.exp((cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population_size = max(5, int(self.temperature * 10))  # Adaptive population size based on temperature\n        population = [np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim) for _ in range(population_size)]\n        best_solution = min(population, key=func)\n        best_cost = func(best_solution)\n        current_solution = np.copy(best_solution)\n        current_cost = best_cost\n        elite_solutions = [best_solution]\n        prev_solution = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            levy_flight = np.random.standard_cauchy(self.dim) * (1 + 0.1 * self.temperature)\n            candidate_solution = current_solution + levy_flight * self.step_size\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n            candidate_cost = func(candidate_solution)\n\n            if self._acceptance_probability(current_cost, candidate_cost, self.temperature) > np.random.rand():\n                prev_solution = current_solution\n                current_solution = candidate_solution\n                current_cost = candidate_cost\n\n                if candidate_cost < best_cost:\n                    best_solution = candidate_solution\n                    best_cost = candidate_cost\n                    elite_solutions.append(best_solution)\n                    elite_solutions = sorted(elite_solutions, key=func)[:int(self.elite_fraction * len(elite_solutions) + 1)]\n\n            self.temperature = max(self.temperature * (0.95 - 0.01 * (best_cost - current_cost)), 0.01)\n\n            if candidate_cost < current_cost:\n                self.step_size = min(self.step_size * 1.2, self.initial_step_size)  # Enhanced step size increase\n            else:\n                self.step_size = max(self.step_size * 0.8 * (1 + self.temperature), self.min_step_size)  # Adjusted reduction\n\n            if elite_solutions:\n                influence = np.mean(elite_solutions, axis=0)\n                current_solution = (current_solution + influence) / 2\n\n            self.momentum_factor = 0.9 * (1 - self.temperature)\n            current_solution += self.momentum_factor * (current_solution - prev_solution) * self.temperature\n\n            if np.random.rand() < 0.02 + 0.05 * (1 - self.temperature):  # Increased restart probability\n                current_solution = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n                current_cost = func(current_solution)\n\n            self.step_size *= (1 + 0.02 * self.temperature)  # Enhanced exploration with larger scaling\n\n            if np.random.rand() < 0.05 * self.temperature:\n                mutation = np.random.randn(self.dim) * self.step_size / self.temperature\n\n        return best_solution", "name": "AdaptiveSimulatedAnnealing", "description": "Enhance exploration via adaptive population size, temperature-based restart, and dynamic step size scaling for improved convergence.", "configspace": "", "generation": 99, "fitness": 0.8729330668924877, "feedback": "The algorithm AdaptiveSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.873 with standard deviation 0.070. And the mean value of best solutions found was 0.199 (0. is the best) with standard deviation 0.024.", "error": "", "parent_id": "f435fc38-f348-4ee0-a546-69c94831d19d", "metadata": {"aucs": [0.8169596591020793, 0.9716356443986583, 0.8302038971767256], "final_y": [0.2163536056936861, 0.1657678425660405, 0.2152483923648867]}, "mutation_prompt": null}
