{"id": "5ec7c40a-9f73-420f-873f-080d5392e518", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))  # Adaptive population size based on dimension\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n        \n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "A novel probabilistic swarm optimization algorithm that adaptively balances exploration and exploitation through dynamic self-organizing behavior and local search refinement.", "configspace": "", "generation": 0, "fitness": 0.8880153553248924, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.888 with standard deviation 0.029. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8578590136502657, 0.8794893753846997, 0.9266976769397116], "final_y": [0.13549357241381543, 0.13013028950722683, 0.11620049349785744]}, "mutation_prompt": null}
{"id": "59111d9d-edca-4538-8a94-ad30aa727ea2", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))  # Adaptive population size based on dimension\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9  # Changed to a higher initial value for better exploration\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n        \n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity\n        self.inertia_weight *= 0.99  # Adaptive inertia weight decrease for better exploitation\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "An enhanced probabilistic swarm optimization algorithm incorporating adaptive inertia weights and a dynamic population size for improved balance between exploration and exploitation.", "configspace": "", "generation": 1, "fitness": 0.9001441828657638, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.900 with standard deviation 0.016. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "5ec7c40a-9f73-420f-873f-080d5392e518", "metadata": {"aucs": [0.8798130547098177, 0.9020736602176876, 0.9185458336697858], "final_y": [0.1264498893422341, 0.12039839089323501, 0.11685737934952611]}, "mutation_prompt": null}
{"id": "b2f791d9-eca8-4013-8dc8-61f2d831c735", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n        \n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        self.cognitive_weight = 1.5 * (1 - r1.mean())  # Adaptive cognitive factor\n        self.social_weight = 1.5 * (1 - r2.mean())  # Adaptive social factor\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity\n        reset_threshold = 0.1  # Threshold probability for velocity reset\n        reset_mask = np.random.rand(self.population_size, self.dim) < reset_threshold\n        self.velocity[reset_mask] = 0.0  # Stochastic velocity reset\n        self.inertia_weight *= 0.99\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "An enhanced probabilistic swarm optimization algorithm with adaptive learning factors and a stochastic velocity reset strategy for improved convergence.", "configspace": "", "generation": 2, "fitness": 0.8555425726563494, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.856 with standard deviation 0.039. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "59111d9d-edca-4538-8a94-ad30aa727ea2", "metadata": {"aucs": [0.8252185994638676, 0.830792645975211, 0.9106164725299695], "final_y": [0.14662246832264503, 0.1455647733941855, 0.11840020389484707]}, "mutation_prompt": null}
{"id": "cf99eebe-c472-4af7-b824-b495db538d59", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity\n        self.position += np.random.normal(0, 0.01, self.position.shape)  # Gaussian perturbation for local search\n        self.inertia_weight *= 0.99\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "A probabilistic swarm optimization algorithm using adaptive population size and Gaussian perturbation to enhance local search and balance exploration-exploitation trade-offs.", "configspace": "", "generation": 3, "fitness": 0.9028071890828896, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.903 with standard deviation 0.007. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "59111d9d-edca-4538-8a94-ad30aa727ea2", "metadata": {"aucs": [0.9083961433192014, 0.8924047278487365, 0.907620696080731], "final_y": [0.11339381451476072, 0.12176557829081103, 0.1174195490227139]}, "mutation_prompt": null}
{"id": "1efa1637-3fcb-49bd-8b73-c78e0eeb498f", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        self.cognitive_weight = 2 - (2 * (self.best_score / np.sum(self.best_scores)))  # Dynamic adjustment\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity\n        self.position += np.random.normal(0, 0.01, self.position.shape)  # Gaussian perturbation for local search\n        self.inertia_weight *= 0.99\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "A probabilistic swarm optimization algorithm using adaptive population size and Gaussian perturbation, now with a dynamic cognitive weight to balance personal and social learning for improved exploration-exploitation.", "configspace": "", "generation": 4, "fitness": 0.8996444199673727, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.900 with standard deviation 0.017. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "cf99eebe-c472-4af7-b824-b495db538d59", "metadata": {"aucs": [0.9024100109619224, 0.8773571470417142, 0.9191661018984816], "final_y": [0.11712262028263054, 0.12869035505436122, 0.11618429950372311]}, "mutation_prompt": null}
{"id": "29f38a77-997e-4a81-befb-4e462a44ac6c", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity\n        perturbation_amplitude = 0.01 * (1 - evaluations / self.budget)  # Adaptive perturbation\n        self.position += np.random.normal(0, perturbation_amplitude, self.position.shape)  # Gaussian perturbation\n        self.inertia_weight *= 0.99\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "A probabilistic swarm optimization algorithm enhancing local search with adaptive Gaussian perturbation amplitude for improved exploration-exploitation balance.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'evaluations' is not defined\").", "error": "NameError(\"name 'evaluations' is not defined\")", "parent_id": "cf99eebe-c472-4af7-b824-b495db538d59", "metadata": {}, "mutation_prompt": null}
{"id": "3d76ec3e-d24b-4252-b922-6b03041bf2a5", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity\n        mutation_rate = 0.01 + 0.19 * (1 - self.inertia_weight)  # Adaptive mutation based on inertia\n        self.position += np.random.normal(0, mutation_rate, self.position.shape)\n        self.inertia_weight *= 0.99\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "An enhanced probabilistic swarm optimization algorithm implementing adaptive mutation rate to improve exploration in early stages.", "configspace": "", "generation": 6, "fitness": 0.9003109816955872, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.900 with standard deviation 0.014. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "cf99eebe-c472-4af7-b824-b495db538d59", "metadata": {"aucs": [0.9008854379849554, 0.8825717057483051, 0.9174758013535013], "final_y": [0.11697425563059094, 0.12303442807957832, 0.11183214495439409]}, "mutation_prompt": null}
{"id": "cca6ec03-3583-4691-8f78-23e785efe56c", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity\n        self.position += np.random.normal(0, 0.01, self.position.shape)  # Gaussian perturbation for local search\n        self.inertia_weight *= 0.99\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self.cognitive_weight = 1.5 - (1.0 * evaluations / self.budget)  # Dynamic cognitive weight\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Enhance exploration by introducing a dynamic adaptation of cognitive weight based on iteration progress.", "configspace": "", "generation": 7, "fitness": 0.879868458797883, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.880 with standard deviation 0.005. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "cf99eebe-c472-4af7-b824-b495db538d59", "metadata": {"aucs": [0.8804910894451342, 0.8851363012581657, 0.8739779856903493], "final_y": [0.12328231198837103, 0.12611811191869737, 0.12970709745213205]}, "mutation_prompt": null}
{"id": "79ef240e-673c-469d-b5cd-db950e36b0b4", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        adaptive_cognitive = self.cognitive_weight * (0.5 + np.random.rand())  # Adaptive cognitive weight\n        adaptive_social = self.social_weight * (0.5 + np.random.rand())  # Adaptive social weight\n        cognitive_term = adaptive_cognitive * r1 * (self.best_position - self.position)\n        social_term = adaptive_social * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity\n        self.position += np.random.normal(0, 0.01, self.position.shape)  # Gaussian perturbation for local search\n        self.inertia_weight *= 0.99\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "A probabilistic swarm optimization algorithm enhanced by introducing adaptive social and cognitive weights to dynamically adjust exploration and exploitation.", "configspace": "", "generation": 8, "fitness": 0.8413148268832732, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.841 with standard deviation 0.036. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "cf99eebe-c472-4af7-b824-b495db538d59", "metadata": {"aucs": [0.8041919924627506, 0.8299955354577878, 0.8897569527292811], "final_y": [0.1549593712161499, 0.14521127727390304, 0.1252795823786973]}, "mutation_prompt": null}
{"id": "c0d2b5e6-8b73-4c31-9ae5-aec55ceb9066", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity\n        self.position += np.random.normal(0, 0.01, self.position.shape)  # Gaussian perturbation for local search\n        self.inertia_weight = max(0.4, self.inertia_weight * 0.99)  # Dynamic inertia adaptation\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Enhanced Probabilistic Swarm Optimizer using dynamic inertia weight adaptation to improve convergence rate and solution quality.", "configspace": "", "generation": 9, "fitness": 0.9029731897281756, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.903 with standard deviation 0.007. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "cf99eebe-c472-4af7-b824-b495db538d59", "metadata": {"aucs": [0.9085566187639676, 0.892556207675558, 0.9078067427450013], "final_y": [0.11323938741701411, 0.12159537807260568, 0.11721554189302252]}, "mutation_prompt": null}
{"id": "c366117a-b543-4008-bb52-8f1c8990b7a2", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.velocity = np.clip(self.velocity, -0.1, 0.1)  # Velocity clamping for stability\n        self.position += self.velocity\n        self.position += np.random.normal(0, 0.01, self.position.shape)  # Gaussian perturbation for local search\n        self.inertia_weight = max(0.4, self.inertia_weight * 0.99)  # Dynamic inertia adaptation\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Enhanced Probabilistic Swarm Optimizer with additional velocity constraint for improved stability and convergence.", "configspace": "", "generation": 10, "fitness": 0.7243481859763059, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.724 with standard deviation 0.039. And the mean value of best solutions found was 0.188 (0. is the best) with standard deviation 0.017.", "error": "", "parent_id": "c0d2b5e6-8b73-4c31-9ae5-aec55ceb9066", "metadata": {"aucs": [0.6769359021638452, 0.7719325366670768, 0.7241761190979956], "final_y": [0.20908695342569428, 0.16784596080444714, 0.18676830967677482]}, "mutation_prompt": null}
{"id": "1df3acf8-3af2-4f15-b279-d6a6eb337a8e", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity\n        self.position += np.random.normal(0, 0.01, self.position.shape)  # Gaussian perturbation for local search\n        self.inertia_weight = max(0.4, self.inertia_weight * 0.99)  # Dynamic inertia adaptation\n        self.cognitive_weight = max(0.5, self.cognitive_weight * 0.995)  # New adaptive cognitive weight\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Enhanced Probabilistic Swarm Optimizer with adaptive cognitive and social weights to improve convergence and exploration capabilities.", "configspace": "", "generation": 11, "fitness": 0.8752636069423354, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.875 with standard deviation 0.029. And the mean value of best solutions found was 0.128 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "c0d2b5e6-8b73-4c31-9ae5-aec55ceb9066", "metadata": {"aucs": [0.8884679990666097, 0.9023738988800358, 0.8349489228803609], "final_y": [0.11997221585820006, 0.1209435704065317, 0.14413031571757906]}, "mutation_prompt": null}
{"id": "e43700a7-cebc-4cd3-8c82-ff0f1f4de5b2", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity\n        self.position += np.random.normal(0, 0.02, self.position.shape)  # Enhanced Gaussian perturbation for local search\n        self.inertia_weight = max(0.4, self.inertia_weight * 0.99)  # Dynamic inertia adaptation\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Probabilistic Swarm Optimizer with enhanced Gaussian perturbation scale for improved local search.", "configspace": "", "generation": 12, "fitness": 0.90251690144826, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.903 with standard deviation 0.008. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "c0d2b5e6-8b73-4c31-9ae5-aec55ceb9066", "metadata": {"aucs": [0.8992874880927338, 0.8948182766780068, 0.9134449395740396], "final_y": [0.11786523261810333, 0.12019580255454954, 0.11440172409099747]}, "mutation_prompt": null}
{"id": "60ac0dcf-3cd5-4b2f-bbce-a2db81790d83", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity\n        self.position += np.random.normal(0, 0.01, self.position.shape)  # Gaussian perturbation for local search\n        self.inertia_weight = max(0.4, self.inertia_weight * 0.99)  # Dynamic inertia adaptation\n        self.cognitive_weight = max(1.2, self.cognitive_weight * 0.99)  # Adaptive cognitive weight\n        self.social_weight = min(1.8, self.social_weight * 1.01)  # Adaptive social weight\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce adaptive cognitive and social weights based on convergence trends to enhance exploration-exploitation balance.", "configspace": "", "generation": 13, "fitness": 0.8757754362978991, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.876 with standard deviation 0.027. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "c0d2b5e6-8b73-4c31-9ae5-aec55ceb9066", "metadata": {"aucs": [0.8384303316283392, 0.8860035425327051, 0.9028924347326529], "final_y": [0.1404644104549856, 0.12605252501825104, 0.11924417809072618]}, "mutation_prompt": null}
{"id": "861e45ee-cb23-451e-b029-d7a2dc2fd729", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity\n        self.position += np.random.normal(0, 0.01, self.position.shape)  # Gaussian perturbation for local search\n        self.inertia_weight = max(0.4, self.inertia_weight * 0.99)  # Dynamic inertia adaptation\n        self.social_weight = 1.5 + 0.5 * np.sin(evaluations / self.budget * np.pi)  # Adaptive social weight\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Probabilistic Swarm Optimizer with adaptive social-cognitive balance to enhance exploration and exploitation balance.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'evaluations' is not defined\").", "error": "NameError(\"name 'evaluations' is not defined\")", "parent_id": "c0d2b5e6-8b73-4c31-9ae5-aec55ceb9066", "metadata": {}, "mutation_prompt": null}
{"id": "787b75f3-5e67-48e1-96a0-172862b32e65", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1  # New: Momentum factor\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)  # Modified: Added momentum factor\n        self.position += np.random.normal(0, 0.01 * (1 - self.inertia_weight), self.position.shape)  # Modified: Adaptive perturbation scaling\n        self.inertia_weight = max(0.4, self.inertia_weight * 0.99)  # Dynamic inertia adaptation\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduced a momentum factor and adaptive perturbation scaling to refine the balance between exploration and exploitation in the Probabilistic Swarm Optimizer.", "configspace": "", "generation": 15, "fitness": 0.9039410421907838, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.904 with standard deviation 0.006. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "c0d2b5e6-8b73-4c31-9ae5-aec55ceb9066", "metadata": {"aucs": [0.9128253407534825, 0.8979140305088384, 0.9010837553100303], "final_y": [0.11475100318728759, 0.11936488167805037, 0.11731623857632267]}, "mutation_prompt": null}
{"id": "f9b7aa50-3d81-42e0-b766-593a0780b9f9", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1  # New: Momentum factor\n        self.adaptive_learning_rate = 0.5  # New: Adaptive learning rate\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)  # Modified: Added momentum factor\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)  # Modified: Adaptive learning rate\n        self.inertia_weight = max(0.4, self.inertia_weight * 0.99)  # Dynamic inertia adaptation\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduced an adaptive learning rate to enhance convergence speed in the Probabilistic Swarm Optimizer.", "configspace": "", "generation": 16, "fitness": 0.9068651804748553, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.907 with standard deviation 0.007. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "787b75f3-5e67-48e1-96a0-172862b32e65", "metadata": {"aucs": [0.915985206636943, 0.8996514175360878, 0.9049589172515353], "final_y": [0.11235502032976474, 0.11967681408207975, 0.11712915681409442]}, "mutation_prompt": null}
{"id": "c4a1caa8-8eed-46a9-9e7d-0376b4b7d0a3", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1  # New: Momentum factor\n        self.adaptive_learning_rate = 0.5  # New: Adaptive learning rate\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)  # Modified: Added momentum factor\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)  # Modified: Adaptive learning rate\n        self.inertia_weight = max(0.4, self.inertia_weight * 0.99)  # Dynamic inertia adaptation\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)  # Dynamically adjust momentum factor\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Enhanced Probabilistic Swarm Optimizer by dynamically adjusting the momentum factor for improved exploration-exploitation balance.", "configspace": "", "generation": 17, "fitness": 0.9070995200217279, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.907 with standard deviation 0.007. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "f9b7aa50-3d81-42e0-b766-593a0780b9f9", "metadata": {"aucs": [0.9165524824114806, 0.8991698121142205, 0.9055762655394821], "final_y": [0.11235799123769452, 0.11967365942374619, 0.11712639641952993]}, "mutation_prompt": null}
{"id": "f540efd4-9148-40af-a35b-a8e92a41f6a7", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1  # New: Momentum factor\n        self.adaptive_learning_rate = 0.5  # New: Adaptive learning rate\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)  # Modified: Added momentum factor\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)  # Modified: Adaptive learning rate\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 + 0.02 * np.random.rand()))  # Dynamic inertia adaptation\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)  # Dynamically adjust momentum factor\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduced randomness in the inertia weight decay to enhance global exploration and local exploitation balance.", "configspace": "", "generation": 18, "fitness": 0.8374274058618144, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.837 with standard deviation 0.015. And the mean value of best solutions found was 0.140 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "c4a1caa8-8eed-46a9-9e7d-0376b4b7d0a3", "metadata": {"aucs": [0.849122930365732, 0.8161722234466046, 0.8469870637731067], "final_y": [0.13549951303282748, 0.14837517389755517, 0.13640711611999023]}, "mutation_prompt": null}
{"id": "7b0ba577-6711-4c56-ab25-667b9fabe6b1", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = min(3, self.population_size)  # New: Neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        local_best_position = self._get_local_best_positions()  # New: Local best position\n        neighborhood_term = self.social_weight * r2 * (local_best_position - self.position)  # New: Neighborhood term\n        self.velocity = (self.inertia_weight * self.velocity + cognitive_term + social_term + 0.5 * neighborhood_term)  # Modified\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _get_local_best_positions(self):  # New method\n        local_best_positions = np.zeros_like(self.position)\n        for i in range(self.population_size):\n            neighborhood_indices = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n            local_best = min([(self.best_scores[j], self.best_position[j]) for j in neighborhood_indices], key=lambda x: x[0])[1]\n            local_best_positions[i] = local_best\n        return local_best_positions\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Improved Adaptive Probabilistic Swarm Optimizer by incorporating dynamic neighborhood influence and elite selection to enhance solution quality and convergence speed.", "configspace": "", "generation": 19, "fitness": 0.8823090504466887, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.882 with standard deviation 0.012. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "c4a1caa8-8eed-46a9-9e7d-0376b4b7d0a3", "metadata": {"aucs": [0.8676895585373774, 0.881845070908011, 0.8973925218946776], "final_y": [0.12265030209525984, 0.12055431659886029, 0.11569136114749334]}, "mutation_prompt": null}
{"id": "8ec309e0-565a-47d0-b6af-5deff79f6bf9", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1  # New: Momentum factor\n        self.adaptive_learning_rate = 0.5  # New: Adaptive learning rate\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.velocity += np.random.normal(0, 0.01, self.velocity.shape)  # Added: Stochastic velocity perturbation\n        self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Enhanced Swarm with Stochastic Velocity Perturbation for Improved Convergence in Noisy Environments.", "configspace": "", "generation": 20, "fitness": 0.896290810044953, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.896 with standard deviation 0.037. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "c4a1caa8-8eed-46a9-9e7d-0376b4b7d0a3", "metadata": {"aucs": [0.8469987531290133, 0.9040048660793447, 0.9378688109265013], "final_y": [0.12926006962905567, 0.1162234120420772, 0.11032349578719347]}, "mutation_prompt": null}
{"id": "da319396-bebc-4d45-9e14-956da00c119e", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1  # New: Momentum factor\n        self.adaptive_learning_rate = 0.5  # New: Adaptive learning rate\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)  # Modified: Added momentum factor\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)  # Modified: Adaptive learning rate\n        self.inertia_weight = max(0.4, self.inertia_weight * 0.99)  # Dynamic inertia adaptation\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)  # Dynamically adjust momentum factor\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            # Newly added line for dynamic weights adjustment\n            self.cognitive_weight, self.social_weight = 1.5 - (0.1 * evaluations / self.budget), 1.5 + (0.1 * evaluations / self.budget)\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a dynamic adaptation for cognitive and social weights based on the iteration count to enhance convergence efficiency.", "configspace": "", "generation": 21, "fitness": 0.9119912262934898, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.912 with standard deviation 0.009. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "c4a1caa8-8eed-46a9-9e7d-0376b4b7d0a3", "metadata": {"aucs": [0.9160395437462805, 0.9000640277768861, 0.9198701073573031], "final_y": [0.10968863200394208, 0.11967438893487192, 0.11357230663932072]}, "mutation_prompt": null}
{"id": "55c6866a-6d08-4131-b7b2-1402b89ad7ec", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1  # New: Momentum factor\n        self.adaptive_learning_rate = 0.5  # New: Adaptive learning rate\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)  # Modified: Added momentum factor\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)  # Modified: Adaptive learning rate\n        self.inertia_weight = max(0.4, self.inertia_weight * 0.99)  # Dynamic inertia adaptation\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)  # Dynamically adjust momentum factor\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            self.cognitive_weight, self.social_weight = 1.5 - (0.1 * evaluations / self.budget), 1.5 + (0.1 * evaluations / self.budget)\n        self.inertia_weight *= np.exp(-0.005 * (self.budget - evaluations))  # New line: temperature-based inertia adjustment\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a temperature-based mechanism to balance exploration and exploitation by adjusting inertia weight dynamically.", "configspace": "", "generation": 22, "fitness": 0.9119912262934898, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.912 with standard deviation 0.009. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "da319396-bebc-4d45-9e14-956da00c119e", "metadata": {"aucs": [0.9160395437462805, 0.9000640277768861, 0.9198701073573031], "final_y": [0.10968863200394208, 0.11967438893487192, 0.11357230663932072]}, "mutation_prompt": null}
{"id": "164f78a4-085a-4b1f-9847-a6a6a3bc29eb", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1  # New: Momentum factor\n        self.adaptive_learning_rate = 0.5  # New: Adaptive learning rate\n        self.mutation_factor = 0.05  # New: Mutation factor\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)  # Modified: Added momentum factor\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)  # Modified: Adaptive learning rate\n        self.inertia_weight = max(0.4, self.inertia_weight * 0.99)  # Dynamic inertia adaptation\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)  # Dynamically adjust momentum factor\n        self.position += np.random.normal(0, self.mutation_factor, self.position.shape)  # New: Apply mutation factor\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            # Newly added line for dynamic weights adjustment\n            self.cognitive_weight, self.social_weight = 1.5 - (0.1 * evaluations / self.budget), 1.5 + (0.1 * evaluations / self.budget)\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a mutation factor to enhance exploration capabilities by adding slight randomness to particle positions.", "configspace": "", "generation": 23, "fitness": 0.8890993762094784, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.889 with standard deviation 0.041. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "da319396-bebc-4d45-9e14-956da00c119e", "metadata": {"aucs": [0.8371000751290221, 0.8927144804783669, 0.9374835730210461], "final_y": [0.13762288979115855, 0.11937110291866704, 0.11154154081201184]}, "mutation_prompt": null}
{"id": "e4415519-922d-43a2-8cb4-747712854faa", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.uniform(-1, 1, self.velocity.shape) * 0.1  # New: Time-varying random perturbation\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            self.cognitive_weight, self.social_weight = 1.5 - (0.1 * evaluations / self.budget), 1.5 + (0.1 * evaluations / self.budget)\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a time-varying random perturbation in velocity update for improved exploration.", "configspace": "", "generation": 24, "fitness": 0.8598512450900228, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.860 with standard deviation 0.073. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.025.", "error": "", "parent_id": "da319396-bebc-4d45-9e14-956da00c119e", "metadata": {"aucs": [0.7600352994954542, 0.8893613911318888, 0.930157044642725], "final_y": [0.1701787192322295, 0.1213485203039345, 0.11356858517210777]}, "mutation_prompt": null}
{"id": "550143b9-1c0e-4283-958b-33519816b34b", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1  # New: Momentum factor\n        self.adaptive_learning_rate = 0.5  # New: Adaptive learning rate\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)  # Modified: Added momentum factor\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)  # Modified: Adaptive learning rate\n        self.inertia_weight = max(0.4, self.inertia_weight * 0.99)  # Dynamic inertia adaptation\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)  # Dynamically adjust momentum factor\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)  # Adjusted weight change using temp_factor\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a temperature-based annealing factor to dynamically adjust both cognitive and social weights and improve solution exploration.", "configspace": "", "generation": 25, "fitness": 0.9149557692716219, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.915 with standard deviation 0.008. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "da319396-bebc-4d45-9e14-956da00c119e", "metadata": {"aucs": [0.9091818799286477, 0.9090019400169785, 0.9266834878692395], "final_y": [0.11274982305460612, 0.11622178238362546, 0.11178492932010164]}, "mutation_prompt": null}
{"id": "bc2be867-bdfa-4c9b-baac-80d6504f9ef5", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1  # New: Momentum factor\n        self.adaptive_learning_rate = 0.5  # New: Adaptive learning rate\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)  # Modified: Added momentum factor\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)  # Modified: Adaptive learning rate\n        self.inertia_weight = max(0.4, self.inertia_weight * 0.99)  # Dynamic inertia adaptation\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)  # Dynamically adjust momentum factor\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            if np.random.rand() < 0.01:  # Random reinitialization to escape local optima\n                self.position = np.random.uniform(func.bounds.lb, func.bounds.ub, self.position.shape)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)  # Adjusted weight change using temp_factor\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Incorporate a random reinitialization step for particles to escape local optima.", "configspace": "", "generation": 26, "fitness": 0.8940349297313693, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.894 with standard deviation 0.014. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "550143b9-1c0e-4283-958b-33519816b34b", "metadata": {"aucs": [0.8777563626854503, 0.9108204436047627, 0.8935279829038953], "final_y": [0.11984196857509677, 0.11698351382371819, 0.1150835973618608]}, "mutation_prompt": null}
{"id": "31599934-a139-4e69-a3fb-4a54642dd730", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce dynamic neighborhood topology and adaptive inertia decay to enhance exploration and exploitation balance.", "configspace": "", "generation": 27, "fitness": 0.9209105114409004, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.921 with standard deviation 0.007. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "550143b9-1c0e-4283-958b-33519816b34b", "metadata": {"aucs": [0.927375260296191, 0.9117272507459171, 0.9236290232805928], "final_y": [0.11275428590603509, 0.11621916458074288, 0.11357148549928531]}, "mutation_prompt": null}
{"id": "9b2f5890-37b6-4f85-9266-3af49227b4f5", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 ** (1 + 0.1 * (self.budget/1000))))  # Nonlinear inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Modify velocity update by incorporating a nonlinear inertia weight schedule to balance exploration and exploitation.", "configspace": "", "generation": 28, "fitness": 0.9115858806838787, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.912 with standard deviation 0.013. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "31599934-a139-4e69-a3fb-4a54642dd730", "metadata": {"aucs": [0.9028986688266166, 0.9019394689386254, 0.9299195042863938], "final_y": [0.11274822998897571, 0.11622112398177487, 0.11179869823237687]}, "mutation_prompt": null}
{"id": "39a90f52-244a-4411-8a20-83198489ea8c", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position) * np.sin(np.pi * self.inertia_weight)  # Modified\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Enhance the social learning mechanism by introducing a temporary scaling factor to the social term for improved convergence.", "configspace": "", "generation": 29, "fitness": 0.9003182681667852, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.900 with standard deviation 0.023. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "31599934-a139-4e69-a3fb-4a54642dd730", "metadata": {"aucs": [0.8689371433165345, 0.9088763404295258, 0.9231413207542952], "final_y": [0.13048564097747561, 0.11622738858045967, 0.11154396919286691]}, "mutation_prompt": null}
{"id": "f911b537-a702-4905-b088-538f305fb079", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor) + np.random.uniform(-0.05, 0.05)\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Implement a randomized adjustment to social weight for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": 0.9052064512619237, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.905 with standard deviation 0.013. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "31599934-a139-4e69-a3fb-4a54642dd730", "metadata": {"aucs": [0.8988167444675588, 0.8940500895938065, 0.9227525197244059], "final_y": [0.12311207193219353, 0.11622195688419545, 0.11499070057455585]}, "mutation_prompt": null}
{"id": "ed858111-1730-469d-81fc-506069a52a4d", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))\n        self.memory_factor = 0.1  # New memory factor\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n        self.previous_position = self.position.copy()  # Track previous positions\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.position = np.clip(self.position, self.previous_position - self.memory_factor, self.previous_position + self.memory_factor)  # Stochastic boundary handling\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n        self.previous_position = self.position.copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce an adaptive memory mechanism and stochastic boundary handling to improve convergence and robustness.", "configspace": "", "generation": 31, "fitness": 0.7387125716277257, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.739 with standard deviation 0.039. And the mean value of best solutions found was 0.176 (0. is the best) with standard deviation 0.017.", "error": "", "parent_id": "31599934-a139-4e69-a3fb-4a54642dd730", "metadata": {"aucs": [0.6873230427014307, 0.7829465890418598, 0.7458680831398865], "final_y": [0.199593810860064, 0.15911949285837057, 0.16967017625631886]}, "mutation_prompt": null}
{"id": "27d970a4-3dac-4f34-9e51-56dc38f921d2", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor * 0.5)  # Time-varying social weight multiplier\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a time-varying social weight multiplier to dynamically adjust convergence pressure.", "configspace": "", "generation": 32, "fitness": 0.9122968395792346, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.912 with standard deviation 0.015. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "31599934-a139-4e69-a3fb-4a54642dd730", "metadata": {"aucs": [0.9337189952285665, 0.9043008629581922, 0.8988706605509452], "final_y": [0.11061133065624107, 0.12022209810689732, 0.12252605077589163]}, "mutation_prompt": null}
{"id": "889be46a-5740-4e0f-aebc-16e4b1dd0078", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Enhance the probabilistic neighborhood influence by introducing random perturbations in the velocity update for better exploration.", "configspace": "", "generation": 33, "fitness": 0.9261259326631158, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "31599934-a139-4e69-a3fb-4a54642dd730", "metadata": {"aucs": [0.9259202386658246, 0.9065887550703493, 0.9458688042531733], "final_y": [0.11275438896716905, 0.12006067810232712, 0.11002591364401881]}, "mutation_prompt": null}
{"id": "69af1cb4-ec60-4d18-9e73-bf04ff2b2112", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n        self.max_velocity = 0.1  # New velocity clamping parameter\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.velocity = np.clip(self.velocity, -self.max_velocity, self.max_velocity)  # Apply velocity clamping\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a velocity clamping mechanism to limit excessive velocity, thus improving solution stability and convergence.", "configspace": "", "generation": 34, "fitness": 0.7519751752830434, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.752 with standard deviation 0.040. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "889be46a-5740-4e0f-aebc-16e4b1dd0078", "metadata": {"aucs": [0.7042970653228255, 0.8018893167861358, 0.7497391437401686], "final_y": [0.18366779520788556, 0.15114695963445035, 0.16008863710147836]}, "mutation_prompt": null}
{"id": "7388c4ce-2ede-498d-ade7-045041a0f3cd", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.2, self.velocity.shape)  # Increased perturbation\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Improve exploration by augmenting random perturbation in velocity updates for better solution discovery.", "configspace": "", "generation": 35, "fitness": 0.8856999926719382, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.886 with standard deviation 0.059. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": "889be46a-5740-4e0f-aebc-16e4b1dd0078", "metadata": {"aucs": [0.805294408891473, 0.9074509613668001, 0.9443546077575413], "final_y": [0.15201342959594177, 0.12006951037360492, 0.11004648381693982]}, "mutation_prompt": null}
{"id": "3bf75826-7df3-42b5-9e2a-e7b121f43e5a", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            # Change: Introduce a dynamic component that reacts to improvements\n            recent_improvement_factor = 1.0 + (0.1 * evaluations / self.budget) * (self.best_score / np.mean(self.best_scores))\n            self.cognitive_weight = (1.5 - (0.1 * evaluations / self.budget) * temp_factor) * recent_improvement_factor\n            self.social_weight = (1.5 + max_weight_change * (1 - temp_factor)) * recent_improvement_factor\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce an adaptive cognitive and social weight mechanism based on recent improvements in positions to enhance convergence.", "configspace": "", "generation": 36, "fitness": 0.9246667668375816, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.925 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "889be46a-5740-4e0f-aebc-16e4b1dd0078", "metadata": {"aucs": [0.922046873392273, 0.9069680921617237, 0.9449853349587483], "final_y": [0.11275368187240864, 0.12006359428945013, 0.11000873335985661]}, "mutation_prompt": null}
{"id": "92c33d1f-e10e-4b93-96f3-7aa8d2c930bc", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n        self.neighborhood_size = max(2, int(0.1 * self.population_size * (1 + 0.5 * np.sin(evaluations / self.budget * 2 * np.pi))))  # Dynamic adjustment\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Incorporated a dynamic neighborhood size adjustment to enhance local exploration and convergence in the swarm.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'evaluations' is not defined\").", "error": "NameError(\"name 'evaluations' is not defined\")", "parent_id": "889be46a-5740-4e0f-aebc-16e4b1dd0078", "metadata": {}, "mutation_prompt": null}
{"id": "f435bac2-3f07-444f-9c5e-b3a22d112be7", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            # Adaptive neighborhood influence scaling\n            self.neighborhood_size = max(2, int(0.1 * self.population_size * (1 + 0.5 * (1 - temp_factor))))\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce adaptive neighborhood influence scaling to enhance exploration and exploitation balance.", "configspace": "", "generation": 38, "fitness": 0.9261259326631158, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "889be46a-5740-4e0f-aebc-16e4b1dd0078", "metadata": {"aucs": [0.9259202386658246, 0.9065887550703493, 0.9458688042531733], "final_y": [0.11275438896716905, 0.12006067810232712, 0.11002591364401881]}, "mutation_prompt": null}
{"id": "5acc38f8-1b68-47b2-9a4d-4f01eb407726", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        neighborhood_best = self.best_position[np.argmin(self.best_scores)]\n        social_term = self.social_weight * r2 * (neighborhood_best - self.position)  # Changed line\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce an adaptive social weight influenced by the neighborhood's best position to enhance local exploration.", "configspace": "", "generation": 39, "fitness": 0.9261259326631158, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "889be46a-5740-4e0f-aebc-16e4b1dd0078", "metadata": {"aucs": [0.9259202386658246, 0.9065887550703493, 0.9458688042531733], "final_y": [0.11275438896716905, 0.12006067810232712, 0.11002591364401881]}, "mutation_prompt": null}
{"id": "b84292d1-de8a-45d2-8ac0-7773f4ece454", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = max(0.1, self.adaptive_learning_rate * (1 - temp_factor))  # Dynamic learning rate adjustment\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a dynamic adjustment of the adaptive learning rate to enhance exploration and exploitation balance.", "configspace": "", "generation": 40, "fitness": 0.9223111553997833, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.922 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "889be46a-5740-4e0f-aebc-16e4b1dd0078", "metadata": {"aucs": [0.9152766978415878, 0.9068976530115745, 0.9447591153461873], "final_y": [0.11275984636252712, 0.12004677584216916, 0.11001160802541665]}, "mutation_prompt": null}
{"id": "cb0380a4-2d0c-4d63-b360-0f7d5f384ba5", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, np.exp(-0.05 * evaluations / self.budget), self.velocity.shape)  # Updated line\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a dynamic random perturbation scale to enhance exploration and avoid premature convergence.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'evaluations' is not defined\").", "error": "NameError(\"name 'evaluations' is not defined\")", "parent_id": "889be46a-5740-4e0f-aebc-16e4b1dd0078", "metadata": {}, "mutation_prompt": null}
{"id": "08b7aa19-aac2-4655-8cf0-ba726aa9bc88", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.neighborhood_size = max(2, int(0.1 * self.population_size) + np.random.binomial(1, temp_factor))  # Adjust neighborhood size dynamically\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce an adaptive neighborhood influence using a temperature-based factor to enhance the local search capability.", "configspace": "", "generation": 42, "fitness": 0.8782678475708261, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.878 with standard deviation 0.039. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "889be46a-5740-4e0f-aebc-16e4b1dd0078", "metadata": {"aucs": [0.8462190200611861, 0.8558537828061432, 0.9327307398451488], "final_y": [0.12981786647350202, 0.13497744775481335, 0.11154153947621737]}, "mutation_prompt": null}
{"id": "8c2456ed-0219-4224-868d-d2519a22dfa0", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.neighborhood_size = max(2, int(0.1 * self.population_size) + (0.1 * self.population_size * (self.best_score / (current_best_score + 1e-8))))  # Update neighborhood size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Incorporate a dynamic neighborhood size based on the success rate of the best solution updates to enhance exploitation-exploration balance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'current_best_score' is not defined\").", "error": "NameError(\"name 'current_best_score' is not defined\")", "parent_id": "889be46a-5740-4e0f-aebc-16e4b1dd0078", "metadata": {}, "mutation_prompt": null}
{"id": "7c2a0ea8-ad7c-4584-a899-30affd527a31", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - evaluations / self.budget)))  # Dynamic inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce dynamic inertia weight decay based on function evaluations to enhance exploration-exploitation balance.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'evaluations' is not defined\").", "error": "NameError(\"name 'evaluations' is not defined\")", "parent_id": "889be46a-5740-4e0f-aebc-16e4b1dd0078", "metadata": {}, "mutation_prompt": null}
{"id": "b620421f-0ef1-4d3e-bfba-8cd71f2cafaf", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget)**2)  # Nonlinear inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a time-varying nonlinear inertia weight to improve convergence speed and solution quality.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'evaluations' is not defined\").", "error": "NameError(\"name 'evaluations' is not defined\")", "parent_id": "889be46a-5740-4e0f-aebc-16e4b1dd0078", "metadata": {}, "mutation_prompt": null}
{"id": "d9bda000-7c00-4fb3-9bbc-22d87cf719d6", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.15, self.velocity.shape)  # Increased standard deviation\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Fine-tune the random perturbation term by slightly increasing its standard deviation to enhance exploration capabilities.", "configspace": "", "generation": 46, "fitness": 0.9248907605758334, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.925 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "889be46a-5740-4e0f-aebc-16e4b1dd0078", "metadata": {"aucs": [0.9226775881331318, 0.9066950990399123, 0.9452995945544561], "final_y": [0.11274167978716709, 0.12005874794407101, 0.11002688450485398]}, "mutation_prompt": null}
{"id": "aca8226f-6940-47da-9e78-fcc5631dfbca", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.neighborhood_size = max(2, int(0.1 * self.population_size * (1 + 0.1 * (1 - temp_factor))))  # Dynamic adaptation based on performance\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a dynamic adaptation of neighborhood size based on performance improvement to balance exploration and exploitation.", "configspace": "", "generation": 47, "fitness": 0.9261259326631158, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "889be46a-5740-4e0f-aebc-16e4b1dd0078", "metadata": {"aucs": [0.9259202386658246, 0.9065887550703493, 0.9458688042531733], "final_y": [0.11275438896716905, 0.12006067810232712, 0.11002591364401881]}, "mutation_prompt": null}
{"id": "02b3d9ac-7d41-45da-9389-85c20794ec72", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.inertia_weight = max(0.4, 0.9 * (1 - (current_best_score / self.best_score)))  # Dynamic inertia adjustment\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a dynamic inertia weight adjustment based on current performance to improve convergence speed.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'current_best_score' is not defined\").", "error": "NameError(\"name 'current_best_score' is not defined\")", "parent_id": "889be46a-5740-4e0f-aebc-16e4b1dd0078", "metadata": {}, "mutation_prompt": null}
{"id": "3344cf88-13ab-4565-9094-c44397226a31", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - 0.5 * (1 - np.min(scores) / (np.max(scores) + 1e-9))  # Variable cognitive-social balance\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a variable cognitive-social weight balance method to enhance adaptability across different problem landscapes.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'scores' is not defined\").", "error": "NameError(\"name 'scores' is not defined\")", "parent_id": "889be46a-5740-4e0f-aebc-16e4b1dd0078", "metadata": {}, "mutation_prompt": null}
{"id": "866be419-bb7d-4302-9e87-157756ec1ac5", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = 0.1 * (1 - evaluations / self.budget) # Changed to make perturbation adaptive\n        random_perturbation = np.random.normal(0, random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introducing an adaptive random perturbation scale based on evaluations to improve exploration-exploitation balance.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'evaluations' is not defined\").", "error": "NameError(\"name 'evaluations' is not defined\")", "parent_id": "889be46a-5740-4e0f-aebc-16e4b1dd0078", "metadata": {}, "mutation_prompt": null}
{"id": "8f709d38-58e2-41ab-93fe-dd56eea649b4", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a dynamic adaptive learning rate adjustment based on the current best score to enhance convergence speed.", "configspace": "", "generation": 51, "fitness": 0.9261281280167619, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "889be46a-5740-4e0f-aebc-16e4b1dd0078", "metadata": {"aucs": [0.9258867471342975, 0.9066726182193042, 0.945825018696684], "final_y": [0.11275276494268327, 0.1200588915822276, 0.11001458146242915]}, "mutation_prompt": null}
{"id": "8f201350-072f-41eb-87ff-35547bd95b77", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        neighborhood_influence = np.mean(self.position, axis=0)  # New neighborhood influence factor\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Incorporate a dynamic neighborhood influence factor to enhance exploration and exploitation balance.", "configspace": "", "generation": 52, "fitness": 0.9261281280167619, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "8f709d38-58e2-41ab-93fe-dd56eea649b4", "metadata": {"aucs": [0.9258867471342975, 0.9066726182193042, 0.945825018696684], "final_y": [0.11275276494268327, 0.1200588915822276, 0.11001458146242915]}, "mutation_prompt": null}
{"id": "0173f71a-a297-4aa9-bf84-e2abc0e52ed3", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score))) * np.random.uniform(0.95, 1.05)  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a small random scaling factor to the adaptive learning rate for enhanced exploration.", "configspace": "", "generation": 53, "fitness": 0.8774285915318326, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.877 with standard deviation 0.039. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "8f709d38-58e2-41ab-93fe-dd56eea649b4", "metadata": {"aucs": [0.8446280421748439, 0.8558373319330151, 0.931820400487639], "final_y": [0.12982395801568813, 0.1345432562262454, 0.11155227484595287]}, "mutation_prompt": null}
{"id": "215ce21f-ec25-4af2-a484-ffdad8c16644", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        # Change: Introduce feedback in velocity update\n        self.velocity += 0.1 * (self.position - self.best_position[np.newaxis, :]) \n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a feedback mechanism in the velocity update to better exploit promising regions in the search space.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"non-broadcastable output operand with shape (5,10) doesn't match the broadcast shape (1,5,10)\").", "error": "ValueError(\"non-broadcastable output operand with shape (5,10) doesn't match the broadcast shape (1,5,10)\")", "parent_id": "8f709d38-58e2-41ab-93fe-dd56eea649b4", "metadata": {}, "mutation_prompt": null}
{"id": "81127923-43be-44f6-9c21-927e41b38c55", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        neighborhood_influence = np.random.normal(0, 0.05, self.velocity.shape)  # Added line\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = (self.inertia_weight * self.velocity + cognitive_term + \n                         social_term + random_perturbation + neighborhood_influence)\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a dynamic neighborhood influence factor to enhance the exploration capability.", "configspace": "", "generation": 55, "fitness": 0.9126191537210819, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.913 with standard deviation 0.009. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "8f709d38-58e2-41ab-93fe-dd56eea649b4", "metadata": {"aucs": [0.9247507360525936, 0.9060338266674084, 0.9070728984432437], "final_y": [0.11274370236590137, 0.11621967380983989, 0.11934687677327926]}, "mutation_prompt": null}
{"id": "8383287d-540d-4f8d-91b3-9b8677c303e5", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size)) \n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        neighborhood_best = np.apply_along_axis(self._find_neighborhood_best, 1, self.position)\n        self.velocity += 0.2 * (neighborhood_best - self.position)\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position = np.clip(self.position, bounds.lb, bounds.ub)  # Adaptive boundary handling\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _find_neighborhood_best(self, individual):\n        idx = np.argsort(np.linalg.norm(self.position - individual, axis=1))[:self.neighborhood_size]\n        return self.position[idx[np.argmin(self.best_scores[idx])]]\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        bounds = func.bounds  # Added to use in boundary handling\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Enhance the swarm optimizer with dynamic neighborhood-based learning and adaptive boundary-handling to improve convergence speed and accuracy.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'bounds' is not defined\").", "error": "NameError(\"name 'bounds' is not defined\")", "parent_id": "8f709d38-58e2-41ab-93fe-dd56eea649b4", "metadata": {}, "mutation_prompt": null}
{"id": "582d9269-a14d-4295-8b6d-0c46aa899d07", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        diversity = np.std(self.position, axis=0).mean()\n        self.inertia_weight = max(0.4, 0.8 * (1 - diversity))  # Adaptive inertia based on diversity\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Improve convergence speed by introducing an adaptive inertia weight strategy that dynamically reacts to population diversity.", "configspace": "", "generation": 57, "fitness": 0.9198260196383923, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.920 with standard deviation 0.019. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "8f709d38-58e2-41ab-93fe-dd56eea649b4", "metadata": {"aucs": [0.9189578339272264, 0.8965169912611496, 0.9440032337268011], "final_y": [0.11435053433085818, 0.1162556999011709, 0.11002427595601139]}, "mutation_prompt": null}
{"id": "012d3e9e-c43f-4858-9328-18b57e9cb9bd", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))\n        self.momentum_factor = max(0.05, self.momentum_factor * np.exp(-0.01 * self.best_score))  # Modulated momentum factor\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introducing temperature-based modulation for momentum factor to improve exploration and convergence balance.", "configspace": "", "generation": 58, "fitness": 0.9256190048052182, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "8f709d38-58e2-41ab-93fe-dd56eea649b4", "metadata": {"aucs": [0.9240370646663408, 0.9069391072080013, 0.9458808425413124], "final_y": [0.11274550711083309, 0.12005859774492822, 0.11003312032071]}, "mutation_prompt": null}
{"id": "1386a6d9-bf2d-40cf-ab84-1dbceb159c76", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight) * 0.5, self.position.shape)  # Enhanced perturbation\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a Gaussian perturbation in the position update to enhance exploration.", "configspace": "", "generation": 59, "fitness": 0.9246613003160057, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.925 with standard deviation 0.017. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "8f709d38-58e2-41ab-93fe-dd56eea649b4", "metadata": {"aucs": [0.9221350573866381, 0.9057276523770822, 0.9461211911842964], "final_y": [0.1127414119471154, 0.12005811095397412, 0.1100091874159802]}, "mutation_prompt": null}
{"id": "e4be5ab6-6c20-4d89-8530-51da0139a544", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n            self.neighborhood_size = min(self.population_size, int(self.neighborhood_size * 1.05))  # Increase neighborhood size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a gradual increase in neighborhood size to enhance exploration in early stages.", "configspace": "", "generation": 60, "fitness": 0.9261281280167619, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "8f709d38-58e2-41ab-93fe-dd56eea649b4", "metadata": {"aucs": [0.9258867471342975, 0.9066726182193042, 0.945825018696684], "final_y": [0.11275276494268327, 0.1200588915822276, 0.11001458146242915]}, "mutation_prompt": null}
{"id": "11772dfd-53d9-49e4-9086-09a21c6ac632", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.02 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a non-linear decay for adaptive learning rate to enhance exploration-exploitation balance.", "configspace": "", "generation": 61, "fitness": 0.9247125382806983, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.925 with standard deviation 0.014. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "8f709d38-58e2-41ab-93fe-dd56eea649b4", "metadata": {"aucs": [0.92587427765602, 0.9067154330390121, 0.9415479041470627], "final_y": [0.11274095040415832, 0.12006071849581668, 0.11154300060090772]}, "mutation_prompt": null}
{"id": "e35414e9-734c-42f8-b922-2ddea2908ba1", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n        self.velocity_clamp = None  # New attribute for velocity clamping\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n        self.velocity_clamp = 0.1 * (ub - lb)  # Set velocity clamp range\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.velocity = np.clip(self.velocity, -self.velocity_clamp, self.velocity_clamp)  # Apply velocity clamping\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce velocity clamping based on the range of search space to improve stability and convergence.", "configspace": "", "generation": 62, "fitness": 0.8937807156915859, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.894 with standard deviation 0.048. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "8f709d38-58e2-41ab-93fe-dd56eea649b4", "metadata": {"aucs": [0.8303484248582996, 0.90617755143453, 0.944816170781928], "final_y": [0.1305486790652891, 0.11623084016203655, 0.11003646048803606]}, "mutation_prompt": null}
{"id": "2d74e5d3-3285-4124-af04-18939f626ee2", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            # Line changed below\n            self.velocity *= (1 + 0.1 * np.sin(2 * np.pi * evaluations / self.budget))  # Dynamic velocity scaling\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Incorporate a dynamic velocity scaling mechanism to improve adaptability and exploration capability.", "configspace": "", "generation": 63, "fitness": 0.8958479139533253, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.896 with standard deviation 0.040. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "8f709d38-58e2-41ab-93fe-dd56eea649b4", "metadata": {"aucs": [0.8427791082775095, 0.905275382838665, 0.9394892507438015], "final_y": [0.139277937675498, 0.12005869725753893, 0.11155030501009067]}, "mutation_prompt": null}
{"id": "f55ee884-7535-4d7f-a6f9-07392efd85a1", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        random_scaling = np.random.uniform(0.8, 1.2, (self.population_size, self.dim))  # Introduce random scaling\n        social_term = self.social_weight * r2 * random_scaling * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a random scaling factor in the social term to enhance exploration and convergence balance.", "configspace": "", "generation": 64, "fitness": 0.8884734975815425, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.888 with standard deviation 0.029. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "8f709d38-58e2-41ab-93fe-dd56eea649b4", "metadata": {"aucs": [0.8490843609992174, 0.8974758443912324, 0.9188602873541776], "final_y": [0.13550424127633387, 0.12022326894713131, 0.1149855623362106]}, "mutation_prompt": null}
{"id": "d89c6d3c-9d47-46d9-b495-a596d8abf354", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * np.sin(1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a non-linear decay for inertia weight to balance exploration and exploitation effectively.", "configspace": "", "generation": 65, "fitness": 0.9248349472964444, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.925 with standard deviation 0.014. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "8f709d38-58e2-41ab-93fe-dd56eea649b4", "metadata": {"aucs": [0.9266550804080901, 0.9065145417143474, 0.9413352197668959], "final_y": [0.11274995217558448, 0.12006596844957174, 0.11154208892062678]}, "mutation_prompt": null}
{"id": "2dca1e2d-fa1c-4e85-9f61-cdf06513c7eb", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.velocity = np.clip(self.velocity, -1, 1)  # Noise filtering in velocity\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a noise filtering mechanism in velocity calculation to enhance robustness against noisy evaluations.", "configspace": "", "generation": 66, "fitness": 0.8013865632264557, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.801 with standard deviation 0.045. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.019.", "error": "", "parent_id": "8f709d38-58e2-41ab-93fe-dd56eea649b4", "metadata": {"aucs": [0.7377755508579514, 0.8389169197999111, 0.8274672190215049], "final_y": [0.16336633830043557, 0.12855618300442073, 0.11782486410206039]}, "mutation_prompt": null}
{"id": "51803f46-4be0-4128-8cfa-7b2f16c79db4", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score))) * np.exp(-0.01 * evaluations / self.budget)\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Integrate a temperature-based adaptive learning strategy to refine convergence precision.", "configspace": "", "generation": 67, "fitness": 0.9245609483436716, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.925 with standard deviation 0.014. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "8f709d38-58e2-41ab-93fe-dd56eea649b4", "metadata": {"aucs": [0.9257499526014534, 0.9064909772941403, 0.941441915135421], "final_y": [0.11274588109814021, 0.12005970479256811, 0.11154289966901709]}, "mutation_prompt": null}
{"id": "6a6a5625-653c-4705-a154-962e124a85e4", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation = np.random.normal(0, 0.1, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        # Changed line: Dynamic inertia weight based on population diversity\n        self.inertia_weight = 0.9 - 0.5 * (np.std(self.position) / (np.mean(self.position) + 1e-10)) \n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a dynamic inertia weight adjustment based on population diversity to enhance exploration capability.", "configspace": "", "generation": 68, "fitness": 0.9139444609617815, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.914 with standard deviation 0.006. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "8f709d38-58e2-41ab-93fe-dd56eea649b4", "metadata": {"aucs": [0.9230830532860387, 0.9098623758691414, 0.9088879537301646], "final_y": [0.11435535593337731, 0.11622326831800556, 0.12140466181307263]}, "mutation_prompt": null}
{"id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce random perturbation scaling based on iteration progress to enhance exploration and exploitation balance.", "configspace": "", "generation": 69, "fitness": 0.9264660716534062, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "8f709d38-58e2-41ab-93fe-dd56eea649b4", "metadata": {"aucs": [0.9254233941066525, 0.9068809271227735, 0.9470938937307927], "final_y": [0.11274307702500719, 0.12006775839190087, 0.11002849027243311]}, "mutation_prompt": null}
{"id": "6bb63e17-0d4f-4173-a8d0-445505f938a7", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor + 0.1 * np.exp(-self.best_score))  # Changed line\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Enhance social influence dynamically based on the best position history to improve convergence.", "configspace": "", "generation": 70, "fitness": 0.9240053486237633, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.924 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.920252832647598, 0.9066258509172799, 0.9451373623064118], "final_y": [0.11275022381050537, 0.12006230640167836, 0.11004652232981149]}, "mutation_prompt": null}
{"id": "70d13795-ef59-4fcc-8a61-99249c0ada6e", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor + 0.1 * np.sin(evaluations)  # Modified line\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Enhance exploration by introducing a sinusoidal variation on cognitive weight.", "configspace": "", "generation": 71, "fitness": 0.9058244373984805, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.906 with standard deviation 0.018. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.8810432796096976, 0.9137352961039101, 0.9226947364818336], "final_y": [0.12318641927218699, 0.11715623783420881, 0.1115416719426805]}, "mutation_prompt": null}
{"id": "1eca67df-17cd-4530-b23b-fd16381094de", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)  # Adjusted for adaptive scaling\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce adaptive social weight scaling based on iteration progress to enhance solution convergence.  ", "configspace": "", "generation": 72, "fitness": 0.9264660716534062, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.9254233941066525, 0.9068809271227735, 0.9470938937307927], "final_y": [0.11274307702500719, 0.12006775839190087, 0.11002849027243311]}, "mutation_prompt": null}
{"id": "f6637163-cfe9-4745-ab37-6f71191a6224", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n            self.velocity *= 1 - 0.1 * np.tanh(self.best_score)  # Adaptive velocity scaling based on best score\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce adaptive velocity scaling based on the population's best score to enhance convergence speed and stability.", "configspace": "", "generation": 73, "fitness": 0.9262346279156947, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.9257757876393069, 0.9071778267931697, 0.9457502693146073], "final_y": [0.11274068579642116, 0.12005621544596834, 0.11001855608032263]}, "mutation_prompt": null}
{"id": "20f2507f-17c4-4c9a-947c-8d0aee4404f6", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n        self.velocity += np.random.normal(0, 0.001 * np.random.randn(), self.velocity.shape)  # Stochastic adjustment\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Incorporate stochastic gradient descent-inspired random velocity adjustment for adaptive exploration and exploitation balance.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {}, "mutation_prompt": null}
{"id": "fcbc644b-8cc6-4417-96f3-1d3950dc3963", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * np.sqrt(self.budget))  # Enhanced perturbation\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.05 * (1 - self.inertia_weight)))  # Adjusted inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.98)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Improve exploration-exploitation balance using dynamic neighborhood communication and enhanced perturbation techniques.", "configspace": "", "generation": 75, "fitness": 0.8895178369525659, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.890 with standard deviation 0.055. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.017.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.8127344893590084, 0.9158620109785172, 0.9399570105201722], "final_y": [0.1502035817727564, 0.11681268456501637, 0.11154356228042073]}, "mutation_prompt": null}
{"id": "b39116be-d9da-4ea9-b00f-df60fa381876", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = 0.1 * (1 + 0.5 * np.sin(np.pi * evaluations / self.budget))  # Adaptive momentum factor\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Enhance exploration-exploitation balance by introducing an adaptive momentum factor based on evaluations.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'evaluations' is not defined\").", "error": "NameError(\"name 'evaluations' is not defined\")", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {}, "mutation_prompt": null}
{"id": "20de0db0-b495-40bf-af6a-66f5a8c1c748", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Optimize velocity update by introducing convergence acceleration through decay in inertia weight.", "configspace": "", "generation": 77, "fitness": 0.9264660716534062, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.9254233941066525, 0.9068809271227735, 0.9470938937307927], "final_y": [0.11274307702500719, 0.12006775839190087, 0.11002849027243311]}, "mutation_prompt": null}
{"id": "73c88b18-5db0-40ad-8398-e1c9cadf3364", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        normalized_fitness = (1.0 - self.best_score) / (1.0 + self.best_score)  # Changed line\n        self.velocity = normalized_fitness * (self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation)\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Integrate adaptive velocity scaling based on normalized fitness to improve convergence.", "configspace": "", "generation": 78, "fitness": 0.8941045977040661, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.894 with standard deviation 0.017. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.8773995972573052, 0.8868654176720504, 0.9180487781828429], "final_y": [0.1231084582252856, 0.11713158839703175, 0.11168238914246309]}, "mutation_prompt": null}
{"id": "61c26202-a31c-4d92-bf13-60cf5a317a70", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.log(self.budget + 1) / (self.budget + 1)  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Leverage an adaptive random perturbation scale decaying logarithmically with evaluations to enhance exploration and convergence.", "configspace": "", "generation": 79, "fitness": 0.9264660211783019, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.9254232506738859, 0.9068809246518784, 0.9470938882091413], "final_y": [0.11274306129091038, 0.1200677545711698, 0.11002848244596253]}, "mutation_prompt": null}
{"id": "78dc8c7c-182d-46af-92b8-ccd56b99998e", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n            self.neighborhood_size = max(2, int(0.1 * self.population_size) + int(0.05 * (1 - self.best_score)))  # Adaptive neighborhood size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Incorporate an adaptive neighborhood influence mechanism to enhance local search capabilities.", "configspace": "", "generation": 80, "fitness": 0.9264660716534062, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.9254233941066525, 0.9068809271227735, 0.9470938937307927], "final_y": [0.11274307702500719, 0.12006775839190087, 0.11002849027243311]}, "mutation_prompt": null}
{"id": "ac84aa7c-6731-47ba-ab56-f1cf72263b42", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n            self.neighborhood_size = max(2, int(0.1 * self.population_size) + int(evaluations / (10 * self.budget)))  # Increase neighborhood size\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Enhance exploration by increasing neighborhood size over iterations to improve convergence.", "configspace": "", "generation": 81, "fitness": 0.9264660716534062, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.9254233941066525, 0.9068809271227735, 0.9470938937307927], "final_y": [0.11274307702500719, 0.12006775839190087, 0.11002849027243311]}, "mutation_prompt": null}
{"id": "8ed61519-a8e8-41da-8e08-0bf63680e1bb", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        relative_improvement = (self.best_score - np.min(self.best_scores)) / (1 + self.best_score)  # New line\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * relative_improvement))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Incorporate a dynamic inertia weight update based on the relative improvement to enhance convergence.", "configspace": "", "generation": 82, "fitness": 0.8911129104012345, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.891 with standard deviation 0.042. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.8359979412033315, 0.8991296592249343, 0.938211130775438], "final_y": [0.13763651164356483, 0.11623082774895888, 0.11154376938720467]}, "mutation_prompt": null}
{"id": "0323ca20-93cf-4417-b24d-0ab68cfa0ebe", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = 0.05 + 0.95 * (1 - (np.exp(-0.01 * self.budget)))  # Dynamically adjust momentum\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Dynamically adjust the momentum factor to improve convergence stability.", "configspace": "", "generation": 83, "fitness": 0.8837381690176969, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.884 with standard deviation 0.041. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.8485052233810311, 0.8620983399025675, 0.9406109437694923], "final_y": [0.13555160325304494, 0.13382544532072282, 0.11026259438756048]}, "mutation_prompt": null}
{"id": "da147cbc-96f8-4550-9ce3-a5a58c0108a7", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        # Updated line for nonlinear scaling\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * np.sin(np.pi * (1 - self.inertia_weight))))  \n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce nonlinear scaling in inertia weight decay to improve exploration-exploitation balance dynamically.", "configspace": "", "generation": 84, "fitness": 0.9256804988376821, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.014. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.9269126804673773, 0.9075955154347222, 0.942533300610947], "final_y": [0.11275180229015724, 0.11622661000227241, 0.11154329331592794]}, "mutation_prompt": null}
{"id": "9b63e781-26e7-418d-b657-79cd47e356de", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget**0.5)  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Refine velocity update with nonlinear decay of random perturbation to improve convergence dynamics.", "configspace": "", "generation": 85, "fitness": 0.9246227449464571, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.925 with standard deviation 0.014. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.9257278961383414, 0.9066462463964942, 0.9414940923045356], "final_y": [0.11274614113462089, 0.12006548513128856, 0.11154975300918979]}, "mutation_prompt": null}
{"id": "574a0801-2cf2-4e64-8bdd-900a4923d2b5", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (1.01 + 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia growth\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a time-varying inertia weight that increases gradually, enhancing local search capabilities over iterations.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {}, "mutation_prompt": null}
{"id": "98105b64-4c09-46a5-ba21-51ac4c75c0ec", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * (1.2 ** self.budget))  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Enhance convergence by introducing non-linear decay in random perturbation scaling.", "configspace": "", "generation": 87, "fitness": 0.9252899708610046, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.925 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.9253105979763665, 0.9062464945393487, 0.9443128200672988], "final_y": [0.11274931425472035, 0.12006323224418769, 0.11004777056184045]}, "mutation_prompt": null}
{"id": "49ab8c54-abdb-460b-97d7-e4877234beb4", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, 0.9 * (1 - evaluations / self.budget))  # Dynamic inertia weight adjustment\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce dynamic inertia weight adjustment based on current iteration progress to enhance convergence speed and solution quality.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'evaluations' is not defined\").", "error": "NameError(\"name 'evaluations' is not defined\")", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {}, "mutation_prompt": null}
{"id": "2a10232d-0395-4537-9de6-b9ef43c28f87", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            diversity = np.std(self.position, axis=0).mean()  # Adaptive social weight based on diversity\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor) * (diversity / self.dim)  # Updated line\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Implement an adaptive social weight based on population's diversity to enhance exploration and convergence.", "configspace": "", "generation": 89, "fitness": 0.9236543498643702, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.924 with standard deviation 0.015. And the mean value of best solutions found was 0.113 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.9140255142717865, 0.9121422687879106, 0.9447952665334136], "final_y": [0.11274847536513344, 0.11622610709538705, 0.11000789692149182]}, "mutation_prompt": null}
{"id": "e1e048f8-ed38-41a6-9a46-2486654eb68d", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 - np.tanh(5 * self.best_score))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Dynamically adjust the adaptive learning rate based on the current best score's proximity to zero to enhance convergence near optimal solutions.", "configspace": "", "generation": 90, "fitness": 0.9216310628499528, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.922 with standard deviation 0.014. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.9181786657357396, 0.9064213789474664, 0.9402931438666524], "final_y": [0.11276997718833348, 0.12005567034738085, 0.11153763071148837]}, "mutation_prompt": null}
{"id": "8acbbee9-b034-4971-a707-e4189b08d103", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        time_dependent_velocity = 0.5 * np.sin(2 * np.pi * np.arange(self.population_size) / self.budget)  # New line\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation + time_dependent_velocity\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Incorporate a time-dependent velocity update to enhance solution diversity and convergence efficacy.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (5,10) (5,) ').", "error": "ValueError('operands could not be broadcast together with shapes (5,10) (5,) ')", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {}, "mutation_prompt": null}
{"id": "4c15f86d-f173-4872-910e-671e8bb09f45", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        individual_progress_factor = np.exp(-0.005 * np.mean(self.best_scores))  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * individual_progress_factor, self.velocity.shape)  # Updated line\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Enhance local exploration by introducing a dynamic perturbation factor based on individual particle progress.", "configspace": "", "generation": 92, "fitness": 0.926128185412728, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.9258870031431634, 0.9066724836385837, 0.9458250694564369], "final_y": [0.11275276522679811, 0.12005888970274547, 0.1100145454454261]}, "mutation_prompt": null}
{"id": "206cb149-ab69-46d3-812c-4f32f1ed8200", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.05 * (self.best_score/self.budget)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce variable inertia decay to balance convergence speed and solution diversity.", "configspace": "", "generation": 93, "fitness": 0.8917807384949171, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.892 with standard deviation 0.043. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.8354434130798363, 0.9017164799527676, 0.9381823224521473], "final_y": [0.1396618851928777, 0.11622326539339922, 0.11155408679889312]}, "mutation_prompt": null}
{"id": "c94656a0-a4d7-468d-a901-ffe9c5495063", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight**2)))  # Non-linear inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce non-linear decay to the inertia weight for improved convergence dynamics.", "configspace": "", "generation": 94, "fitness": 0.9110862655318389, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.911 with standard deviation 0.028. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.9176908261959859, 0.8735245456956695, 0.9420434247038612], "final_y": [0.11274464502180825, 0.1288742700756106, 0.1115511617574837]}, "mutation_prompt": null}
{"id": "838da829-50b3-4c85-a6f2-696c5e5d0e84", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * (1 - temp_factor)  # Updated line\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce dynamic cognitive and social weight scaling based on budget progress to enhance convergence.", "configspace": "", "generation": 95, "fitness": 0.9252706572581397, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.925 with standard deviation 0.015. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.9252116814782523, 0.9064496451022388, 0.9441506451939283], "final_y": [0.112741854211172, 0.1200597981449697, 0.11000705537443856]}, "mutation_prompt": null}
{"id": "8d8911b7-c305-477c-8b01-a94c7aedd9e9", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget)  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.995 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Enhance the balance of exploration and exploitation by optimizing the inertia weight decay rate's convergence speed.", "configspace": "", "generation": 96, "fitness": 0.9028781248714325, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.903 with standard deviation 0.037. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.8550144425754229, 0.908404540205638, 0.9452153918332364], "final_y": [0.1304862536673942, 0.11861609434836462, 0.11003890958336682]}, "mutation_prompt": null}
{"id": "4fec650f-e201-432e-91ab-569220597905", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget * (1 - self.best_score))  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Adaptively adjust the random perturbation scale based on the best score improvement to enhance convergence.", "configspace": "", "generation": 97, "fitness": 0.9264719931819375, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "d1f8809e-fa46-4a34-ae42-ef5babb2bc50", "metadata": {"aucs": [0.9254092958401201, 0.9069137870185231, 0.9470928966871697], "final_y": [0.11275289854832449, 0.12005742982363954, 0.11003027071523841]}, "mutation_prompt": null}
{"id": "ec754a3b-13c9-470a-92be-30e7e584d432", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget * (1 - self.best_score / np.max(self.best_scores)))  # Updated line\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))  # Adaptive inertia decay\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor)\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))  # Adjust learning rate\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a temperature-based perturbation scaling approach to balance exploration and exploitation. ", "configspace": "", "generation": 98, "fitness": 0.9259035051602374, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "4fec650f-e201-432e-91ab-569220597905", "metadata": {"aucs": [0.924425442064753, 0.9068850346823543, 0.9464000387336051], "final_y": [0.11274956250235413, 0.12005750301178841, 0.11001948380364757]}, "mutation_prompt": null}
{"id": "ac11e54a-0f84-4c88-b0f1-be19b94b084d", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.1 * dim))\n        self.position = None\n        self.velocity = None\n        self.best_position = None\n        self.best_score = np.inf\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.global_best_position = None\n        self.momentum_factor = 0.1\n        self.adaptive_learning_rate = 0.5\n        self.neighborhood_size = max(2, int(0.1 * self.population_size))  # New dynamic neighborhood size\n\n    def initialize(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.best_position = self.position.copy()\n        self.best_scores = np.full(self.population_size, np.inf)\n\n    def _update_velocity_position(self):\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_term = self.cognitive_weight * r1 * (self.best_position - self.position)\n        social_term = self.social_weight * r2 * (self.global_best_position - self.position)\n        random_perturbation_scale = np.exp(-0.005 * self.budget * (1 - self.best_score))\n        random_perturbation = np.random.normal(0, 0.1 * random_perturbation_scale, self.velocity.shape)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_term + social_term + random_perturbation\n        self.position += self.velocity + self.momentum_factor * np.sign(self.velocity)\n        self.position += np.random.normal(0, self.adaptive_learning_rate * (1 - self.inertia_weight), self.position.shape)\n        self.inertia_weight = max(0.4, self.inertia_weight * (0.99 - 0.1 * (1 - self.inertia_weight)))\n        self.momentum_factor = max(0.05, self.momentum_factor * 0.99)\n\n    def _evaluate_population(self, func):\n        scores = np.apply_along_axis(func, 1, self.position)\n        for i in range(self.population_size):\n            if scores[i] < self.best_scores[i]:\n                self.best_scores[i] = scores[i]\n                self.best_position[i] = self.position[i].copy()\n        current_best_score = np.min(scores)\n        if current_best_score < self.best_score:\n            self.best_score = current_best_score\n            self.global_best_position = self.best_position[np.argmin(scores)].copy()\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n        evaluations = 0\n        while evaluations < self.budget:\n            self._evaluate_population(func)\n            self._update_velocity_position()\n            evaluations += self.population_size\n            max_weight_change = 0.3\n            temp_factor = np.exp(-evaluations / (0.1 * self.budget))\n            self.cognitive_weight = 1.5 - (0.1 * evaluations / self.budget) * temp_factor\n            self.social_weight = 1.5 + max_weight_change * (1 - temp_factor) * np.exp(-0.01 * evaluations / self.budget)  # Adjust social weight\n            self.adaptive_learning_rate = 0.5 * (1 + np.tanh(0.01 * (1 - self.best_score)))\n        return self.global_best_position, self.best_score", "name": "ProbabilisticSwarmOptimizer", "description": "Introduce a decay factor to the social weight to enhance convergence reliability.", "configspace": "", "generation": 99, "fitness": 0.926419753262627, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.016. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "4fec650f-e201-432e-91ab-569220597905", "metadata": {"aucs": [0.9252481397016558, 0.9069169896793517, 0.9470941304068736], "final_y": [0.11275008062243463, 0.12005481582110045, 0.1100257562147473]}, "mutation_prompt": null}
