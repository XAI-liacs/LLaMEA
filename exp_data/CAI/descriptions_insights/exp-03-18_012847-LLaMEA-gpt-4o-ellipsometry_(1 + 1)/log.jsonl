{"id": "a1f04b9c-c3d5-4ede-bf50-736ddcfd7ffe", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.9\n        self.F = 0.8  # Differential weight\n        self.lb, self.ub = None, None\n\n    def chaotic_sequence(self, seed, n):\n        # Generate a chaotic sequence using logistic map\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 4.0 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(0.1234, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "A novel hybrid metaheuristic combining Differential Evolution with adaptive chaos-based parameter control to efficiently explore and exploit complex search spaces.", "configspace": "", "generation": 0, "fitness": 0.28644618074455874, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.286 with standard deviation 0.092. And the mean value of best solutions found was 0.008 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": null, "metadata": {"aucs": [0.3515864271046544, 0.35152936856076555, 0.1562227465682563], "final_y": [1.692082063235886e-05, 3.614934720349906e-05, 0.02332898585784688]}, "mutation_prompt": null}
{"id": "dda957b6-7986-4f0e-99c2-156b15d859b7", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.8\n        self.F = 0.5  # Reduced differential weight for better stability\n        self.lb, self.ub = None, None\n\n    def chaotic_sequence(self, seed, n):\n        # Generate a chaotic sequence using logistic map with enhanced parameters\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.9 * x * (1.0 - x)  # Slightly altered logistic map\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(0.5678, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F  # Initialize adaptive control\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + adaptive_F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.9  # Decrease F to favor stability\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "An improved hybrid metaheuristic combining Differential Evolution with chaotic sequences and adaptive parameter control for enhanced exploration and exploitation in complex search spaces.", "configspace": "", "generation": 1, "fitness": 0.373021161433195, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.373 with standard deviation 0.103. And the mean value of best solutions found was 0.029 (0. is the best) with standard deviation 0.041.", "error": "", "parent_id": "a1f04b9c-c3d5-4ede-bf50-736ddcfd7ffe", "metadata": {"aucs": [0.3762980119112991, 0.24479663454922773, 0.4979688378390583], "final_y": [0.00021545688039615156, 0.08684230389779497, 9.819821693805445e-07]}, "mutation_prompt": null}
{"id": "fd75560f-9287-4914-925d-0c41ebbf0307", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.8\n        self.F = 0.5  # Reduced differential weight for better stability\n        self.lb, self.ub = None, None\n\n    def chaotic_sequence(self, seed, n):\n        # Generate a chaotic sequence using logistic map with enhanced parameters\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.9 * x * (1.0 - x)  # Slightly altered logistic map\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(0.5678, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F  # Initialize adaptive control\n        adaptive_crossover_rate = self.crossover_rate  # Initialize adaptive crossover\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + adaptive_F * (population[b] - population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate  # Adaptive crossover\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.9  # Decrease F to favor stability\n                        adaptive_crossover_rate *= 1.1  # Increase crossover rate to boost exploration\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with adaptive crossover for improved exploration-exploitation balance in optimization tasks.", "configspace": "", "generation": 2, "fitness": 0.29414758855439055, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.294 with standard deviation 0.089. And the mean value of best solutions found was 0.179 (0. is the best) with standard deviation 0.235.", "error": "", "parent_id": "dda957b6-7986-4f0e-99c2-156b15d859b7", "metadata": {"aucs": [0.1861496810542308, 0.2924240070851737, 0.4038690775237672], "final_y": [0.5120233722235759, 0.025036998813300182, 0.0008431983552902737]}, "mutation_prompt": null}
{"id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85  # Slightly increased for more diversity\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678  # Enhanced initialization for chaotic sequence\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)  # Altered logistic map for better chaos\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Experiment with another individual for mutation\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.95  # Slightly adjust F to control exploration\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "A refined hybrid metaheuristic incorporating a chaotic sequence variant and adaptive mutation strategies for enhanced diversity and convergence in complex search spaces.", "configspace": "", "generation": 3, "fitness": 0.4285978597707123, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.429 with standard deviation 0.009. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "dda957b6-7986-4f0e-99c2-156b15d859b7", "metadata": {"aucs": [0.41978739312779245, 0.4413266493603967, 0.4246795368239479], "final_y": [1.4554628945852391e-05, 3.922742352513682e-07, 5.564048674166954e-06]}, "mutation_prompt": null}
{"id": "498ebbd8-d6bd-463d-970d-17547adc9d2c", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.9  # Increased for more diversity\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Experiment with another individual for mutation\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.2 * (population[d] - population[i])  # Increased influence of fourth individual\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.90  # Adjust F more aggressively\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "An adaptive chaotic differential evolution algorithm with enhanced mutation and crossover strategies for improved optimization of black box functions.", "configspace": "", "generation": 4, "fitness": 0.37254909854456614, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.373 with standard deviation 0.055. And the mean value of best solutions found was 0.004 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.37866482601141216, 0.4361707274925579, 0.3028117421297284], "final_y": [0.0005129195744817855, 6.631841507733155e-07, 0.010456270487603893]}, "mutation_prompt": null}
{"id": "ba360809-4834-4d71-9903-a36202b902a9", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.9  # Increased for more exploration\n        self.F = 0.6  # Adjusted to improve exploration\n        self.lb, self.ub = None, None\n        self.chaotic_seed1 = 0.5678\n        self.chaotic_seed2 = 0.8765  # Second chaotic sequence seed for diversity\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq1 = self.chaotic_sequence(self.chaotic_seed1, self.population_size * self.dim)\n        chaotic_seq2 = self.chaotic_sequence(self.chaotic_seed2, self.population_size * self.dim)\n        mixed_seq = [(a + b) / 2 for a, b in zip(chaotic_seq1, chaotic_seq2)]\n        population = np.array(mixed_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.93  # Further adjust F for optimized exploration\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with dual-chaos sequences and adaptive mutation strategy to improve diversity and convergence.", "configspace": "", "generation": 5, "fitness": 0.4054061940951248, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.405 with standard deviation 0.026. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.43689585536279407, 0.37292982605050484, 0.40639290087207547], "final_y": [2.193930478858568e-05, 0.00033923029450914764, 7.495838963892912e-06]}, "mutation_prompt": null}
{"id": "0798a0df-5883-4168-81b5-3079d73af128", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Adjusted for better exploration\n        self.crossover_rate = 0.9  # Increased for more diverse solutions\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678  # Seed for chaotic sequence\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 4.0 * x * (1.0 - x)  # More intense logistic map for enhanced chaos\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.2 * (population[d] - population[i])  # Adjusted factor\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.92  # More fine-tuned adjustment of F\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with a dynamic chaotic sequence and adaptive parameter control for improved convergence.", "configspace": "", "generation": 6, "fitness": 0.3933764113432702, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.393 with standard deviation 0.015. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.3737255901263914, 0.39804882058491486, 0.40835482331850426], "final_y": [5.193756056036208e-05, 3.540649713181473e-06, 9.202725949612548e-06]}, "mutation_prompt": null}
{"id": "8f5fadcb-a8f8-428a-9c95-119edf94d764", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85  # Slightly increased for more diversity\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678  # Enhanced initialization for chaotic sequence\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)  # Altered logistic map for better chaos\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Experiment with another individual for mutation\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate * (1.0 - evaluations / self.budget)  # Adaptive crossover rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.95  # Slightly adjust F to control exploration\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with adaptive crossover rate for improved exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.27076425304456, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.271 with standard deviation 0.042. And the mean value of best solutions found was 0.018 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.21261153113816256, 0.29236601959761355, 0.3073152083979038], "final_y": [0.03889476805054915, 0.009334752281167672, 0.0069768953953484565]}, "mutation_prompt": null}
{"id": "4f5fa72b-edc4-4da4-bcf9-b76c8e5556d5", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85  # Slightly increased for more diversity\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678  # Enhanced initialization for chaotic sequence\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)  # Altered logistic map for better chaos\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Experiment with another individual for mutation\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.90  # Adjusted F to control exploration\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "A refined hybrid metaheuristic incorporating chaotic sequence variant, adaptive mutation strategies, and improved crossover for enhanced diversity and convergence in complex search spaces.", "configspace": "", "generation": 8, "fitness": 0.18671778340122244, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.187 with standard deviation 0.103. And the mean value of best solutions found was 1.821 (0. is the best) with standard deviation 1.590.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.13566934551815413, 0.09468967753475299, 0.3297943271507602], "final_y": [1.580894613847943, 3.877917246755667, 0.004595887657131064]}, "mutation_prompt": null}
{"id": "e4d6e9fd-a085-4e3f-a48a-782ab498f247", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Adaptive crossover rate based on fitness improvement\n                self.crossover_rate = 0.8 + 0.2 * (fitness[best_idx] / (fitness[i] + 1e-9))\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.95\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced chaotic differential evolution with adaptive crossover for improved convergence and exploration-exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.4072814621080327, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.407 with standard deviation 0.038. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.4476531091563867, 0.35571843047729745, 0.41847284669041385], "final_y": [2.9399173859245022e-05, 0.0012426734325576916, 1.352669777377892e-06]}, "mutation_prompt": null}
{"id": "9f4f1cc4-7123-4a73-9b72-daa9b1f3721e", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 4.0 * x * (1.0 - x)  # Enhanced chaos with logistic map\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.15 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.93  # Further adjust F for exploration\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced chaotic strategy and adaptive mutation dynamics for robust search convergence.", "configspace": "", "generation": 10, "fitness": 0.40352313285029534, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.404 with standard deviation 0.073. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.46150761946362795, 0.4481679441391516, 0.3008938349481065], "final_y": [4.8764127660356105e-06, 3.7753002191294022e-06, 0.002962830601808253]}, "mutation_prompt": null}
{"id": "a00573d3-3928-428a-b9f6-6b14f4c0020c", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85  # Slightly increased for more diversity\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678  # Enhanced initialization for chaotic sequence\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)  # Altered logistic map for better chaos\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Experiment with another individual for mutation\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.90  # More aggressive F adjustment for controlling exploration\n\n                # Introduce tournament selection to maintain diversity\n                tournament_indices = np.random.choice(self.population_size, 2, replace=False)\n                if fitness[tournament_indices[0]] < fitness[tournament_indices[1]]:\n                    loser = tournament_indices[1]\n                else:\n                    loser = tournament_indices[0]\n                if trial_fitness < fitness[loser]:\n                    population[loser] = trial\n                    fitness[loser] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhancing the mutation strategy with dynamic adaptation and introducing tournament selection for better exploration-exploitation balance.", "configspace": "", "generation": 11, "fitness": 0.25310751306207063, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.253 with standard deviation 0.062. And the mean value of best solutions found was 0.250 (0. is the best) with standard deviation 0.227.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.33653041555283447, 0.23627280769000292, 0.18651931594337456], "final_y": [0.013415206562173432, 0.17953385602024302, 0.5557369722167725]}, "mutation_prompt": null}
{"id": "cc633490-6286-4b71-9a9e-4749ed86950f", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85  # Slightly increased for more diversity\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678  # Enhanced initialization for chaotic sequence\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)  # Altered logistic map for better chaos\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n        golden_ratio = 1.618  # Added golden ratio for mutation scaling\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Experiment with another individual for mutation\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant *= golden_ratio  # Use golden ratio for mutation scaling\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.95  # Slightly adjust F to control exploration\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Improve convergence by enhancing mutation using golden ratio scaling for diversity.", "configspace": "", "generation": 12, "fitness": 0.1589746817457076, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.159 with standard deviation 0.011. And the mean value of best solutions found was 0.880 (0. is the best) with standard deviation 0.566.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.17406356494963948, 0.15176817182863478, 0.15109230845884858], "final_y": [0.08168278633950932, 1.3257654813729427, 1.2323026451331216]}, "mutation_prompt": null}
{"id": "5c4f2d14-844b-48e0-a3d4-9c03d90ec5d4", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n        adaptive_CR = self.crossover_rate  # Added adaptive crossover rate\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR  # Use adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.95\n                        adaptive_CR *= 0.98  # Adjust crossover rate\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "A refined hybrid metaheuristic that enhances diversity and convergence by integrating a chaotic sequence with adaptive mutation and crossover strategies, now incorporating adaptive crossover rate for improved exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": 0.4180476324463073, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.418 with standard deviation 0.013. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.43538930782387275, 0.4128313965549354, 0.4059221929601138], "final_y": [1.662107055867211e-06, 2.156808019657389e-05, 4.397672024612987e-06]}, "mutation_prompt": null}
{"id": "a6451727-5344-4477-8b09-b1e5db9ea534", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85  # Slightly increased for more diversity\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678  # Enhanced initialization for chaotic sequence\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)  # Altered logistic map for better chaos\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n        adaptive_crossover_rate = self.crossover_rate\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Experiment with another individual for mutation\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.95  # Slightly adjust F to control exploration\n                        adaptive_crossover_rate *= 0.98  # Adjust crossover rate for balance\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with adaptive crossover rate for better balance between exploration and exploitation.", "configspace": "", "generation": 14, "fitness": 0.32301814307096255, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.323 with standard deviation 0.145. And the mean value of best solutions found was 0.695 (0. is the best) with standard deviation 0.982.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.46001993422122456, 0.12211189018020296, 0.3869226048114601], "final_y": [2.325279776491135e-06, 2.0835923350200036, 1.2974986137844609e-05]}, "mutation_prompt": null}
{"id": "61d52090-b06f-4ed1-a7e1-d77397079026", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            diversity = np.std(population, axis=0).mean()  # Compute population diversity\n            adaptive_CR = 0.5 + 0.5 * (1 - diversity)  # Adjust crossover rate based on diversity\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR  # Use adaptive crossover rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.95\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Chaotic Adaptive DE variant balancing exploration and exploitation using adaptive scaling and crossover rates based on population diversity.", "configspace": "", "generation": 15, "fitness": 0.17232479084368843, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.172 with standard deviation 0.009. And the mean value of best solutions found was 0.415 (0. is the best) with standard deviation 0.248.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.18355930888061034, 0.16238129554354064, 0.17103376810691429], "final_y": [0.09287495375769317, 0.6976851210569631, 0.45396296177711937]}, "mutation_prompt": null}
{"id": "49e9d0e4-4027-4198-966f-52083d00a1b7", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85  # Adjusted dynamically in the loop\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = 0.8 + 0.2 * (fitness[i] - fitness[best_idx]) / (fitness[i] + fitness[best_idx])\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.95\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Improved Chaotic Differential Evolution by dynamically adjusting crossover rate and integrating elitism to enhance exploration and exploitation balance.", "configspace": "", "generation": 16, "fitness": 0.44099633662845167, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.441 with standard deviation 0.052. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ffab5ea6-e0eb-4916-9e1d-b9f11f3c5a46", "metadata": {"aucs": [0.38632731806485043, 0.4249236189271278, 0.5117380728933766], "final_y": [0.0001445495552728142, 1.3931906721536147e-05, 2.2842020716525611e-07]}, "mutation_prompt": null}
{"id": "570bb3f0-b7c3-40d0-9f20-f7ca34b74fe5", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85  # Adjusted dynamically in the loop\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                adaptive_F = 0.4 + 0.6 * np.random.rand()  # Adaptive mutation factor\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = 0.7 + 0.3 * (fitness[i] - fitness[best_idx]) / (fitness[i] + fitness[best_idx])\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F *= 0.95\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with adaptive mutation and dynamic crossover for improved convergence and robustness.", "configspace": "", "generation": 17, "fitness": 0.34454583516538956, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.345 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "49e9d0e4-4027-4198-966f-52083d00a1b7", "metadata": {"aucs": [0.3187681013307453, 0.37654147777579916, 0.3383279263896243], "final_y": [0.0003380140302123144, 2.544881960013884e-05, 5.3736581111096636e-05]}, "mutation_prompt": null}
{"id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Adaptive Chaotic Differential Evolution with dynamic scaling factor and chaotic crossover rate for improved balance.", "configspace": "", "generation": 18, "fitness": 0.5230666321472787, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.523 with standard deviation 0.031. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "49e9d0e4-4027-4198-966f-52083d00a1b7", "metadata": {"aucs": [0.4934882251209114, 0.5654811450292025, 0.5102305262917219], "final_y": [4.982374068297639e-07, 3.699743000155531e-08, 6.148716632008198e-08]}, "mutation_prompt": null}
{"id": "53384fbd-7c25-4f66-85e1-e65bd7ec2cc2", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n        self.mutation_factor = 0.2\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def chaotic_mutation_factor(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, 1)\n        return 0.1 + chaotic_seq[0] * 0.9\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                adaptive_mutation_factor = self.chaotic_mutation_factor()\n                mutant = population[a] + adaptive_mutation_factor * (population[b] - population[c]) + self.mutation_factor * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Advanced Chaotic Differential Evolution with dynamic chaotic mutation and adaptive crossover for enhanced exploration and exploitation.", "configspace": "", "generation": 19, "fitness": 0.2770352145863906, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.277 with standard deviation 0.016. And the mean value of best solutions found was 0.005 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.29654961369436794, 0.27657066241435946, 0.25798536765044433], "final_y": [0.00027735055161332776, 0.0027159158024587333, 0.012717298736042985]}, "mutation_prompt": null}
{"id": "27412d7b-52d4-4b9c-9a32-7c46edd33c62", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget * 0.5:\n                self.population_size = int(self.population_size * 0.9)  # Reduce population size\n                self.dim = max(1, self.dim - 1)  # Reduce dimensionality\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Chaotic Differential Evolution with Time-Varying Population and Dimensionality Reduction for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {}, "mutation_prompt": null}
{"id": "037509ae-a84d-4b99-82e7-d1fd9f083548", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                chaotic_mutation_factor = 0.1 * self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + chaotic_mutation_factor * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Adaptive Chaotic Differential Evolution with a dynamic and chaotic mutation strategy for improved exploration.", "configspace": "", "generation": 21, "fitness": 0.4698137356415046, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.470 with standard deviation 0.032. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.45055745439632755, 0.44360812331591737, 0.5152756292122689], "final_y": [1.5515802228124561e-06, 1.3500625201056557e-06, 2.6275326596098903e-07]}, "mutation_prompt": null}
{"id": "0ba97f2e-8553-4db1-ae0d-4e698a2150e4", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def dynamic_population_adaptation(self, evaluations):\n        if evaluations > self.budget // 2:\n            self.population_size = max(5, self.population_size // 2)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            self.dynamic_population_adaptation(evaluations)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + np.random.uniform(-0.1, 0.1, self.dim)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Improved Chaotic Differential Evolution with enhanced mutation strategy and dynamic population adaptation for better exploration and exploitation balance.", "configspace": "", "generation": 22, "fitness": 0.2542283609215958, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.254 with standard deviation 0.007. And the mean value of best solutions found was 0.037 (0. is the best) with standard deviation 0.020.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.26435479775857673, 0.2474141730937377, 0.2509161119124729], "final_y": [0.023287941727443764, 0.06509393720701995, 0.024047754861912764]}, "mutation_prompt": null}
{"id": "ae91082a-cec1-4018-bc10-a9de608f40d2", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamically reduce population size\n            if evaluations % (self.budget // 5) == 0:\n                self.population_size = max(4, int(self.population_size * 0.9))\n                population = population[:self.population_size]\n                fitness = fitness[:self.population_size]\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introducing dynamic population size reduction to enhance convergence efficiency in Chaotic Differential Evolution.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 19 is out of bounds for axis 0 with size 18').", "error": "IndexError('index 19 is out of bounds for axis 0 with size 18')", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {}, "mutation_prompt": null}
{"id": "ded90d95-8cdc-4076-aab6-9c0ffdd901bf", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.15 * (population[d] - population[i])  # Increased mutation step\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Adaptive Chaotic Differential Evolution with dynamic scaling factor, chaotic crossover rate, and refined mutation step for improved solution quality.", "configspace": "", "generation": 24, "fitness": 0.41620171362956065, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.416 with standard deviation 0.011. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.423381793165465, 0.425124414892896, 0.40009893283032094], "final_y": [6.016170781698728e-07, 9.551532079822043e-07, 1.558491116291989e-06]}, "mutation_prompt": null}
{"id": "2f2ba23d-d75c-4263-9b9a-1ad9dd68e701", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n        self.chaotic_sequence_cache = {}\n\n    def chaotic_sequence(self, seed, n):\n        if (seed, n) in self.chaotic_sequence_cache:\n            return self.chaotic_sequence_cache[(seed, n)]\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        self.chaotic_sequence_cache[(seed, n)] = result\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def dynamic_mutation_strategy(self, population, best_solution, i, a, b, c):\n        mutation_rate = 0.3 + 0.7 * np.mean(population, axis=0)\n        mutant = best_solution + mutation_rate * (population[a] - population[b] + population[c] - population[i])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.dynamic_mutation_strategy(population, best_solution, i, a, b, c)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Improved Chaotic Differential Evolution with dynamic mutation strategy and enhanced chaotic crossover to boost exploration and exploitation.", "configspace": "", "generation": 25, "fitness": 0.09735329218511964, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.097 with standard deviation 0.002. And the mean value of best solutions found was 4.194 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.09645149598433256, 0.09610188392469188, 0.09950649664633449], "final_y": [4.211640247576694, 4.195930450224511, 4.173338903361582]}, "mutation_prompt": null}
{"id": "a1faeca0-7149-4d90-8aab-124262fbc4b5", "solution": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased population size\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 4.0 * x * (1.0 - x)  # Improved chaotic sequence for better exploration\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def update_population(self, population, fitness, best_idx):  # New helper method\n        inertia_weight = 0.5 + np.random.rand() / 2\n        best_pos = population[best_idx]\n        for i in range(self.population_size):\n            if i != best_idx:\n                population[i] = inertia_weight * population[i] + (best_pos - population[i])\n                population[i] = np.clip(population[i], self.lb, self.ub)\n        return population, fitness\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n            population, fitness = self.update_population(population, fitness, best_idx)  # Swarm intelligence update\n\n        return best_solution", "name": "EnhancedChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with dynamic swarm intelligence and improved chaotic sequence for global exploration.", "configspace": "", "generation": 26, "fitness": 0.19026057262756732, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.190 with standard deviation 0.044. And the mean value of best solutions found was 0.647 (0. is the best) with standard deviation 0.566.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.18373272436145938, 0.14034553445534548, 0.24670345906589708], "final_y": [0.4334673392003505, 1.4213785975363502, 0.08611608643783004]}, "mutation_prompt": null}
{"id": "b9539e53-a5fb-45a3-897d-4429f444c842", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self, size):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, size * self.dim)\n        population = np.array(chaotic_seq).reshape(size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def dynamic_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size / (1 + 0.1 * evaluations / self.budget)))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        population = self.initialize_population(population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            population_size = self.dynamic_population_size(evaluations)\n            for i in range(population_size):\n                indices = list(range(population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                r = np.random.rand()\n                mutant = population[a] + r * adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with adaptive population size and dynamic mutation strategy for improved convergence.", "configspace": "", "generation": 27, "fitness": 0.3731216904257617, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.373 with standard deviation 0.128. And the mean value of best solutions found was 0.132 (0. is the best) with standard deviation 0.186.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.5048091209600788, 0.19895501603192212, 0.41560093428528433], "final_y": [1.5368615256041256e-05, 0.39595447943874196, 0.0010504195174418159]}, "mutation_prompt": null}
{"id": "48461118-e90e-47be-a933-d8be9ab7d292", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.95 * x * (1.0 - x)  # Slightly changed chaotic sequence multiplier\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.9 + 0.1 * chaotic_cross  # Adjusted crossover rate calculation\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Adaptive Chaotic Differential Evolution with improved chaotic sequences and crossover strategy.", "configspace": "", "generation": 28, "fitness": 0.5116429135106234, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.512 with standard deviation 0.010. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.5007325200614308, 0.5250905182891643, 0.5091057021812754], "final_y": [4.949261673432147e-08, 1.2084964477633582e-07, 5.423969718499872e-08]}, "mutation_prompt": null}
{"id": "07888386-4e21-4577-85bc-0a367d6b8a05", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def nonlinear_chaotic_mutation(self, x, y, z, w):\n        chaotic_factor = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n        return x + chaotic_factor * ((y - z) * np.cos(w))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = self.nonlinear_chaotic_mutation(population[a], population[b], population[c], population[d])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introducing a Nonlinear Chaotic Mutation Strategy for Enhanced Exploration in Chaotic Differential Evolution.", "configspace": "", "generation": 29, "fitness": 0.36440069630805144, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.364 with standard deviation 0.044. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.31909451519740817, 0.424480822958341, 0.3496267507684051], "final_y": [2.890874490780302e-05, 2.4801629364311214e-06, 1.6383710629097216e-05]}, "mutation_prompt": null}
{"id": "90614179-579b-4386-a75d-fdbe5735b984", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def levy_flight(self, L):\n        return np.random.normal(0, 1, self.dim) / np.power(np.random.normal(0, 1), 1/L)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n        L = 1.5  # Levy flight index\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                levy_step = self.levy_flight(L)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + levy_step\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.6 + 0.4 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with Lévy Flight for exploration and novel adaptive crossover rate for balance.", "configspace": "", "generation": 30, "fitness": 0.18201436295589635, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.182 with standard deviation 0.003. And the mean value of best solutions found was 0.457 (0. is the best) with standard deviation 0.145.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.17813265240701803, 0.18212014241863428, 0.18579029404203673], "final_y": [0.5026101648355845, 0.6075346337909904, 0.2602580000649294]}, "mutation_prompt": null}
{"id": "360f3e3c-5168-4b0d-880b-95df005f0777", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.2 * (population[d] - population[i])  # Changed line\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Improved success rate adaptation by adjusting mutation strategy to boost convergence speed.", "configspace": "", "generation": 31, "fitness": 0.4487937553805777, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.449 with standard deviation 0.049. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.45363556881688616, 0.38629550495732223, 0.5064501923675246], "final_y": [1.4528392834060252e-06, 4.332018648056223e-06, 2.57493588469716e-07]}, "mutation_prompt": null}
{"id": "66ed17d1-80b0-4c65-926f-c8618237c12c", "solution": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 5 * dim  # Reduced initial population size\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def levy_flight(self, size):\n        # Lévy flight step calculation\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + self.levy_flight(self.dim)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of population size\n            if success_count > self.population_size / 2:\n                self.population_size = min(self.population_size + 1, 10 * self.dim)\n            else:\n                self.population_size = max(self.population_size - 1, 5 * self.dim)\n\n        return best_solution", "name": "EnhancedChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with dynamic population size adjustment and Lévy flight-based mutation for improved exploration.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {}, "mutation_prompt": null}
{"id": "94571e0d-b541-49c8-a0e1-b994b8af9e02", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)  # Line 1 changed\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.2 * (population[d] - population[i])  # Line 2 changed\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.15 * chaotic_cross  # Line 3 changed\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Improved Adaptive Chaotic Differential Evolution with dynamic scaling factor and chaotic crossover rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": 0.4510083352684291, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.451 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.4554550663191842, 0.47022335749212696, 0.4273465819939761], "final_y": [1.927737398984837e-07, 1.1429913149603507e-06, 8.292029023266519e-07]}, "mutation_prompt": null}
{"id": "733ff076-4822-48b1-a278-6dc69680afcb", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self, population_size):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_population_size(self, evaluations):\n        return max(3, int(self.initial_population_size * (1 - evaluations / self.budget)))\n\n    def self_adaptive_crossover_rate(self, trial_fitness, current_fitness):\n        return 0.9 if trial_fitness < current_fitness else 0.6\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        population = self.initialize_population(population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = population_size\n\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(population_size):\n                indices = list(range(population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = self.self_adaptive_crossover_rate(fitness[i], fitness[best_idx])\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n            population_size = self.adaptive_population_size(evaluations)\n            population = self.initialize_population(population_size)\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with adaptive population size and self-adaptive crossover rate for improved convergence.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {}, "mutation_prompt": null}
{"id": "b70490d1-8272-466b-8b1d-07b0ac4cc624", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def opposition_based_learning(self, population):\n        opposition_population = self.lb + self.ub - population\n        return np.clip(opposition_population, self.lb, self.ub)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            opposition_population = self.opposition_based_learning(population)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, opposition_population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution by introducing opposition-based learning for better diversity and convergence.", "configspace": "", "generation": 35, "fitness": 0.36914424955234654, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.369 with standard deviation 0.145. And the mean value of best solutions found was 0.227 (0. is the best) with standard deviation 0.321.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.4737576370065527, 0.1640496101098573, 0.46962550154062976], "final_y": [9.389597071951318e-08, 0.6805393783190404, 2.891518945784062e-07]}, "mutation_prompt": null}
{"id": "959783b5-4986-440c-9644-429623e25d0d", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n        self.history = []\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def dynamic_chaotic_mutation(self, a, b, c, d, i, feedback):\n        chaos_factor = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n        direction = population[b] - population[c] + feedback * (population[d] - population[i])\n        return population[a] + self.F * chaos_factor * direction\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            feedback = np.average(fitness)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = self.dynamic_chaotic_mutation(a, b, c, d, i, feedback)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Integrates dynamic chaotic mutation with feedback mechanism for enhanced convergence and diversity in solution space.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'population' is not defined\").", "error": "NameError(\"name 'population' is not defined\")", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {}, "mutation_prompt": null}
{"id": "1de7d145-2ce8-47a6-b496-a44c6cfdf9b0", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n        self.chaotic_perturbation = np.random.rand() * 0.1  # Added line\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Add time-varying chaos to crossover rate\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0] + self.chaotic_perturbation  # Modified line\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Adaptive Chaotic Differential Evolution with time-varying chaotic perturbations for better exploration.", "configspace": "", "generation": 37, "fitness": 0.39745244967447874, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.397 with standard deviation 0.014. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.37797091241735525, 0.40471223701675774, 0.4096741995893233], "final_y": [9.044116350829877e-07, 7.502157098177125e-07, 5.641399771740052e-06]}, "mutation_prompt": null}
{"id": "44ea5689-4fb3-4f3b-a8e2-34e668bbcaf8", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.2 * np.tanh(success_rate))  # Modified scaling factor\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed + i, 1)[0]  # Modified chaotic seed usage\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Improved Chaotic Differential Evolution with adaptive chaotic sequences and enhanced scaling for better convergence.", "configspace": "", "generation": 38, "fitness": 0.28581842085389525, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.286 with standard deviation 0.009. And the mean value of best solutions found was 0.003 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.29765992583012746, 0.2822263100044148, 0.27756902672714356], "final_y": [0.0036644352581260415, 0.002931186096232539, 0.0037499573665405704]}, "mutation_prompt": null}
{"id": "18aced80-5097-43d5-ba09-d855a2afab33", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.9 + 0.1 * chaotic_cross  # Modified line\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Adaptive Chaotic Differential Evolution using a modified chaotic crossover rate for improved convergence.", "configspace": "", "generation": 39, "fitness": 0.4114695786723879, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.411 with standard deviation 0.121. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.4788085501357958, 0.24152952177942066, 0.5140706641019472], "final_y": [2.8296682069063276e-07, 0.00039041808316112465, 1.2272972349425306e-07]}, "mutation_prompt": null}
{"id": "e90d73b3-24f6-46fc-8d64-aed89e9a59f7", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def quantum_superposition(self, pop):\n        Q = np.random.rand(self.population_size, self.dim)\n        return np.where(Q < 0.5, pop, self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim))\n\n    def adaptive_mutation(self, success_rate):\n        return self.F * (1 + np.sin(success_rate * np.pi))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            population = self.quantum_superposition(population)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_mutation(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Chaotic Quantum-Inspired Differential Evolution with quantum superposition and adaptive mutation for enhanced convergence.", "configspace": "", "generation": 40, "fitness": 0.16052765455710882, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.161 with standard deviation 0.012. And the mean value of best solutions found was 0.861 (0. is the best) with standard deviation 0.103.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.16231085615101692, 0.1748515965749574, 0.14442051094535213], "final_y": [0.9017570722736569, 0.7194241431451832, 0.9622205775397906]}, "mutation_prompt": null}
{"id": "d84fd1b9-c291-437d-85d7-1af9fc0f6b3c", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] - adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Adaptive Chaotic Differential Evolution with mutation strategy variation for improved exploration.", "configspace": "", "generation": 41, "fitness": 0.48422756623798674, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.484 with standard deviation 0.006. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.4852467058685581, 0.47655171815486097, 0.4908842746905413], "final_y": [3.9076448902262744e-07, 1.05823603773028e-07, 4.2568587196608496e-08]}, "mutation_prompt": null}
{"id": "d4b6c2ff-5aa2-4b42-a163-8d8438f68975", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n        self.diversity_threshold = 0.1  # New diversity threshold\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_mutation(self, population, fitness):  # New adaptive mutation strategy\n        avg_fitness = np.mean(fitness)\n        diversity = np.std(population, axis=0).mean()\n        if diversity < self.diversity_threshold:\n            return self.F * 2  # Increase mutation factor when diversity is low\n        return self.F\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            adaptive_F = self.adaptive_mutation(population, fitness)  # Use adaptive mutation\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Improved Chaotic Differential Evolution with adaptive mutation strategy and enhanced convergence through diversity preservation.", "configspace": "", "generation": 42, "fitness": 0.39258664383790426, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.393 with standard deviation 0.017. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.402099518339628, 0.4063785214779849, 0.36928189169610004], "final_y": [2.434182188865614e-05, 7.708464381931398e-05, 0.00012993825007417934]}, "mutation_prompt": null}
{"id": "a9bb6f96-3608-4d32-9bbd-705ad5145d7f", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def opposition_based_learning(self, population):\n        opposite_population = self.lb + self.ub - population\n        return opposite_population\n\n    def dynamic_scaling_factor(self, success_rate, iteration):\n        return self.F * (0.6 + 0.4 * np.exp(-iteration / 1000))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        iteration = 0\n\n        while evaluations < self.budget:\n            success_count = 0\n            opposite_population = self.opposition_based_learning(population)\n            opposite_fitness = np.apply_along_axis(func, 1, opposite_population)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if opposite_fitness[i] < fitness[i]:\n                    population[i] = opposite_population[i]\n                    fitness[i] = opposite_fitness[i]\n                    if fitness[i] < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = population[i]\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = population[a] + self.dynamic_scaling_factor(success_count / self.population_size, iteration) * (population[b] - population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            iteration += 1\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with Opposition-Based Learning and Dynamic Scale Adaptation for improved exploration and exploitation.", "configspace": "", "generation": 43, "fitness": 0.275165167105247, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.275 with standard deviation 0.026. And the mean value of best solutions found was 0.003 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.24480463216865178, 0.307221887701432, 0.27346898144565723], "final_y": [0.0050713872969068196, 0.0006880437780477268, 0.0029201941743713035]}, "mutation_prompt": null}
{"id": "f1415f37-814b-49a1-8c5d-17eeb13292d2", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.97 * x * (1.0 - x)  # Slight change in chaotic sequence formula\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Improved the Chaotic Differential Evolution by making a minor adjustment in the chaotic sequence generation to enhance exploration.", "configspace": "", "generation": 44, "fitness": 0.4897518814220681, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.490 with standard deviation 0.035. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.44963603253983453, 0.4846997794589053, 0.5349198322674644], "final_y": [4.856167276321379e-07, 1.5778620149435595e-07, 8.554132110364581e-08]}, "mutation_prompt": null}
{"id": "32c14178-57be-48ec-b682-442062f076c1", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.initial_population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.initial_population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_population_size(self, evaluations):\n        max_pop_size = self.initial_population_size\n        min_pop_size = self.dim\n        return int(min_pop_size + (max_pop_size - min_pop_size) * (1 - evaluations / self.budget))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.initial_population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            pop_size = self.adaptive_population_size(evaluations)\n            for i in range(pop_size):\n                indices = list(range(pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                chaotic_mutation = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + chaotic_mutation * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / pop_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with adaptive population size and dynamic chaotic mutation for improved exploration.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {}, "mutation_prompt": null}
{"id": "131ba9ef-c365-471d-8aca-22e88a1311f1", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                self.population_size = max(5, int(self.population_size * (0.95 + 0.1 * (success_count / self.population_size))))\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introduce a dynamic population size adjustment to enhance exploitation and exploration balance.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('list.remove(x): x not in list').", "error": "ValueError('list.remove(x): x not in list')", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {}, "mutation_prompt": null}
{"id": "98d8218a-a5ba-44a3-bca4-9dcbe465b261", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 4.0 * x * (1.0 - x)  # Changed from 3.91 to 4.0 for better chaotic behavior\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed + i / self.population_size, 1)[0]  # Adjusted seed for chaotic crossover\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Improved Adaptive Chaotic Differential Evolution with adjusted chaotic sequence parameters for enhanced exploration-exploitation balance.", "configspace": "", "generation": 47, "fitness": 0.28292645799696187, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.283 with standard deviation 0.005. And the mean value of best solutions found was 0.007 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.28992235512749354, 0.27848095215994206, 0.28037606670345006], "final_y": [0.005698941269895406, 0.006556092897471057, 0.00853099441117254]}, "mutation_prompt": null}
{"id": "81feba9a-9f8f-4777-9f0b-fafe2f07abf4", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.8 * x * (1.0 - x)  # Modified logistic map parameter for better chaos\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n        memory = np.zeros((self.population_size, self.dim))  # Memory for past best solutions\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Introduce memory-based diversity\n                d = np.random.choice(indices)\n                memory_trial = memory[np.random.choice(indices)]\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i]) + 0.1 * (memory_trial - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n                        memory[i] = trial  # Update memory with the best trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Improved Adaptive Chaotic Differential Evolution with enhanced diversity introduction and memory-based crossover for better exploration-exploitation balance.", "configspace": "", "generation": 48, "fitness": 0.3092742681383855, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.309 with standard deviation 0.013. And the mean value of best solutions found was 0.007 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.3163291930455311, 0.29131076931881716, 0.32018284205080827], "final_y": [0.005660233378038636, 0.0059152201653231784, 0.008938934884474963]}, "mutation_prompt": null}
{"id": "d1642e8e-653a-4e87-9b0b-d97eb05ac48c", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                chaotic_factor = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                mutant = population[a] + chaotic_factor * adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Improved Chaotic Differential Evolution with adaptive chaotic crossover and mutation strategies for enhanced convergence.", "configspace": "", "generation": 49, "fitness": 0.48529479396977565, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.485 with standard deviation 0.047. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.5190446437964094, 0.4193167978602945, 0.517522940252623], "final_y": [5.3455895293901826e-08, 0.0001911373067487878, 8.691807573082141e-08]}, "mutation_prompt": null}
{"id": "b0c03f44-d55f-45a6-ab02-c8c31accb10d", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def levy_flight(self, step_size=0.01, beta=1.5):\n        sigma1 = np.power((np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2)) / \n                          (np.math.gamma((1 + beta) / 2) * beta * np.power(2, (beta - 1) / 2)), 1 / beta)\n        sigma2 = 1\n        u = np.random.normal(0, sigma1, self.dim)\n        v = np.random.normal(0, sigma2, self.dim)\n        step = u / np.power(np.abs(v), 1 / beta)\n        return step_size * step\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                if np.random.rand() < 0.1:  # Apply Lévy flight with 10% probability\n                    mutant += self.levy_flight()\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Incorporating Lévy flights into Chaotic Differential Evolution for enhanced exploration and exploitation balance.", "configspace": "", "generation": 50, "fitness": 0.41281542125268045, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.413 with standard deviation 0.028. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.4185444808972648, 0.4439110494373394, 0.37599073342343703], "final_y": [2.7621735816915577e-06, 2.3323495911178863e-06, 4.583531375787615e-06]}, "mutation_prompt": null}
{"id": "83b28a11-f1a3-42bb-99d6-a4594eefa77f", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                    self.chaotic_seed = (self.chaotic_seed + 0.1) % 1.0  # Slightly alter chaotic seed\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Differential Evolution using chaotic initialization and adaptive parameters for robust solution discovery.", "configspace": "", "generation": 51, "fitness": 0.5082930998120986, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.508 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.495351920859756, 0.541322667113681, 0.4882047114628585], "final_y": [8.96085082329647e-08, 2.2188878725684478e-08, 1.5176953834900405e-07]}, "mutation_prompt": null}
{"id": "aa5995c6-5b5b-4c3b-99c6-e47d5ee8837c", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def dynamic_learning_strategy(self, population, best_solution):\n        perturb = np.random.normal(0, 0.1, self.dim)\n        new_dim = np.random.randint(1, self.dim)\n        for i in range(self.population_size):\n            if np.random.rand() < 0.2:\n                population[i, :new_dim] = best_solution[:new_dim] + perturb[:new_dim]\n        return population\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                mutant = population[a] + adaptive_F * (population[b] - population[c]) + 0.1 * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n            population = self.dynamic_learning_strategy(population, best_solution)\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with dynamic dimensional learning strategy to exploit promising regions more effectively.", "configspace": "", "generation": 52, "fitness": 0.2723500666805172, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.272 with standard deviation 0.020. And the mean value of best solutions found was 0.032 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.26389842456879753, 0.30047754599878307, 0.252674229473971], "final_y": [0.03559106300566933, 0.0169737529261213, 0.04250189148878348]}, "mutation_prompt": null}
{"id": "4e2094dc-51c5-4548-9b3f-7e5244c4b8f9", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand()\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])  # Modified line\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                chaotic_cross = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n                self.crossover_rate = 0.8 + 0.2 * chaotic_cross\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Improved mutation strategy using a weighted combination of the best and random solutions for enhanced exploration.", "configspace": "", "generation": 53, "fitness": 0.524098883258633, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.524 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e589d126-fd14-4e01-9ee8-0b0444706adf", "metadata": {"aucs": [0.5278754769142706, 0.5319409557600561, 0.5124802171015721], "final_y": [2.6334492191006685e-08, 9.128540882112607e-10, 9.815206757536679e-08]}, "mutation_prompt": null}
{"id": "4502cd7d-c4c6-4879-96a7-a0d0e8110e18", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def dynamic_scaling(self, iter, budget):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n        return self.F * (1 + 0.5 * chaotic_seq * (1 - iter / budget))\n\n    def dynamic_crossover(self, iter, budget):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, 1)[0]\n        return 0.7 + 0.3 * chaotic_seq * (1 - iter / budget)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand()\n                mutant = best_solution + self.dynamic_scaling(evaluations, self.budget) * (population[b] - population[c]) + random_weight * (population[d] - population[i])  # Modified line 1\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.dynamic_crossover(evaluations, self.budget)  # Modified line 2\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introduced dynamic scaling and crossover rates based on chaotic maps to enhance exploitation and exploration balance.", "configspace": "", "generation": 54, "fitness": 0.46452097779829665, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.465 with standard deviation 0.023. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4e2094dc-51c5-4548-9b3f-7e5244c4b8f9", "metadata": {"aucs": [0.47080096415081973, 0.48870328079353664, 0.4340586884505335], "final_y": [1.1318003243698707e-06, 2.2214774503945695e-06, 4.024873803388499e-06]}, "mutation_prompt": null}
{"id": "904befee-4189-4db4-85ae-45379706d4b1", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)  # Modified line\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Incorporating adaptive chaotic crossover rate and dynamic weighting for improved balance between exploration and exploitation.", "configspace": "", "generation": 55, "fitness": 0.7052750666868851, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.705 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4e2094dc-51c5-4548-9b3f-7e5244c4b8f9", "metadata": {"aucs": [0.6986808625127241, 0.7162814241172835, 0.7008629134306479], "final_y": [4.282387991245812e-12, 1.391305853230448e-13, 1.3848658038289291e-12]}, "mutation_prompt": null}
{"id": "489054ab-4097-4e08-99df-94d88c2b513c", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)  # Modified line\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n                        self.chaotic_seed = 0.5 * (self.chaotic_seed + np.random.rand())  # Modified line\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introducing a dynamic chaotic seed adjustment for enhancing exploration capability.", "configspace": "", "generation": 56, "fitness": 0.49786635907473625, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.498 with standard deviation 0.245. And the mean value of best solutions found was 0.458 (0. is the best) with standard deviation 0.648.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.6791399192408996, 0.662894832473438, 0.1515643255098713], "final_y": [2.408520414029369e-12, 2.0180837061456086e-12, 1.3754533068082508]}, "mutation_prompt": null}
{"id": "afc6c30d-8367-4c1e-b448-25ea2bd207ed", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter + np.random.rand())  # Modified line\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)  # Modified line\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introducing stochastic element in adaptive crossover rate for enhanced exploration capabilities.", "configspace": "", "generation": 57, "fitness": 0.6949932984457036, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.695 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.7037114926662602, 0.6848858349746209, 0.6963825676962296], "final_y": [1.7400188708236982e-11, 3.079708949544817e-11, 5.310671404907294e-11]}, "mutation_prompt": null}
{"id": "ab6cb0c5-ba11-46e9-b4cc-d46bb037388b", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F  \n                chaotic_factor = self.chaotic_sequence(self.chaotic_seed + iteration, 1)[0] \n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + chaotic_factor * random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Incorporating a dynamic chaotic factor to diversify mutation vectors for enhanced exploration.", "configspace": "", "generation": 58, "fitness": 0.13725406396727177, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.003. And the mean value of best solutions found was 1.600 (0. is the best) with standard deviation 0.484.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.13922526617755504, 0.13237482001647216, 0.1401621057077881], "final_y": [0.9412116668333722, 2.090618902524967, 1.7693475477415668]}, "mutation_prompt": null}
{"id": "d823ca91-9f92-48ed-b46a-7f502055c603", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        # Introducing perturbation for better exploration\n        perturbation = np.random.normal(0, 0.01, population.shape)\n        return self.lb + (population + perturbation) * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introduced perturbation to chaotic sequence for enhanced exploration diversity.", "configspace": "", "generation": 59, "fitness": 0.6684182728788085, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.668 with standard deviation 0.012. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.6589571594751189, 0.6612061223107981, 0.6850915368505085], "final_y": [3.0848792669487955e-12, 2.859851746424272e-12, 1.529843198352253e-12]}, "mutation_prompt": null}
{"id": "73a04eb1-1258-4ce6-8902-a323f81027ee", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def adaptive_chaotic_weight(self, iteration):  # New function added\n        return 0.3 + 0.7 * np.sin(2 * np.pi * iteration / self.population_size)\n\n    def tournament_selection(self, fitness):  # New function added\n        idx1, idx2 = np.random.choice(len(fitness), 2, replace=False)\n        return idx1 if fitness[idx1] < fitness[idx2] else idx2\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = self.tournament_selection(fitness)  # Modified line\n                chaotic_weight = self.adaptive_chaotic_weight(iteration)  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + chaotic_weight * (population[d] - population[i])  # Modified line\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introducing adaptive chaotic weights and tournament selection for a more robust search process.", "configspace": "", "generation": 60, "fitness": 0.5097003312310187, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.510 with standard deviation 0.010. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.5217989213806054, 0.5093476933417999, 0.497954378970651], "final_y": [3.518689808977822e-08, 8.247335715677805e-08, 1.7754333030807167e-06]}, "mutation_prompt": null}
{"id": "1a333121-1740-478e-964a-612102f2f6f4", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            if iteration > 0 and iteration % (max_iter // 5) == 0:  # Random restart condition\n                population = self.initialize_population()  # New restart\n                fitness = np.apply_along_axis(func, 1, population)  # Recalculate fitness\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhance exploration by introducing random restarts and optimizing chaotic sequence use.  ", "configspace": "", "generation": 61, "fitness": 0.32563582783567907, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.326 with standard deviation 0.025. And the mean value of best solutions found was 0.007 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.30497497964419484, 0.3109690535574202, 0.3609634503054222], "final_y": [0.01005631553176758, 0.009864438381268666, 0.0007201681751420322]}, "mutation_prompt": null}
{"id": "b9cd6937-24a3-4e33-83f0-57a9686a3a3a", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Introduce chaotic mutation through adaptive chaotic sequence\n                chaotic_weight = self.chaotic_sequence(np.random.rand(), 1)[0]  # New line\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + chaotic_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)  # Modified line\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhancing the exploration-exploitation balance by introducing chaotic mutation and adaptive mutation selection.", "configspace": "", "generation": 62, "fitness": 0.3609753749081181, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.361 with standard deviation 0.007. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.3668812173597795, 0.3651910775437367, 0.350853829820838], "final_y": [2.0087106710574265e-05, 4.972350239730488e-05, 6.104667381444258e-05]}, "mutation_prompt": null}
{"id": "5264d2f2-1843-41f3-92a0-37deb97159e2", "solution": "import numpy as np\n\nclass ImprovedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate, iteration, max_iter):\n        exploration_factor = 1.0 - np.cos(np.pi * iteration / max_iter)\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate)) * exploration_factor\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size, iteration, max_iter)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ImprovedChaoticDifferentialEvolution", "description": "Enhance differential evolution using a chaotic sequence for initialization and adaptive strategies for scaling and crossover based on exploration-exploitation dynamics.", "configspace": "", "generation": 63, "fitness": 0.17684989752779925, "feedback": "The algorithm ImprovedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.177 with standard deviation 0.041. And the mean value of best solutions found was 1.109 (0. is the best) with standard deviation 1.132.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.18458368739424036, 0.22298112809376036, 0.12298487709539707], "final_y": [0.6588631983408353, 0.0029922472005287004, 2.6648462063599005]}, "mutation_prompt": null}
{"id": "7a895225-ebb3-41c0-832c-f5567a6bb270", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F\n                chaotic_scaling = self.chaotic_sequence(self.chaotic_seed, 1)[0]  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + chaotic_scaling * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introduce chaotic mutation scaling for enhanced exploration during evolution.", "configspace": "", "generation": 64, "fitness": 0.1515580055339489, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.152 with standard deviation 0.000. And the mean value of best solutions found was 1.375 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.15159901556081157, 0.15156343465280875, 0.15151156638822638], "final_y": [1.3754533068082602, 1.3754533068106833, 1.3754533069727666]}, "mutation_prompt": null}
{"id": "d324892d-4a09-4eba-a9db-ff1e05f51bad", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                chaotic_factor = self.chaotic_sequence(self.chaotic_seed, 1)[0]  # Modified line\n                random_weight = np.random.rand() * adaptive_F\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + chaotic_factor * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introducing a chaotic scaling factor to further enhance exploration capabilities.", "configspace": "", "generation": 65, "fitness": 0.1515580055339489, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.152 with standard deviation 0.000. And the mean value of best solutions found was 1.375 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.15159901556081157, 0.15156343465280875, 0.15151156638822638], "final_y": [1.3754533068082602, 1.3754533068106833, 1.3754533069727666]}, "mutation_prompt": null}
{"id": "52e6435b-e4d1-4ee5-8833-da144dabedcc", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.97 * x * (1.0 - x)  # Changed line: adjusted chaotic constant to improve variability\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)  # Modified line\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhance exploration by increasing chaotic sequence variability to improve solution diversity.", "configspace": "", "generation": 66, "fitness": 0.6763384918314298, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.676 with standard deviation 0.003. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.6776024604908649, 0.6718472410226406, 0.6795657739807843], "final_y": [6.047631800851208e-10, 8.295872186999792e-12, 2.1697466238511166e-12]}, "mutation_prompt": null}
{"id": "04ad20db-6357-4f7d-bfb3-d2b1ad881e82", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            chaotic_weights = self.chaotic_sequence(self.chaotic_seed, self.population_size)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = chaotic_weights[i] * adaptive_F  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)  # Modified line\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introduce dynamic chaotic weight in the mutation strategy for diversified search and better convergence.", "configspace": "", "generation": 67, "fitness": 0.6477987869570906, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.648 with standard deviation 0.015. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.633674245038838, 0.6414592708664633, 0.6682628449659707], "final_y": [2.5175609757141407e-10, 3.7425622272388453e-10, 6.10451011574117e-11]}, "mutation_prompt": null}
{"id": "77408c23-0d90-4215-bc96-b0fcedb358ac", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate, fitness_variance):  # Modified line\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate) + 0.05 * fitness_variance)  # Modified line\n\n    def adaptive_crossover_rate(self, iteration, max_iter, fitness_variance):  # Modified line\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter) + 0.05 * fitness_variance  # Modified line\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            fitness_variance = np.var(fitness)  # Added line\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant += np.random.normal(0, 0.01, self.dim)  # Modified line\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter, fitness_variance)  # Modified line\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size, fitness_variance)  # Modified line\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhancing diversity by introducing a mutation strategy using a Gaussian perturbation and improving adaptive parameters based on fitness variance.", "configspace": "", "generation": 68, "fitness": 0.29898007565209894, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.299 with standard deviation 0.093. And the mean value of best solutions found was 0.328 (0. is the best) with standard deviation 0.462.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.36276576104458946, 0.1669198634778024, 0.36725460243390495], "final_y": [0.0014330757897821867, 0.9814616764453694, 0.0013948349690604905]}, "mutation_prompt": null}
{"id": "ae1fad6c-6318-4fbb-96ba-2dc928573fb6", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size=size)\n        v = np.random.normal(0, 1, size=size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                levy_step = self.levy_flight(self.dim)  # Added line\n                mutant = best_solution + levy_step * (population[b] - population[c])  # Modified line\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Utilizing chaotic initialization with Lévy flight-based mutation and adaptive selection pressure for enhanced exploration and convergence.", "configspace": "", "generation": 69, "fitness": 0.6848705819056028, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.685 with standard deviation 0.014. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.7026747202024073, 0.68225172816091, 0.6696852973534909], "final_y": [9.470849224883695e-13, 8.694856233367894e-12, 6.6681930008008185e-12]}, "mutation_prompt": null}
{"id": "d827cd2f-7584-4a8f-a1aa-e0eff21b4ac6", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * np.random.randn(self.dim)  # Modified line\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)  # Modified line\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introduced stochastic perturbation to enhance exploration in mutation.", "configspace": "", "generation": 70, "fitness": 0.2771692126427596, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.277 with standard deviation 0.006. And the mean value of best solutions found was 0.019 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.27354869152400074, 0.27227973181958953, 0.2856792145846886], "final_y": [0.0297762785475024, 0.013107878298168353, 0.01283522726444058]}, "mutation_prompt": null}
{"id": "c1de2691-a801-4f6c-a1c0-5883796fcfaf", "solution": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def chaotic_mutation(self, candidate, best_solution, b, c, d):\n        chaotic_factor = np.random.uniform(0, 1)\n        return candidate + chaotic_factor * (best_solution - candidate) + self.F * (b - c) + chaotic_factor * (d - candidate)\n    \n    def self_adaptive_population(self, population, fitness):\n        sorted_indices = np.argsort(fitness)\n        return population[sorted_indices[:len(population) // 2]]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                \n                mutant = self.chaotic_mutation(population[i], best_solution, population[b], population[c], population[d])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n            population = self.self_adaptive_population(population, fitness)\n            self.population_size = len(population)\n\n        return best_solution", "name": "EnhancedChaoticDifferentialEvolution", "description": "Enhanced Chaotic Differential Evolution with adaptive chaotic mutation and self-adaptive population dynamics for improved convergence.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 12 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 12 is out of bounds for axis 0 with size 10')", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {}, "mutation_prompt": null}
{"id": "d3af3a57-f586-41e2-965c-f8303b2e4d65", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        # Introduced a stochastic element for chaotic sequence generation\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed * np.random.rand(), self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        # Enhanced adaptive scaling factor calculation\n        return self.F * (1.0 + 0.15 * np.tanh(success_rate - 0.5))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)  # Modified line\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introducing stochastic chaotic sequence generation and enhancing adaptive scaling factor for better convergence.", "configspace": "", "generation": 72, "fitness": 0.6561357913516215, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.656 with standard deviation 0.015. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.6415147630146987, 0.6764842139077667, 0.6504083971323991], "final_y": [6.022650979171293e-11, 8.114044083292768e-12, 1.8650470190702207e-11]}, "mutation_prompt": null}
{"id": "30d43f11-5622-4a5e-aca3-fe220688f3b5", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n            self.chaotic_seed = 3.91 * self.chaotic_seed * (1.0 - self.chaotic_seed)  # Modified line\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introducing a dynamic chaotic seed to enhance exploration and diversity in the population.", "configspace": "", "generation": 73, "fitness": 0.5034561914102288, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.503 with standard deviation 0.249. And the mean value of best solutions found was 0.458 (0. is the best) with standard deviation 0.648.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.7007284414630175, 0.6581348297674154, 0.15150530300025356], "final_y": [3.946441264919318e-12, 4.198330490052295e-11, 1.3754533068082508]}, "mutation_prompt": null}
{"id": "835ceeb5-c10b-4380-b72d-a8ed97ffd2cf", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        decay_factor = 0.01  # Modified line\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x) * (1 - decay_factor) \n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)  # Modified line\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introducing a decay factor to the chaotic sequence to enhance exploration-exploitation balance.", "configspace": "", "generation": 74, "fitness": 0.4992512752267258, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.499 with standard deviation 0.247. And the mean value of best solutions found was 0.458 (0. is the best) with standard deviation 0.648.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.6544672983286048, 0.692892917299824, 0.15039361005174856], "final_y": [5.7340820586866325e-11, 2.7013694459265445e-12, 1.3754533068082493]}, "mutation_prompt": null}
{"id": "6651c2fb-3fa9-4cd0-b43c-1a88d509ef62", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)  # Changed line\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introduce a Gaussian perturbation to the mutant vector to enhance exploration and prevent premature convergence.", "configspace": "", "generation": 75, "fitness": 0.29474467284191314, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.295 with standard deviation 0.017. And the mean value of best solutions found was 0.021 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.31868939493383563, 0.2816278451570442, 0.28391677843485963], "final_y": [0.011268857020001896, 0.03538852669426213, 0.01731692994891093]}, "mutation_prompt": null}
{"id": "35f1ccbb-afc7-4324-b5ed-61843c39a1a6", "solution": "import numpy as np\n\nclass RefinedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.9  # Adjusted crossover rate\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n        self.local_search_prob = 0.2  # New parameter for local search probability\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.2 * np.tanh(success_rate))  # Adjusted scaling mechanism\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.cos(np.pi * iteration / max_iter)  # Modified line\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_prob:  # Local search condition\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = population[a] + adaptive_F * (population[b] - population[c])\n                else:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    d = np.random.choice(indices)\n                    random_weight = np.random.rand() * adaptive_F\n                    mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "RefinedChaoticDifferentialEvolution", "description": "Incorporating chaotic initialization, adaptive mutation strategies, and a balance of global and local search to enhance convergence and solution quality.", "configspace": "", "generation": 76, "fitness": 0.6488140226999023, "feedback": "The algorithm RefinedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.649 with standard deviation 0.027. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.6372319520014846, 0.6225755141677167, 0.6866346019305055], "final_y": [3.3016362674364704e-08, 1.407636815728633e-07, 4.4979581665667e-09]}, "mutation_prompt": null}
{"id": "8a533de9-c999-4110-94ba-6a86960832d0", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                # Modified line\n                random_weight = np.random.rand() * adaptive_F * (0.5 + 0.5 * (np.sin(iteration) + 1)) \n                # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introducing dynamic scaling of chaotic seed and stochastic mutation rate for enhanced adaptability and convergence.", "configspace": "", "generation": 77, "fitness": 0.6310394509256994, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.631 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.6390727530977831, 0.6475053853781545, 0.6065402143011603], "final_y": [2.7028423166341776e-11, 3.899438380875969e-10, 1.008532668827373e-10]}, "mutation_prompt": null}
{"id": "d3630246-7a80-400a-97fb-eccc458c80c7", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                diversity_factor = np.std(population) / np.mean(population)  # New dynamic mutation factor\n                random_weight = np.random.rand() * adaptive_F * (1 + diversity_factor)  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introduce a dynamic mutation strategy based on population diversity for enhanced exploration.", "configspace": "", "generation": 78, "fitness": 0.5666246511194625, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.567 with standard deviation 0.014. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.5478031446478708, 0.5699301353663935, 0.5821406733441232], "final_y": [8.110852649186436e-08, 4.690875715407293e-09, 1.9975088900239894e-08]}, "mutation_prompt": null}
{"id": "b8d2080f-e325-49c5-80b6-6e28c4cd6d47", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            if success_count / self.population_size > 0.1:  # Modified line\n                self.population_size = min(self.population_size + 1, 20 * self.dim)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introducing a dynamic population size adjustment based on performance to improve convergence.", "configspace": "", "generation": 79, "fitness": 0.5034561914102288, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.503 with standard deviation 0.249. And the mean value of best solutions found was 0.458 (0. is the best) with standard deviation 0.648.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.7007284414630175, 0.6581348297674154, 0.15150530300025356], "final_y": [3.946441264919318e-12, 4.198330490052295e-11, 1.3754533068082508]}, "mutation_prompt": null}
{"id": "5b7a3836-acbc-4db7-8033-19b43076969f", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                chaotic_mutation = 0.01 * np.random.rand(self.dim)  # Change made here\n                random_weight = np.random.rand() * adaptive_F\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i]) + chaotic_mutation\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introducing a chaotic mutation step to enhance diversity in solution updates.", "configspace": "", "generation": 80, "fitness": 0.3621202235837358, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.362 with standard deviation 0.008. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.3580932908533533, 0.354441007906771, 0.37382637199108315], "final_y": [0.002507813364484276, 0.002815491184099675, 0.0020464562781754526]}, "mutation_prompt": null}
{"id": "26ffc608-5e42-45e2-8c5e-732922050483", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def local_search(self, solution):\n        perturbation = np.random.normal(0, 0.01, self.dim)  # New line for local search perturbation\n        new_solution = solution + perturbation\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)  # Modified line\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial = self.local_search(trial)  # New line to integrate local search\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhance diversity and convergence efficiency by integrating a hybrid local search and chaotic mutation strategy.", "configspace": "", "generation": 81, "fitness": 0.3309198847904078, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.331 with standard deviation 0.012. And the mean value of best solutions found was 0.003 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.3458568502121654, 0.32903719505519935, 0.31786560910385864], "final_y": [0.0009340565269211779, 0.005086826023478657, 0.0043385097634541896]}, "mutation_prompt": null}
{"id": "784a104b-44d1-4e3a-9b0b-e95a43935ba7", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim  # Modified line\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def adjust_population_size(self, iteration, max_iter):  # Modified line\n        return int(self.initial_population_size * (0.5 + 0.5 * (1 - iteration / max_iter)))  # Modified line\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            self.population_size = self.adjust_population_size(iteration, max_iter)  # Modified line\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introducing a dynamic population size adaptation strategy alongside improved chaotic crossover rate tuning for enhanced solution refinement.", "configspace": "", "generation": 82, "fitness": 0.5468280689853241, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.547 with standard deviation 0.183. And the mean value of best solutions found was 0.015 (0. is the best) with standard deviation 0.021.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.2883959473832889, 0.6564490356306917, 0.6956392239419917], "final_y": [0.0450185260636739, 8.352330609778446e-08, 1.4601551216632935e-12]}, "mutation_prompt": null}
{"id": "28f672f4-3798-4877-ace7-4f9a269fb0a5", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        chaotic_factor = self.chaotic_sequence(self.chaotic_seed, 1)[0]  # Modified line\n        return self.F * (chaotic_factor + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)  # Modified line\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introducing a chaotic scaling factor for improved convergence by enhancing exploration dynamics.  ", "configspace": "", "generation": 83, "fitness": 0.6145495669928017, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.615 with standard deviation 0.026. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.6337972601319046, 0.5782518791186757, 0.6315995617278247], "final_y": [6.752487558319364e-10, 1.8045369957953773e-10, 7.661065175817382e-11]}, "mutation_prompt": null}
{"id": "e066f8fd-bd7b-40b3-a5a6-0a9e699972a3", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F\n                chaotic_factor = self.chaotic_sequence(self.chaotic_seed, 1)[0]  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i]) * chaotic_factor\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced mutation strategy by introducing a nonlinear chaotic map to improve diversity and convergence.", "configspace": "", "generation": 84, "fitness": 0.5049483919821774, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.505 with standard deviation 0.250. And the mean value of best solutions found was 0.458 (0. is the best) with standard deviation 0.648.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.6797178131661501, 0.6836168987596631, 0.1515104640207191], "final_y": [1.455491031518248e-12, 8.329231491881769e-13, 1.3754533068082495]}, "mutation_prompt": null}
{"id": "beb73447-559c-4ba5-b888-f760a7eda2d1", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        # Applying chaotic perturbation\n        perturbation = np.sin(np.arange(self.population_size * self.dim)).reshape(self.population_size, self.dim)\n        population = (population + 0.1 * perturbation) % 1.0\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)  # Modified line\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhancing solution diversity by incorporating chaotic perturbation in population initialization.", "configspace": "", "generation": 85, "fitness": 0.6779712507809363, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.678 with standard deviation 0.012. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.6892385902903582, 0.6831677859228674, 0.6615073761295833], "final_y": [9.233386831463257e-13, 2.1061913785071674e-12, 5.735272163489751e-12]}, "mutation_prompt": null}
{"id": "8f138618-2127-4e21-a71c-1616529d28c8", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.uniform(0.7, 1.3) * adaptive_F  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced exploration by introducing randomness in dynamic weighting, slightly improving adaptability.", "configspace": "", "generation": 86, "fitness": 0.5437783250691148, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.544 with standard deviation 0.022. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.5544998135348741, 0.5642801932556697, 0.5125549684168007], "final_y": [4.844781781504153e-08, 2.106749695726618e-08, 2.1929954660486062e-07]}, "mutation_prompt": null}
{"id": "72cb232d-d9d6-478d-818d-26b017a0ac27", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, 1)  # Modified line\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate) * chaotic_seq[0])  # Modified line\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)  # Modified line\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introducing a chaotic scaling factor for improved exploration dynamics.", "configspace": "", "generation": 87, "fitness": 0.5120735122713621, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.512 with standard deviation 0.255. And the mean value of best solutions found was 0.458 (0. is the best) with standard deviation 0.648.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.6844263629877836, 0.7002886396064965, 0.15150553421980617], "final_y": [1.718201038080347e-10, 1.6603501533942621e-12, 1.3754533068082504]}, "mutation_prompt": null}
{"id": "b4267377-5401-4791-a0dd-b84b685af481", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            self.chaotic_seed += 0.01  # Modified line\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Refining ChaoticDifferentialEvolution by adding a dynamic chaotic seed modulation to enhance exploration and convergence.", "configspace": "", "generation": 88, "fitness": 0.5034561914102288, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.503 with standard deviation 0.249. And the mean value of best solutions found was 0.458 (0. is the best) with standard deviation 0.648.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.7007284414630175, 0.6581348297674154, 0.15150530300025356], "final_y": [3.946441264919318e-12, 4.198330490052295e-11, 1.3754533068082508]}, "mutation_prompt": null}
{"id": "bb2d0795-31dc-4f8d-96ed-915b510521c2", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * np.sin(x * np.pi) * (1.0 - x)  # Modified line\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introducing a nonlinear chaotic sequence to enhance population diversity and convergence speed.", "configspace": "", "generation": 89, "fitness": 0.1425837113456443, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.143 with standard deviation 0.000. And the mean value of best solutions found was 1.738 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.1425837113456443, 0.1425837113456443, 0.1425837113456443], "final_y": [1.7376573761203, 1.7376573761203, 1.7376573761203]}, "mutation_prompt": null}
{"id": "2417e7ae-2126-4e47-8976-0b21709650d6", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant += np.random.normal(0, 0.01, self.dim)  # New random perturbation\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)  # Modified line\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhancing population diversity by introducing random perturbation to avoid premature convergence.", "configspace": "", "generation": 90, "fitness": 0.34680708514702374, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.347 with standard deviation 0.007. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.34454654622524206, 0.35588322895891644, 0.3399914802569127], "final_y": [0.001879972856108891, 0.0012814754772104016, 0.0017508171237141036]}, "mutation_prompt": null}
{"id": "ca8fee59-3ad6-42ef-96c8-f42131f695de", "solution": "import numpy as np\n\nclass ImprovedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def levy_flight(self, L):\n        return np.random.normal(0, L, size=self.dim)\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                if np.random.rand() < 0.5:  # Introducing Levy flight with probability 0.5\n                    mutant = best_solution + adaptive_F * (population[b] - population[c]) + self.levy_flight(1.5)\n                else:\n                    mutant = best_solution + adaptive_F * (population[b] - population[c]) + self.F * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ImprovedChaoticDifferentialEvolution", "description": "Enhancing exploration by introducing Levy flights and adaptive mutation for improved solution diversity.", "configspace": "", "generation": 91, "fitness": 0.35771604621439496, "feedback": "The algorithm ImprovedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.358 with standard deviation 0.027. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.32057261586069463, 0.3827262823050108, 0.36984924047747947], "final_y": [0.00185942432091237, 4.684949636201351e-05, 0.00019622608843155288]}, "mutation_prompt": null}
{"id": "996fdc4d-9d33-4cef-99ef-b23e1b710a05", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)  # Modified line\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n            adaptive_F *= np.exp(-success_count / self.population_size)  # Modified line\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhanced adaptive control incorporating chaotic sequences and exponential scaling for improved convergence.", "configspace": "", "generation": 92, "fitness": 0.6573463980239369, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.657 with standard deviation 0.105. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.7194347452515083, 0.7435687857260858, 0.5090356630942168], "final_y": [0.0, 2.2665168632114292e-14, 3.178874204852623e-05]}, "mutation_prompt": null}
{"id": "e5cec0ee-f222-4d1e-994c-3f0854b96f84", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.97 * x * (1.0 - x)  # Modified line\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)  # Modified line\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhance chaotic sequence randomness by adjusting the chaotic parameter for improved exploration. ", "configspace": "", "generation": 93, "fitness": 0.6763384918314298, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.676 with standard deviation 0.003. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.6776024604908649, 0.6718472410226406, 0.6795657739807843], "final_y": [6.047631800851208e-10, 8.295872186999792e-12, 2.1697466238511166e-12]}, "mutation_prompt": null}
{"id": "d6e759de-1280-43d4-a1b6-d679e406d3e9", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F * (1 - iteration / max_iter)  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introduce a dynamic weighting factor based on iteration progress to enhance exploration-exploitation balance.", "configspace": "", "generation": 94, "fitness": 0.5157739985233126, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.516 with standard deviation 0.258. And the mean value of best solutions found was 0.458 (0. is the best) with standard deviation 0.648.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.7046806685009779, 0.6911360441845441, 0.15150528288441556], "final_y": [9.168594624381134e-14, 2.5302130251930746e-13, 1.3754533068082504]}, "mutation_prompt": null}
{"id": "680e7bd4-4a91-4f69-862c-f0d65327b662", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)  # Modified line\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < 0.1:  # Modified line\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introducing a diversity preservation mechanism by modifying the selection strategy to occasionally pick diverse solutions.", "configspace": "", "generation": 95, "fitness": 0.6614480366246788, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.661 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.6720780203876004, 0.6591505288226405, 0.6531155606637955], "final_y": [6.388437520767284e-12, 2.986469136095035e-11, 1.4587670708926104e-11]}, "mutation_prompt": null}
{"id": "e87ce048-8885-4d02-a3df-7b2ceba57a1f", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def dynamic_mutation_scale(self, fitness):\n        return 0.5 + 0.5 * np.var(fitness)  # New line for dynamic mutation scaling\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            adaptive_F = self.dynamic_mutation_scale(fitness)  # Modified line for dynamic mutation scaling\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhancing exploration with dynamic mutation scaling based on current fitness variance.", "configspace": "", "generation": 96, "fitness": 0.09900247286754027, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.099 with standard deviation 0.002. And the mean value of best solutions found was 3.694 (0. is the best) with standard deviation 1.067.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.09747850007828851, 0.10178402997516878, 0.09774488854916352], "final_y": [4.655212724445739, 2.2059822969513467, 4.219958985217683]}, "mutation_prompt": null}
{"id": "be8d239a-7dda-4183-8ead-90f32e01161a", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed1 = 0.5678\n        self.chaotic_seed2 = 0.6789  # Added second chaotic seed\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq1 = self.chaotic_sequence(self.chaotic_seed1, self.population_size * self.dim)\n        chaotic_seq2 = self.chaotic_sequence(self.chaotic_seed2, self.population_size * self.dim)  # Second sequence\n        population = (np.array(chaotic_seq1) + np.array(chaotic_seq2)).reshape(self.population_size, self.dim) / 2  # Averaging\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F  # Modified line\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)  # Modified line\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Utilizes a dual chaotic sequence approach for enhanced solution diversity and convergence stability.", "configspace": "", "generation": 97, "fitness": 0.6840546680118811, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.684 with standard deviation 0.005. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.6779105264550204, 0.6885974852986663, 0.6856559922819567], "final_y": [2.1344857487785274e-12, 2.058675262927557e-12, 2.476924613759692e-12]}, "mutation_prompt": null}
{"id": "575c074b-3217-47d3-b5a1-f263ab2c02d0", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F  # Modified line\n                random_vector = np.random.rand(self.dim)  # New line for random vector influence\n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i]) + random_vector * 0.1\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter)  # Modified line\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Enhance exploration by introducing a scaled random vector influence in the mutation step.", "configspace": "", "generation": 98, "fitness": 0.3053576326629156, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.305 with standard deviation 0.023. And the mean value of best solutions found was 0.008 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.3335032896834146, 0.27603413121902, 0.30653547708631224], "final_y": [0.003738507178209417, 0.01796195855931898, 0.0037220528524988974]}, "mutation_prompt": null}
{"id": "9e523288-6496-486d-8849-1755e7239c95", "solution": "import numpy as np\n\nclass ChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.crossover_rate = 0.85\n        self.F = 0.5\n        self.lb, self.ub = None, None\n        self.chaotic_seed = 0.5678\n        self.inertia_weight = 0.9  # New line\n\n    def chaotic_sequence(self, seed, n):\n        x = seed\n        result = []\n        for _ in range(n):\n            x = 3.91 * x * (1.0 - x)\n            result.append(x)\n        return result\n\n    def initialize_population(self):\n        chaotic_seq = self.chaotic_sequence(self.chaotic_seed, self.population_size * self.dim)\n        population = np.array(chaotic_seq).reshape(self.population_size, self.dim)\n        return self.lb + population * (self.ub - self.lb)\n\n    def adaptive_scaling_factor(self, success_rate):\n        return self.F * (0.9 + 0.1 * np.tanh(success_rate))\n\n    def adaptive_crossover_rate(self, iteration, max_iter):\n        return 0.7 + 0.3 * np.sin(np.pi * iteration / max_iter)\n\n    def adaptive_inertia_weight(self, iteration, max_iter):  # New function\n        return 0.4 + 0.5 * (1 - iteration / max_iter)  # New line\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        evaluations = self.population_size\n        adaptive_F = self.F\n\n        max_iter = self.budget // self.population_size\n        for iteration in range(max_iter):\n            success_count = 0\n            self.inertia_weight = self.adaptive_inertia_weight(iteration, max_iter)  # New line\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                d = np.random.choice(indices)\n                random_weight = np.random.rand() * adaptive_F \n                mutant = best_solution + adaptive_F * (population[b] - population[c]) + random_weight * (population[d] - population[i])\n                mutant = self.inertia_weight * mutant + (1 - self.inertia_weight) * population[i]  # Modified line\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                self.crossover_rate = self.adaptive_crossover_rate(iteration, max_iter) \n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1\n\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best_solution = trial\n                        adaptive_F = self.adaptive_scaling_factor(success_count / self.population_size)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "ChaoticDifferentialEvolution", "description": "Introducing an adaptive inertia weight and modified mutation strategy in ChaoticDifferentialEvolution for enhanced exploration and exploitation balance.", "configspace": "", "generation": 99, "fitness": 0.7121298315931722, "feedback": "The algorithm ChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.712 with standard deviation 0.012. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "904befee-4189-4db4-85ae-45379706d4b1", "metadata": {"aucs": [0.7046990955001424, 0.7290223404224985, 0.7026680588568759], "final_y": [0.0, 0.0, 2.8339513904566506e-10]}, "mutation_prompt": null}
