{"id": "188a596c-473c-457f-a6af-9b727c48668f", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A hybrid genetic-simulated annealing algorithm that combines population-based exploration with local refinement to efficiently navigate complex search spaces.", "configspace": "", "generation": 0, "fitness": 0.8141912615545751, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.049. And the mean value of best solutions found was 0.145 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7606534142740471, 0.8787265942224565, 0.8031937761672217], "final_y": [0.15238315794020807, 0.1271736282956687, 0.1554953294727649]}, "mutation_prompt": null}
{"id": "fbefa3c6-2106-4676-8d3a-d306cf024cd4", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n        self.dynamic_mutation = 0.05  # Adaptive mutation rate increment\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n\n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        self.mutation_rate += self.dynamic_mutation  # Adjust mutation rate\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate * 0.99  # Adaptive cooling\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An enhanced hybrid genetic-simulated annealing algorithm incorporating dynamic mutation and adaptive cooling rate for improved convergence.", "configspace": "", "generation": 1, "fitness": 0.797134864270458, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.797 with standard deviation 0.011. And the mean value of best solutions found was 0.149 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.8033929325543149, 0.8060738541148343, 0.7819378061422249], "final_y": [0.13688650986864015, 0.14851302367762642, 0.16095158262297704]}, "mutation_prompt": null}
{"id": "e82ac22d-7c4f-438d-bd7f-47b5c374872f", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_mutation_rate = self.mutation_rate * (1 - float(self.budget_used) / self.budget)\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        self.budget_used = len(population)\n\n        while self.budget_used < self.budget:\n            new_population = []\n            elite_index = np.argmin(fitness)\n            new_population.append(population[elite_index])  # Elitism\n            for _ in range((self.population_size - 1) // 2): # Adjusted loop for elitism\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            self.budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                self.budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid algorithm with adaptive mutation and elitism for better convergence and diversity retention.", "configspace": "", "generation": 2, "fitness": 0.7947769259276368, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.795 with standard deviation 0.012. And the mean value of best solutions found was 0.151 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7775946841016391, 0.8057289612079426, 0.8010071324733286], "final_y": [0.16037157123122026, 0.15581344506869055, 0.13691709333948576]}, "mutation_prompt": null}
{"id": "73193506-04cd-480b-8aa7-016bd1c427cc", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_mutation_rate = self.mutation_rate * (1 - (self.budget_used / self.budget))\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:  # Change made here\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        self.budget_used = len(population)\n\n        while self.budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            self.budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                self.budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced mutation strategy with dynamically adjusted mutation rate to improve exploration capabilities.", "configspace": "", "generation": 3, "fitness": 0.7961690930662085, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.796 with standard deviation 0.028. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7712473632955971, 0.8360589853615356, 0.7812009305414929], "final_y": [0.16056430053156812, 0.13820037343924485, 0.15212473393626236]}, "mutation_prompt": null}
{"id": "25b25bab-b304-4cef-81c3-4545647fba96", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(20):  # Increased local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic-simulated annealing algorithm with increased local search steps for improved exploration.", "configspace": "", "generation": 4, "fitness": 0.7857202192925826, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.786 with standard deviation 0.011. And the mean value of best solutions found was 0.151 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7767377755858068, 0.779354532921567, 0.8010683493703739], "final_y": [0.15373587753484053, 0.16133963689545894, 0.13768254634845933]}, "mutation_prompt": null}
{"id": "56f1486d-09cf-4544-acc4-524db87fd955", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate * (1 - (budget_used / self.budget))  # Adaptive cooling rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic-simulated annealing algorithm with adaptive cooling rate for improved exploration-exploitation balance.", "configspace": "", "generation": 5, "fitness": 0.7890564616981761, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.789 with standard deviation 0.015. And the mean value of best solutions found was 0.148 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7902479077055825, 0.8063764954207333, 0.7705449819682124], "final_y": [0.1428587539252596, 0.15045768917209745, 0.149920951580655]}, "mutation_prompt": null}
{"id": "a171a076-6459-47d5-afee-1d694cfd599c", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                self.mutation_rate = 0.1 * (1 - budget_used / self.budget)  # Adjust mutation rate dynamically\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An enhanced hybrid genetic-simulated annealing algorithm that increases population diversity through dynamic mutation rate adjustment for better exploration. ", "configspace": "", "generation": 6, "fitness": 0.7855932916892524, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.786 with standard deviation 0.018. And the mean value of best solutions found was 0.149 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7608313855519383, 0.80197346107313, 0.7939750284426892], "final_y": [0.16299356048733427, 0.1471763787708813, 0.13777764871755716]}, "mutation_prompt": null}
{"id": "2a8b98ae-7ef2-40e6-9297-f20f7ee542d2", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_mutation_rate = self.mutation_rate * (1 - self.temperature / 1000.0)\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An enhanced hybrid genetic-simulated annealing algorithm with adaptive mutation rates to improve convergence and solution quality.", "configspace": "", "generation": 7, "fitness": 0.7620299924004935, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.762 with standard deviation 0.019. And the mean value of best solutions found was 0.157 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7407528950636244, 0.7874942313296627, 0.7578428508081937], "final_y": [0.1612250394300616, 0.14802519189030017, 0.16065309635725145]}, "mutation_prompt": null}
{"id": "c9324a07-5ac3-4508-801c-e74d0835f422", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):  # Adjusted line\n        dynamic_mutation_rate = max(self.mutation_rate, 1 / self.dim)\n        for i in range(self.dim):\n            if random.random() < dynamic_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A refined hybrid genetic-simulated annealing algorithm with a dynamic mutation rate to improve solution exploration and convergence.", "configspace": "", "generation": 8, "fitness": 0.7792105965095452, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.779 with standard deviation 0.015. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7846067896811864, 0.7939132315642344, 0.7591117682832149], "final_y": [0.1550951736082571, 0.14113535071106975, 0.15524977775784565]}, "mutation_prompt": null}
{"id": "5d2e2ece-317c-40cc-8295-b0b81b6d07e0", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                step_size = (bounds.ub[i] - bounds.lb[i]) * 0.1  # Adjusted mutation step size\n                individual[i] = np.clip(individual[i] + np.random.normal(0, step_size), bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic-simulated annealing algorithm with improved mutation strategy for better exploration and exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.7814739369942524, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.781 with standard deviation 0.029. And the mean value of best solutions found was 0.152 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7501040020604458, 0.8192814150668897, 0.7750363938554217], "final_y": [0.16448121038984553, 0.14030900656496315, 0.14980379512073516]}, "mutation_prompt": null}
{"id": "2b34aea2-cbde-4816-8513-00cb1fd677f8", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n        self.elite_size = 2\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_rate = self.mutation_rate * (1 - self.temperature / 1000)\n        for i in range(self.dim):\n            if random.random() < adaptive_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range((self.population_size - self.elite_size) // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic-simulated annealing with adaptive mutation rate and elitism for improved convergence and solution quality.", "configspace": "", "generation": 10, "fitness": 0.7552543770650813, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.755 with standard deviation 0.014. And the mean value of best solutions found was 0.161 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7378626538714173, 0.7718158188186972, 0.7560846585051295], "final_y": [0.16237567265271735, 0.16509399772463718, 0.1553576594110777]}, "mutation_prompt": null}
{"id": "0215b8bd-a6cd-4dc8-a5fb-3d408d8fa72a", "solution": "import numpy as np\nimport random\n\nclass MemeticAlgorithmDynamicAdaptation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.8  # Enhanced crossover rate\n        self.mutation_rate = 0.2   # Adaptive mutation rate\n        self.temperature = 800     # Reduced initial temperature\n        self.cooling_rate = 0.9    # Adaptive cooling rate\n        self.local_search_steps = 15  # Increased local refinement steps\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n\n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point1, point2 = sorted(random.sample(range(1, self.dim), 2))\n            child1 = np.concatenate([parent1[:point1], parent2[point1:point2], parent1[point2:]])\n            child2 = np.concatenate([parent2[:point1], parent1[point1:point2], parent2[point2:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(self.local_search_steps):  # Adjusted local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticAlgorithmDynamicAdaptation", "description": "A Memetic Algorithm with Dynamic Adaptation that synergizes genetic search with localized improvement and adaptive strategies to efficiently tackle complex optimization problems.", "configspace": "", "generation": 11, "fitness": 0.7716986720951567, "feedback": "The algorithm MemeticAlgorithmDynamicAdaptation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.772 with standard deviation 0.017. And the mean value of best solutions found was 0.156 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7484468114122695, 0.7789716642456037, 0.7876775406275973], "final_y": [0.15882857956901097, 0.1567745661921215, 0.15309478268567445]}, "mutation_prompt": null}
{"id": "a0e59267-c239-466f-b3b7-4a16d0c47638", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n        self.elite_fraction = 0.1  # added: fraction of elites to carry over\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = population[:int(self.elite_fraction * self.population_size)]  # retain elites\n            for _ in range((self.population_size - len(new_population)) // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                self.mutation_rate = max(0.01, self.mutation_rate * (1 - budget_used / self.budget))  # adapt mutation rate\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An enhanced hybrid genetic-simulated annealing algorithm incorporating adaptive mutation rates and elitism to improve solution quality and convergence speed.", "configspace": "", "generation": 12, "fitness": 0.7917261561869942, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.792 with standard deviation 0.017. And the mean value of best solutions found was 0.158 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7678567163481205, 0.8028310014165867, 0.8044907507962754], "final_y": [0.16911619319396587, 0.15399426155634377, 0.15053542318775814]}, "mutation_prompt": null}
{"id": "b1a0bc59-4172-4648-8477-535fcb897449", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [(f / total_fitness) ** 2 for f in fitness]  # Modify this line\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A refined hybrid genetic-simulated annealing algorithm that emphasizes diverse parent selection by scaling selection probabilities with a power factor.", "configspace": "", "generation": 13, "fitness": 0.7940610459667751, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.794 with standard deviation 0.037. And the mean value of best solutions found was 0.141 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7778851587451766, 0.8449769896323406, 0.7593209895228082], "final_y": [0.15227558817348352, 0.11945881509444567, 0.1502917693900444]}, "mutation_prompt": null}
{"id": "02af910e-145a-441f-936c-a56f1c7855eb", "solution": "import numpy as np\nimport random\n\nclass EnhancedHybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n        self.elitism_rate = 0.1  # New: elitism rate\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_mutation_rate = self.mutation_rate / (1 + self.budget)  # New: adaptive mutation rate\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(5):  # New: reduced local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            # New: Preserve elite individuals\n            num_elites = int(self.elitism_rate * self.population_size)\n            elites = combined[:num_elites]\n            remaining = combined[num_elites:self.population_size]\n            population, fitness = zip(*elites + remaining)\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "EnhancedHybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic algorithm with adaptive mutation rate and elitist strategy for improved exploration and exploitation balance.", "configspace": "", "generation": 14, "fitness": 0.7887654007154746, "feedback": "The algorithm EnhancedHybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.789 with standard deviation 0.007. And the mean value of best solutions found was 0.148 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7795610403166428, 0.7906148438198348, 0.796120318009946], "final_y": [0.15539362236182497, 0.1513940929348807, 0.13624890819439017]}, "mutation_prompt": null}
{"id": "b6490fb6-145c-4126-9d90-d80349d755a0", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_mutation_rate = 0.05 + 0.05 * random.random()  # Adaptively adjust mutation rate\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An enhanced hybrid genetic-simulated annealing algorithm with adaptive mutation rates for efficient exploration and exploitation.", "configspace": "", "generation": 15, "fitness": 0.7815203647969035, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.782 with standard deviation 0.021. And the mean value of best solutions found was 0.146 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7603923655126048, 0.8103145871622388, 0.7738541417158669], "final_y": [0.1492367053326238, 0.13862195787149822, 0.14980298033722173]}, "mutation_prompt": null}
{"id": "e2deb6f8-6ff9-4f58-bc87-3c9338d90fa4", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        diversity = np.std(individual) / (np.max(individual) - np.min(individual) + 1e-9)\n        adaptive_mutation_rate = self.mutation_rate * (1 + diversity)\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An improved hybrid genetic-simulated annealing algorithm that incorporates adaptive mutation rates based on diversity to enhance exploration in complex search spaces.", "configspace": "", "generation": 16, "fitness": 0.7832503094856039, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.783 with standard deviation 0.020. And the mean value of best solutions found was 0.157 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7617082474091733, 0.8092762018959417, 0.7787664791516967], "final_y": [0.16978056399674646, 0.14437257364680556, 0.15566945227912476]}, "mutation_prompt": null}
{"id": "dc358858-7bc5-4012-a5e1-106de5d672ba", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_rate = self.mutation_rate * (1 - self.temperature / 1000)  # Adaptive mutation rate\n        for i in range(self.dim):\n            if random.random() < adaptive_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            best_individual = min(zip(population, fitness), key=lambda x: x[1])[0]  # Elitism: track best individual\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size-1])\n            population, fitness = list(population), list(fitness)\n\n            population.append(best_individual)  # Elitism: retain the best individual\n            fitness.append(func(best_individual))\n\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An enhanced hybrid genetic-simulated annealing algorithm that incorporates adaptive mutation rates and elitism for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": 0.7661613783570428, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.766 with standard deviation 0.036. And the mean value of best solutions found was 0.161 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7257909769665116, 0.8131978068579018, 0.7594953512467149], "final_y": [0.16888137636602896, 0.14851603791874002, 0.16533502933624444]}, "mutation_prompt": null}
{"id": "144ca1c6-e539-4d41-8e3c-935d3b15625e", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def adaptive_mutation(self, individual, bounds, adapt_factor):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate * adapt_factor:\n                individual[i] += np.random.normal(0, 1) * (bounds.ub[i] - bounds.lb[i]) / 10\n                individual[i] = np.clip(individual[i], bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):\n            neighbor = self.adaptive_mutation(current.copy(), bounds, adapt_factor=1.0)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            adapt_factor = max(0.1, 1 - budget_used / self.budget)\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.adaptive_mutation(child1, bounds, adapt_factor)\n                child2 = self.adaptive_mutation(child2, bounds, adapt_factor)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic-simulated annealing algorithm with adaptive mutation and dynamic parameter tuning for improved exploration and exploitation balance.", "configspace": "", "generation": 18, "fitness": 0.7828201975011021, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.783 with standard deviation 0.026. And the mean value of best solutions found was 0.153 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7472875773205234, 0.8068461516349414, 0.7943268635478411], "final_y": [0.15988910319892813, 0.1479577732642703, 0.1500178863369377]}, "mutation_prompt": null}
{"id": "fbe6689b-4eda-47d1-a0a5-5442927cc543", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_mutation_rate = self.mutation_rate * (1 - self.temperature / 1000)  # Adaptive mutation rate\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic-simulated annealing algorithm with an adaptive mutation rate to improve exploration and convergence.", "configspace": "", "generation": 19, "fitness": 0.7713768385914527, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.771 with standard deviation 0.033. And the mean value of best solutions found was 0.157 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7316601584430196, 0.8133164004040256, 0.7691539569273125], "final_y": [0.17574567824544796, 0.14851603791874002, 0.1462575568127482]}, "mutation_prompt": null}
{"id": "e1e48bfe-b2cf-45a9-8219-9b9491d5273d", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n        self.mutation_adapt_factor = 0.9\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                if new_fitness[i] < min(fitness):  # Adaptive mutation\n                    self.mutation_rate *= self.mutation_adapt_factor\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic-simulated annealing algorithm by introducing adaptive mutation rates and elite preservation to improve convergence.", "configspace": "", "generation": 20, "fitness": 0.7980231033636777, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.798 with standard deviation 0.005. And the mean value of best solutions found was 0.152 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7962420965221249, 0.8052313749561126, 0.7925958386127956], "final_y": [0.15477115177678347, 0.15024320754389553, 0.15032668503414792]}, "mutation_prompt": null}
{"id": "50fe8918-1991-461f-a741-45c0403cdb15", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_mutation_rate = self.mutation_rate * (1.0 - (self.temperature / 1000))  # Modified line\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A genetically enhanced simulated annealing approach that incorporates a dynamic mutation rate for adaptive exploration in diverse search spaces.", "configspace": "", "generation": 21, "fitness": 0.7645739165034574, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.765 with standard deviation 0.007. And the mean value of best solutions found was 0.157 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.757863013876677, 0.7745330950883674, 0.7613256405453278], "final_y": [0.1616246798969595, 0.1633793570521287, 0.1465197340092832]}, "mutation_prompt": null}
{"id": "4f97e60d-ad1a-498e-a7eb-048b1a538f2b", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_mutation_rate = self.mutation_rate * (1 - self.temperature / 1000) # change\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An enhanced hybrid genetic-simulated annealing algorithm with an adaptive mutation rate for better exploration.", "configspace": "", "generation": 22, "fitness": 0.771510185621259, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.772 with standard deviation 0.011. And the mean value of best solutions found was 0.160 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7586165443407284, 0.770511744591066, 0.7854022679319824], "final_y": [0.164697165222512, 0.16940796931957258, 0.14458411578545083]}, "mutation_prompt": null}
{"id": "4b1ef3a6-0db0-47fd-9981-19b9b41b7188", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.90  # Changed cooling rate from 0.95 to 0.90\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_mutation_rate = self.mutation_rate * (self.temperature / 1000)  # Introduced adaptive mutation rate\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Improved temperature cooling strategy and adaptive mutation rate to enhance exploration and convergence efficiency.  ", "configspace": "", "generation": 23, "fitness": 0.7721786669177338, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.772 with standard deviation 0.024. And the mean value of best solutions found was 0.151 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7386220569533758, 0.7887138526387129, 0.7892000911611131], "final_y": [0.16958484462652113, 0.1375943980179385, 0.14645469888280782]}, "mutation_prompt": null}
{"id": "0802d885-99d9-46f9-bd6e-8ad4f56e0aab", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        dynamic_mutation_rate = self.mutation_rate * (self.temperature / 1000)  # Dynamic mutation rate\n        for i in range(self.dim):\n            if random.random() < dynamic_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A hybrid genetic-simulated annealing algorithm with dynamic mutation rate to enhance exploration-exploitation balance in complex search spaces.", "configspace": "", "generation": 24, "fitness": 0.7806503813850841, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.781 with standard deviation 0.008. And the mean value of best solutions found was 0.160 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7703082721577479, 0.781566071797491, 0.7900768002000136], "final_y": [0.16154524191775177, 0.16198547575333955, 0.15613247950637665]}, "mutation_prompt": null}
{"id": "42841b2e-a0bf-4e93-b198-3529a7ec6285", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        fitness = [f - min(fitness) + 1e-12 for f in fitness]  # Fitness scaling to reduce bias \n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An enhanced hybrid genetic-simulated annealing algorithm that incorporates fitness scaling for parent selection to improve exploitation without adversely affecting exploration.", "configspace": "", "generation": 25, "fitness": 0.7613803764224065, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.761 with standard deviation 0.005. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7573079803146829, 0.76890311738062, 0.7579300315719167], "final_y": [0.16784993989943175, 0.1702433386818767, 0.15996762644583884]}, "mutation_prompt": null}
{"id": "6b83c532-e67e-485d-b833-d8d593a48acd", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(15):  # Limit local search steps modified from 10 to 15\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A refined hybrid genetic-simulated annealing algorithm with enhanced local search to efficiently explore complex search spaces.", "configspace": "", "generation": 26, "fitness": 0.7778797745996204, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.778 with standard deviation 0.016. And the mean value of best solutions found was 0.159 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7554025153716215, 0.7916902079742129, 0.7865466004530267], "final_y": [0.16399637916803278, 0.15673233942945852, 0.15709056446065128]}, "mutation_prompt": null}
{"id": "714b5c77-eb51-4ec2-8a52-1b27324909f4", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        dynamic_mutation_rate = self.mutation_rate * (self.temperature / 1000) \n        for i in range(self.dim):\n            if random.random() < dynamic_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An enhanced hybrid genetic-simulated annealing algorithm with dynamic mutation rate adjustment based on temperature for improved exploration and convergence.", "configspace": "", "generation": 27, "fitness": 0.791461123681351, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.791 with standard deviation 0.006. And the mean value of best solutions found was 0.152 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.798996370765326, 0.7901478340872021, 0.7852391661915251], "final_y": [0.14997577006930007, 0.15240004102018845, 0.15339396012017392]}, "mutation_prompt": null}
{"id": "5d80b187-1a8d-4a25-b9f9-6f3d15e78ce9", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        self.crossover_rate = max(0.1, 1.0 - np.std(parent1 - parent2) / 10)  # Dynamic crossover rate adjustment\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Optimized crossover operation by dynamically adjusting crossover rate based on population diversity to enhance exploration efficiency.", "configspace": "", "generation": 28, "fitness": 0.7737179287102015, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.774 with standard deviation 0.024. And the mean value of best solutions found was 0.158 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.8003325698304053, 0.778495861400355, 0.7423253548998441], "final_y": [0.14321172321952802, 0.15539199658350167, 0.17396780113632182]}, "mutation_prompt": null}
{"id": "bf865229-738c-4821-9ae7-8a27b77f0a7d", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.97  # Adjusted for faster cooling\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += np.random.normal(0, 0.1) * (bounds.ub[i] - bounds.lb[i])  # Dynamic mutation\n                individual[i] = np.clip(individual[i], bounds.lb[i], bounds.ub[i])  # Ensure within bounds\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic-simulated annealing algorithm with dynamic mutation and adaptive cooling to improve convergence efficiency and solution quality.", "configspace": "", "generation": 29, "fitness": 0.8038691344976283, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.804 with standard deviation 0.040. And the mean value of best solutions found was 0.141 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7485886310452208, 0.8403210955167377, 0.8226976769309263], "final_y": [0.1501314403559615, 0.13817303560093497, 0.135447774955597]}, "mutation_prompt": null}
{"id": "7f3f51ee-ed4e-4914-8f05-180c664dacf8", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.15  # Changed from 0.1 to 0.15\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic-simulated annealing algorithm with an improved mutation rate for better exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": 0.8018002843059623, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.802 with standard deviation 0.008. And the mean value of best solutions found was 0.147 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.8130400148240641, 0.7958243224877192, 0.7965365156061035], "final_y": [0.13689886961238673, 0.1469013372324517, 0.15590203019592375]}, "mutation_prompt": null}
{"id": "56c1482a-f1c6-45ce-80a1-0d22d67fb3f0", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Increased population size for better exploration\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic-simulated annealing with a variable population size for better exploration and exploitation balance.  ", "configspace": "", "generation": 31, "fitness": 0.7963702682124936, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.796 with standard deviation 0.021. And the mean value of best solutions found was 0.149 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7869815695705756, 0.825028895749328, 0.7771003393175772], "final_y": [0.15430355263406337, 0.14414009698896646, 0.14991533829262627]}, "mutation_prompt": null}
{"id": "728a619a-71ba-4290-98a9-b0d59fb1ff48", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        dynamic_mutation_rate = self.mutation_rate * self.temperature / 1000  # Change 1\n        for i in range(self.dim):\n            if random.random() < dynamic_mutation_rate:  # Change 2\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A refined hybrid genetic-simulated annealing algorithm that includes a dynamic mutation rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 32, "fitness": 0.7977131377511295, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.798 with standard deviation 0.011. And the mean value of best solutions found was 0.138 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.8014797208412732, 0.8092501657283205, 0.7824095266837948], "final_y": [0.1466562346323521, 0.14400515211738885, 0.12303731248436434]}, "mutation_prompt": null}
{"id": "70d48274-7df2-4853-8f82-c5336541233c", "solution": "import numpy as np\nimport random\n\nclass EnhancedHybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n        self.elite_size = 2\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds, adapt_rate):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate * adapt_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(5):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds, adapt_rate=1)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            adapt_rate = max(0.1, 1 - (budget_used / self.budget))\n            for _ in range((self.population_size - self.elite_size) // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds, adapt_rate)\n                child2 = self.mutate(child2, bounds, adapt_rate)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "EnhancedHybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic-simulated annealing algorithm with adaptive mutation and elite preservation to improve solution quality and convergence.", "configspace": "", "generation": 33, "fitness": 0.8008513143805237, "feedback": "The algorithm EnhancedHybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.801 with standard deviation 0.012. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.794736363942216, 0.817338522530582, 0.7904790566687729], "final_y": [0.13029675722800238, 0.13915680468216118, 0.1464630706515193]}, "mutation_prompt": null}
{"id": "d4bd74cb-950e-44da-ad73-2fc2fe965c15", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n                self.mutation_rate = max(0.05, self.mutation_rate * 0.9)  # Adjust mutation rate\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An enhanced hybrid genetic-simulated annealing algorithm that refines local exploration by adjusting mutation based on fitness improvement.", "configspace": "", "generation": 34, "fitness": 0.7788355765302265, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.779 with standard deviation 0.021. And the mean value of best solutions found was 0.157 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7497324261755465, 0.7960430889531238, 0.7907312144620089], "final_y": [0.16461015777888788, 0.1545364956425952, 0.15229647700079252]}, "mutation_prompt": null}
{"id": "1d74597b-3655-432e-be54-d7f6fde18e5d", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n            self.mutation_rate *= 0.99  # Adaptive mutation rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A hybrid genetic-simulated annealing algorithm with adaptive mutation rate to enhance exploration in complex search spaces.", "configspace": "", "generation": 35, "fitness": 0.7738655484650224, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.774 with standard deviation 0.004. And the mean value of best solutions found was 0.154 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7695923305571228, 0.778894825324778, 0.7731094895131662], "final_y": [0.16419820074921754, 0.14529087000559482, 0.15214429748071157]}, "mutation_prompt": null}
{"id": "c1b7b046-c64b-4035-a441-e02ec1b50526", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.15  # Adjusted mutation rate for better exploration\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A hybrid genetic-simulated annealing algorithm with enhanced mutation strategy for improved exploration and exploitation balance.", "configspace": "", "generation": 36, "fitness": 0.8105205536651873, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.811 with standard deviation 0.035. And the mean value of best solutions found was 0.149 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.8573893905279257, 0.7724088800303962, 0.8017633904372397], "final_y": [0.1365273995263364, 0.16308816793893544, 0.1458954310646331]}, "mutation_prompt": null}
{"id": "6c0b1763-3da0-471d-8130-e4bd44865715", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.base_mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n        self.elitism_count = 2  # New elitism parameter\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_mutation_rate = self.base_mutation_rate * (0.5 + random.random())  # Adaptive mutation\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n    \n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            sorted_population = sorted(zip(population, fitness), key=lambda x: x[1])\n            elites = [ind for ind, _ in sorted_population[:self.elitism_count]]  # Elitism\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size - self.elitism_count] + elites)\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An enhanced hybrid genetic-simulated annealing algorithm that integrates adaptive mutation rates and elitism to improve convergence efficiency and solution quality.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {}, "mutation_prompt": null}
{"id": "9f8980ff-3806-4dc7-a3fa-16069547e0b3", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.05  # Reduced mutation rate\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_mutation_rate = self.mutation_rate * (self.temperature / 1000)  # Adaptive mutation rate\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Improved hybrid genetic-simulated annealing with adaptive mutation rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 38, "fitness": 0.7891417812030853, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.789 with standard deviation 0.028. And the mean value of best solutions found was 0.152 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7504334341302733, 0.8020752288069884, 0.8149166806719943], "final_y": [0.16356299634806948, 0.14902147800927046, 0.14444340295136082]}, "mutation_prompt": null}
{"id": "b2dd018c-2485-4df6-be8e-765d383a24a2", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n            self.mutation_rate = max(0.01, self.mutation_rate * 0.99)  # Adaptive mutation rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Improved Hybrid Genetic-Simulated Annealing algorithm with adaptive mutation rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 39, "fitness": 0.7917862274124721, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.792 with standard deviation 0.015. And the mean value of best solutions found was 0.155 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.8124540101806357, 0.7839914991458237, 0.7789131729109566], "final_y": [0.15148846898317803, 0.1541835649497656, 0.15969483709614618]}, "mutation_prompt": null}
{"id": "bb9dfa12-7f7e-4328-a62a-e2de672d349a", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size for better diversity\n        self.crossover_rate = 0.8  # Increased crossover rate for more exploration\n        self.mutation_rate = 0.2  # Increased mutation rate to introduce more variability\n        self.temperature = 2000  # Higher initial temperature for broader search\n        self.cooling_rate = 0.9  # Adjusted cooling rate for slower temperature decrease\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        if total_fitness == 0:\n            selection_probs = [1 / len(fitness) for _ in fitness]\n        else:\n            selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            return (np.concatenate([parent1[:point], parent2[point:]]),\n                    np.concatenate([parent2[:point], parent1[point:]]))\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(15):  # Increased local search steps for thorough refinement\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An improved hybrid algorithm combining genetic algorithms with adaptive simulated annealing for dynamic exploration-exploitation balance.", "configspace": "", "generation": 40, "fitness": 0.7662529645013006, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.766 with standard deviation 0.023. And the mean value of best solutions found was 0.157 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7378684960491864, 0.7952261811739362, 0.7656642162807791], "final_y": [0.15807577479456303, 0.1592256897393266, 0.15450161023266995]}, "mutation_prompt": null}
{"id": "7740b03d-da9d-4012-8b44-93a5f1939623", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size for better exploration\n        self.crossover_rate = 0.8  # Increased crossover rate for more recombination\n        self.mutation_rate = 0.05  # Decreased mutation rate to maintain stability\n        self.temperature = 1200  # Increased initial temperature for exploration\n        self.cooling_rate = 0.9  # Faster cooling to exploit solutions effectively\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n\n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point1, point2 = sorted(random.sample(range(1, self.dim), 2))  # Two-point crossover\n            child1 = np.concatenate([parent1[:point1], parent2[point1:point2], parent1[point2:]])\n            child2 = np.concatenate([parent2[:point1], parent1[point1:point2], parent2[point2:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(5):  # Reduced local search steps to save budget\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An enhanced hybrid algorithm integrating genetic algorithms and simulated annealing with adaptive population diversity and dynamic cooling for superior optimization efficiency.", "configspace": "", "generation": 41, "fitness": 0.787333416457567, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.787 with standard deviation 0.014. And the mean value of best solutions found was 0.147 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7740534275162785, 0.7818827611057915, 0.8060640607506311], "final_y": [0.14948855311505815, 0.15743163390980175, 0.13328433430485176]}, "mutation_prompt": null}
{"id": "fdcc72e4-13ce-44da-bd20-f8d4332131d3", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n        self.secondary_population_size = 10  # Additional population for diversity\n\n    def initialize_population(self, bounds):\n        primary_population = [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n        secondary_population = [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.secondary_population_size)]\n        return primary_population, secondary_population\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        selected = np.random.choice(len(population), 5, replace=False)  # Tournament selection\n        selected = sorted(selected, key=lambda x: fitness[x])\n        return population[selected[0]], population[selected[1]]\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_mutation_rate = self.mutation_rate * (1.0 - self.temperature / 1000)  # Adaptive mutation\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population, secondary_population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        secondary_fitness = self.evaluate_population(secondary_population, func)\n        budget_used = len(population) + len(secondary_population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population + secondary_population, fitness + new_fitness + secondary_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            secondary_population, secondary_fitness = zip(*combined[self.population_size:self.population_size+self.secondary_population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A dual-population hybrid genetic-simulated annealing algorithm with adaptive mutation rate and improved parent selection to enhance exploration and exploitation. ", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('can only concatenate list (not \"tuple\") to list').", "error": "TypeError('can only concatenate list (not \"tuple\") to list')", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {}, "mutation_prompt": null}
{"id": "7e0af656-8dc6-437b-81d6-44672050a96a", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.15  # Increased mutation rate for more diversity\n        self.temperature = 1000\n        self.cooling_rate = 0.90  # Adjusted cooling rate for slower cooling\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic-simulated annealing algorithm with improved cooling schedule and mutation diversity to better balance exploration and exploitation in complex search spaces.", "configspace": "", "generation": 43, "fitness": 0.7701045736737266, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.770 with standard deviation 0.013. And the mean value of best solutions found was 0.157 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7601866263764101, 0.7886024508012723, 0.7615246438434974], "final_y": [0.14646947366267782, 0.1598350014544847, 0.1658527327057342]}, "mutation_prompt": null}
{"id": "65ee89a0-c768-4a4e-a83c-3acd3e007684", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A hybrid genetic-simulated annealing algorithm that combines population-based exploration with local refinement to efficiently navigate complex search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: InternalServerError(\"Error code: 500 - {'error': {'message': 'The server had an error processing your request. Sorry about that! You can retry your request, or contact us through our help center at help.openai.com if you keep seeing this error. (Please include the request ID req_e7e55f669ae4ba1ccec348b6486fc454 in your email.)', 'type': 'server_error', 'param': None, 'code': None}}\").", "error": "InternalServerError(\"Error code: 500 - {'error': {'message': 'The server had an error processing your request. Sorry about that! You can retry your request, or contact us through our help center at help.openai.com if you keep seeing this error. (Please include the request ID req_e7e55f669ae4ba1ccec348b6486fc454 in your email.)', 'type': 'server_error', 'param': None, 'code': None}}\")", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7606534142740471, 0.8787265942224565, 0.8031937761672217], "final_y": [0.15238315794020807, 0.1271736282956687, 0.1554953294727649]}, "mutation_prompt": null}
{"id": "0a55044d-fd9f-4528-9d34-7f7231768bea", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A hybrid genetic-simulated annealing algorithm that combines population-based exploration with local refinement to efficiently navigate complex search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: InternalServerError(\"Error code: 500 - {'error': {'message': 'The server had an error processing your request. Sorry about that! You can retry your request, or contact us through our help center at help.openai.com if you keep seeing this error. (Please include the request ID req_401a52dd9112db7fc320b1b12dd70c16 in your email.)', 'type': 'server_error', 'param': None, 'code': None}}\").", "error": "InternalServerError(\"Error code: 500 - {'error': {'message': 'The server had an error processing your request. Sorry about that! You can retry your request, or contact us through our help center at help.openai.com if you keep seeing this error. (Please include the request ID req_401a52dd9112db7fc320b1b12dd70c16 in your email.)', 'type': 'server_error', 'param': None, 'code': None}}\")", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7606534142740471, 0.8787265942224565, 0.8031937761672217], "final_y": [0.15238315794020807, 0.1271736282956687, 0.1554953294727649]}, "mutation_prompt": null}
{"id": "ac252976-d6d2-4b04-a883-c88691e054ed", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A hybrid genetic-simulated annealing algorithm that combines population-based exploration with local refinement to efficiently navigate complex search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: InternalServerError(\"Error code: 500 - {'error': {'message': 'The server had an error processing your request. Sorry about that! You can retry your request, or contact us through our help center at help.openai.com if you keep seeing this error. (Please include the request ID req_28097267e4a74a047747d7e6e3f3ccf0 in your email.)', 'type': 'server_error', 'param': None, 'code': None}}\").", "error": "InternalServerError(\"Error code: 500 - {'error': {'message': 'The server had an error processing your request. Sorry about that! You can retry your request, or contact us through our help center at help.openai.com if you keep seeing this error. (Please include the request ID req_28097267e4a74a047747d7e6e3f3ccf0 in your email.)', 'type': 'server_error', 'param': None, 'code': None}}\")", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7606534142740471, 0.8787265942224565, 0.8031937761672217], "final_y": [0.15238315794020807, 0.1271736282956687, 0.1554953294727649]}, "mutation_prompt": null}
{"id": "ec9b0925-d486-4875-abef-6f8e339e2c6f", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1  # Dynamic mutation rate\n        self.temperature = 1000\n        self.cooling_rate = 0.95  # Adaptive cooling rate\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n\n            # Updated mutation_rate and cooling_rate\n            self.mutation_rate *= 1.01\n            self.temperature *= (self.cooling_rate + 0.01)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic-simulated annealing algorithm with dynamic mutation rate and adaptive cooling for improved exploration and convergence.", "configspace": "", "generation": 47, "fitness": 0.7959883996231598, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.796 with standard deviation 0.020. And the mean value of best solutions found was 0.151 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7680529454446623, 0.8140841981938813, 0.8058280552309358], "final_y": [0.15270648195202374, 0.14648898187817483, 0.15445307804232888]}, "mutation_prompt": null}
{"id": "1e6d204a-9723-46ca-987b-56c2645e3e13", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.15  # Increased mutation rate\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An enhanced hybrid genetic-simulated annealing algorithm with increased mutation rate to explore diverse solutions effectively.", "configspace": "", "generation": 48, "fitness": 0.7890233454886152, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.789 with standard deviation 0.016. And the mean value of best solutions found was 0.155 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7847858222175625, 0.8107138465353197, 0.7715703677129633], "final_y": [0.15378362241999044, 0.14714469370019456, 0.16258784739705334]}, "mutation_prompt": null}
{"id": "c4801abe-c787-4ad5-a17b-b1a2cc25bf3a", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate * (1 - i / self.dim):  # Enhanced mutation strategy\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population_size = min(self.population_size, self.budget - budget_used)  # Dynamic population size\n            new_population = []\n            for _ in range(new_population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A refined hybrid genetic-simulated annealing algorithm with enhanced mutation strategy and dynamic population size for better exploration and exploitation balance.", "configspace": "", "generation": 49, "fitness": 0.7718726241094128, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.772 with standard deviation 0.012. And the mean value of best solutions found was 0.151 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.757519084402589, 0.7879842053422488, 0.770114582583401], "final_y": [0.1588973186110859, 0.14806803453814643, 0.14654067007833516]}, "mutation_prompt": null}
{"id": "bd9ae5a7-ca97-428b-a156-c49a3ea3d498", "solution": "import numpy as np\nimport random\n\nclass HybridParticleSwarmGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.best_global = None\n        self.best_global_fitness = float('inf')\n\n    def initialize_population(self, bounds):\n        population = [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n        velocities = [np.zeros(self.dim) for _ in range(self.population_size)]\n        return population, velocities\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def update_velocity(self, velocity, position, best_position, bounds):\n        inertia = self.inertia_weight * velocity\n        cognitive = self.cognitive_weight * random.random() * (best_position - position)\n        social = self.social_weight * random.random() * (self.best_global - position)\n        return inertia + cognitive + social\n\n    def update_position(self, position, velocity, bounds):\n        new_position = position + velocity\n        new_position = np.clip(new_position, bounds.lb, bounds.ub)\n        return new_position\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def local_search(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(5):  # Limit local search steps to improve efficiency\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if neighbor_cost < current_cost:\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population, velocities = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n        best_positions = population.copy()\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                velocities[i] = self.update_velocity(velocities[i], population[i], best_positions[i], bounds)\n                population[i] = self.update_position(population[i], velocities[i], bounds)\n\n            new_fitness = self.evaluate_population(population, func)\n            budget_used += self.population_size\n\n            for i in range(self.population_size):\n                if new_fitness[i] < fitness[i]:\n                    best_positions[i] = population[i]\n                    fitness[i] = new_fitness[i]\n                \n                if fitness[i] < self.best_global_fitness:\n                    self.best_global = population[i]\n                    self.best_global_fitness = fitness[i]\n\n            for i in range(len(population)):\n                population[i], fitness[i] = self.local_search(population[i], fitness[i], func, bounds)\n                budget_used += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridParticleSwarmGeneticAlgorithm", "description": "A hybrid particle swarm-genetic algorithm with local search that leverages swarm intelligence for global exploration and genetic crossover for local refinement.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {}, "mutation_prompt": null}
{"id": "e2c81d97-b08f-4ca3-91c8-35bb55f58bd3", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.15  # Increased mutation rate for better exploration\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic-simulated annealing algorithm with refined mutation strategy for improved exploration and solution quality.", "configspace": "", "generation": 51, "fitness": 0.8054711113349446, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.805 with standard deviation 0.029. And the mean value of best solutions found was 0.149 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7698955385762977, 0.8066080159023052, 0.8399097795262311], "final_y": [0.15632329323315663, 0.1506041643768934, 0.13971902308104533]}, "mutation_prompt": null}
{"id": "0e4f034d-0cbd-4f58-9ef0-406980c1501a", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i] * 0.8)  # Change 1\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(12):  # Change 2, Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A refined hybrid genetic-simulated annealing algorithm with adaptive mutation for improved search efficiency.", "configspace": "", "generation": 52, "fitness": 0.8007335238002614, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.801 with standard deviation 0.013. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7935589358490657, 0.8183284620812881, 0.7903131734704303], "final_y": [0.13948971817946354, 0.12884110304239293, 0.14790987772030695]}, "mutation_prompt": null}
{"id": "d864dccb-2a2d-4525-a858-e2077cdf2921", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealingParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n        self.inertia_weight = 0.5  # New inertia weight parameter\n        self.cognitive_coeff = 1.5  # New cognitive parameter\n        self.social_coeff = 1.5  # New social parameter\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def initialize_velocities(self, bounds):  # New function for initializing velocities\n        return [np.random.uniform(-1, 1, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def update_velocities_and_positions(self, velocities, population, personal_best, global_best, bounds):  # New function\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive_velocity = self.cognitive_coeff * r1 * (personal_best[i] - population[i])\n            social_velocity = self.social_coeff * r2 * (global_best - population[i])\n            velocities[i] = (self.inertia_weight * velocities[i] +\n                             cognitive_velocity +\n                             social_velocity)\n            population[i] = np.clip(population[i] + velocities[i], bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        velocities = self.initialize_velocities(bounds)  # Initializing velocities\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_index = np.argmin(fitness)\n        global_best = population[global_best_index]\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n            # Particle Swarm Update\n            self.update_velocities_and_positions(velocities, population, personal_best, global_best, bounds)\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if fitness[i] < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = population[i], fitness[i]\n            global_best_index = np.argmin(fitness)\n            global_best = population[global_best_index]\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealingParticleSwarm", "description": "A hybrid genetic-simulated annealing-particle swarm algorithm that integrates swarm intelligence for enhanced exploration, hybridized with local refinement to efficiently optimize complex search spaces.", "configspace": "", "generation": 53, "fitness": 0.7995599627798713, "feedback": "The algorithm HybridGeneticSimulatedAnnealingParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.800 with standard deviation 0.009. And the mean value of best solutions found was 0.154 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.8118727588300512, 0.7913592776726226, 0.7954478518369403], "final_y": [0.14820232502354802, 0.15655769048220003, 0.15827704204963267]}, "mutation_prompt": null}
{"id": "0b127782-1127-4b6d-8d6a-a291ae63e40b", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate * 2:  # Changed mutation rate adaptively\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Improved hybrid genetic-simulated annealing algorithm with adaptive mutation rate for enhanced exploration.", "configspace": "", "generation": 54, "fitness": 0.7881140226854222, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.788 with standard deviation 0.012. And the mean value of best solutions found was 0.159 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7995051623094814, 0.7707907383948807, 0.7940461673519046], "final_y": [0.1521775074880367, 0.16582681299637592, 0.15823206713458504]}, "mutation_prompt": null}
{"id": "12e43513-f39a-4d6c-97e1-afd608437a5b", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.15  # Increased mutation rate from 0.1 to 0.15\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced mutation strategy by increasing mutation rate for greater exploration.", "configspace": "", "generation": 55, "fitness": 0.7749174846398287, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.775 with standard deviation 0.004. And the mean value of best solutions found was 0.160 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7788042489596363, 0.7700944461197234, 0.7758537588401263], "final_y": [0.15112085132906183, 0.16911788163802488, 0.15886939737784567]}, "mutation_prompt": null}
{"id": "e09c2fd7-2433-40ce-b2c5-cd5865ea57a3", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        \n        budget_used = len(population)\n        elite = min(fitness)  # Add elite for elitism\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n            self.mutation_rate = max(0.01, self.mutation_rate * 0.99) if elite >= min(fitness) else self.mutation_rate / 0.99\n            elite = min(fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An enhanced hybrid genetic-simulated annealing algorithm incorporating elitism and adaptive mutation rate for improved exploration-exploitation balance.", "configspace": "", "generation": 56, "fitness": 0.8024035483916668, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.802 with standard deviation 0.014. And the mean value of best solutions found was 0.153 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7844355397923192, 0.819331567609551, 0.8034435377731305], "final_y": [0.16078501409004708, 0.14905662864093094, 0.1505439670194595]}, "mutation_prompt": null}
{"id": "5c392bed-204c-4862-978b-1be74621f31c", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_rate = self.mutation_rate * (1 - self.cooling_rate)  # Adaptive mutation rate\n        for i in range(self.dim):\n            if random.random() < adaptive_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic-simulated annealing algorithm with adaptive mutation rate to improve exploration efficiency.", "configspace": "", "generation": 57, "fitness": 0.7615688397748018, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.762 with standard deviation 0.020. And the mean value of best solutions found was 0.156 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7436491913266505, 0.7896584150390432, 0.7513989129587119], "final_y": [0.17612523959582982, 0.15617862971460839, 0.13634056517321036]}, "mutation_prompt": null}
{"id": "9d8a7fde-4449-43b6-b053-c2e7c0c13a39", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n        self.elite_fraction = 0.1  # Line 1 change: Introduce elite retention\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_mutation_rate = self.mutation_rate / (1 + np.std(individual))  # Line 2 change: Adaptive mutation\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:  # Line 3 change: Use adaptive mutation rate\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            elite_count = int(self.population_size * self.elite_fraction)  # Line 4 change: Calculate elite count\n            new_population = population[:elite_count]  # Preserve elite individuals\n\n            for _ in range((self.population_size - elite_count) // 2):  # Adjust loop for elites\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic-simulated annealing algorithm with elite retention and adaptive mutation for improved convergence.", "configspace": "", "generation": 58, "fitness": 0.7645458856165975, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.765 with standard deviation 0.027. And the mean value of best solutions found was 0.156 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7260986190904661, 0.7875123699601687, 0.7800266677991581], "final_y": [0.17316528931825148, 0.14600755810240973, 0.1485078618044694]}, "mutation_prompt": null}
{"id": "9cb3738f-ba9d-4a5d-a282-839e3988123a", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n            self.mutation_rate *= 0.99  # Adjust mutation rate dynamically\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic-simulated annealing by adjusting mutation rate dynamically for improved exploration-exploitation balance.", "configspace": "", "generation": 59, "fitness": 0.7971998999734078, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.797 with standard deviation 0.013. And the mean value of best solutions found was 0.156 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7797368784643677, 0.802956441134851, 0.808906380321005], "final_y": [0.15957998408720442, 0.15666901522590126, 0.15204533434280254]}, "mutation_prompt": null}
{"id": "20b64c5b-0506-4bda-85c8-2cdab4dc8ad6", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                mutation_strength = random.uniform(0.05, 0.2)  # Enhanced mutation diversity\n                individual[i] = np.clip(individual[i] + mutation_strength * (np.random.uniform(bounds.lb[i], bounds.ub[i]) - individual[i]), bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A hybrid genetic-simulated annealing algorithm with enhanced mutation diversity to improve exploration.", "configspace": "", "generation": 60, "fitness": 0.770314819189189, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.770 with standard deviation 0.019. And the mean value of best solutions found was 0.147 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7466238554140139, 0.791859139035771, 0.7724614631177824], "final_y": [0.1475436086149653, 0.14076179242287623, 0.15182660942963533]}, "mutation_prompt": null}
{"id": "c7b5e8d5-f3b2-4cdb-afd4-69340b875bb7", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n            self.mutation_rate = max(0.01, self.mutation_rate * 0.99)  # Adaptive mutation rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A hybrid genetic-simulated annealing algorithm with an adaptive mutation rate to improve exploration and exploitation balance.", "configspace": "", "generation": 61, "fitness": 0.7788908980478118, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.779 with standard deviation 0.013. And the mean value of best solutions found was 0.153 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7657902981253402, 0.797337274221297, 0.7735451217967981], "final_y": [0.15939946540960304, 0.15223423945172843, 0.14604280333912567]}, "mutation_prompt": null}
{"id": "2ae7a55a-bb88-403c-9e24-fb2fae26b3c2", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds, fitness_score):\n        dynamic_mutation_rate = self.mutation_rate * (1 - fitness_score)  # Dynamic mutation rate\n        for i in range(self.dim):\n            if random.random() < dynamic_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds, current_cost)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds, min(fitness))\n                child2 = self.mutate(child2, bounds, min(fitness))\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhancing the mutation step by introducing a dynamic mutation rate that decreases with increasing fitness to better balance exploration and exploitation.", "configspace": "", "generation": 62, "fitness": 0.7754385719965807, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.775 with standard deviation 0.014. And the mean value of best solutions found was 0.157 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7679702608205888, 0.7949139261667573, 0.7634315290023965], "final_y": [0.1560066492157436, 0.15789519919389672, 0.15669955347412623]}, "mutation_prompt": null}
{"id": "36d0e6a5-01f9-4df1-8b61-ea80cafe38a6", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  \n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n            self.mutation_rate = max(0.01, self.mutation_rate * 0.99)  # Dynamic mutation rate adjustment\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An enhanced hybrid genetic-simulated annealing algorithm with dynamic mutation rate adjustment for improved global search efficiency.", "configspace": "", "generation": 63, "fitness": 0.7872043551903869, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.787 with standard deviation 0.018. And the mean value of best solutions found was 0.160 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7655507482129933, 0.8084999631755212, 0.7875623541826462], "final_y": [0.1685935815933185, 0.15164228623360754, 0.1610117024268315]}, "mutation_prompt": null}
{"id": "31ef4e22-4e62-450b-bd02-50ce98f4a2c6", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            self.crossover_rate = 0.6 + 0.4 * (budget_used / self.budget)  # Adaptive crossover\n            self.mutation_rate = 0.05 + 0.15 * (1 - budget_used / self.budget)  # Adaptive mutation\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An enhanced hybrid genetic-simulated annealing algorithm with adaptive crossover and mutation rates to improve exploration and exploitation balance.", "configspace": "", "generation": 64, "fitness": 0.7828133618817459, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.783 with standard deviation 0.016. And the mean value of best solutions found was 0.155 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7760706325412214, 0.8042569493278882, 0.768112503776128], "final_y": [0.15333322165072905, 0.1467871126228225, 0.16461168820435523]}, "mutation_prompt": null}
{"id": "33585ef8-172d-4b57-83d3-d1373ce68681", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                # Enhanced mutation strategy: Gaussian mutation for exploration\n                individual[i] += np.random.normal(0, (bounds.ub[i] - bounds.lb[i]) * 0.1)\n                individual[i] = np.clip(individual[i], bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A refined hybrid genetic-simulated annealing algorithm with enhanced mutation strategy to explore search spaces more effectively.", "configspace": "", "generation": 65, "fitness": 0.7624188206807231, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.762 with standard deviation 0.031. And the mean value of best solutions found was 0.156 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7445859194231137, 0.8061940029176071, 0.7364765397014486], "final_y": [0.16146481890587772, 0.13774092938462146, 0.1677214523572501]}, "mutation_prompt": null}
{"id": "22d0af73-8eac-449d-a14e-fcb25184e819", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n        self.initial_mutation_rate = 0.1\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        mutation_rate = self.adaptive_mutation_rate()\n        for i in range(self.dim):\n            if random.random() < mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def adaptive_mutation_rate(self):\n        return self.initial_mutation_rate * (1 - self.budget / (self.budget + 1))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic-simulated annealing algorithm with adaptive mutation and dynamic temperature adjustment for optimized performance.", "configspace": "", "generation": 66, "fitness": 0.7531632266932075, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.753 with standard deviation 0.027. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7164098988864641, 0.7802296576435419, 0.7628501235496159], "final_y": [0.1827696749360619, 0.1636578374010882, 0.16736420671000252]}, "mutation_prompt": null}
{"id": "044dc97a-6f2e-45e7-b7b9-6d68f123be1b", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_mutation_rate = self.mutation_rate * (1 - self.budget_used / self.budget)  # Adaptive mutation rate\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        self.budget_used = len(population)\n\n        while self.budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            self.budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                self.budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic-simulated annealing algorithm with adaptive mutation rate for improved exploration and exploitation balance.", "configspace": "", "generation": 67, "fitness": 0.7829348604498323, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.783 with standard deviation 0.009. And the mean value of best solutions found was 0.153 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7735155740195891, 0.7946631032830601, 0.780625904046848], "final_y": [0.15402991702510904, 0.1532271343968984, 0.15090760067691678]}, "mutation_prompt": null}
{"id": "22a2971a-988f-42f7-bf14-5a3439d8670e", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds, iteration, max_iterations):\n        adaptive_mutation_rate = self.mutation_rate * (1 - iteration / max_iterations)\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds, budget_used, self.budget)\n                child2 = self.mutate(child2, bounds, budget_used, self.budget)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An enhanced hybrid genetic-simulated annealing algorithm that incorporates dynamic mutation rate adaptation based on the current iteration to improve search efficiency.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"HybridGeneticSimulatedAnnealing.mutate() missing 2 required positional arguments: 'iteration' and 'max_iterations'\").", "error": "TypeError(\"HybridGeneticSimulatedAnnealing.mutate() missing 2 required positional arguments: 'iteration' and 'max_iterations'\")", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {}, "mutation_prompt": null}
{"id": "90c4f14d-a450-458a-b5f0-25ceca4085ac", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += np.random.normal(0, 0.1)  # Enhanced mutation with Gaussian noise\n                individual[i] = np.clip(individual[i], bounds.lb[i], bounds.ub[i])  # Ensure bounds\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A refined hybrid genetic-simulated annealing algorithm with enhanced mutation to boost exploration of the solution space.", "configspace": "", "generation": 69, "fitness": 0.7574885313082738, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.757 with standard deviation 0.010. And the mean value of best solutions found was 0.163 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7580124118847715, 0.7698318618236841, 0.7446213202163657], "final_y": [0.14666371327316519, 0.16633172037030686, 0.17484791376733444]}, "mutation_prompt": null}
{"id": "52cf9745-c987-4af7-ac0c-2dcbbe07e67a", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        tournament_size = 3\n        selected = random.sample(list(zip(population, fitness)), tournament_size)\n        selected.sort(key=lambda x: x[1])\n        return selected[0][0], selected[1][0]\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                scale = (bounds.ub[i] - bounds.lb[i]) * 0.1\n                individual[i] = np.clip(individual[i] + np.random.normal(0, scale), bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic-simulated annealing with improved selection and adaptive mutation for better exploration and exploitation balancing.", "configspace": "", "generation": 70, "fitness": 0.7989315909867596, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.799 with standard deviation 0.026. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7633308091211788, 0.8084064864395841, 0.8250574773995156], "final_y": [0.14682882845479084, 0.13816378349930458, 0.14430962381649837]}, "mutation_prompt": null}
{"id": "0d19cfc7-f1bf-436b-9271-1371d301e49a", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n            \n            self.crossover_rate = 0.5 + 0.5 * (1 - self.temperature / 1000)  # Adaptive crossover rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An enhanced hybrid genetic-simulated annealing strategy with adaptive crossover rate for improved exploration-exploitation balance.", "configspace": "", "generation": 71, "fitness": 0.7852951498465918, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.785 with standard deviation 0.009. And the mean value of best solutions found was 0.159 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7731397066453188, 0.7917147003593896, 0.791031042535067], "final_y": [0.1651725485554114, 0.1549607080617441, 0.15543468412955364]}, "mutation_prompt": null}
{"id": "a35ae9b6-73e9-4a52-a81e-e4eee7b08479", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_mutation_rate = self.mutation_rate * (self.temperature / 1000)  # Dynamic mutation rate\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid algorithm integrating dynamic mutation rates for adaptive exploration in complex search spaces.", "configspace": "", "generation": 72, "fitness": 0.7938637220774319, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.794 with standard deviation 0.017. And the mean value of best solutions found was 0.154 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7989867366431181, 0.7705152477621106, 0.8120891818270669], "final_y": [0.15668156663148125, 0.1690834868070612, 0.13658734752535429]}, "mutation_prompt": null}
{"id": "ae2741a2-728a-48da-a5cd-27b2d0fbeece", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.12  # Slightly increased mutation rate for better exploration\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A hybrid genetic-simulated annealing algorithm that combines population-based exploration with local refinement to efficiently navigate complex search spaces, enhanced by slightly increasing the mutation rate to improve exploration.", "configspace": "", "generation": 73, "fitness": 0.7883815924539488, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.788 with standard deviation 0.024. And the mean value of best solutions found was 0.157 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7612243195437249, 0.7850923417599667, 0.8188281160581548], "final_y": [0.16921458965039582, 0.16061069620564072, 0.14166398905347477]}, "mutation_prompt": null}
{"id": "2ff65592-4cf2-46b4-899a-af1e5fbf51bb", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        # Adaptive mutation rate based on temperature\n        mutation_rate = self.mutation_rate * (self.temperature / 1000)\n        for i in range(self.dim):\n            if random.random() < mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A hybrid genetic-simulated annealing algorithm that incorporates adaptive mutation rates to enhance exploration in complex search spaces.", "configspace": "", "generation": 74, "fitness": 0.7967915452694729, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.797 with standard deviation 0.014. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7966406136067248, 0.8143503171154642, 0.77938370508623], "final_y": [0.15204515178346456, 0.14217585729861137, 0.15681862305407868]}, "mutation_prompt": null}
{"id": "f9ba8071-9de5-4e67-9634-6bf50ad52f52", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                scale_factor = self.temperature / 1000  # Adaptive mutation\n                mutation_step = scale_factor * (bounds.ub[i] - bounds.lb[i]) * np.random.normal()\n                individual[i] += mutation_step\n                individual[i] = np.clip(individual[i], bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A hybrid genetic-simulated annealing algorithm with adaptive mutation to enhance exploration while maintaining strong local search capabilities.", "configspace": "", "generation": 75, "fitness": 0.7936853647138965, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.794 with standard deviation 0.012. And the mean value of best solutions found was 0.157 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7772823967248116, 0.8032555206266405, 0.8005181767902374], "final_y": [0.1631816705256005, 0.15543154677094684, 0.15143746412998638]}, "mutation_prompt": null}
{"id": "67da5141-9dcc-4cb1-9c4f-7613e98b8150", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_mutation_rate = self.mutation_rate * (self.budget / 1000)  # Adaptive mutation rate\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid algorithm with adaptive mutation rate to balance exploration and exploitation dynamically.", "configspace": "", "generation": 76, "fitness": 0.7955237808320268, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.796 with standard deviation 0.026. And the mean value of best solutions found was 0.153 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7723779515050325, 0.7816375540044195, 0.8325558369866286], "final_y": [0.16390115170208408, 0.1617755156935835, 0.13256126812102154]}, "mutation_prompt": null}
{"id": "18662d85-9f69-4ac8-9604-899178299fc2", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= 1 - 0.05 * self.cooling_rate  # Dynamic cooling\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic-simulated annealing with dynamic mutation rate and adaptive cooling schedule for improved exploration and convergence.", "configspace": "", "generation": 77, "fitness": 0.783885032468968, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.784 with standard deviation 0.011. And the mean value of best solutions found was 0.146 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7699611306366708, 0.784018220353509, 0.7976757464167242], "final_y": [0.14772428148689631, 0.13990235609053825, 0.150851735300366]}, "mutation_prompt": null}
{"id": "62169414-45d6-460d-b5c5-bcd850f9fec7", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate * 1.01  # Change: Applied dynamic cooling rate adjustment\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An enhanced hybrid genetic-simulated annealing algorithm with dynamic cooling to balance exploration and exploitation efficiently.", "configspace": "", "generation": 78, "fitness": 0.8039719442890266, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.804 with standard deviation 0.030. And the mean value of best solutions found was 0.151 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.8399786692397737, 0.8060289078160964, 0.7659082558112097], "final_y": [0.1318361805961754, 0.15158206054666312, 0.17076478387541416]}, "mutation_prompt": null}
{"id": "ed455027-4a66-49bc-ade8-4b3869a51039", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        diversity = np.std(individual)\n        adjusted_mutation_rate = self.mutation_rate * (1 + diversity)\n        for i in range(self.dim):\n            if random.random() < adjusted_mutation_rate:  # Adjusted mutation rate\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A hybrid genetic-simulated annealing algorithm with improved mutation rate adaptation based on population diversity for efficient search space exploration and local refinement.", "configspace": "", "generation": 79, "fitness": 0.7929045718632305, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.793 with standard deviation 0.022. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7743123704477324, 0.8238396845321996, 0.7805616606097593], "final_y": [0.159550667556406, 0.13568443342775582, 0.1559635328249157]}, "mutation_prompt": null}
{"id": "cf2b2952-c930-4a9b-b463-bf32d399c3f3", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.15  # Increased mutation rate\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        # Using tournament selection for better parent diversity\n        tournament_size = 3\n        selected = random.sample(list(zip(population, fitness)), tournament_size)\n        selected.sort(key=lambda x: x[1])\n        return selected[0][0], selected[1][0]\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An enhanced hybrid genetic-simulated annealing algorithm with improved selection and mutation strategies for better exploration and exploitation.", "configspace": "", "generation": 80, "fitness": 0.8113671786413056, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.811 with standard deviation 0.042. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7646378328874107, 0.8023487773155052, 0.8671149257210007], "final_y": [0.1391794238341918, 0.14589318276532437, 0.12692851078844958]}, "mutation_prompt": null}
{"id": "e4ed8b14-c87a-4685-b06f-a11bfb5e4f27", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        tournament_size = min(3, len(population))\n        selected = random.sample(list(zip(population, fitness)), tournament_size)\n        selected.sort(key=lambda x: x[1])\n        return selected[0][0], selected[1][0]\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced parent selection based on tournament selection to improve exploration and exploitation balance.", "configspace": "", "generation": 81, "fitness": 0.790974675105315, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.791 with standard deviation 0.006. And the mean value of best solutions found was 0.146 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7976231332727906, 0.7828706850399672, 0.7924302070031876], "final_y": [0.14750756896800277, 0.14057615102184828, 0.14918621956710176]}, "mutation_prompt": null}
{"id": "03982369-aa35-4947-beb8-8cd6b9118cad", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_mutation_rate = self.mutation_rate * (0.5 + random.random())  # Adaptive mutation\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid algorithm with adaptive mutation rate for improved exploration and convergence in black box optimization.", "configspace": "", "generation": 82, "fitness": 0.7712309263723994, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.771 with standard deviation 0.010. And the mean value of best solutions found was 0.149 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7811176567463096, 0.7744206588341909, 0.7581544635366979], "final_y": [0.15416544000206123, 0.13682627344564113, 0.15649757002674614]}, "mutation_prompt": null}
{"id": "e702314b-ad25-4fd4-b05e-82e5f444702a", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.15  # Increased mutation rate from 0.1 to 0.15\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An enhanced hybrid genetic-simulated annealing algorithm with increased mutation probability for improved exploration in complex search spaces.", "configspace": "", "generation": 83, "fitness": 0.7773082731988009, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.777 with standard deviation 0.010. And the mean value of best solutions found was 0.159 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7641959682895875, 0.7895280646705365, 0.7782007866362788], "final_y": [0.1575440674950711, 0.15836062918079463, 0.16011736640316765]}, "mutation_prompt": null}
{"id": "87e20ee1-be17-4a0f-884e-96b039e32a39", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_mutation_rate = self.mutation_rate * (self.budget / 1000)\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "An improved hybrid genetic-simulated annealing algorithm with adaptive mutation rate to enhance exploration in complex search spaces.", "configspace": "", "generation": 84, "fitness": 0.8052936156696786, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.805 with standard deviation 0.013. And the mean value of best solutions found was 0.148 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.8206445895145574, 0.8061569334181149, 0.7890793240763637], "final_y": [0.1451609740976907, 0.1545117028545696, 0.14555939501882453]}, "mutation_prompt": null}
{"id": "616a0398-a960-4fd2-8a8c-036a171b8f2f", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.1\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        # Revised to tournament selection for better exploration-exploitation balance\n        tournament_size = 3\n        selected = random.sample(list(zip(population, fitness)), tournament_size)\n        selected.sort(key=lambda x: x[1])\n        return selected[0][0], selected[1][0]\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced hybrid genetic-simulated annealing algorithm with improved parent selection strategy for better exploration-exploitation balance.", "configspace": "", "generation": 85, "fitness": 0.8035322443944244, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.804 with standard deviation 0.017. And the mean value of best solutions found was 0.147 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.818087651435539, 0.812555962791061, 0.7799531189566733], "final_y": [0.13576200085216306, 0.1479626602517774, 0.15749459642610852]}, "mutation_prompt": null}
{"id": "464920ab-368b-4cd1-9309-644a2ecd0cd1", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.15  # Increased mutation rate from 0.1 to 0.15\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "A hybrid genetic-simulated annealing algorithm with enhanced mutation rate for improved exploration and efficient navigation of complex search spaces.", "configspace": "", "generation": 86, "fitness": 0.7961385132787008, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.796 with standard deviation 0.021. And the mean value of best solutions found was 0.154 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7968411148007164, 0.8216872992999857, 0.7698871257354], "final_y": [0.15484280403128303, 0.1487742465184394, 0.1572468803709729]}, "mutation_prompt": null}
{"id": "b4f6c9cf-47f2-4b30-a451-daa4e3b54d73", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.15  # Adjusted to improve exploration\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        return random.choices(population, weights=selection_probs, k=2)\n    \n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Optimized hybrid algorithm with improved mutation rate for better exploration and exploitation balance.", "configspace": "", "generation": 87, "fitness": 0.8016596040243346, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.802 with standard deviation 0.025. And the mean value of best solutions found was 0.149 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7870829401593729, 0.7816306267716984, 0.8362652451419326], "final_y": [0.145128382081829, 0.16341590210445012, 0.13733599287273124]}, "mutation_prompt": null}
{"id": "51c87add-d8f5-4729-98a0-aa68b3444e27", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.05  # Adjusted for better exploration\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        elite = population[np.argmin(fitness)]  # Adding elitism\n        parents = random.choices(population, weights=selection_probs, k=2)\n        return parents[0], elite  # Ensure one parent is elite\n\n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced by integrating elitism in selection and tuning mutation rate for better exploration-exploitation balance.", "configspace": "", "generation": 88, "fitness": 0.8200425918237438, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.820 with standard deviation 0.035. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "188a596c-473c-457f-a6af-9b727c48668f", "metadata": {"aucs": [0.7862428466162407, 0.8058101993038946, 0.8680747295510965], "final_y": [0.13408586147949042, 0.15236771101459579, 0.12470691166758208]}, "mutation_prompt": null}
{"id": "d2ee6a08-6d70-4b06-a981-0fbed012b163", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.85  # Increased crossover rate for more recombination\n        self.mutation_rate = 0.03  # Reduced mutation rate for finer adjustments\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        elite = population[np.argmin(fitness)]  # Adding elitism\n        parents = random.choices(population, weights=selection_probs, k=2)\n        return parents[0], elite  # Ensure one parent is elite\n\n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Improved exploration by adjusting crossover and mutation strategies to optimize solution diversity.", "configspace": "", "generation": 89, "fitness": 0.8129091401935137, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.813 with standard deviation 0.032. And the mean value of best solutions found was 0.145 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "51c87add-d8f5-4729-98a0-aa68b3444e27", "metadata": {"aucs": [0.7700359870109181, 0.8467946243344974, 0.8218968092351255], "final_y": [0.16084042500282159, 0.13700642828992293, 0.13605643657223465]}, "mutation_prompt": null}
{"id": "ccf6dd39-381d-4f82-a379-49acac10c2b1", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.05  # Adjusted for better exploration\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        elites = sorted(population, key=lambda ind: func(ind))[:2]  # Increase number of elites to 2\n        parents = random.choices(population, weights=selection_probs, k=2)\n        return parents[0], elites[0]  # Ensure one parent is elite\n\n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced elite preservation by increasing the number of elites retained during selection.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "51c87add-d8f5-4729-98a0-aa68b3444e27", "metadata": {}, "mutation_prompt": null}
{"id": "638ac08a-345f-4b59-92e2-ed152d91ad1e", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.05  # Adjusted for better exploration\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        elite = population[np.argmin(fitness)]  # Adding elitism\n        parents = random.choices(population, weights=selection_probs, k=2)\n        return parents[0], elite  # Ensure one parent is elite\n\n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_mutation_rate = self.mutation_rate * (1 - self.budget_used / self.budget)  # New adaptive mutation rate\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        self.budget_used = len(population)\n\n        while self.budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            self.budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                self.budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Introduced adaptive mutation rate scaling based on budget usage to enhance the exploration-exploitation balance.", "configspace": "", "generation": 91, "fitness": 0.815198380116449, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.815 with standard deviation 0.030. And the mean value of best solutions found was 0.141 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "51c87add-d8f5-4729-98a0-aa68b3444e27", "metadata": {"aucs": [0.7780699135671064, 0.8159816721997957, 0.8515435545824449], "final_y": [0.1487652018806146, 0.14724847626599646, 0.12675161272873536]}, "mutation_prompt": null}
{"id": "38e9f3c5-2cbd-48e1-80d9-9e422e615d33", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.05  # Adjusted for better exploration\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        elite_indices = np.argsort(fitness)[:2]  # Select top two elites\n        elite1, elite2 = population[elite_indices[0]], population[elite_indices[1]]\n        parents = random.choices(population, weights=selection_probs, k=1)\n        return elite1, elite2  # Ensure both parents are elite\n\n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Refined the selection process by choosing the top two elites to enhance solution quality.", "configspace": "", "generation": 92, "fitness": 0.8166797929933303, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.817 with standard deviation 0.008. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "51c87add-d8f5-4729-98a0-aa68b3444e27", "metadata": {"aucs": [0.8172897346561063, 0.8261532652061402, 0.806596379117744], "final_y": [0.13900647344836248, 0.14407862281704287, 0.14808639330281337]}, "mutation_prompt": null}
{"id": "eeff9bd7-17ca-45c4-b390-ae3263e0c45d", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.05  # Base mutation rate\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        elite = population[np.argmin(fitness)]  # Adding elitism\n        parents = random.choices(population, weights=selection_probs, k=2)\n        return parents[0], elite  # Ensure one parent is elite\n\n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds, fitness_std):\n        adaptive_mutation_rate = self.mutation_rate * (1 + fitness_std)  # Adaptive mutation rate\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds, np.std(fitness))\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds, np.std(fitness))\n                child2 = self.mutate(child2, bounds, np.std(fitness))\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Introduced adaptive mutation rate based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 93, "fitness": 0.8093835525178253, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.809 with standard deviation 0.006. And the mean value of best solutions found was 0.145 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "51c87add-d8f5-4729-98a0-aa68b3444e27", "metadata": {"aucs": [0.8035755679197171, 0.8168446793059345, 0.8077304103278242], "final_y": [0.14056206778188662, 0.1460782379656146, 0.14757377242678804]}, "mutation_prompt": null}
{"id": "c2ccf05f-852d-4aaa-ba1c-212b169b4d89", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_rate = 0.05  # Adjusted for better exploration\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        elite = population[np.argmin(fitness)]  # Adding elitism\n        parents = random.choices(population, weights=selection_probs, k=2)\n        return parents[0], elite  # Ensure one parent is elite\n\n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        adaptive_mutation_rate = self.mutation_rate * (1 - (sum(fitness) / (self.population_size * min(fitness)))) # Adaptive mutation rate\n        for i in range(self.dim):\n            if random.random() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Integrating adaptive mutation rate dynamically based on convergence to enhance exploration and exploitation balance.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'fitness' is not defined\").", "error": "NameError(\"name 'fitness' is not defined\")", "parent_id": "51c87add-d8f5-4729-98a0-aa68b3444e27", "metadata": {}, "mutation_prompt": null}
{"id": "c57e856f-94c2-402d-a6d0-2000dc33aa8d", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9  # Increased for better exploration\n        self.mutation_rate = 0.05  # Adjusted for better exploration\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        elite = population[np.argmin(fitness)]  # Adding elitism\n        parents = random.choices(population, weights=selection_probs, k=2)\n        return parents[0], elite  # Ensure one parent is elite\n\n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced exploration by increasing crossover rate for diversified offspring generation. ", "configspace": "", "generation": 95, "fitness": 0.8215780742610511, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.822 with standard deviation 0.024. And the mean value of best solutions found was 0.138 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "51c87add-d8f5-4729-98a0-aa68b3444e27", "metadata": {"aucs": [0.7988416372814163, 0.8542483365477691, 0.8116442489539679], "final_y": [0.13475134915028075, 0.13142041086337308, 0.1467148733891308]}, "mutation_prompt": null}
{"id": "5fff8a67-e6f2-40bc-bbec-571dbb1382de", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9  # Increased for better exploration\n        self.mutation_rate = 0.1  # Adjusted for better exploration (changed from 0.05 to 0.1)\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        elite = population[np.argmin(fitness)]  # Adding elitism\n        parents = random.choices(population, weights=selection_probs, k=2)\n        return parents[0], elite  # Ensure one parent is elite\n\n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Enhanced exploration by increasing mutation rate for diversified solution search.", "configspace": "", "generation": 96, "fitness": 0.8031457074174794, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.803 with standard deviation 0.007. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "c57e856f-94c2-402d-a6d0-2000dc33aa8d", "metadata": {"aucs": [0.7973630075019836, 0.8135663865208795, 0.7985077282295747], "final_y": [0.14731501998678276, 0.1468028178193661, 0.15535237037607508]}, "mutation_prompt": null}
{"id": "07b9aeaa-3909-4eb0-9f87-f7b396c2b9f3", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9  # Increased for better exploration\n        self.mutation_rate = 0.05  # Adjusted for better exploration\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        elite = population[np.argmin(fitness)]  # Adding elitism\n        parents = random.choices(population, weights=selection_probs, k=2)\n        return parents[0], elite  # Ensure one parent is elite\n\n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(12):  # Increased local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Minor improvement by increasing the number of local search steps within annealing to enhance local exploration capabilities.", "configspace": "", "generation": 97, "fitness": 0.8093921196325571, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.809 with standard deviation 0.017. And the mean value of best solutions found was 0.143 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "c57e856f-94c2-402d-a6d0-2000dc33aa8d", "metadata": {"aucs": [0.7955945018178852, 0.8340460492909867, 0.7985358077887992], "final_y": [0.14784761452181994, 0.13238219846764132, 0.14869509114352142]}, "mutation_prompt": null}
{"id": "55c8e0f3-b4ab-4640-9012-87b1860da30b", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9  # Increased for better exploration\n        self.mutation_rate = 0.05  # Initial value for adaptive mutation\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        total_fitness = sum(fitness)\n        selection_probs = [f / total_fitness for f in fitness]\n        elite = population[np.argmin(fitness)]  # Adding elitism\n        parents = random.choices(population, weights=selection_probs, k=2)\n        return parents[0], elite  # Ensure one parent is elite\n\n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        self.mutation_rate = max(0.01, self.mutation_rate * 0.99)  # Adapt mutation rate\n        for _ in range(10):  # Limit local search steps\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Introduced adaptive mutation rate to balance exploration and exploitation dynamically.", "configspace": "", "generation": 98, "fitness": 0.8177256446026622, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.818 with standard deviation 0.034. And the mean value of best solutions found was 0.139 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "c57e856f-94c2-402d-a6d0-2000dc33aa8d", "metadata": {"aucs": [0.7706965548025267, 0.8467337738443609, 0.8357466051610989], "final_y": [0.14287697992154147, 0.1359610151231585, 0.137361630265198]}, "mutation_prompt": null}
{"id": "f6d290ae-f2ce-4273-918a-8c482bbdb699", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticSimulatedAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_rate = 0.9\n        self.mutation_rate = 0.05\n        self.temperature = 1000\n        self.cooling_rate = 0.95\n\n    def initialize_population(self, bounds):\n        return [np.random.uniform(bounds.lb, bounds.ub, self.dim) for _ in range(self.population_size)]\n\n    def evaluate_population(self, population, func):\n        return [func(ind) for ind in population]\n\n    def select_parents(self, population, fitness):\n        diversity_scores = [np.std(pop) for pop in population]  # Compute diversity\n        elite = population[np.argmin(fitness)]\n        parents = random.choices(population, weights=diversity_scores, k=2)  # Use diversity for selection\n        return parents[0], elite\n\n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            point = random.randint(1, self.dim - 1)\n            child1 = np.concatenate([parent1[:point], parent2[point:]])\n            child2 = np.concatenate([parent2[:point], parent1[point:]])\n            return child1, child2\n        return parent1, parent2\n\n    def mutate(self, individual, bounds):\n        for i in range(self.dim):\n            adaptive_mutation_rate = self.mutation_rate * max(0.1, self.temperature / 1000)  # Adaptive rate\n            if random.random() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return individual\n\n    def acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def anneal(self, individual, fitness, func, bounds):\n        current = individual\n        current_cost = fitness\n        for _ in range(10):\n            neighbor = self.mutate(current.copy(), bounds)\n            neighbor_cost = func(neighbor)\n            if self.acceptance_probability(current_cost, neighbor_cost, self.temperature) > random.random():\n                current, current_cost = neighbor, neighbor_cost\n        return current, current_cost\n\n    def __call__(self, func):\n        bounds = func.bounds\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate_population(population, func)\n        budget_used = len(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            for _ in range(self.population_size // 2):\n                parent1, parent2 = self.select_parents(population, fitness)\n                child1, child2 = self.crossover(parent1, parent2)\n                child1 = self.mutate(child1, bounds)\n                child2 = self.mutate(child2, bounds)\n                new_population.extend([child1, child2])\n\n            new_fitness = self.evaluate_population(new_population, func)\n            budget_used += len(new_population)\n\n            for i in range(len(new_population)):\n                new_population[i], new_fitness[i] = self.anneal(new_population[i], new_fitness[i], func, bounds)\n                budget_used += 1\n\n            combined = list(zip(population + new_population, fitness + new_fitness))\n            combined.sort(key=lambda x: x[1])\n            population, fitness = zip(*combined[:self.population_size])\n            population, fitness = list(population), list(fitness)\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "HybridGeneticSimulatedAnnealing", "description": "Introduced adaptive mutation rate and diversity-based parent selection to boost exploration and convergence.", "configspace": "", "generation": 99, "fitness": 0.7870900615868489, "feedback": "The algorithm HybridGeneticSimulatedAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.787 with standard deviation 0.014. And the mean value of best solutions found was 0.151 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "c57e856f-94c2-402d-a6d0-2000dc33aa8d", "metadata": {"aucs": [0.8054650521156198, 0.7855240668150332, 0.7702810658298938], "final_y": [0.1424839107891075, 0.15478066203914154, 0.15665806848934094]}, "mutation_prompt": null}
