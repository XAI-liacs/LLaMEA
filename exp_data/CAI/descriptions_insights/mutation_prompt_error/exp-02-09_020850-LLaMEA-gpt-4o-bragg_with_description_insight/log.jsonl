{"id": "df33f705-febe-4963-9693-41db02ea6a5a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridDEPeriodicity:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.periodicity_factor = 0.1\n\n    def periodicity_cost(self, solution):\n        return np.var(solution[:self.dim//2] - solution[self.dim//2:])\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def mutate(self, population, idx):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func, penalty_factor):\n        target_cost = func(target) + penalty_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + penalty_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx)\n                trial = self.crossover(target, mutant)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func, penalty_factor=self.periodicity_factor)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n\n        # Local refinement on the best solution found\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n                          \n        return result.x", "name": "HybridDEPeriodicity", "description": "Hybrid Differential Evolution with Periodicity Enhancement, combining global exploration and local refinement to optimize multilayer photonic structures by encouraging periodic solutions.", "configspace": "", "generation": 0, "fitness": 0.19924938399962377, "feedback": "The algorithm HybridDEPeriodicity got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.199 with standard deviation 0.002. And the mean value of best solutions found was 0.490 (0. is the best) with standard deviation 0.022.", "error": "", "parent_id": null, "metadata": {"aucs": [0.19963086083011705, 0.19656648176080416, 0.20155080940795012], "final_y": [0.4851222111652522, 0.5192011663143732, 0.46469205749927356]}, "mutation_prompt": null}
{"id": "f6e2d2ac-ad3a-4e81-a564-fe54ef178cf4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridDEPeriodicity:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.mutation_factor = 0.9  # Adjusted mutation factor from 0.8 to 0.9\n        self.crossover_rate = 0.9\n        self.periodicity_factor = 0.1\n\n    def periodicity_cost(self, solution):\n        return np.var(solution[:self.dim//2] - solution[self.dim//2:])\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def mutate(self, population, idx):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func, penalty_factor):\n        target_cost = func(target) + penalty_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + penalty_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx)\n                trial = self.crossover(target, mutant)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func, penalty_factor=self.periodicity_factor)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n\n        # Local refinement on the best solution found\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n                          \n        return result.x", "name": "HybridDEPeriodicity", "description": "Enhanced Hybrid Differential Evolution with Periodicity and Adaptive Mutation Factor to optimize multilayer photonic structures with improved global exploration capabilities.", "configspace": "", "generation": 1, "fitness": 0.19924938399962377, "feedback": "The algorithm HybridDEPeriodicity got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.199 with standard deviation 0.002. And the mean value of best solutions found was 0.490 (0. is the best) with standard deviation 0.022.", "error": "", "parent_id": "df33f705-febe-4963-9693-41db02ea6a5a", "metadata": {"aucs": [0.19963086083011705, 0.19656648176080416, 0.20155080940795012], "final_y": [0.4851222111652522, 0.5192011663143732, 0.46469205749927356]}, "mutation_prompt": null}
{"id": "a838c0f5-5c39-4238-8f7f-2ad7ff5df5e9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.periodicity_factor = 0.1\n        self.local_search_prob = 0.2\n        self.best_solution = None\n\n    def periodicity_cost(self, solution):\n        half_dim = self.dim // 2\n        periodic_error = np.var(solution[:half_dim] - solution[half_dim:])\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation):\n        return self.base_mutation_factor + 0.1 * np.sin(2 * np.pi * generation / 10)\n\n    def mutate(self, population, idx, generation):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation)\n        mutant = a + mutation_factor * (b - c)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x), \n                       solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation)\n                trial = self.crossover(target, mutant)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Adaptive Memetic Differential Evolution with Periodicity Awareness (AMDEPA), integrating adaptive mutation rates and memetic local search to enhance convergence while encouraging periodicity in solutions.", "configspace": "", "generation": 2, "fitness": 0.23488432956957364, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.235 with standard deviation 0.008. And the mean value of best solutions found was 0.173 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "df33f705-febe-4963-9693-41db02ea6a5a", "metadata": {"aucs": [0.22940447321421875, 0.2295703733582709, 0.2456781421362313], "final_y": [0.172596901414806, 0.17259445725604916, 0.17259535234415257]}, "mutation_prompt": null}
{"id": "fa38df24-69d6-4bcc-8885-085f8538ab00", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.periodicity_factor = 0.1\n        self.local_search_prob = 0.2\n        self.best_solution = None\n\n    def periodicity_cost(self, solution):\n        half_dim = self.dim // 2\n        periodic_error = np.var(solution[:half_dim] - solution[half_dim:])\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation):\n        return self.base_mutation_factor + 0.1 * np.sin(2 * np.pi * generation / 10)\n\n    def mutate(self, population, idx, generation):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation)\n        mutant = a + mutation_factor * (b - c)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])  # Simplifying: Removed penalty term here\n        return res.x\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation)\n                trial = self.crossover(target, mutant)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Adaptive Memetic Differential Evolution with Enhanced Periodicity Awareness (AMDEPA+), incorporating periodicity cost optimization directly into local refinement for improved convergence.", "configspace": "", "generation": 3, "fitness": 0.2453024280099383, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "a838c0f5-5c39-4238-8f7f-2ad7ff5df5e9", "metadata": {"aucs": [0.24548534699679425, 0.24241055772794395, 0.24801137930507666], "final_y": [0.16485785008543985, 0.1818793238132389, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "aa8c4c50-22fb-4cfa-887d-f3ee1bdb8831", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPAC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.base_mutation_factor = 0.5\n        self.base_crossover_rate = 0.9\n        self.periodicity_factor = 0.1\n        self.local_search_prob = 0.2\n        self.best_solution = None\n\n    def periodicity_cost(self, solution):\n        half_dim = self.dim // 2\n        periodic_error = np.var(solution[:half_dim] - solution[half_dim:])\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation):\n        return self.base_mutation_factor + 0.1 * np.sin(2 * np.pi * generation / 10)\n\n    def adapt_crossover_rate(self, generation):\n        return self.base_crossover_rate - 0.3 * np.cos(2 * np.pi * generation / 10)\n\n    def mutate(self, population, idx, generation):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation)\n        mutant = a + mutation_factor * (b - c)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        crossover_rate = self.adapt_crossover_rate(generation)\n        cross_points = np.random.rand(self.dim) < crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                       solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            for idx in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPAC", "description": "Adaptive Memetic Differential Evolution with Enhanced Periodicity and Adaptive Crossover (AMDEPAC), integrating a dynamic crossover rate and improved local refinement for faster convergence.", "configspace": "", "generation": 4, "fitness": 0.2340236960790745, "feedback": "The algorithm AdaptiveMemeticDEPAC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.234 with standard deviation 0.009. And the mean value of best solutions found was 0.205 (0. is the best) with standard deviation 0.046.", "error": "", "parent_id": "fa38df24-69d6-4bcc-8885-085f8538ab00", "metadata": {"aucs": [0.2329824477247021, 0.22341051305776027, 0.24567812745476114], "final_y": [0.172596901414806, 0.269126053989007, 0.17259535234415257]}, "mutation_prompt": null}
{"id": "7262dda8-919c-4458-b050-ffd7fb6fe12e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.periodicity_factor = 0.1\n        self.local_search_prob = 0.2\n        self.best_solution = None\n\n    def periodicity_cost(self, solution):\n        half_dim = self.dim // 2\n        periodic_error = np.var(solution[:half_dim] - solution[half_dim:])\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation):\n        return self.base_mutation_factor + 0.1 * np.sin(2 * np.pi * generation / 10)\n\n    def mutate(self, population, idx, generation):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation)\n        mutant = a + mutation_factor * (b - c)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(lambda x: func(x) + self.periodicity_cost(x), solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])  # Updated\n        return res.x\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation)\n                trial = self.crossover(target, mutant)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhanced local refinement by including periodicity cost directly into the minimize function optimization.", "configspace": "", "generation": 5, "fitness": 0.22967536217588547, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.230 with standard deviation 0.011. And the mean value of best solutions found was 0.173 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "fa38df24-69d6-4bcc-8885-085f8538ab00", "metadata": {"aucs": [0.2197757033302603, 0.22381404585070186, 0.24543633734669423], "final_y": [0.17260136181832153, 0.17262539992536396, 0.17259669086267582]}, "mutation_prompt": null}
{"id": "408a4e7e-8d3e-4cbd-8383-9f3613969101", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.periodicity_factor = 0.1\n        self.local_search_prob = 0.2\n        self.best_solution = None\n\n    def periodicity_cost(self, solution):\n        half_dim = self.dim // 2\n        periodic_error = np.var(solution[:half_dim] - solution[half_dim:])\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation):\n        return self.base_mutation_factor + 0.1 * np.sin(2 * np.pi * generation / 10)\n\n    def mutate(self, population, idx, generation):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation)\n        mutant = a + mutation_factor * (b - c)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(lambda x: func(x) + 0.5 * self.periodicity_factor * self.periodicity_cost(x), solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])  # Adjusted periodicity factor\n        return res.x\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation)\n                trial = self.crossover(target, mutant)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhanced periodicity awareness by adjusting periodicity factor during local refinement for improved solution convergence.", "configspace": "", "generation": 6, "fitness": 0.23241183935494836, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.232 with standard deviation 0.010. And the mean value of best solutions found was 0.173 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "fa38df24-69d6-4bcc-8885-085f8538ab00", "metadata": {"aucs": [0.2232799886834359, 0.22822429550558632, 0.24573123387582285], "final_y": [0.1725917722971303, 0.17259055884222552, 0.1725894443089635]}, "mutation_prompt": null}
{"id": "f43a6a7b-5da5-4a49-b550-58b440c78e94", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.periodicity_factor = 0.1\n        self.local_search_prob = 0.2\n        self.best_solution = None\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2])\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation):\n        return self.base_mutation_factor + 0.1 * np.sin(2 * np.pi * generation / 10)\n\n    def mutate(self, population, idx, generation):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation)\n        mutant = a + mutation_factor * (b - c)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])  # Simplifying: Removed penalty term here\n        return res.x\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation)\n                trial = self.crossover(target, mutant)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Improved periodicity cost function by reducing error calculation only to relevant layers.", "configspace": "", "generation": 7, "fitness": 0.24611244981211314, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "fa38df24-69d6-4bcc-8885-085f8538ab00", "metadata": {"aucs": [0.24470557231746548, 0.2456203978137973, 0.24801137930507666], "final_y": [0.16485785008543985, 0.1648579151925491, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "3b03fa01-a022-483d-972f-f43c4b1716c9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.periodicity_factor = 0.1\n        self.local_search_prob = 0.2\n        self.best_solution = None\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2])\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation):\n        return self.base_mutation_factor + 0.1 * np.cos(2 * np.pi * generation / 10)\n\n    def mutate(self, population, idx, generation):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation)\n        mutant = a + mutation_factor * (b - c)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x), solution, \n                          bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation)\n                trial = self.crossover(target, mutant)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                self.local_search_prob = 0.2 + 0.05 * np.sin(2 * np.pi * generation / 10)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhanced AdaptiveMemeticDEPA with dynamic local search probability and improved periodicity handling.", "configspace": "", "generation": 8, "fitness": 0.23355834537565143, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.234 with standard deviation 0.010. And the mean value of best solutions found was 0.219 (0. is the best) with standard deviation 0.038.", "error": "", "parent_id": "f43a6a7b-5da5-4a49-b550-58b440c78e94", "metadata": {"aucs": [0.2263048574180372, 0.22707826960142852, 0.24729190910748855], "final_y": [0.2444316607550696, 0.24661110306395617, 0.16485580063008098]}, "mutation_prompt": null}
{"id": "bc0adc56-f21f-46c5-b90c-688f61fb16bf", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.periodicity_factor = 0.1\n        self.local_search_prob = 0.2\n        self.best_solution = None\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2])\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation):\n        return self.base_mutation_factor + 0.05 * np.sin(2 * np.pi * generation / 5)  # changed adaptation pattern\n\n    def mutate(self, population, idx, generation):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation)\n        mutant = a + mutation_factor * (b - c)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])  # Simplifying: Removed penalty term here\n        return res.x\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation)\n                trial = self.crossover(target, mutant)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Improved mutation factor adaptation to better navigate the optimization landscape.", "configspace": "", "generation": 9, "fitness": 0.24611244981211314, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f43a6a7b-5da5-4a49-b550-58b440c78e94", "metadata": {"aucs": [0.24470557231746548, 0.2456203978137973, 0.24801137930507666], "final_y": [0.16485785008543985, 0.1648579151925491, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "4b0580cb-05af-41b7-a58c-f3b3404ab743", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.periodicity_factor = 0.1\n        self.local_search_prob = 0.2\n        self.best_solution = None\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 1)) # Changed line\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation):\n        return self.base_mutation_factor + 0.1 * np.sin(2 * np.pi * generation / 10)\n\n    def mutate(self, population, idx, generation):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation)\n        mutant = a + mutation_factor * (b - c)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])  # Simplifying: Removed penalty term here\n        return res.x\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation)\n                trial = self.crossover(target, mutant)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhanced periodicity cost function to better differentiate between solutions with varying periodic alignment.", "configspace": "", "generation": 10, "fitness": 0.2461271156901538, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f43a6a7b-5da5-4a49-b550-58b440c78e94", "metadata": {"aucs": [0.24470557231746548, 0.2456643954479193, 0.24801137930507666], "final_y": [0.16485785008543985, 0.1648579151925491, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "b7dd4ca0-617c-4c51-b2c0-1ca6ddb03e26", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumInspiredADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.local_search_prob = 0.2\n        self.best_solution = None\n        self.wave_amplitude = 0.1\n        self.global_best = None\n\n    def quantum_wave_function(self, solution, lb, ub):\n        perturbation = self.wave_amplitude * np.sin(2 * np.pi * np.random.rand(self.dim))\n        return np.clip(solution + perturbation, lb, ub)\n\n    def initialize_population(self, lb, ub):\n        population = lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n        return population\n\n    def adapt_mutation_factor(self, generation):\n        return self.base_mutation_factor + 0.1 * np.sin(2 * np.pi * generation / 10)\n\n    def mutate(self, population, idx, generation):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation)\n        mutant = a + mutation_factor * (b - c)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        return trial if func(trial) < func(target) else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation)\n                trial = self.crossover(target, mutant)\n                trial = lb + (ub - lb) * trial\n                quantum_trial = self.quantum_wave_function(trial, lb, ub)\n                selected = self.select(target, quantum_trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(func, self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "QuantumInspiredADE", "description": "Quantum-Inspired Adaptive Differential Evolution leverages quantum-inspired mechanisms to enhance global exploration and maintain diversity for complex optimization landscapes.", "configspace": "", "generation": 11, "fitness": 0.24572927690530944, "feedback": "The algorithm QuantumInspiredADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b0580cb-05af-41b7-a58c-f3b3404ab743", "metadata": {"aucs": [0.2474543977766922, 0.24562197039970146, 0.24411146253953464], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485848066033448]}, "mutation_prompt": null}
{"id": "b48ca707-e1c5-4669-84f2-00ea32505e15", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.periodicity_factor = 0.1\n        self.local_search_prob = 0.2\n        self.best_solution = None\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 1))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation):\n        return self.base_mutation_factor + 0.1 * np.sin(2 * np.pi * generation / 10)\n\n    def mutate(self, population, idx, generation):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation)\n        mutant = a + mutation_factor * (b - c)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        gen_factor = 0.1 + 0.1 * np.sin(2 * np.pi * generation / 20)  # Changed line\n        target_cost = func(target) + gen_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + gen_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation)\n                trial = self.crossover(target, mutant)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduced adaptive periodicity factor to dynamically enhance solution differentiation based on generations.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'generation' is not defined\").", "error": "NameError(\"name 'generation' is not defined\")", "parent_id": "4b0580cb-05af-41b7-a58c-f3b3404ab743", "metadata": {}, "mutation_prompt": null}
{"id": "cef1860e-636c-4d71-9f41-d1eaee18cecb", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Changed line\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85  # Changed line\n        self.periodicity_factor = 0.15  # Changed line\n        self.local_search_prob = 0.3  # Changed line\n        self.best_solution = None\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))  # Changed line\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation):\n        return self.base_mutation_factor + 0.1 * np.sin(2 * np.pi * generation / 12)  # Changed line\n\n    def mutate(self, population, idx, generation):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation)\n        mutant = a + mutation_factor * (b - c) + 0.05 * (np.mean(population, axis=0) - a)  # Changed line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation)\n                trial = self.crossover(target, mutant)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhanced periodicity and diversity mechanisms to improve exploration and solution robustness.", "configspace": "", "generation": 13, "fitness": 0.24684125874506516, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b0580cb-05af-41b7-a58c-f3b3404ab743", "metadata": {"aucs": [0.24808662195239473, 0.2447671099507428, 0.24767004433205797], "final_y": [0.16485751310148167, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "303393a7-446b-4024-a560-0d8102409cd2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation):\n        return self.base_mutation_factor + 0.1 * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation)\n        mutant = a + mutation_factor * (b - c) + 0.05 * (np.mean(population, axis=0) - a)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)  # Changed line\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce dynamic crossover rates to enhance exploration and exploitation balance.", "configspace": "", "generation": 14, "fitness": 0.24684130607514254, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cef1860e-636c-4d71-9f41-d1eaee18cecb", "metadata": {"aucs": [0.24808676394262685, 0.2447671099507428, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "85bf2013-7415-4508-a3df-f614ae633e2a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation):\n        return self.base_mutation_factor + 0.1 * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation)\n        mutant = a + mutation_factor * (b - c) + 0.05 * (np.mean(population, axis=0) - a)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.tanh(0.5 * np.cos(2 * np.pi * generation / 20))  # Changed line\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance exploration by adjusting the dynamic crossover rate using a non-linear function.", "configspace": "", "generation": 15, "fitness": 0.24683152679887851, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "303393a7-446b-4024-a560-0d8102409cd2", "metadata": {"aucs": [0.24808676035701493, 0.2447377757075626, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "26b9b78e-6a34-4b29-879b-90f0ad2bebd0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation):\n        return self.base_mutation_factor + 0.1 * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation) * (1 + 0.1 * np.cos(2 * np.pi * generation / 20))  # Changed line\n        mutant = a + mutation_factor * (b - c) + 0.05 * (np.mean(population, axis=0) - a)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce dynamic mutation factors to enhance exploration and exploitation balance.", "configspace": "", "generation": 16, "fitness": 0.24684130528087642, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "303393a7-446b-4024-a560-0d8102409cd2", "metadata": {"aucs": [0.24808676394262685, 0.2447671075679444, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "c081ccbc-9ba3-416e-838f-31327edc64de", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation):\n        return self.base_mutation_factor + 0.1 * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation)\n        mutant = a + mutation_factor * (b - c) + 0.05 * (np.mean(population, axis=0) - a)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)  # Changed line\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce adaptive periodicity factor to improve the balance between periodicity and solution exploration.", "configspace": "", "generation": 17, "fitness": 0.24684130607514254, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "303393a7-446b-4024-a560-0d8102409cd2", "metadata": {"aucs": [0.24808676394262685, 0.2447671099507428, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "f951a77e-3823-40bf-8a02-7b49102029d4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Increased population size\n        self.base_mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.9\n        self.periodicity_factor = 0.1  # Reduced periodicity factor\n        self.local_search_prob = 0.4  # Increased local search probability\n        self.best_solution = None\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation):\n        return self.base_mutation_factor + 0.1 * np.sin(2 * np.pi * generation / 8)  # Altered frequency\n\n    def mutate(self, population, idx, generation):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation)\n        mutant = a + mutation_factor * (b - c)\n        return np.clip(mutant, 0, 1)\n\n    def layer_based_crossover(self, target, mutant, generation):  # Renamed and enhanced crossover method\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation)\n                trial = self.layer_based_crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance Differential Evolution with adaptive strategies and layer-based crossover to improve multimodal optimization.", "configspace": "", "generation": 18, "fitness": 0.24654117455581073, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "303393a7-446b-4024-a560-0d8102409cd2", "metadata": {"aucs": [0.2474045487506582, 0.24473795329712333, 0.2474810216196507], "final_y": [0.16485632498843794, 0.16485620555962366, 0.1648563448188196]}, "mutation_prompt": null}
{"id": "94f07d71-c031-4286-a913-57e35847bf28", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01  # Added line\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):  # Modified line\n        factor_adjustment = 0.1 * (1 - diversity)  # Added line\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):  # Modified line\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)  # Modified line\n        mutant = a + mutation_factor * (b - c) + 0.05 * (np.mean(population, axis=0) - a)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):  # Added function\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)  # Added line\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)  # Modified line\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce adaptive local search strategies and fitness diversity to enhance convergence and global exploration balance.", "configspace": "", "generation": 19, "fitness": 0.2468413256451064, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "303393a7-446b-4024-a560-0d8102409cd2", "metadata": {"aucs": [0.24808676394262685, 0.24476716866063442, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "ddf5ffb8-8f60-4ec2-9d2b-ee27d600aac1", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01  # Added line\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):  # Modified line\n        factor_adjustment = 0.1 * (1 - diversity)  # Added line\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):  # Modified line\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)  # Modified line\n        mutant = a + mutation_factor * (b - c) + 0.05 * (np.mean(population, axis=0) - a)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):  # Added function\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity * 1.05  # Modified line\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)  # Added line\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)  # Modified line\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance exploration by integrating neighborhood search to increase diversity.", "configspace": "", "generation": 20, "fitness": 0.2468413256451064, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "94f07d71-c031-4286-a913-57e35847bf28", "metadata": {"aucs": [0.24808676394262685, 0.24476716866063442, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "eafb8c5a-e031-4562-ad7d-60bbd54f5369", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.05 * (np.mean(population, axis=0) - a)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n            self.periodicity_factor *= (1 + 0.01 * np.sin(2 * np.pi * generation / 50))  # Changed line\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce an adaptive periodicity factor to dynamically emphasize periodic solutions based on generation count and diversity.", "configspace": "", "generation": 21, "fitness": 0.2468413256451064, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "94f07d71-c031-4286-a913-57e35847bf28", "metadata": {"aucs": [0.24808676394262685, 0.24476716866063442, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "67a4ce33-0ef7-42e1-9422-ae3e191b13d8", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.05 * (np.mean(population, axis=0) - a)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            self.periodicity_factor = 0.15 + 0.1 * np.sin(2 * np.pi * generation / 10)  # Modified line\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce dynamic periodicity factor to better balance between exploration and exploiting periodic solutions.", "configspace": "", "generation": 22, "fitness": 0.2468413256451064, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "94f07d71-c031-4286-a913-57e35847bf28", "metadata": {"aucs": [0.24808676394262685, 0.24476716866063442, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "fcc5e647-749d-474c-beb0-70607e8b8ba4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        weights = np.array([1 / (1 + func(ind)) for ind in population])  # Added line\n        indices = np.random.choice(range(self.pop_size), 3, replace=False, p=weights / weights.sum())  # Modified line\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False, p=weights / weights.sum())  # Modified line\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.05 * (np.mean(population, axis=0) - a)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance the selection and mutation process by incorporating fitness-driven weighting and increasing diversity through crossover adjustments.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "94f07d71-c031-4286-a913-57e35847bf28", "metadata": {}, "mutation_prompt": null}
{"id": "b2b3d45f-8eb3-4d57-b361-f263309fe71b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n        self.mutation_memory = [0.5] * 5 # Added line\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity): \n        factor_adjustment = 0.1 * (1 - diversity)\n        memory_factor = np.mean(self.mutation_memory) # Added line\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12) + memory_factor # Modified line\n\n    def mutate(self, population, idx, generation, diversity): \n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity) \n        mutant = a + mutation_factor * (b - c) + 0.05 * (np.mean(population, axis=0) - a)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        if trial_cost < target_cost: # Modified line\n            success = 1\n        else:\n            success = 0\n        self.mutation_memory.pop(0)\n        self.mutation_memory.append(success)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population): \n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population) \n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity) \n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce a mutation memory mechanism to adapt mutation factors based on past success rates.", "configspace": "", "generation": 24, "fitness": 0.2468413256451064, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "94f07d71-c031-4286-a913-57e35847bf28", "metadata": {"aucs": [0.24808676394262685, 0.24476716866063442, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "64b29bab-6c85-4594-9c36-2344ec43693a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01  # Added line\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):  # Modified line\n        factor_adjustment = 0.1 * (1 - diversity)  # Added line\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):  # Modified line\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)  # Modified line\n        mutant = a + mutation_factor * (b - c) + 0.05 * (np.mean(population, axis=0) - a)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation, diversity):  # Modified line\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20) * (1 + diversity)  # Modified line\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):  # Added function\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)  # Added line\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)  # Modified line\n                trial = self.crossover(target, mutant, generation, diversity)  # Modified line\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance adaptive mutation by including diversity in the dynamic crossover rate for better exploration-exploitation balance.", "configspace": "", "generation": 25, "fitness": 0.24631529598315496, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "94f07d71-c031-4286-a913-57e35847bf28", "metadata": {"aucs": [0.24666909859590125, 0.2446067450215057, 0.24767004433205797], "final_y": [0.16485751310148167, 0.16485914511389144, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "cb5dddeb-443d-43ee-885c-1dd1254f2bb9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01  # Added line\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):  # Modified line\n        factor_adjustment = 0.2 * (1 - diversity)  # Changed line\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):  # Modified line\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)  # Modified line\n        mutant = a + mutation_factor * (b - c) + 0.05 * (np.mean(population, axis=0) - a)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):  # Added function\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)  # Added line\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)  # Modified line\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance the scaling of diversity adjustment to dynamically balance exploration and exploitation.", "configspace": "", "generation": 26, "fitness": 0.2468413256451064, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "94f07d71-c031-4286-a913-57e35847bf28", "metadata": {"aucs": [0.24808676394262685, 0.24476716866063442, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "883351f3-e1b4-4bec-a276-7a12a6229d02", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.05 * (np.mean(population, axis=0) - a)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob + 0.1 * np.sin(2 * np.pi * generation / 20):  # Modified line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance local search probability dynamically based on current generation to fine-tune convergence.  ", "configspace": "", "generation": 27, "fitness": 0.24683805844683407, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "94f07d71-c031-4286-a913-57e35847bf28", "metadata": {"aucs": [0.24808675569571947, 0.2447573753127248, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "88e7963b-dac7-4a86-b3fa-a009f687ac30", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01  # Added line\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):  # Modified line\n        factor_adjustment = 0.1 * (1 - diversity)  # Added line\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):  # Modified line\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)  # Modified line\n        mutant = a + mutation_factor * (b - c) + 0.05 * (np.mean(population, axis=0) - a)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + 0.1 * self.periodicity_cost(trial)  # Changed line\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):  # Added function\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)  # Added line\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)  # Modified line\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance periodicity handling by adjusting the cost function factor for better optimization.", "configspace": "", "generation": 28, "fitness": 0.24646638949173963, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "94f07d71-c031-4286-a913-57e35847bf28", "metadata": {"aucs": [0.24808676394262685, 0.2436423602005341, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "b8828526-83fe-4665-9a1c-f07f526fce90", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.05 * (np.mean(population, axis=0) - a)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        # Integrate periodicity cost into local search optimization objective\n        res = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x), \n                       solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance local search efficiency by integrating a periodicity-aware penalty in local refinement.", "configspace": "", "generation": 29, "fitness": 0.24428369291937344, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.001. And the mean value of best solutions found was 0.173 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "94f07d71-c031-4286-a913-57e35847bf28", "metadata": {"aucs": [0.24482998689579283, 0.24283620353099256, 0.2451848883313349], "final_y": [0.17323688175078, 0.1731049101700457, 0.17330953593740883]}, "mutation_prompt": null}
{"id": "dd346a73-c412-439d-995c-cc9bef1105d4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)  # Changed line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce adaptive local search strategies and fitness diversity to enhance convergence and global exploration balance with improved mutation diversity.", "configspace": "", "generation": 30, "fitness": 0.24714572624271627, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "94f07d71-c031-4286-a913-57e35847bf28", "metadata": {"aucs": [0.2474024167726051, 0.2460235023577234, 0.24801125959782033], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "8eecff6e-453a-45ff-ab41-89aaacd77dc4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                dynamic_local_search_prob = self.local_search_prob * (1 - diversity)  # Changed line\n                if np.random.rand() < dynamic_local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce a dynamic local search probability to enhance convergence by increasing local search when close to promising areas.", "configspace": "", "generation": 31, "fitness": 0.2030507077801864, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.203 with standard deviation 0.003. And the mean value of best solutions found was 0.450 (0. is the best) with standard deviation 0.026.", "error": "", "parent_id": "dd346a73-c412-439d-995c-cc9bef1105d4", "metadata": {"aucs": [0.20082786901957228, 0.20677344491303684, 0.20155080940795012], "final_y": [0.47239265783783124, 0.41379549904142665, 0.46469205749927356]}, "mutation_prompt": null}
{"id": "d8e1da5e-d545-497f-ab3f-6bb045cc9a8c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.std(population, axis=0))  # Changed line for diversity calculation\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n            self.periodicity_factor = 0.1 + 0.05 * np.sin(2 * np.pi * generation / 20)  # Changed line for periodicity factor\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance periodicity control and diversity management by adjusting periodicity factor dynamically and refining diversity calculation.", "configspace": "", "generation": 32, "fitness": 0.24714572624271627, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "dd346a73-c412-439d-995c-cc9bef1105d4", "metadata": {"aucs": [0.2474024167726051, 0.2460235023577234, 0.24801125959782033], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "50af5a48-578b-4b71-996e-8f25be7469ab", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity) * np.random.rand()  # Changed line\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        if np.random.rand() < self.local_search_prob + 0.05:  # Changed line\n            res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n            return res.x\n        return solution\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance mutation diversity by introducing stochastic scaling in mutation factor adjustment and improve local refinement chances.", "configspace": "", "generation": 33, "fitness": 0.2465559981958093, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "dd346a73-c412-439d-995c-cc9bef1105d4", "metadata": {"aucs": [0.2455468228645563, 0.24788174556969345, 0.24623942615317818], "final_y": [0.16485751310148167, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "f6f5b8bb-0ac8-4cbc-8d75-aa0bf0167470", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)  # Changed line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * np.cos(2 * np.pi * generation / 15):  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])  # Changed line\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),  # Changed line\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce dynamic local search probability and adaptive periodicity to enhance solution refinement and exploit periodic structures.", "configspace": "", "generation": 34, "fitness": 0.247145730908078, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "dd346a73-c412-439d-995c-cc9bef1105d4", "metadata": {"aucs": [0.2474024167726051, 0.2460235023577234, 0.2480112735939055], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "65f688f2-6e89-4bdf-8844-809bffd90b90", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass InertiaMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.1\n        self.local_search_prob = 0.25\n        self.best_solution = None\n        self.inertia_weight = 0.9\n        self.velocity = np.zeros((self.pop_size, self.dim))\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_inertia_weight(self, generation):\n        return 0.5 + 0.4 * np.exp(-generation / 10)\n\n    def mutate(self, population, idx, generation):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.base_mutation_factor\n        mutant = a + mutation_factor * (b - c)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            inertia_weight = self.adapt_inertia_weight(generation)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation)\n                trial = self.crossover(target, mutant)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                self.velocity[idx] = inertia_weight * self.velocity[idx] + (1 - inertia_weight) * (selected - target)\n                selected = selected + self.velocity[idx]\n                selected = np.clip(selected, lb, ub)\n                if np.random.rand() < self.local_search_prob:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "InertiaMemeticDE", "description": "Introduce adaptive inertia-based memetic differential evolution to balance exploration and exploitation dynamically, leveraging momentum and periodic patterns.", "configspace": "", "generation": 35, "fitness": 0.24557045681896314, "feedback": "The algorithm InertiaMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f6f5b8bb-0ac8-4cbc-8d75-aa0bf0167470", "metadata": {"aucs": [0.24808662195239473, 0.2450408874834975, 0.24358386102099716], "final_y": [0.16485751310148167, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "c75016be-dabd-4946-b3b1-bc53ca2f5a0a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.6  # Changed line\n        self.crossover_rate = 0.9  # Changed line\n        self.periodicity_factor = 0.2  # Changed line\n        self.local_search_prob = 0.35  # Changed line\n        self.best_solution = None\n        self.diversity_threshold = 0.015  # Changed line\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.15 * (1 - diversity)  # Changed line\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 8)  # Changed line\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.55 + 0.3 * np.cos(2 * np.pi * generation / 10)  # Changed line\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.3 + 0.15 * np.cos(2 * np.pi * generation / 18):  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 18)) * self.periodicity_cost(ind) for ind in population])  # Changed line\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 18)) * self.periodicity_cost(x),  # Changed line\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance memetic DE with adaptive local search and dynamic crossover to exploit periodic structure more effectively.", "configspace": "", "generation": 36, "fitness": 0.24676075212373957, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f6f5b8bb-0ac8-4cbc-8d75-aa0bf0167470", "metadata": {"aucs": [0.24718014487958961, 0.2454320671595711, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "70178f15-7906-4c8b-b9b5-d1305efeac7c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.15 * (1 - diversity)  # Changed line\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) \n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.6 + 0.25 * np.cos(2 * np.pi * generation / 20)  # Changed line\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * np.cos(2 * np.pi * generation / 15): \n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population]) \n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),  \n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance diversity and convergence through dynamic mutation factor scaling and crossover strategy adjustments.", "configspace": "", "generation": 37, "fitness": 0.24684295594765313, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f6f5b8bb-0ac8-4cbc-8d75-aa0bf0167470", "metadata": {"aucs": [0.24808676394262685, 0.24477205956827452, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "3a6da50e-bd29-4fc8-8a89-84d9503b3291", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 4))  # Changed line\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * np.cos(2 * np.pi * generation / 15):\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Slightly alter the calculation of periodicity cost to better capture periodic structures and enhance convergence.", "configspace": "", "generation": 38, "fitness": 0.24689806000578485, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f6f5b8bb-0ac8-4cbc-8d75-aa0bf0167470", "metadata": {"aucs": [0.2474024167726051, 0.24528049021847398, 0.24801127302627546], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "b810696e-6022-4e9e-8b03-7bed0d4a713d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGroupDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.neutral_zone_factor = 0.1\n        self.best_solution = None\n        self.group_size = 5\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def differential_grouping(self, population):\n        random_indices = np.random.permutation(self.pop_size)\n        groups = [population[random_indices[i:i + self.group_size]] for i in range(0, self.pop_size, self.group_size)]\n        return groups\n\n    def mutate(self, group, idx):\n        indices = np.random.choice(len(group), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(len(group), 3, replace=False)\n        a, b, c = group[indices]\n        mutation_factor = self.base_mutation_factor\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        neutral_zone = np.random.rand(self.dim) < self.neutral_zone_factor\n        if np.any(neutral_zone):\n            trial[neutral_zone] = target[neutral_zone]\n        target_cost = func(target)\n        trial_cost = func(trial)\n        return trial if trial_cost < target_cost else target\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            groups = self.differential_grouping(population)\n            for group in groups:\n                for idx in range(len(group)):\n                    target = group[idx]\n                    mutant = self.mutate(group, idx)\n                    trial = self.crossover(target, mutant)\n                    trial = lb + trial * (ub - lb)\n                    selected = self.select(target, trial, func)\n                    new_population.append(selected)\n                    evaluations += 1\n                    if evaluations >= self.budget:\n                        break\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n\n        best_idx = np.argmin([func(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(func, self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveGroupDE", "description": "Introduce adaptive differential grouping and neutral zone exploration to enhance robustness and diversity in solving complex layered optimization problems.", "configspace": "", "generation": 39, "fitness": 0.20305724934879718, "feedback": "The algorithm AdaptiveGroupDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.203 with standard deviation 0.003. And the mean value of best solutions found was 0.450 (0. is the best) with standard deviation 0.026.", "error": "", "parent_id": "f6f5b8bb-0ac8-4cbc-8d75-aa0bf0167470", "metadata": {"aucs": [0.2008339498851348, 0.2068239829746309, 0.2015138151866258], "final_y": [0.47239265783783124, 0.41379549904142665, 0.46469205749927356]}, "mutation_prompt": null}
{"id": "ede3d4f1-1611-47cd-af88-719febff7738", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.55 + 0.35 * np.cos(2 * np.pi * generation / 20)  # Changed line\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.1 * np.cos(2 * np.pi * generation / 15):  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 18)) * self.periodicity_cost(ind) for ind in population])  # Changed line\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 18)) * self.periodicity_cost(x),  # Changed line\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance periodicity modulation and adapt crossover dynamics to improve exploration-exploitation balance.", "configspace": "", "generation": 40, "fitness": 0.24674725886087678, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f6f5b8bb-0ac8-4cbc-8d75-aa0bf0167470", "metadata": {"aucs": [0.24742369542832143, 0.24620393793954387, 0.24661414321476505], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "d518a49f-09ff-408a-8f85-dae0e70de6e4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 2))  # Changed line\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * diversity  # Changed line\n        return self.base_mutation_factor + factor_adjustment * np.sin(np.pi * generation / 6)  # Changed line\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = self.crossover_rate + 0.35 * np.cos(np.pi * generation / 10)  # Changed line\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.std(np.linalg.norm(population - mean_sol, axis=1))  # Changed line\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.05 * np.cos(np.pi * generation / 10):  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])  # Changed line\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),  # Changed line\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce adaptive mutation and crossover based on diversity and periodicity to enhance exploration and exploitation balance.", "configspace": "", "generation": 41, "fitness": 0.24631203715231234, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f6f5b8bb-0ac8-4cbc-8d75-aa0bf0167470", "metadata": {"aucs": [0.24666909859590125, 0.24459696852897783, 0.24767004433205797], "final_y": [0.16485751310148167, 0.16485914511389144, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)  # Changed line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * diversity:  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])  # Changed line\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),  # Changed line\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce a diversity-driven local search trigger to enhance exploration and escape local minima.", "configspace": "", "generation": 42, "fitness": 0.24717913647110012, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f6f5b8bb-0ac8-4cbc-8d75-aa0bf0167470", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "99ac8fab-b44c-4870-bdaf-fe23a90e5699", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)  # Changed line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * diversity:  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])  # Changed line\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),  # Changed line\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance diversity by adjusting mutation dynamics to improve exploration and exploitation balance.", "configspace": "", "generation": 43, "fitness": 0.24717913647110012, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "3386f092-ce4f-47b1-8428-ccc65b608a1b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.15 * (1 - diversity)  # Changed line\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        perturbation = 0.20 * (np.random.rand(self.dim) - 0.5)  # Changed line\n        mutant = a + mutation_factor * (b - c) + perturbation  # Changed line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.15 * diversity:  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance the diversity mechanism by adjusting convergence pressure and refining mutation strategy for improved exploration and exploitation balance.", "configspace": "", "generation": 44, "fitness": 0.24717913647110012, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "3cb0424f-807f-4e2f-9d0a-c2c6884f4e65", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)  # Changed line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < min(0.25, 0.2 + 0.1 * diversity):  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])  # Changed line\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),  # Changed line\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance exploitation by increasing local search probability based on diversity.", "configspace": "", "generation": 45, "fitness": 0.24714574341319692, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24740242965986514, 0.24602352660740012, 0.24801127397232547], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "a23d2b3b-d95b-4c77-a216-a42cde6c6392", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        dynamic_periodicity_factor = self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20) + 0.05 * diversity  # Changed line\n        best_idx = np.argmin([func(ind) + dynamic_periodicity_factor * self.periodicity_cost(ind) for ind in population])  # Changed line\n\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + dynamic_periodicity_factor * self.periodicity_cost(x),  # Changed line\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce adaptive periodicity factor modulation based on diversity to enhance solution periodicity and global optimality.", "configspace": "", "generation": 46, "fitness": 0.24717913647110012, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "e3ba5431-7945-4eb1-b4b2-dd445ab51bc4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n        elite = None  # Initialize elite variable\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n            if elite is not None and func(elite) < np.min([func(ind) for ind in population]):  # Preserve elite\n                population[np.argmax([func(ind) for ind in population])] = elite\n            elite = population[np.argmin([func(ind) for ind in population])]  # Update elite\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhancing AdaptiveMemeticDEPA by introducing an elite-preserving mechanism and adaptive periodicity adjustment.", "configspace": "", "generation": 47, "fitness": 0.24717913647110012, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "da68edc5-b873-474d-8094-e6eca44cf96f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.15 + 0.05 * diversity:  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance local search adaptively based on diversity and generation cycle.", "configspace": "", "generation": 48, "fitness": 0.24717913647110012, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "03726ce6-96b9-4fc2-8f50-3fd21a51ef92", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)  # Changed line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * diversity:  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])  # Changed line\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        # Updated a single line by adding generation-based dynamic periodicity factor adjustment\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.1 * np.cos(2 * np.pi * generation / 30)) * self.periodicity_cost(x),  # Changed line\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance periodicity reinforcement by dynamically adjusting the periodicity factor based on generation progression to foster more optimal interference patterns.", "configspace": "", "generation": 49, "fitness": 0.24717913647110012, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "69fd34a8-5e4f-4d18-8671-f43405be8677", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)  # Changed line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * diversity:  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 10)) * self.periodicity_cost(ind) for ind in population])  # Changed line\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),  # Changed line\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce seasonally adaptive periodicity adjustment to the cost function to improve periodic solution convergence.", "configspace": "", "generation": 50, "fitness": 0.24717913647110012, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "8abf9aae-c573-42c1-bd02-8f83e00ad164", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * np.random.rand())) * self.periodicity_cost(x), # Changed line\n                       solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce adaptive periodicity factor modulation in the local refinement process to enhance convergence.", "configspace": "", "generation": 51, "fitness": 0.20385368081527985, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.204 with standard deviation 0.006. And the mean value of best solutions found was 0.363 (0. is the best) with standard deviation 0.033.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.2117189612849243, 0.19898758285438667, 0.20085449830652857], "final_y": [0.3508347723973311, 0.40731765850071366, 0.32942239431544484]}, "mutation_prompt": null}
{"id": "3f71ec9e-eb92-4c2c-994a-70c83ead5314", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)  # Changed line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.1 * diversity:  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])  # Changed line\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),  # Changed line\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance exploration by increasing local search probability at higher diversity levels.", "configspace": "", "generation": 52, "fitness": 0.24717913647110012, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "ca6ea2b6-08c8-45d6-927e-ddaebf3126b9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)  # Changed line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * diversity:  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])  # Changed line\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),  # Changed line\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce a diversity-driven local search trigger to enhance exploration and escape local minima.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "307123e5-cadf-4816-9d85-0e84b714a3fc", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.2  # Changed line\n        self.local_search_prob = 0.2  # Changed line\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[:len(solution)//2] - solution[len(solution)//2:]) + np.var(solution - np.roll(solution, 2))  # Changed line\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob * (1 + diversity):  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + self.periodicity_factor * self.periodicity_cost(ind) for ind in population])  # Changed line\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + self.periodicity_factor * self.periodicity_cost(x),  # Changed line\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Refine the AdaptiveMemeticDEPA by incorporating adaptive local search probability and improved periodic cost calculation.", "configspace": "", "generation": 54, "fitness": 0.24717913647110012, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "9d08dd1c-fcbc-48ce-b484-92ced2a4af0b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)  # Changed line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.10 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])  # Changed line\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance solution exploration by refining the mutation strategy and fine-tuning periodicity constraint adaptation.", "configspace": "", "generation": 55, "fitness": 0.24717913647110012, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "2650996e-6894-42d4-b96c-f60e03bbef83", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * diversity) * self.periodicity_cost(ind) for ind in population])  # Changed line\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * diversity) * self.periodicity_cost(x),  # Changed line\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance solution selection by incorporating diversity-based adaptive periodic factor adjustment.", "configspace": "", "generation": 56, "fitness": 0.24717913647110012, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "1c61f586-3907-41fb-b686-ee9de77b3806", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)  # Changed line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * diversity:  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])  # Changed line\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),  # Changed line\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce a diversity-driven local search trigger to enhance exploration and escape local minima.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "f134972e-f04c-426c-9a72-69d9c85211de", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.6  # Changed line\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.4  # Changed line\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Improve exploration by adjusting the mutation factor and increase local search probability for better convergence.", "configspace": "", "generation": 58, "fitness": 0.24717913647110012, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "b87c9803-e007-4404-8d43-b59b0111bb85", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def adjust_periodicity_factor(self, generation):  # New function added\n        return self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 30)  # New line added\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)  # Changed line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        periodicity_factor_adjusted = self.adjust_periodicity_factor(0)  # Changed line\n        target_cost = func(target) + periodicity_factor_adjusted * self.periodicity_cost(target)\n        trial_cost = func(trial) + periodicity_factor_adjusted * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * diversity:  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])  # Changed line\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),  # Changed line\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Implement a dynamic periodicity factor adjustment to better guide the optimization towards periodic solutions.", "configspace": "", "generation": 59, "fitness": 0.24717913647110012, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "4915bef7-47a1-4029-8018-11f0a4671c5b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.35  # Changed line\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 2))  # Changed line\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.1 * diversity:  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance periodicity and adjust local search probability to improve convergence reliability.", "configspace": "", "generation": 60, "fitness": 0.24717913647110012, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "97bb8f8b-e0d7-4afe-8603-0b256eefd17a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity, recent_improvement):\n        factor_adjustment = 0.1 * (1 - diversity)\n        performance_adjustment = 0.05 * recent_improvement  # Changed line\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12) + performance_adjustment\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity, 0)  # Placeholder value for recent_improvement\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce a feedback mechanism to adjust the mutation factor dynamically based on recent performance improvements.", "configspace": "", "generation": 61, "fitness": 0.24717913647110012, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "d90393f5-5273-480e-a556-9d839bbc01f9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.55  # Changed line\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.2  # Changed line\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.15 * (1 - diversity)  # Changed line\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.1 * diversity:  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance solution periodicity and adaptive factors to improve convergence and solution diversity.", "configspace": "", "generation": 62, "fitness": 0.2463857974626964, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24742501247099546, 0.24406233558503576, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "79599b2e-a8ca-4146-a2ac-0fb2b8077425", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.05 * (np.random.rand(self.dim) - 0.5)  # Changed line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Refine mutation strategy for enhanced exploration by adjusting random perturbation scale.", "configspace": "", "generation": 63, "fitness": 0.24717913647110012, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "fe9fcecf-a7fd-4e8a-a525-6d7af353d40e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)  # Changed line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        selection_bias = 0.95  # New line added for selection bias, promoting promising trials\n        return trial if selection_bias * trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * diversity:  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])  # Changed line\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),  # Changed line\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance the selection process to emphasize promising trials, improving convergence speed and solution quality.", "configspace": "", "generation": 64, "fitness": 0.24717895212253874, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737034804500924, 0.2464963694603094, 0.2476701388622976], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "30dc31a9-0257-450e-9b35-477311d3c063", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 10)  # Changed line\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 18)  # Changed line\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.1 * diversity:  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.04 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])  # Changed line\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance dynamic adaptation mechanisms to better balance exploration and exploitation.", "configspace": "", "generation": 65, "fitness": 0.24717913647110012, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "4a654bbc-ae0b-4ba1-8e9b-6dde81b5868f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.15 * diversity:  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance local search trigger probability to adapt based on diversity to improve convergence speed.", "configspace": "", "generation": 66, "fitness": 0.24717913647110012, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "a01db3cd-0b1b-4955-9cd1-a74b0210e9c7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            self.periodicity_factor = 0.1 + 0.1 * np.abs(np.sin(np.pi * diversity * generation / 15))  # Changed line\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Refine periodicity adaptation by dynamically adjusting the periodicity factor based on diversity and generation.", "configspace": "", "generation": 67, "fitness": 0.24717913647110012, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "1515442d-015b-4455-b4c4-61baddb7ee9c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)  # Changed line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * diversity:  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])  # Changed line\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),  # Changed line\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce a diversity-driven local search trigger to enhance exploration and escape local minima.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "1a9eb39b-238c-496f-824b-419efa4ca37b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)], method='L-BFGS-B')  # Changed line\n        return res.x\n\n    def calculate_diversity(self, population):\n        norm_pop = np.linalg.norm(population, axis=1)  # Changed line\n        diversity = np.var(norm_pop) / np.mean(norm_pop)  # Changed line\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance local optimization refinement and diversity calculation to exploit promising regions while maintaining solution diversity.", "configspace": "", "generation": 69, "fitness": 0.24717913647110012, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "fd564726-6f8c-4b13-930e-d699627d8a63", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.10 * (np.random.rand(self.dim) - 0.5)\n        mutant += 0.05 * np.sin(2 * np.pi * np.arange(self.dim) / 4)  # Changed line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.35 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.2 + 0.1 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor - 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance exploration and periodic solution bias by introducing random periodic perturbations and adaptive periodicity factors.", "configspace": "", "generation": 70, "fitness": 0.24717913647110012, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649603836349232, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "bc27e73d-2054-4593-841c-2fbe1a4b11e1", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)  # New line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)  # New line\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.05 * diversity:  # New line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])  # New line\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),  # New line\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Integrate diversity-adaptive periodicity promotion and dynamic local exploration to enhance convergence in complex optimization landscapes.", "configspace": "", "generation": 71, "fitness": 0.2471791372037222, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5955b352-5107-4bba-a3a2-b004dc9b003b", "metadata": {"aucs": [0.24737132671775008, 0.24649604056135854, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "ee224a1e-f1ef-4fc1-bb6a-aad650f14f65", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)  # New line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)  # New line\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.05 * diversity:  # New line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.sin(2 * np.pi * generation / 20)) * self.periodicity_cost(ind) for ind in population])  # Modified line\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 20)) * self.periodicity_cost(x),  # Modified line\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Refine adaptive search dynamics by intensifying periodicity control to enhance solution quality.", "configspace": "", "generation": 72, "fitness": 0.2471791372037222, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bc27e73d-2054-4593-841c-2fbe1a4b11e1", "metadata": {"aucs": [0.24737132671775008, 0.24649604056135854, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "0e782e85-fb19-4b03-a222-e1f16283a24a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.25  # Adjusted line\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c)  # Removed random perturbation line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob + 0.05 * diversity:  # Adjusted line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance the balance between global and local search by adjusting local search probability and mutation factor based on diversity metrics.", "configspace": "", "generation": 73, "fitness": 0.24638579758650872, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bc27e73d-2054-4593-841c-2fbe1a4b11e1", "metadata": {"aucs": [0.24742501247099546, 0.24406233595647275, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "3dbcf31c-bac2-415a-b91b-3c7c77067610", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.05 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance solution refinement by adjusting local search probability and periodicity factor dynamically based on diversity.", "configspace": "", "generation": 74, "fitness": 0.2471791372037222, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bc27e73d-2054-4593-841c-2fbe1a4b11e1", "metadata": {"aucs": [0.24737132671775008, 0.24649604056135854, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "5ddcad36-a39d-442f-b627-be9fea5fe191", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            self.local_search_prob = 0.25 + 0.1 * diversity  # Changed line (1)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob:  # Changed line (2)\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance local search by dynamically adapting the local search probability based on diversity.", "configspace": "", "generation": 75, "fitness": 0.2471791372037222, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bc27e73d-2054-4593-841c-2fbe1a4b11e1", "metadata": {"aucs": [0.24737132671775008, 0.24649604056135854, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "1664556f-5d7d-4ac2-87f6-6d541ea8e86e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)  # New line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)  # New line\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.1 * diversity:  # Adjusted line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])  # New line\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),  # New line\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance local refinement probability based on diversity to better exploit promising regions.", "configspace": "", "generation": 76, "fitness": 0.2471791372037222, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bc27e73d-2054-4593-841c-2fbe1a4b11e1", "metadata": {"aucs": [0.24737132671775008, 0.24649604056135854, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "ceba3f31-b5bd-445e-8bd9-470935549226", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.6  # Changed from 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.1 * (np.random.rand(self.dim) - 0.5)  # Changed from 0.15\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.05 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance periodicity promotion and adaptive mutation to boost convergence in diverse optimization landscapes.", "configspace": "", "generation": 77, "fitness": 0.2471791372037222, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bc27e73d-2054-4593-841c-2fbe1a4b11e1", "metadata": {"aucs": [0.24737132671775008, 0.24649604056135854, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "8eba0365-ff24-42ce-a24c-77f4bdb6b1f0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob * (1 + diversity):  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance adaptability by dynamically adjusting local search probability based on diversity.", "configspace": "", "generation": 78, "fitness": 0.2471791372037222, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bc27e73d-2054-4593-841c-2fbe1a4b11e1", "metadata": {"aucs": [0.24737132671775008, 0.24649604056135854, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "82e6164a-6b6a-4d02-9e84-4c4d273b026c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        target_cost = func(target) + self.periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + self.periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.05 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x), \n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Improve convergence by adapting the periodicity factor dynamically instead of using a constant value.", "configspace": "", "generation": 79, "fitness": 0.2471791372037222, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bc27e73d-2054-4593-841c-2fbe1a4b11e1", "metadata": {"aucs": [0.24737132671775008, 0.24649604056135854, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "ad11b891-61af-4f8e-8659-036c4149c9ba", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        adaptive_periodicity_factor = self.periodicity_factor + 0.05 * np.sin(2 * np.pi * np.random.rand())  # Changed line\n        target_cost = func(target) + adaptive_periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + adaptive_periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.05 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce adaptive periodicity factor to refine solution selection and enhance convergence by dynamically balancing exploration and exploitation.", "configspace": "", "generation": 80, "fitness": 0.24718730721799978, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bc27e73d-2054-4593-841c-2fbe1a4b11e1", "metadata": {"aucs": [0.24739583676058285, 0.24649604056135854, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "18eb6996-e8d4-47ab-932d-706ce298304c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)\n        cross_points = np.random.rand(self.dim) < (dynamic_crossover_rate + 0.1)\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        adaptive_periodicity_factor = self.periodicity_factor + 0.05 * np.sin(2 * np.pi * np.random.rand())\n        target_cost = func(target) + adaptive_periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + adaptive_periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.05 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance solution selection by adding diversity consideration during crossover and mutation phases for improved convergence.", "configspace": "", "generation": 81, "fitness": 0.24718719459212446, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ad11b891-61af-4f8e-8659-036c4149c9ba", "metadata": {"aucs": [0.24739557559766556, 0.24649596384664985, 0.24767004433205797], "final_y": [0.16485751310148167, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "fd03be92-db3e-4d13-862a-e2711b4bfb3b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.2 * (1 - diversity)  # Changed line\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        adaptive_periodicity_factor = self.periodicity_factor + 0.05 * np.sin(2 * np.pi * np.random.rand())\n        target_cost = func(target) + adaptive_periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + adaptive_periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.05 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance adaptive periodicity by strengthening the impact of diversity on mutation, promoting better exploration.", "configspace": "", "generation": 82, "fitness": 0.24718730721799978, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ad11b891-61af-4f8e-8659-036c4149c9ba", "metadata": {"aucs": [0.24739583676058285, 0.24649604056135854, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "c9bb90c5-99da-4749-ba4e-01a7e3674ce6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        adaptive_periodicity_factor = self.periodicity_factor + 0.05 * np.sin(2 * np.pi * np.random.rand())\n        target_cost = func(target) + adaptive_periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + adaptive_periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def adjust_population_size(self, diversity):  # New line\n        self.pop_size = max(10, int(30 * (1 + diversity)))  # New line\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            self.adjust_population_size(diversity)  # New line\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.05 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance diversity maintenance by incorporating adaptive population size and improved local search strategy.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 5242 is out of bounds for axis 0 with size 30').", "error": "IndexError('index 5242 is out of bounds for axis 0 with size 30')", "parent_id": "ad11b891-61af-4f8e-8659-036c4149c9ba", "metadata": {}, "mutation_prompt": null}
{"id": "6f4de5db-7d75-4ed4-b638-7c389853d173", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation, diversity):  # Changed line\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25) * (1 + diversity)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        adaptive_periodicity_factor = self.periodicity_factor + 0.05 * np.sin(2 * np.pi * np.random.rand())\n        target_cost = func(target) + adaptive_periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + adaptive_periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation, diversity)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.05 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance exploration by dynamically adjusting the crossover rate based on population diversity to improve convergence speed and solution quality.", "configspace": "", "generation": 84, "fitness": 0.24715375543238804, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ad11b891-61af-4f8e-8659-036c4149c9ba", "metadata": {"aucs": [0.247316299364998, 0.24647492260010817, 0.24767004433205797], "final_y": [0.16485751310148167, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "8c88efee-d496-404c-bcf6-387c32368ad7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 4, replace=False)  # Changed line\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 4, replace=False)  # Changed line\n        a, b, c, d = population[indices]  # Changed line\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c + d - a)  # Changed line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation, diversity):  # Changed line\n        dynamic_crossover_rate = self.crossover_rate * (1 + 0.5 * diversity)  # Changed line\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        adaptive_periodicity_factor = self.periodicity_factor + 0.05 * np.sin(2 * np.pi * np.random.rand())\n        target_cost = func(target) + adaptive_periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + adaptive_periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation, diversity)  # Changed line\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.05 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance exploration by dynamically adjusting crossover rate based on diversity and introducing a new mutation strategy.", "configspace": "", "generation": 85, "fitness": 0.24106252001953332, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.241 with standard deviation 0.005. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "ad11b891-61af-4f8e-8659-036c4149c9ba", "metadata": {"aucs": [0.23606621783527681, 0.23945129789126518, 0.24767004433205797], "final_y": [0.16485981690450935, 0.1818792924659013, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "41e19e74-2f85-4acb-9f20-aaaa4239e03f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 2))  # Changed line\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        adaptive_periodicity_factor = self.periodicity_factor + 0.05 * np.sin(2 * np.pi * np.random.rand())\n        target_cost = func(target) + adaptive_periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + adaptive_periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.05 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance periodicity by adjusting periodicity error calculation to encourage more constructive interference.", "configspace": "", "generation": 86, "fitness": 0.24718730721799978, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ad11b891-61af-4f8e-8659-036c4149c9ba", "metadata": {"aucs": [0.24739583676058285, 0.24649604056135854, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "0669f4ee-7ed7-4638-b2d4-f383b1d7c9d0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        diversity = self.calculate_diversity([target, trial])  # Changed line\n        adaptive_periodicity_factor = self.periodicity_factor + 0.05 * np.sin(2 * np.pi * diversity)  # Changed line\n        target_cost = func(target) + adaptive_periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + adaptive_periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.05 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Refine the adaptive periodicity factor by incorporating diversity-based feedback for improved convergence.", "configspace": "", "generation": 87, "fitness": 0.2471791372037222, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ad11b891-61af-4f8e-8659-036c4149c9ba", "metadata": {"aucs": [0.24737132671775008, 0.24649604056135854, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "9073e2c6-f35e-40cd-b76d-be7768e1f65b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation): # Changed line\n        dynamic_crossover_rate = 0.6 + 0.2 * np.cos(2 * np.pi * generation / 25) # Changed line\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        adaptive_periodicity_factor = self.periodicity_factor + 0.1 * np.sin(2 * np.pi * np.random.rand())  # Changed line\n        target_cost = func(target) + adaptive_periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + adaptive_periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.20 + 0.10 * diversity: # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub) # Changed line\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhanced exploration-exploitation balance by refining periodicity adaptation and diversity influence.", "configspace": "", "generation": 88, "fitness": 0.24718730721799978, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ad11b891-61af-4f8e-8659-036c4149c9ba", "metadata": {"aucs": [0.24739583676058285, 0.24649604056135854, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "ec9d5d48-d0f8-4652-9aa5-f892bd960b67", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        adaptive_periodicity_factor = self.periodicity_factor + 0.05 * np.sin(2 * np.pi * np.random.rand())  # Changed line\n        target_cost = func(target) + adaptive_periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + adaptive_periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.05 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce stochastic periodicity factor in solution selection to enhance adaptation based on random fluctuations.", "configspace": "", "generation": 89, "fitness": 0.24718730721799978, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ad11b891-61af-4f8e-8659-036c4149c9ba", "metadata": {"aucs": [0.24739583676058285, 0.24649604056135854, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "5c6a28e6-d29c-4676-81a1-adb13dbf3353", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        adaptive_periodicity_factor = self.periodicity_factor + 0.05 * np.sin(2 * np.pi * np.random.rand())  # Changed line\n        target_cost = func(target) + adaptive_periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + adaptive_periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.05 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Refine AdaptiveMemeticDEPA by enhancing local search exploitation based on solution diversity.", "configspace": "", "generation": 90, "fitness": 0.24718730721799978, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ad11b891-61af-4f8e-8659-036c4149c9ba", "metadata": {"aucs": [0.24739583676058285, 0.24649604056135854, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "05c4f658-b19f-4bf6-8286-e818c9539c7f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial + 0.02 * np.sin(2 * np.pi * generation / 40)  # Changed line\n\n    def select(self, target, trial, func):\n        adaptive_periodicity_factor = self.periodicity_factor + 0.05 * np.sin(2 * np.pi * np.random.rand())\n        target_cost = func(target) + adaptive_periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + adaptive_periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.05 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Integrate a sinusoidal perturbation into the crossover process to enhance diversity and convergence in challenging landscapes.", "configspace": "", "generation": 91, "fitness": 0.24718730721799978, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ad11b891-61af-4f8e-8659-036c4149c9ba", "metadata": {"aucs": [0.24739583676058285, 0.24649604056135854, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "d98555ba-85b8-46d4-8dd3-b4a6a7ec889c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        # Changed line\n        dynamic_crossover_rate = 0.6 + 0.25 * np.cos(2 * np.pi * generation / 20)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        adaptive_periodicity_factor = self.periodicity_factor + 0.05 * np.sin(2 * np.pi * np.random.rand())  # Changed line\n        target_cost = func(target) + adaptive_periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + adaptive_periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.05 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce adaptive crossover rate enhancement to improve balance between exploration and exploitation.", "configspace": "", "generation": 92, "fitness": 0.24718719442014092, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ad11b891-61af-4f8e-8659-036c4149c9ba", "metadata": {"aucs": [0.24739557559766556, 0.24649596333069923, 0.24767004433205797], "final_y": [0.16485751310148167, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "0c17d303-d799-4ce0-afda-2bea9c748833", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.2  # Adjusted periodicity factor\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2])\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * np.log1p(1 - diversity)  # Adjust mutation factor adaptation\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.1 * (np.random.rand(self.dim) - 0.5)  # Modified noise\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = self.crossover_rate * (0.8 + 0.2 * np.sin(2 * np.pi * generation / 25))  # Adjusted crossover\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        adaptive_periodicity_factor = self.periodicity_factor + 0.05 * np.random.rand()  # Adjusted factor\n        target_cost = func(target) + adaptive_periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + adaptive_periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < self.local_search_prob * (1 + diversity):  # Adjust local search probability\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance exploration-exploitation balance using adaptive periodicity, dynamic mutation, and selective local refinement to optimize multilayered photonic structures.", "configspace": "", "generation": 93, "fitness": 0.2471604514426351, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ad11b891-61af-4f8e-8659-036c4149c9ba", "metadata": {"aucs": [0.24733735991298922, 0.24647097277576335, 0.24767302163915272], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "b3933b64-b97c-474d-8421-6cc2a639c228", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        sinusoidal_factor = 0.15 * np.sin(2 * np.pi * generation / 30)  # Changed line\n        mutant = a + mutation_factor * (b - c) + sinusoidal_factor * (np.random.rand(self.dim) - 0.5)  # Changed line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        adaptive_periodicity_factor = self.periodicity_factor + 0.05 * np.sin(2 * np.pi * np.random.rand())\n        target_cost = func(target) + adaptive_periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + adaptive_periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.05 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance diversity management by introducing a sinusoidal factor in the mutation process to maintain exploration capabilities.", "configspace": "", "generation": 94, "fitness": 0.24718730721799978, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ad11b891-61af-4f8e-8659-036c4149c9ba", "metadata": {"aucs": [0.24739583676058285, 0.24649604056135854, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "3b676a02-777d-487e-bb07-4b3fe764b48e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):  # Changed line\n        dynamic_crossover_rate = 0.6 + 0.25 * np.cos(2 * np.pi * generation / 15)  # Changed line\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        adaptive_periodicity_factor = self.periodicity_factor + 0.05 * np.sin(2 * np.pi * np.random.rand())\n        target_cost = func(target) + adaptive_periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + adaptive_periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.05 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Incorporate adaptive crossover rate modulation to enhance solution diversity and convergence precision.", "configspace": "", "generation": 95, "fitness": 0.24718719442014092, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ad11b891-61af-4f8e-8659-036c4149c9ba", "metadata": {"aucs": [0.24739557559766556, 0.24649596333069923, 0.24767004433205797], "final_y": [0.16485751310148167, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "80d7368e-0a1d-43ec-aa79-900055b6dbf4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        adaptive_periodicity_factor = self.periodicity_factor + 0.05 * np.cos(2 * np.pi * np.random.rand())  # Changed line\n        target_cost = func(target) + adaptive_periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + adaptive_periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.05 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Refine periodicity factor adjustment for improved solution selection and convergence.", "configspace": "", "generation": 96, "fitness": 0.24718730721799978, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ad11b891-61af-4f8e-8659-036c4149c9ba", "metadata": {"aucs": [0.24739583676058285, 0.24649604056135854, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "c45e6a18-dcf5-493c-a683-c6ef35dffbd0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        mutant += 0.1 * (np.random.rand(self.dim) - 0.5) * diversity # Changed line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        adaptive_periodicity_factor = self.periodicity_factor + 0.05 * np.sin(2 * np.pi * np.random.rand())\n        target_cost = func(target) + adaptive_periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + adaptive_periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.1 * diversity: # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduce diversity-driven mutation and adaptive local search frequency to enhance exploration and local refinement.", "configspace": "", "generation": 97, "fitness": 0.24715760365771214, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ad11b891-61af-4f8e-8659-036c4149c9ba", "metadata": {"aucs": [0.24732776010295354, 0.24647500653812493, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "42fb2434-a818-49d7-931e-d4247087732b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.1 * (1 - diversity)\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.15 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        diversity = self.calculate_diversity([target, trial])\n        adaptive_periodicity_factor = self.periodicity_factor + 0.05 * np.sin(2 * np.pi * diversity)  # Changed line\n        target_cost = func(target) + adaptive_periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + adaptive_periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.25 + 0.05 * diversity:\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Introduced adaptive diversity-based periodicity to enhance convergence by balancing exploration and exploitation more effectively.", "configspace": "", "generation": 98, "fitness": 0.2471791372037222, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ad11b891-61af-4f8e-8659-036c4149c9ba", "metadata": {"aucs": [0.24737132671775008, 0.24649604056135854, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "cae3fec1-4da1-4349-a67b-0ddfd965a4f8", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticDEPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.base_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.periodicity_factor = 0.15\n        self.local_search_prob = 0.3\n        self.best_solution = None\n        self.diversity_threshold = 0.01\n\n    def periodicity_cost(self, solution):\n        periodic_error = np.var(solution[::2] - solution[1::2]) + np.var(solution - np.roll(solution, 3))\n        return periodic_error\n\n    def initialize_population(self, lb, ub):\n        return lb + np.random.rand(self.pop_size, self.dim) * (ub - lb)\n\n    def adapt_mutation_factor(self, generation, diversity):\n        factor_adjustment = 0.2 * (1 - diversity)  # Changed line\n        return self.base_mutation_factor + factor_adjustment * np.sin(2 * np.pi * generation / 12)\n\n    def mutate(self, population, idx, generation, diversity):\n        indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(range(self.pop_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutation_factor = self.adapt_mutation_factor(generation, diversity)\n        mutant = a + mutation_factor * (b - c) + 0.1 * (np.random.rand(self.dim) - 0.5)  # Changed line\n        return np.clip(mutant, 0, 1)\n\n    def crossover(self, target, mutant, generation):\n        dynamic_crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * generation / 25)\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target, trial, func):\n        adaptive_periodicity_factor = self.periodicity_factor + 0.1 * np.sin(2 * np.pi * np.random.rand())  # Changed line\n        target_cost = func(target) + adaptive_periodicity_factor * self.periodicity_cost(target)\n        trial_cost = func(trial) + adaptive_periodicity_factor * self.periodicity_cost(trial)\n        return trial if trial_cost < target_cost else target\n\n    def local_refinement(self, solution, func, lb, ub):\n        res = minimize(func, solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return res.x\n\n    def calculate_diversity(self, population):\n        mean_sol = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - mean_sol, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.initialize_population(lb, ub)\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            new_population = []\n            diversity = self.calculate_diversity(population)\n            for idx in range(self.pop_size):\n                target = population[idx]\n                mutant = self.mutate(population, idx, generation, diversity)\n                trial = self.crossover(target, mutant, generation)\n                trial = lb + trial * (ub - lb)\n                selected = self.select(target, trial, func)\n                if np.random.rand() < 0.3 + 0.05 * diversity:  # Changed line\n                    selected = self.local_refinement(selected, func, lb, ub)\n                new_population.append(selected)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n            population = np.array(new_population)\n            generation += 1\n\n        best_idx = np.argmin([func(ind) + (self.periodicity_factor + 0.05 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(ind) for ind in population])\n        best_solution = population[best_idx]\n\n        if self.best_solution is None or func(best_solution) < func(self.best_solution):\n            self.best_solution = best_solution\n\n        result = minimize(lambda x: func(x) + (self.periodicity_factor + 0.1 * np.cos(2 * np.pi * generation / 25)) * self.periodicity_cost(x),  # Changed line\n                          self.best_solution, bounds=[(lb[i], ub[i]) for i in range(self.dim)])\n        return result.x", "name": "AdaptiveMemeticDEPA", "description": "Enhance mutation strategy and adaptive periodicity for improved convergence in complex landscapes.", "configspace": "", "generation": 99, "fitness": 0.24718730721799978, "feedback": "The algorithm AdaptiveMemeticDEPA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "ad11b891-61af-4f8e-8659-036c4149c9ba", "metadata": {"aucs": [0.24739583676058285, 0.24649604056135854, 0.24767004433205797], "final_y": [0.16485632498843794, 0.16485620555962366, 0.16485668047782742]}, "mutation_prompt": null}
