{"id": "9ad0a7c3-b584-4d71-aa52-5171e7f228c5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if remaining_budget <= 0:\n                    break\n\n            diversity = np.std(self.population, axis=0)\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.mean(diversity) / (self.bounds.ub - self.bounds.lb))\n            self.crossover_rate = 0.7 + 0.2 * np.mean(diversity / (self.bounds.ub - self.bounds.lb))\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "The algorithm combines differential evolution with adaptive learning, dynamically adjusting mutation and crossover rates based on population diversity to efficiently explore and exploit the search space.", "configspace": "", "generation": 0, "fitness": 0.22593050365006492, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.226 with standard deviation 0.005. And the mean value of best solutions found was 0.237 (0. is the best) with standard deviation 0.021.", "error": "", "parent_id": null, "metadata": {"aucs": [0.2283013860591162, 0.22993144002279742, 0.21955868486828112], "final_y": [0.23055990681382044, 0.21519192075412252, 0.2652032537699477]}, "mutation_prompt": null}
{"id": "07a18a5b-9bc0-4403-b15d-d2e81f804a3e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            # Update mutation factor and crossover rate based on historical success\n            self.historical_success_rate = 0.9 * self.historical_success_rate + 0.1 * (success_count / self.population_size)\n            self.mutation_factor = 0.5 + 0.3 * self.historical_success_rate\n            self.crossover_rate = 0.7 + 0.2 * (1 - self.historical_success_rate)\n\n            # Apply elitism: preserve a fraction of the best individuals\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "The algorithm enhances Adaptive Differential Evolution by incorporating an elitist strategy and adaptive mutation scaling based on historical success, further balancing exploration and exploitation for improved optimization performance.", "configspace": "", "generation": 1, "fitness": 0.23600652003881153, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.236 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9ad0a7c3-b584-4d71-aa52-5171e7f228c5", "metadata": {"aucs": [0.23317406328130752, 0.2353540165319956, 0.2394914803031315], "final_y": [0.16601991246671255, 0.16534144084545577, 0.16492723322266356]}, "mutation_prompt": null}
{"id": "22df5ec8-8fa4-4b92-b51e-b31f641e5905", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def dual_mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        return np.clip((mutant1 + mutant2) / 2, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.2:\n            self.population_size = min(2 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 2, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.5:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.dual_mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.9 * self.historical_success_rate + 0.1 * (success_count / self.population_size)\n            self.mutation_factor = 0.5 + 0.3 * self.historical_success_rate\n            self.crossover_rate = 0.7 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "The algorithm enhances Adaptive Differential Evolution by introducing adaptive population resizing and dual mutation strategies to dynamically balance exploration and exploitation, improving optimization performance.", "configspace": "", "generation": 2, "fitness": 0.24597749349126352, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "07a18a5b-9bc0-4403-b15d-d2e81f804a3e", "metadata": {"aucs": [0.24591243288691267, 0.24583004689975663, 0.24619000068712127], "final_y": [0.16485609361726938, 0.1648561656728762, 0.16485652913251247]}, "mutation_prompt": null}
{"id": "741e8a37-4e58-413c-a263-16e139186cde", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.5 + 0.4 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "The algorithm improves Enhanced Adaptive Differential Evolution by introducing dynamic parameter adaptation based on real-time performance metrics and incorporating a multi-phase mutation strategy to enhance convergence and solution quality.", "configspace": "", "generation": 3, "fitness": 0.24669774054928048, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "22df5ec8-8fa4-4b92-b51e-b31f641e5905", "metadata": {"aucs": [0.2470138969337191, 0.24604692690808172, 0.24703239780604058], "final_y": [0.16488446001476043, 0.1652829450394051, 0.16486632069942808]}, "mutation_prompt": null}
{"id": "e1a7f571-fc9d-428c-a7bd-69aca0f72dd7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.5 + 0.4 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.1 + 0.1 * np.var(self.fitness)  # Change made here\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "The algorithm dynamically adjusts the elite fraction based on the current population's fitness variance to balance exploration and exploitation.", "configspace": "", "generation": 4, "fitness": 0.24669774054928048, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "741e8a37-4e58-413c-a263-16e139186cde", "metadata": {"aucs": [0.2470138969337191, 0.24604692690808172, 0.24703239780604058], "final_y": [0.16488446001476043, 0.1652829450394051, 0.16486632069942808]}, "mutation_prompt": null}
{"id": "b311d4ec-59a9-4846-bf8c-769cd2f3f678", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate  # Changed line\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Fine-tune the mutation factor dynamically based on the success rate, enhancing adaptability and convergence speed.", "configspace": "", "generation": 5, "fitness": 0.24676724095442037, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "741e8a37-4e58-413c-a263-16e139186cde", "metadata": {"aucs": [0.24710074073752408, 0.2461981734297416, 0.24700280869599545], "final_y": [0.16503109444559605, 0.165058021640484, 0.1649149344110672]}, "mutation_prompt": null}
{"id": "46e5dcc0-1304-48af-a3a4-3f805d8fdb46", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(-0.1, 0.1, self.dim)  # Changed line\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced mutation diversity by incorporating a random perturbation in the multi-phase mutation strategy.", "configspace": "", "generation": 6, "fitness": 0.24702989367179326, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b311d4ec-59a9-4846-bf8c-769cd2f3f678", "metadata": {"aucs": [0.2468786481929811, 0.2473936719550185, 0.24681736086738015], "final_y": [0.16492607634837875, 0.16485696821313434, 0.164905123269377]}, "mutation_prompt": null}
{"id": "c131b2cb-b288-46ac-b2c4-c111d6814fe8", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.normal(0, 0.1, self.dim)  # Changed line\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance mutation diversity further by introducing a Gaussian perturbation in the multi-phase mutation strategy.", "configspace": "", "generation": 7, "fitness": 0.24690558677981522, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "46e5dcc0-1304-48af-a3a4-3f805d8fdb46", "metadata": {"aucs": [0.2468001993563107, 0.24676097852930057, 0.2471555824538344], "final_y": [0.16491237387418078, 0.16485606539500242, 0.16485760971911045]}, "mutation_prompt": null}
{"id": "6964bf36-ebf1-461d-b25a-c3902ebaacc0", "solution": "import numpy as np\n\nclass AdaptiveQuantumEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.quantum_population = None\n        self.bounds = None\n        self.phi = 0.5 * np.pi  # Initial phase angle for quantum superposition\n    \n    def initialize_population(self):\n        self.quantum_population = np.random.uniform(-1, 1, (self.population_size, self.dim))\n    \n    def measure_population(self):\n        # Convert quantum states to real space solutions\n        real_population = self.bounds.lb + ((self.bounds.ub - self.bounds.lb) * (np.sin(self.phi * self.quantum_population) + 1) / 2)\n        return real_population\n    \n    def quantum_rotation(self, target_idx, best_idx):\n        # Rotate quantum states towards the global best\n        self.quantum_population[target_idx] = (\n            self.quantum_population[target_idx]\n            + np.random.uniform(0.05, 0.1) * (self.quantum_population[best_idx] - self.quantum_population[target_idx])\n        )\n    \n    def adaptive_strategy(self, success_rate):\n        # Adjust quantum phase angle based on success rate\n        self.phi = 0.5 * np.pi * (1 - success_rate)\n    \n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        real_population = self.measure_population()\n        fitness = np.array([func(ind) for ind in real_population])\n        remaining_budget = self.budget - self.population_size\n        \n        while remaining_budget > 0:\n            best_idx = np.argmin(fitness)\n            success_count = 0\n            \n            for i in range(self.population_size):\n                if i != best_idx:\n                    self.quantum_rotation(i, best_idx)\n                    \n                real_population = self.measure_population()\n                trial_fitness = func(real_population[i])\n                remaining_budget -= 1\n                \n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    success_count += 1\n                \n                if remaining_budget <= 0:\n                    break\n            \n            success_rate = success_count / self.population_size\n            self.adaptive_strategy(success_rate)\n        \n        best_idx = np.argmin(fitness)\n        return real_population[best_idx]", "name": "AdaptiveQuantumEvolution", "description": "Adaptive Quantum Evolution Algorithm (AQEA) that uses quantum-inspired superposition and entanglement principles to explore and exploit the search space, dynamically adjusting strategies based on the fitness landscape.", "configspace": "", "generation": 8, "fitness": 0.2441416721128478, "feedback": "The algorithm AdaptiveQuantumEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.000. And the mean value of best solutions found was 0.174 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "46e5dcc0-1304-48af-a3a4-3f805d8fdb46", "metadata": {"aucs": [0.2440904141775322, 0.2446623931786196, 0.2436722089823916], "final_y": [0.17437043073890157, 0.16950616562796017, 0.17768144740064196]}, "mutation_prompt": null}
{"id": "0333f65d-e525-471b-b5fe-0dd7bef022af", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            if remaining_budget % 10 == 0:  # Added line\n                self.initialize_population() # Reset population to introduce diversity\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced survival strategy by promoting diversity through periodic random migrations.", "configspace": "", "generation": 9, "fitness": 0.23701059470839514, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.237 with standard deviation 0.003. And the mean value of best solutions found was 0.196 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "46e5dcc0-1304-48af-a3a4-3f805d8fdb46", "metadata": {"aucs": [0.23369773271887717, 0.24006154535854607, 0.23727250604776218], "final_y": [0.21739501170053954, 0.18234860187074098, 0.18939282402407587]}, "mutation_prompt": null}
{"id": "e8f3ea06-f8f0-4102-b66b-25b116cdbccc", "solution": "import numpy as np\n\nclass AdaptiveNeighborhoodDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.neighborhood_expansion_rate = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def adaptive_neighborhood_mutation(self, target_idx):\n        neighbors = self.select_neighbors(target_idx)\n        centroid = np.mean(self.population[neighbors], axis=0)\n        perturbation = np.random.uniform(-self.neighborhood_expansion_rate, self.neighborhood_expansion_rate, self.dim)\n        mutant = centroid + perturbation\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def select_neighbors(self, target_idx):\n        neighborhood_size = max(3, int(self.neighborhood_expansion_rate * self.population_size))\n        distances = np.linalg.norm(self.population - self.population[target_idx], axis=1)\n        nearest_neighbors = np.argsort(distances)[:neighborhood_size]\n        return nearest_neighbors\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.5:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.adaptive_neighborhood_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n            self.neighborhood_expansion_rate = 0.05 + 0.45 * self.historical_success_rate\n\n            num_elites = int(0.1 * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveNeighborhoodDifferentialEvolution", "description": "Leverage local search intensification using adaptive neighborhood expansion to dynamically adjust the balance between exploration and exploitation.", "configspace": "", "generation": 10, "fitness": 0.24640853623915204, "feedback": "The algorithm AdaptiveNeighborhoodDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "46e5dcc0-1304-48af-a3a4-3f805d8fdb46", "metadata": {"aucs": [0.24620325005073618, 0.2464009061211635, 0.24662145254555645], "final_y": [0.16507330001440612, 0.1648874320270215, 0.16494912883012158]}, "mutation_prompt": null}
{"id": "b8ba8078-b661-458a-a073-1703d3f9f2ce", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(-0.1, 0.1, self.dim)  # Changed line\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.5 * self.historical_success_rate  # Changed line\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Improved adaptive mutation strategy by enhancing the effect of historical success rate on mutation factor.", "configspace": "", "generation": 11, "fitness": 0.24692688142779903, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "46e5dcc0-1304-48af-a3a4-3f805d8fdb46", "metadata": {"aucs": [0.24694705341416923, 0.24709834554752985, 0.246735245321698], "final_y": [0.16511777409406525, 0.1648724976676429, 0.16522933104640602]}, "mutation_prompt": null}
{"id": "c8f84637-dfa9-4c92-b5bc-8b416d5d0ed7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(-0.1, 0.1, self.dim)  # Changed line\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n            \n            self.mutation_factor *= 1.05 if success_count > self.historical_success_rate * self.population_size else 0.95  # Changed line\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Increases convergence speed by dynamically adjusting the mutation factor based on elite performance.", "configspace": "", "generation": 12, "fitness": 0.24692543091596572, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "46e5dcc0-1304-48af-a3a4-3f805d8fdb46", "metadata": {"aucs": [0.24681733649629523, 0.24718389792233086, 0.24677505832927105], "final_y": [0.16513719021966844, 0.16486598991767487, 0.16503901279472533]}, "mutation_prompt": null}
{"id": "cc61def2-6cc3-4ffb-b103-56b0ff971b55", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n        self.exploration_factor = 0.1  # New line: Exploration factor for hybrid mutation\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def basic_mutate(self, target_idx):  # Renamed from mutate to basic_mutate\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(-self.exploration_factor, self.exploration_factor, self.dim)  # Changed line\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def hybrid_mutation(self, target_idx):  # New function for hybrid mutation\n        if np.random.rand() > 0.5:\n            return self.basic_mutate(target_idx)\n        else:\n            return self.multi_phase_mutation(target_idx)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(int(1.5 * self.population_size), self.initial_population_size)  # Changed line\n        else:\n            self.population_size = max(self.population_size // 2, self.dim)  # Changed line\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                mutant = self.hybrid_mutation(i)  # Changed line\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduced adaptive population size and hybrid mutation strategies for improved convergence and exploration balancing.", "configspace": "", "generation": 13, "fitness": 0.24660086924888644, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "46e5dcc0-1304-48af-a3a4-3f805d8fdb46", "metadata": {"aucs": [0.24650161157066153, 0.2466329823078195, 0.24666801386817827], "final_y": [0.16485617550407583, 0.16486422055187888, 0.16488112384295994]}, "mutation_prompt": null}
{"id": "10ea0b45-1194-42d3-b253-1946202b67cd", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(-0.1, 0.1, self.dim)  # Changed line\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            # Gradually adjust the mutation factor over generations\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Improved convergence by adjusting mutation factor linearly over generations.", "configspace": "", "generation": 14, "fitness": 0.24707321022672293, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "46e5dcc0-1304-48af-a3a4-3f805d8fdb46", "metadata": {"aucs": [0.24693348278338667, 0.24727757682776186, 0.2470085710690203], "final_y": [0.1657516037391058, 0.1649236419931881, 0.16504617135710087]}, "mutation_prompt": null}
{"id": "7cfc4aa4-26ca-4739-a157-f76d939ae9af", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(-0.15, 0.15, self.dim)  # Changed line\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            # Gradually adjust the mutation factor over generations\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance exploration by slightly increasing the random perturbation range in multi-phase mutation.", "configspace": "", "generation": 15, "fitness": 0.24707624918754564, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "10ea0b45-1194-42d3-b253-1946202b67cd", "metadata": {"aucs": [0.2470356382837655, 0.24725982729382412, 0.24693328198504727], "final_y": [0.16529155179319177, 0.164960501776367, 0.16521891633925234]}, "mutation_prompt": null}
{"id": "ec3efc53-7eb0-4cf9-a4b4-e9e6be72dce3", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.normal(0, 0.15, self.dim)  # Changed line\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.4:\n            self.population_size = min(int(1.2 * self.population_size), self.initial_population_size)  # Changed line\n        else:\n            self.population_size = max(int(self.population_size * 0.8), self.dim)  # Changed line\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.5:  # Changed line\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.7 * self.historical_success_rate + 0.3 * (success_count / self.population_size)  # Changed line\n            self.mutation_factor = 0.4 + 0.6 * self.historical_success_rate  # Changed line\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)  # Changed line\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance exploration and exploitation by introducing dynamic adaptation in mutation and crossover rates along with a more diverse multi-phase mutation strategy.", "configspace": "", "generation": 16, "fitness": 0.24622934448948094, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "7cfc4aa4-26ca-4739-a157-f76d939ae9af", "metadata": {"aucs": [0.24634389180477945, 0.24570387327138, 0.24664026839228337], "final_y": [0.16487177002476794, 0.16485667747744925, 0.16485721364549]}, "mutation_prompt": null}
{"id": "b561139e-98b5-4be0-a420-e6274fb94e7e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)  # Changed line\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            # Gradually adjust the mutation factor over generations\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance exploitation by adaptively adjusting the random perturbation range in multi-phase mutation.", "configspace": "", "generation": 17, "fitness": 0.24709726248174682, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "7cfc4aa4-26ca-4739-a157-f76d939ae9af", "metadata": {"aucs": [0.2470008339325801, 0.24727185832455745, 0.24701909518810294], "final_y": [0.16548515193869084, 0.16496013478995675, 0.16502274855201038]}, "mutation_prompt": null}
{"id": "f58e0f70-317e-4639-b239-0b391fcbfb8a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate * (1.0 - remaining_budget / self.budget), \n            0.15 * self.historical_success_rate * (1.0 - remaining_budget / self.budget), self.dim) \n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            # Gradually adjust the mutation factor over generations\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance mutation diversity by adjusting the random perturbation range dynamically based on the generation's progress.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'remaining_budget' is not defined\").", "error": "NameError(\"name 'remaining_budget' is not defined\")", "parent_id": "b561139e-98b5-4be0-a420-e6274fb94e7e", "metadata": {}, "mutation_prompt": null}
{"id": "079457ac-cd64-4bc5-9e1e-30497e6f0c04", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.4 + 0.6 * self.historical_success_rate  # Changed line\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)  # Changed line\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Increase diversity by using dynamic crossover rates and a feedback mechanism for mutation factor adjustment.", "configspace": "", "generation": 19, "fitness": 0.24691562808232528, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b561139e-98b5-4be0-a420-e6274fb94e7e", "metadata": {"aucs": [0.24685008437520595, 0.24706435184654685, 0.24683244802522308], "final_y": [0.16525223231008745, 0.16503669556631595, 0.1651820898996068]}, "mutation_prompt": null}
{"id": "77bbbe5b-f5eb-40cb-a8f1-e6d6daa63568", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.5 + 0.5 * (1 - np.std(self.fitness))  # Updated line\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance exploration by introducing adaptive crossover rate based on current diversity in the population.", "configspace": "", "generation": 20, "fitness": 0.24680042835732355, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "b561139e-98b5-4be0-a420-e6274fb94e7e", "metadata": {"aucs": [0.24677994180866303, 0.24652634948481578, 0.24709499377849187], "final_y": [0.16714732927105547, 0.1669581688022509, 0.16546656999659837]}, "mutation_prompt": null}
{"id": "c5138638-37d2-475b-ac4b-66bfa69557b0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.75  # Changed line\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.15  # Changed line\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Refine the mutation factor's adaptive mechanism based on the success rate, slightly enhance crossover probability, and improve elite preservation.", "configspace": "", "generation": 21, "fitness": 0.24685007980414966, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b561139e-98b5-4be0-a420-e6274fb94e7e", "metadata": {"aucs": [0.2467696391343629, 0.2470287677771108, 0.24675183250097532], "final_y": [0.16583032187886404, 0.16539581395167957, 0.1657458170141084]}, "mutation_prompt": null}
{"id": "a4c430da-c207-4a84-ae6f-202634bc7547", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)  # Changed line\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * (1 - np.std(self.fitness) / np.mean(self.fitness))  # Changed line\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            # Gradually adjust the mutation factor over generations\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Utilize adaptive mutation factor based on fitness improvement trend to balance exploration and exploitation.", "configspace": "", "generation": 22, "fitness": 0.24709726248174682, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b561139e-98b5-4be0-a420-e6274fb94e7e", "metadata": {"aucs": [0.2470008339325801, 0.24727185832455745, 0.24701909518810294], "final_y": [0.16548515193869084, 0.16496013478995675, 0.16502274855201038]}, "mutation_prompt": null}
{"id": "049bcf3c-3084-45ac-b736-eed5deaa2c63", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        fitness_diversity = np.std(self.fitness) / np.mean(self.fitness)  # Changed line\n        if success_rate > 0.3 and fitness_diversity > 0.1:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive population size scaling based on fitness diversity to enhance convergence.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object cannot be interpreted as an integer\").", "error": "TypeError(\"'float' object cannot be interpreted as an integer\")", "parent_id": "b561139e-98b5-4be0-a420-e6274fb94e7e", "metadata": {}, "mutation_prompt": null}
{"id": "505c5f38-7c65-4dec-ae06-1a3868b2a468", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)  # Changed line\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            # Gradually adjust the mutation factor over generations\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Improve exploration by incorporating a linearly decreasing mutation factor over iterations.", "configspace": "", "generation": 24, "fitness": 0.24709726248174682, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b561139e-98b5-4be0-a420-e6274fb94e7e", "metadata": {"aucs": [0.2470008339325801, 0.24727185832455745, 0.24701909518810294], "final_y": [0.16548515193869084, 0.16496013478995675, 0.16502274855201038]}, "mutation_prompt": null}
{"id": "764ae208-f66e-4cc6-ade7-3b69ce986cb0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)  # Changed line\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)  # Changed line\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            # Gradually adjust the mutation factor over generations\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate adaptive scaling of crossover rate with feedback from mutation success rate.", "configspace": "", "generation": 25, "fitness": 0.24691562808232528, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b561139e-98b5-4be0-a420-e6274fb94e7e", "metadata": {"aucs": [0.24685008437520595, 0.24706435184654685, 0.24683244802522308], "final_y": [0.16525223231008745, 0.16503669556631595, 0.1651820898996068]}, "mutation_prompt": null}
{"id": "37c99780-b8aa-4e0e-b4f5-7235d8b9dde1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.6  # Changed line\n        self.crossover_rate = 0.8  # Changed line\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.2  # Changed line\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.2 * self.historical_success_rate, 0.2 * self.historical_success_rate, self.dim)  # Changed line\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.4:  # Changed line\n            self.population_size = int(min(2.0 * self.population_size, self.initial_population_size))  # Changed line\n        else:\n            self.population_size = max(self.population_size // 2, self.dim)  # Changed line\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.5:  # Changed line\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.7 * self.historical_success_rate + 0.3 * (success_count / self.population_size)  # Changed line\n            self.mutation_factor = 0.4 + 0.6 * self.historical_success_rate  # Changed line\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)  # Changed line\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Improve exploitation and exploration balance by implementing adaptive population resizing and enhancing mutation diversity.", "configspace": "", "generation": 26, "fitness": 0.2467811863958437, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b561139e-98b5-4be0-a420-e6274fb94e7e", "metadata": {"aucs": [0.2467260151969103, 0.24687029265825866, 0.2467472513323622], "final_y": [0.16485581486086265, 0.16485952599995968, 0.16485581612997102]}, "mutation_prompt": null}
{"id": "773ba9ee-032a-4cf5-9df6-8d30e156fae6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size * (1 + self.historical_success_rate / 2)) # Changed line\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)**0.5 # Changed line\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance convergence by dynamically adjusting elitism and introducing adaptive mutation factor scaling.", "configspace": "", "generation": 27, "fitness": 0.24701332740583218, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b561139e-98b5-4be0-a420-e6274fb94e7e", "metadata": {"aucs": [0.24685806233173035, 0.2471584145833421, 0.24702350530242412], "final_y": [0.1652472291652204, 0.16509527920188116, 0.16499550402335694]}, "mutation_prompt": null}
{"id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate  # Changed line\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance exploitation by dynamically adjusting the elite fraction based on generational success.", "configspace": "", "generation": 28, "fitness": 0.24710750382258037, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b561139e-98b5-4be0-a420-e6274fb94e7e", "metadata": {"aucs": [0.2469997914176042, 0.2472946988343987, 0.2470280212157382], "final_y": [0.16559443043569755, 0.16492101006271098, 0.16504029703555745]}, "mutation_prompt": null}
{"id": "9c0a3884-a485-41fb-a95f-a482a14f1a0b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate * (remaining_budget / self.budget), \n            0.15 * self.historical_success_rate * (remaining_budget / self.budget), self.dim)  # Changed line\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate  # Changed line\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Improve exploration by incorporating a dynamic perturbation factor in the multi-phase mutation.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'remaining_budget' is not defined\").", "error": "NameError(\"name 'remaining_budget' is not defined\")", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {}, "mutation_prompt": null}
{"id": "f1ad8f87-250f-4ded-b024-ad898c4c095d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        perturbation = np.random.normal(0, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2) / 2 + perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.4:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 2, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.5:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.7 * self.historical_success_rate + 0.3 * (success_count / self.population_size)\n            self.mutation_factor = 0.2 + 0.8 * self.historical_success_rate\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive learning rate and diversify mutation schemes to enhance exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": 0.24639121085195645, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.24623104500010207, 0.24645681812431586, 0.2464857694314514], "final_y": [0.1648557954525277, 0.16485593608592108, 0.16485758650392002]}, "mutation_prompt": null}
{"id": "055b0e2b-b525-45ef-9b47-a027063b25d7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * np.random.rand() * self.historical_success_rate  # Changed line\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce stochastic elite selection and adaptive mutation scaling for improved convergence.", "configspace": "", "generation": 31, "fitness": 0.246882450529506, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.2467145007504108, 0.24727412066774057, 0.24665873017036666], "final_y": [0.16623821688239426, 0.16487819180263907, 0.16548211038142058]}, "mutation_prompt": null}
{"id": "6027deef-6fcb-4105-a7c7-733996eecff5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate  # Changed line\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Implement a refined elite strategy by dynamically adjusting elite preservation based on historical success.", "configspace": "", "generation": 32, "fitness": 0.24698849297785, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.246907785069424, 0.24713283213688708, 0.24692486172723893], "final_y": [0.16507878569397894, 0.16511700623815562, 0.16522755004000267]}, "mutation_prompt": null}
{"id": "0a66128c-bdec-431f-b875-35999d9d6610", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(int(1.5 * self.population_size), self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.4 + 0.6 * self.historical_success_rate  # Changed line\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)  # Changed line\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate  \n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce a success-based adaptation mechanism to tune the mutation factor and crossover rate more effectively.", "configspace": "", "generation": 33, "fitness": 0.2469272356509504, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.2468188089778136, 0.24710706504179536, 0.2468558329332422], "final_y": [0.16531639990420988, 0.1649670700529724, 0.16517135450184972]}, "mutation_prompt": null}
{"id": "9e323033-352d-4b64-8090-383624afa634", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.5 + 0.4 * (1 - self.historical_success_rate)  # Changed line\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate  # Changed line\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive crossover rates based on performance to balance exploration and exploitation.", "configspace": "", "generation": 34, "fitness": 0.2470339630978198, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.24686169394292878, 0.2472007239771119, 0.24703947137341875], "final_y": [0.1658475336235078, 0.1651051916342986, 0.1648979544786383]}, "mutation_prompt": null}
{"id": "962808ae-361c-4b47-8b3c-8287bc962a48", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)  # Changed line\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance crossover adaptability by adjusting the crossover rate based on elite individual's performance.", "configspace": "", "generation": 35, "fitness": 0.2469272356509504, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.2468188089778136, 0.24710706504179536, 0.2468558329332422], "final_y": [0.16531639990420988, 0.1649670700529724, 0.16517135450184972]}, "mutation_prompt": null}
{"id": "e45c1120-29e1-477e-abb9-13b0116cce58", "solution": "import numpy as np\n\nclass CoEvolutionaryOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.subpop_count = 5\n        self.subpop_size = self.population_size // self.subpop_count\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.migration_rate = 0.1\n        self.elite_fraction = 0.1\n        self.subpopulations = None\n        self.fitnesses = None\n        self.bounds = None\n\n    def initialize_subpopulations(self):\n        self.subpopulations = [\n            np.random.uniform(self.bounds.lb, self.bounds.ub, (self.subpop_size, self.dim))\n            for _ in range(self.subpop_count)\n        ]\n        self.fitnesses = [np.full(self.subpop_size, np.inf) for _ in range(self.subpop_count)]\n\n    def mutate(self, subpop_idx, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.subpop_size), target_idx), 3, replace=False)\n        a, b, c = self.subpopulations[subpop_idx][idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def migrate(self):\n        for i in range(self.subpop_count):\n            if np.random.rand() < self.migration_rate:\n                target_subpop = (i + 1) % self.subpop_count\n                elite_idx = np.argsort(self.fitnesses[i])[:int(self.elite_fraction * self.subpop_size)]\n                migrants = self.subpopulations[i][elite_idx]\n                self.subpopulations[target_subpop][:migrants.shape[0]] = migrants\n                self.fitnesses[target_subpop][:migrants.shape[0]] = [np.inf] * migrants.shape[0]\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_subpopulations()\n        remaining_budget = self.budget\n        \n        while remaining_budget > 0:\n            for subpop_idx in range(self.subpop_count):\n                self.fitnesses[subpop_idx] = np.array([func(ind) for ind in self.subpopulations[subpop_idx]])\n                remaining_budget -= self.subpop_size\n\n                success_count = 0\n                for i in range(self.subpop_size):\n                    mutant = self.mutate(subpop_idx, i)\n                    trial = self.crossover(self.subpopulations[subpop_idx][i], mutant)\n                    trial_fitness = func(trial)\n                    remaining_budget -= 1\n\n                    if trial_fitness < self.fitnesses[subpop_idx][i]:\n                        self.subpopulations[subpop_idx][i] = trial\n                        self.fitnesses[subpop_idx][i] = trial_fitness\n                        success_count += 1\n\n                    if remaining_budget <= 0:\n                        break\n\n            self.migrate()\n\n        best_subpop_idx = np.argmin([np.min(fitness) for fitness in self.fitnesses])\n        best_individual_idx = np.argmin(self.fitnesses[best_subpop_idx])\n        return self.subpopulations[best_subpop_idx][best_individual_idx]", "name": "CoEvolutionaryOptimization", "description": "Integrate a co-evolutionary approach where multiple subpopulations evolve in parallel with occasional information exchange to improve diversity and convergence.", "configspace": "", "generation": 36, "fitness": 0.2360536974003746, "feedback": "The algorithm CoEvolutionaryOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.236 with standard deviation 0.001. And the mean value of best solutions found was 0.179 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.2349245429153075, 0.23580219914985845, 0.23743435013595782], "final_y": [0.18422264832347846, 0.18117738466083255, 0.17113240532072427]}, "mutation_prompt": null}
{"id": "c9828211-f10d-448d-a7fd-513f54ba6989", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.3 * (success_count / self.population_size)  # Changed line\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance exploitation by incorporating adaptive crossover rates that depend on historical success and failure ratios.", "configspace": "", "generation": 37, "fitness": 0.2469317432111924, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.2468320397788034, 0.24684015577789065, 0.24712303407688319], "final_y": [0.16639233832668165, 0.1654772585958545, 0.1651678292194979]}, "mutation_prompt": null}
{"id": "9224f4b1-6154-4006-9afd-336a862d9d87", "solution": "import numpy as np\n\nclass EnhancedHyperMutationDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.success_rate_memory = []\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def adaptive_hypermutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        random_factor = np.random.uniform(0.5, 1.5)\n        hypermutant = random_factor * (mutant1 + mutant2) / 2\n        return np.clip(hypermutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self, success_rate):\n        if success_rate > 0.3:\n            self.population_size = int(min(1.5 * self.population_size, self.initial_population_size))\n        else:\n            self.population_size = int(max(self.population_size // 1.5, self.dim))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.adaptive_hypermutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            success_rate = success_count / self.population_size\n            self.success_rate_memory.append(success_rate)\n            if len(self.success_rate_memory) > 5:\n                self.success_rate_memory.pop(0)\n\n            avg_success_rate = np.mean(self.success_rate_memory)\n            self.mutation_factor = 0.3 + 0.7 * avg_success_rate\n            self.crossover_rate = 0.6 + 0.3 * (1 - avg_success_rate)\n\n            self.resize_population(success_rate)\n            self.elite_fraction = 0.05 + 0.1 * avg_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHyperMutationDifferentialEvolution", "description": "Exploit adaptive hypermutation and competition-based elitism to enhance exploration and maintain diversity in solution quality.", "configspace": "", "generation": 38, "fitness": 0.2461240708559046, "feedback": "The algorithm EnhancedHyperMutationDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.24625305573561418, 0.24607764091741413, 0.24604151591468548], "final_y": [0.16493351973871195, 0.16492363801399534, 0.16515935927865277]}, "mutation_prompt": null}
{"id": "a1eb995c-9d8f-45f8-b478-65d836866e91", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices] + np.random.uniform(-0.01, 0.01, self.population[:num_elites].shape)  # Changed line\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance exploration by introducing a small random perturbation in the elite preservation process.", "configspace": "", "generation": 39, "fitness": 0.24691808842103713, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.24708119519044236, 0.24702631032824807, 0.24664675974442096], "final_y": [0.16549298974864401, 0.16510888298090254, 0.1654985164120104]}, "mutation_prompt": null}
{"id": "8cf4d59d-595b-4dca-82f0-2ca694b57610", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        random_scaling = np.random.uniform(0.8, 1.2)  # Changed line\n        mutant = a + self.mutation_factor * random_scaling * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance mutation flexibility by introducing a random scaling factor to the mutation factor for increased exploration.", "configspace": "", "generation": 40, "fitness": 0.24684201357103172, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.24652561481540491, 0.24681278031023035, 0.24718764558745987], "final_y": [0.16599442956435606, 0.16500610831952922, 0.16492943896985146]}, "mutation_prompt": null}
{"id": "f0b2714c-3346-404e-93ca-a204632a791f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate  # Adjusted to enhance selection\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor *= (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolutionV2", "description": "Implement adaptive mutation rate modulation based on success history and incorporate adaptive elite selection to enhance exploration-exploitation balance.", "configspace": "", "generation": 41, "fitness": 0.24707858007477532, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.2468734681083561, 0.24727434700450335, 0.2470879251114665], "final_y": [0.16509149750601415, 0.1648783475951885, 0.1649021295817571]}, "mutation_prompt": null}
{"id": "45aac761-6e8f-4b5f-a7a3-dab05dad526b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        diversity = np.std(self.population, axis=0)  # New line\n        dynamic_factor = 0.5 * (1 + np.mean(diversity))  # New line\n        mutant = a + dynamic_factor * (b - c)  # Modified line\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce diversity control and adaptive mutation scaling to enhance search efficiency and convergence.", "configspace": "", "generation": 42, "fitness": 0.2467158610471245, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.2468504349359698, 0.2467108727873094, 0.2465862754180943], "final_y": [0.16493402250847755, 0.16519743802541043, 0.16488984442932975]}, "mutation_prompt": null}
{"id": "ad6b0e3b-18e7-4cd5-ad2c-6f4cfa2dac2e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.9 * self.historical_success_rate  # Changed line\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance exploration by increasing the mutation factor range to prevent premature convergence.", "configspace": "", "generation": 43, "fitness": 0.24710750382258037, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.2469997914176042, 0.2472946988343987, 0.2470280212157382], "final_y": [0.16559443043569755, 0.16492101006271098, 0.16504029703555745]}, "mutation_prompt": null}
{"id": "955a91ce-d4dd-42c5-8971-e80505263d0b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n        self.local_search_prob = 0.1  # New parameter for local search probability\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def local_search(self, trial):\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        local_variant = trial + perturbation\n        return np.clip(local_variant, self.bounds.lb, self.bounds.ub)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                if np.random.rand() < self.local_search_prob:\n                    trial = self.local_search(trial)  # Apply local search\n\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance exploitation and exploration by integrating adaptive elitism and randomized local search.", "configspace": "", "generation": 44, "fitness": 0.24670489599302417, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.24648728903308803, 0.2466963576147172, 0.2469310413312673], "final_y": [0.1657423804489936, 0.16525454917177018, 0.16532510205882156]}, "mutation_prompt": null}
{"id": "9c1936d8-c497-41d4-9e73-6e68862b6895", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            fitness_variance = np.var(self.fitness)  # New line\n            adjusted_mutation_factor = self.mutation_factor * (1 + fitness_variance)  # New line\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate  # Changed line\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = adjusted_mutation_factor * (remaining_budget / self.budget)  # Changed line\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance exploration using dynamic mutation factor adjustment based on fitness variance.", "configspace": "", "generation": 45, "fitness": 0.2469004555350426, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.2466795341218463, 0.24726037613150376, 0.24676145635177782], "final_y": [0.16664172145357958, 0.16499235161304449, 0.16565445110964616]}, "mutation_prompt": null}
{"id": "6090e842-693c-4396-a0cc-b7187a166bfb", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.5 + 0.4 * (1 - self.historical_success_rate)  # Changed line\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate  # Changed line\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover rate based on generational success to enhance solution diversity.", "configspace": "", "generation": 46, "fitness": 0.2470339630978198, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.24686169394292878, 0.2472007239771119, 0.24703947137341875], "final_y": [0.1658475336235078, 0.1651051916342986, 0.1648979544786383]}, "mutation_prompt": null}
{"id": "8ff13746-d3da-4937-9a10-f12e855c7a54", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n            self.mutation_factor *= 1.05 if success_count > 0.3 * self.population_size else 0.95  # Changed line\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Refine exploration by incorporating a dynamic learning rate for mutation factor adjustment.", "configspace": "", "generation": 47, "fitness": 0.24698932067635473, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.24677363722563705, 0.24726477771951638, 0.2469295470839108], "final_y": [0.16600372682695042, 0.1648792357007326, 0.16522453916053348]}, "mutation_prompt": null}
{"id": "94c90ad4-97c3-42c8-ac26-24a94b3c4958", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce a minor enhancement to increase the elitism impact by more frequently updating elite individuals.", "configspace": "", "generation": 48, "fitness": 0.24710750382258037, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.2469997914176042, 0.2472946988343987, 0.2470280212157382], "final_y": [0.16559443043569755, 0.16492101006271098, 0.16504029703555745]}, "mutation_prompt": null}
{"id": "697ba03c-4255-4cc0-8dcb-2f047c4375d1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = (initial_mutation_factor + 0.1 * np.std(self.population[:num_elites])) * (remaining_budget / self.budget)  # Changed line\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Improved exploitation by refining the mutation strategy based on elite individuals' diversity.", "configspace": "", "generation": 49, "fitness": 0.23648508799966098, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.236 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.23717996649282191, 0.24179222773710396, 0.23048306976905708], "final_y": [0.16550745414224766, 0.164890696695839, 0.16550098909442623]}, "mutation_prompt": null}
{"id": "e156dca3-b2f8-4a8e-a32d-6e774a40352f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Improve exploitation by refining mutation strategy based on success adaptation.", "configspace": "", "generation": 50, "fitness": 0.24710750382258037, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.2469997914176042, 0.2472946988343987, 0.2470280212157382], "final_y": [0.16559443043569755, 0.16492101006271098, 0.16504029703555745]}, "mutation_prompt": null}
{"id": "33b1a46e-0ce6-4086-8045-e0a0758cc77b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        scaling_factor = 1 + 0.1 * (self.historical_success_rate - 0.5)  # Changed line\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 * scaling_factor + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate  # Changed line\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Optimize the convergence by introducing an adaptive scaling factor for mutation perturbation based on success rate.", "configspace": "", "generation": 51, "fitness": 0.2469016989903714, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.24688614603603543, 0.2472044458259416, 0.24661450510913718], "final_y": [0.16570935993669367, 0.16497052577824378, 0.16619626392807618]}, "mutation_prompt": null}
{"id": "8e3fdfc0-c1d8-44bc-b34e-f0b68ac2d095", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.7 + 0.3 * (1 - self.historical_success_rate)  # Changed line\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)  # Changed line\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover rate influenced by success rate for enhanced balance between exploration and exploitation.", "configspace": "", "generation": 52, "fitness": 0.2468404394926932, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.2468831647477716, 0.24687018727638754, 0.2467679664539204], "final_y": [0.16644408286975565, 0.16580506108853932, 0.16611143677890172]}, "mutation_prompt": null}
{"id": "50ef46ce-9624-4bdd-8792-e681f78f863b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate  # Changed line\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices] + np.random.uniform(-0.01, 0.01, (num_elites, self.dim))  # Changed line\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance exploration by introducing a small uniform random shift to elite individuals in each generation.", "configspace": "", "generation": 53, "fitness": 0.24691808842103713, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.24708119519044236, 0.24702631032824807, 0.24664675974442096], "final_y": [0.16549298974864401, 0.16510888298090254, 0.1654985164120104]}, "mutation_prompt": null}
{"id": "ace6ccf4-1cbd-47a4-861b-41a77548df0c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate  # Changed line\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Improve convergence by further enhancing elite retention based on success rate.", "configspace": "", "generation": 54, "fitness": 0.24698849297785, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.246907785069424, 0.24713283213688708, 0.24692486172723893], "final_y": [0.16507878569397894, 0.16511700623815562, 0.16522755004000267]}, "mutation_prompt": null}
{"id": "f2f698d0-4aaf-4e90-8d78-f7603e6f406b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            # Introduce random initialization with a small probability\n            if np.random.rand() < 0.01:\n                self.population[np.random.randint(0, self.population_size)] = np.random.uniform(self.bounds.lb, self.bounds.ub, self.dim)\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance exploration by introducing a small probability of random initialization during population update.", "configspace": "", "generation": 55, "fitness": 0.24683013682294966, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.24669143374558977, 0.24708857859278954, 0.2467103981304697], "final_y": [0.16623498833036665, 0.16495934245939314, 0.1654690658347917]}, "mutation_prompt": null}
{"id": "13f315a7-f8a4-416d-8314-b895d240964a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * (1 - self.historical_success_rate)  # Changed line\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance exploration by adapting the elite fraction based on the worst-performing solutions.", "configspace": "", "generation": 56, "fitness": 0.2469564623469723, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.24679834927923916, 0.24724127273797802, 0.2468297650236997], "final_y": [0.16572591439201556, 0.16500297860690638, 0.16552505020258013]}, "mutation_prompt": null}
{"id": "d07e2986-35b4-4cdd-88d0-425e1039bfc2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        if diversity > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance exploration by incorporating adaptive parameter control based on diversity metrics.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object cannot be interpreted as an integer\").", "error": "TypeError(\"'float' object cannot be interpreted as an integer\")", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {}, "mutation_prompt": null}
{"id": "34a95da3-40fa-4d23-b565-a4183ba31fab", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.7 + 0.2 * (1 - self.historical_success_rate)  # Changed line\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive elitism by modulating the crossover rate based on generational success to balance exploration and exploitation.", "configspace": "", "generation": 58, "fitness": 0.24702374890687925, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.2469324991220443, 0.24709353961539582, 0.24704520798319762], "final_y": [0.16614410577176464, 0.16520182790116145, 0.16564608678317017]}, "mutation_prompt": null}
{"id": "986757aa-d470-43ef-9341-871c5e268604", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.5 + 0.4 * self.historical_success_rate  # Changed line\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Improve mutation diversity by introducing adaptive scaling of the mutation factor based on the success rate.", "configspace": "", "generation": 59, "fitness": 0.24710750382258037, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.2469997914176042, 0.2472946988343987, 0.2470280212157382], "final_y": [0.16559443043569755, 0.16492101006271098, 0.16504029703555745]}, "mutation_prompt": null}
{"id": "7bfef826-df0a-4c18-8417-afc48d8003ed", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1  # Fraction of elite individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.2 * self.historical_success_rate, 0.2 * self.historical_success_rate, self.dim)  # Changed line\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        if success_rate > 0.3:\n            self.population_size = min(1.5 * self.population_size, self.initial_population_size)\n        else:\n            self.population_size = max(self.population_size // 1.5, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n        initial_mutation_factor = self.mutation_factor\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.7 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            self.mutation_factor = initial_mutation_factor * (remaining_budget / self.budget)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Improve exploration by fine-tuning the multi-phase mutation strategy's perturbation range.", "configspace": "", "generation": 60, "fitness": 0.24706738885566545, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.24690844172538728, 0.24727180605196974, 0.2470219187896393], "final_y": [0.16578267657241408, 0.16496745063603369, 0.16502796695610544]}, "mutation_prompt": null}
{"id": "2f4ac087-47f4-4115-bb26-23469b3519d0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.2 + 0.6 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Incorporate adaptive population size and variable mutation factors guided by diversity and success metrics to enhance exploration and exploitation balance.", "configspace": "", "generation": 61, "fitness": 0.24711649376216063, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eb1a3838-0e04-4642-b32c-9388e8b0de7b", "metadata": {"aucs": [0.2471123440522356, 0.24727787340912888, 0.24695926382511746], "final_y": [0.16492096478162066, 0.16486202207518674, 0.16493911059467292]}, "mutation_prompt": null}
{"id": "18502071-0f2a-438d-8732-856ad3c64576", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate + np.random.uniform(-0.05, 0.05)\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.2 + 0.6 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce minor perturbation in crossover rate to enhance diversity in solutions.", "configspace": "", "generation": 62, "fitness": 0.24674115750407946, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2f4ac087-47f4-4115-bb26-23469b3519d0", "metadata": {"aucs": [0.24687298907439026, 0.24671077575658362, 0.24663970768126453], "final_y": [0.16514716439171118, 0.1652774595409806, 0.16531216344558786]}, "mutation_prompt": null}
{"id": "a08f983d-64e6-4547-9c14-46904ae90882", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.2 + 0.6 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.1 + 0.05 * self.historical_success_rate  # Modified line\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate elitist replacement strategy to enhance convergence by preserving the top solutions more effectively.", "configspace": "", "generation": 63, "fitness": 0.24709425851302858, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2f4ac087-47f4-4115-bb26-23469b3519d0", "metadata": {"aucs": [0.24701175553050947, 0.247271187144244, 0.24699983286433225], "final_y": [0.16488673061990688, 0.16486376036796668, 0.16488796582221144]}, "mutation_prompt": null}
{"id": "c359db87-2fa2-44f4-9d57-bf6455d9f3c4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        alpha = 0.1 * (1 - self.historical_success_rate)  # Change 1\n        random_perturbation = np.random.uniform(\n            -alpha, alpha, self.dim)  # Change 2\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.5:  # Change 3\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.85 * self.historical_success_rate + 0.15 * (success_count / self.population_size)  # Change 4\n            self.mutation_factor = 0.3 + 0.5 * self.historical_success_rate  # Change 5\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)  # Change 6\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate  # Change 7\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced adaptation with dynamic mutation based on both diversity and convergence speed, coupled with elite retention for improved exploration and exploitation.", "configspace": "", "generation": 64, "fitness": 0.24661402607723315, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2f4ac087-47f4-4115-bb26-23469b3519d0", "metadata": {"aucs": [0.24640102800065, 0.24672864829159435, 0.2467124019394551], "final_y": [0.1649893209821539, 0.16486010855482292, 0.16485711426041794]}, "mutation_prompt": null}
{"id": "cab8dbf4-f8ec-4349-a858-be397326b1f0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        diversity_scaling = 1 + 0.1 * np.std(self.population, axis=0).mean()  # Changed line\n        mutant = a + diversity_scaling * self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.2 + 0.6 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance exploration by integrating a diversity-based scaling factor into the mutation phase.", "configspace": "", "generation": 65, "fitness": 0.24672296031730667, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2f4ac087-47f4-4115-bb26-23469b3519d0", "metadata": {"aucs": [0.2470596964662597, 0.2464450811879566, 0.24666410329770372], "final_y": [0.16505034920667716, 0.1649622030254957, 0.16491155172990024]}, "mutation_prompt": null}
{"id": "664c9bb0-5ba4-4145-aae1-7b5dbd354b60", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.2 + 0.6 * self.historical_success_rate\n            self.crossover_rate = 0.5 + 0.4 * diversity # Adjusted line\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive crossover rate based on population diversity to better balance exploration and exploitation.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'diversity' is not defined\").", "error": "NameError(\"name 'diversity' is not defined\")", "parent_id": "2f4ac087-47f4-4115-bb26-23469b3519d0", "metadata": {}, "mutation_prompt": null}
{"id": "b67027d5-940f-4178-b3f2-cd16682140ec", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial) * (1 + 0.01 * self.historical_success_rate)  # Adjusted line\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.2 + 0.6 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance fitness evaluation by dynamically adjusting trial fitness comparison to improve convergence.", "configspace": "", "generation": 67, "fitness": 0.2470827656567409, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2f4ac087-47f4-4115-bb26-23469b3519d0", "metadata": {"aucs": [0.24697312979324015, 0.24737332719535543, 0.24690183998162707], "final_y": [0.1654171008185007, 0.16488325917241753, 0.16532858470694223]}, "mutation_prompt": null}
{"id": "da27799f-8e19-4763-a393-d755ca67fbaa", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.2 + 0.6 * (1 - self.historical_success_rate)  # Change made here\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Adjust the mutation factor dynamically based on exploration and exploitation needs to improve convergence accuracy.", "configspace": "", "generation": 68, "fitness": 0.24708357948857473, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2f4ac087-47f4-4115-bb26-23469b3519d0", "metadata": {"aucs": [0.24697685055277485, 0.24729356040538208, 0.24698032750756727], "final_y": [0.1652168623173217, 0.16488920753040615, 0.16505715748678007]}, "mutation_prompt": null}
{"id": "eccdaf12-65dd-4002-8514-57ff2652b531", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3) / 3 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6 + 0.1 * self.historical_success_rate:  # Adjust mutation strategy\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.2 + 0.6 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate a learning factor by slightly adjusting mutation strategy based on historical success for refined exploitation.", "configspace": "", "generation": 69, "fitness": 0.2467740921641756, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2f4ac087-47f4-4115-bb26-23469b3519d0", "metadata": {"aucs": [0.24716081918438626, 0.24654643396120768, 0.24661502334693286], "final_y": [0.16488738687401394, 0.16538932193856593, 0.16554157104286227]}, "mutation_prompt": null}
{"id": "1a3b5000-4fb3-4b75-9786-e9e59834bcf8", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]  # Elitism integration\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.2 + 0.6 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Refine mutation strategy by adding elitism to the multi-phase mutation for enhanced convergence.", "configspace": "", "generation": 70, "fitness": 0.24715531576674463, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2f4ac087-47f4-4115-bb26-23469b3519d0", "metadata": {"aucs": [0.2468434313258886, 0.24733485889061335, 0.2472876570837319], "final_y": [0.16543460481116712, 0.16485585434535288, 0.16500164804888118]}, "mutation_prompt": null}
{"id": "cb2c90a5-11d8-4351-951b-588b1dd74d14", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]  # Elitism integration\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.2 + 0.6 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate  # Adjust elite fraction\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Adjust elitism fraction dynamically for better exploration-exploitation balance.", "configspace": "", "generation": 71, "fitness": 0.24701232469945608, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1a3b5000-4fb3-4b75-9786-e9e59834bcf8", "metadata": {"aucs": [0.24675042308416784, 0.24730272396237218, 0.2469838270518282], "final_y": [0.16532249696617873, 0.1648642956406191, 0.16559190127610535]}, "mutation_prompt": null}
{"id": "ca2de6ae-1420-4bd8-a306-418fc04c05a9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]  # Elitism integration\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.2 + 0.6 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n            # Adjust mutation and crossover rates based on diversity\n            self.mutation_factor *= (1 + 0.1 * diversity)\n            self.crossover_rate *= (1 - 0.1 * diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Improve convergence by dynamically adjusting mutation and crossover rates based on population diversity.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'diversity' is not defined\").", "error": "NameError(\"name 'diversity' is not defined\")", "parent_id": "1a3b5000-4fb3-4b75-9786-e9e59834bcf8", "metadata": {}, "mutation_prompt": null}
{"id": "52603a83-871f-414b-9cba-b016db15bde8", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:2][0]]  # Improved elitism\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.5 * self.historical_success_rate  # Dynamic scaling\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)  # Refined scaling\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance adaptive strategies by introducing dynamic scaling of mutation factor and improved elitism for better exploration and convergence.", "configspace": "", "generation": 73, "fitness": 0.24683721896552135, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "1a3b5000-4fb3-4b75-9786-e9e59834bcf8", "metadata": {"aucs": [0.24616215529764052, 0.2472729129571406, 0.24707658864178295], "final_y": [0.1663809930513841, 0.16503478142540118, 0.16517234578699647]}, "mutation_prompt": null}
{"id": "4d2614d4-8814-444d-b5fc-f4c05ec758ae", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8  # Changed from 0.7 to 0.8 for better early exploration\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]  # Elitism integration\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.2 + 0.6 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Adjust crossover rate to enhance exploration in the early stages of the search process.", "configspace": "", "generation": 74, "fitness": 0.24725112400365204, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1a3b5000-4fb3-4b75-9786-e9e59834bcf8", "metadata": {"aucs": [0.24723287691617002, 0.2474659920603809, 0.24705450303440524], "final_y": [0.16506785043923555, 0.16495016677144514, 0.16523640052704358]}, "mutation_prompt": null}
{"id": "4aec636b-7fef-4263-a6e4-5bed700dd040", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8  # Changed from 0.7 to 0.8 for better early exploration\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]  # Elitism integration\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.2 + 0.6 * self.historical_success_rate * 0.95  # Introduced slight learning rate adjustment\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce a learning rate to adjust the mutation factor dynamically based on recent improvements.", "configspace": "", "generation": 75, "fitness": 0.24718715890618248, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4d2614d4-8814-444d-b5fc-f4c05ec758ae", "metadata": {"aucs": [0.24711511744913373, 0.2474250063011766, 0.24702135296823713], "final_y": [0.16522246485802017, 0.16493345050143082, 0.16555546532609977]}, "mutation_prompt": null}
{"id": "a443a8fc-d736-44bd-88fd-c35626814ab6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n        self.local_search_rate = 0.2  # New parameter for local search\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        random_perturbation = np.random.uniform(\n            -0.2 * self.historical_success_rate, 0.2 * self.historical_success_rate, self.dim)  # Adjusted range\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, idx):\n        return self.population[idx] + np.random.uniform(\n            -self.local_search_rate, self.local_search_rate, self.dim)  # New local search method\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = self.local_search(i) if np.random.rand() < 0.3 else trial  # Integrate local search\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.5 * self.historical_success_rate  # Adjusted mutation factor scaling\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)  # Adjusted crossover rate scaling\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate  # Adjusted elite_fraction scaling\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate adaptive scaling and local search to enhance exploitation and convergence rate.", "configspace": "", "generation": 76, "fitness": 0.24659035528074982, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4d2614d4-8814-444d-b5fc-f4c05ec758ae", "metadata": {"aucs": [0.24570845529302465, 0.24676663218573658, 0.24729597836348827], "final_y": [0.16569971441990483, 0.16490027119117645, 0.16485580611060668]}, "mutation_prompt": null}
{"id": "f07e2831-4bc5-41c1-a6a6-dcef58ee2f3f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8  # Changed from 0.7 to 0.8 for better early exploration\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]  # Elitism integration\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.4 + 0.5 * self.historical_success_rate  # Changed from 0.2 + 0.6 * self.historical_success_rate\n            self.crossover_rate = 0.6 + 0.2 * (1 - self.historical_success_rate)\n\n            self.resize_population()\n            self.elite_fraction = 0.05 + 0.1 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Incorporate adaptive mutation factor scaling based on the current convergence state to improve exploration-exploitation balance.", "configspace": "", "generation": 77, "fitness": 0.2473384755080599, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4d2614d4-8814-444d-b5fc-f4c05ec758ae", "metadata": {"aucs": [0.24710429578570536, 0.2475085478354958, 0.24740258290297856], "final_y": [0.165158090022542, 0.16488442077260224, 0.16486869098217638]}, "mutation_prompt": null}
{"id": "2581f88c-d4c3-47c6-8aac-302151238f66", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 12 * dim  # Changed from 10 to 12\n        self.population_size = self.initial_population_size\n        self.min_population_size = 5  # Changed from 4 to 5\n        self.mutation_factor = 0.6  # Changed from 0.5 to 0.6\n        self.crossover_rate = 0.85  # Changed from 0.8 to 0.85\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.6  # Changed from 0.5 to 0.6\n        self.elite_fraction = 0.15  # Changed from 0.1 to 0.15\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        random_perturbation = np.random.uniform(\n            -0.15 * self.historical_success_rate, 0.15 * self.historical_success_rate, self.dim)  # Changed from 0.1\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.4 + diversity)))  # Changed from 0.5\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.7:  # Changed from 0.6\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.7 * self.historical_success_rate + 0.3 * (success_count / self.population_size)  # Adjusted weights\n            self.mutation_factor = 0.5 + 0.4 * self.historical_success_rate  # Changed from 0.4 + 0.5\n            self.crossover_rate = 0.7 + 0.25 * (1 - self.historical_success_rate)  # Changed from 0.6 + 0.2\n\n            self.resize_population()\n            self.elite_fraction = 0.1 + 0.15 * self.historical_success_rate  # Changed from 0.05 + 0.1\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate adaptive learning of hyperparameters and dynamic population adjustments for optimizing exploration-exploitation trade-offs.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 5779 is out of bounds for axis 0 with size 120').", "error": "IndexError('index 5779 is out of bounds for axis 0 with size 120')", "parent_id": "f07e2831-4bc5-41c1-a6a6-dcef58ee2f3f", "metadata": {}, "mutation_prompt": null}
{"id": "0d0d172d-9fe4-4eaf-9411-6154eb497fd2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.4 + 0.5 * self.historical_success_rate\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)  # Adjusted from 0.6 + 0.2\n            self.resize_population()\n\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate  # Adjusted from 0.05 + 0.1\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Incorporate adaptive elite preservation and dynamic crossover rate adjustment based on diversity to balance exploration and exploitation.", "configspace": "", "generation": 79, "fitness": 0.24738229412759702, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f07e2831-4bc5-41c1-a6a6-dcef58ee2f3f", "metadata": {"aucs": [0.24723464963591846, 0.24755966484816017, 0.2473525678987124], "final_y": [0.16489594113640527, 0.16486670070982834, 0.16489065642171385]}, "mutation_prompt": null}
{"id": "63af1e7b-1709-4e63-b1dc-367e3c0598ef", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        random_perturbation = np.random.uniform(\n            -0.12 * self.historical_success_rate, 0.12 * self.historical_success_rate, self.dim)  # Slightly increased range\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.4 + 0.5 * self.historical_success_rate\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)\n            self.resize_population()\n\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Slightly adjust the multi-phase mutation strategy to enhance variability and convergence speed.", "configspace": "", "generation": 80, "fitness": 0.24737781999354225, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0d0d172d-9fe4-4eaf-9411-6154eb497fd2", "metadata": {"aucs": [0.24721777099676923, 0.24756055006985156, 0.24735513891400596], "final_y": [0.16490989179694382, 0.16486244134016736, 0.16488165157524026]}, "mutation_prompt": null}
{"id": "8a9d28a9-78d5-49a0-9d64-b4a0552aab6a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * np.abs(b - c)\n        mutant2 = d + self.mutation_factor * np.abs(e - a)\n        mutant3 = b + self.mutation_factor * np.abs(c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.55:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.4 + 0.5 * self.historical_success_rate\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)\n            self.resize_population()\n\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance diverse mutation strategies and adaptive selection criteria to improve exploration and convergence balance.", "configspace": "", "generation": 81, "fitness": 0.2392359935103893, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.239 with standard deviation 0.001. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "0d0d172d-9fe4-4eaf-9411-6154eb497fd2", "metadata": {"aucs": [0.23920711978772147, 0.23858281012061966, 0.23991805062282678], "final_y": [0.165012635848102, 0.1818977702810618, 0.16496471348451724]}, "mutation_prompt": null}
{"id": "2eed5a48-7115-4be5-9394-a0866e1afb8b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.4 + 0.5 * self.historical_success_rate\n            self.crossover_rate = 0.5 + 0.5 * (1 - self.historical_success_rate)  # Adjusted from 0.5 + 0.3\n            self.resize_population()\n\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Refine crossover rate adjustment to increase dynamic adaptability based on historical success.", "configspace": "", "generation": 82, "fitness": 0.2473778088410804, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0d0d172d-9fe4-4eaf-9411-6154eb497fd2", "metadata": {"aucs": [0.24738128563830564, 0.2474941646027049, 0.24725797628223067], "final_y": [0.16485597517665407, 0.16492769079461278, 0.16492586724303027]}, "mutation_prompt": null}
{"id": "16ade94e-d639-4b4e-96bb-8f51417f337a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.3 + 0.6 * self.historical_success_rate  # Adjusted range for mutation factor\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)\n            self.resize_population()\n\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation factor modulation based on the success rate to further enhance exploration and exploitation balance.", "configspace": "", "generation": 83, "fitness": 0.2473426887237533, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0d0d172d-9fe4-4eaf-9411-6154eb497fd2", "metadata": {"aucs": [0.24728087460260373, 0.2474489229647634, 0.2472982686038928], "final_y": [0.164898089221982, 0.16487078375700004, 0.16496800263309241]}, "mutation_prompt": null}
{"id": "ab03e52a-05cd-4336-bd00-6d88aa441a3b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n                elif np.random.rand() < 0.01:  # Add random mutation with a small probability\n                    self.population[i] = np.random.uniform(self.bounds.lb, self.bounds.ub, self.dim)\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.4 + 0.5 * self.historical_success_rate\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)  # Adjusted from 0.6 + 0.2\n            self.resize_population()\n\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate  # Adjusted from 0.05 + 0.1\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance exploration by introducing a small probability of random mutation to jump out of local optima.", "configspace": "", "generation": 84, "fitness": 0.247236244517388, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "0d0d172d-9fe4-4eaf-9411-6154eb497fd2", "metadata": {"aucs": [0.2467098475434215, 0.2475617730592261, 0.2474371129495163], "final_y": [0.16610157230293876, 0.16499459488691715, 0.16494096071181352]}, "mutation_prompt": null}
{"id": "e72c78ee-cbf3-4d14-b15a-824407683ca2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        scaling_factor = np.random.uniform(0.4, 0.6)  # New random scaling factor\n        mutant = a + scaling_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.4 + 0.5 * self.historical_success_rate\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)\n            self.resize_population()\n\n            self.elite_fraction = 0.05 + 0.2 * self.historical_success_rate  # Adjusted elite fraction\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance mutation strategy by introducing random scaling factors and dynamic adjustment of elite preservation to improve convergence.", "configspace": "", "generation": 85, "fitness": 0.24676656683771306, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0d0d172d-9fe4-4eaf-9411-6154eb497fd2", "metadata": {"aucs": [0.2459076566290841, 0.24731333593412452, 0.2470787079499306], "final_y": [0.1648632407206213, 0.16502724116897327, 0.16531878916088094]}, "mutation_prompt": null}
{"id": "19861aaa-e1b4-41b4-a285-eb13e1caf8ab", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c) * np.random.uniform(0.9, 1.1)  # Adjusted scaling\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.45 + 0.45 * self.historical_success_rate  # Adjusted scaling factor\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)\n            self.resize_population()\n\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce competitive selective pressure and calibrated mutation scaling to enhance convergence efficiency.", "configspace": "", "generation": 86, "fitness": 0.24703107982201986, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0d0d172d-9fe4-4eaf-9411-6154eb497fd2", "metadata": {"aucs": [0.2466454066073327, 0.24707358823440706, 0.24737424462431978], "final_y": [0.1648759130469789, 0.1650020693727685, 0.16487722439484354]}, "mutation_prompt": null}
{"id": "bfdb2f79-ba70-4d63-8779-5d35cbead852", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        diversity_factor = np.std(self.population, axis=0) / (np.max(self.bounds.ub) - np.min(self.bounds.lb))\n        random_perturbation = np.random.uniform(-0.1, 0.1, self.dim) * diversity_factor\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        dynamic_size_factor = 0.5 + diversity\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * dynamic_size_factor))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.4 + 0.5 * self.historical_success_rate\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)\n            self.resize_population()\n\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Utilize a diversity-guided mutation strategy and dynamic adaptation of population size to enhance exploration and convergence in differential evolution.", "configspace": "", "generation": 87, "fitness": 0.24737002511822337, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0d0d172d-9fe4-4eaf-9411-6154eb497fd2", "metadata": {"aucs": [0.24721535862463084, 0.2475470900216038, 0.24734762670843546], "final_y": [0.16498574841742963, 0.16495800266041527, 0.16499114749651744]}, "mutation_prompt": null}
{"id": "881ffd17-f1cf-434a-99ba-62a11228e1cf", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.4 + 0.25 * self.historical_success_rate + 0.25 * np.mean(np.std(self.population, axis=0))  # Adjusted line\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)\n            self.resize_population()\n\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce a weighted mutation factor influenced by both diversity and success rate to improve adaptability.", "configspace": "", "generation": 88, "fitness": 0.23453380086704598, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.235 with standard deviation 0.005. And the mean value of best solutions found was 0.220 (0. is the best) with standard deviation 0.026.", "error": "", "parent_id": "0d0d172d-9fe4-4eaf-9411-6154eb497fd2", "metadata": {"aucs": [0.2394814513196486, 0.23594103861049143, 0.22817891267099788], "final_y": [0.19081132683183966, 0.21570936025698262, 0.25311679457079994]}, "mutation_prompt": null}
{"id": "25bf8fc7-9e85-437e-b151-2a2e2358d997", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3 * (1 + self.historical_success_rate) + elite) / 5 + random_perturbation, self.bounds.lb, self.bounds.ub)  # Changed line\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i] or np.random.rand() < 0.05:  # Changed line\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.4 + 0.5 * self.historical_success_rate\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)  # Adjusted from 0.6 + 0.2\n            self.resize_population()\n\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate  # Adjusted from 0.05 + 0.1\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduces diversity-based mutation scaling and adaptive trial selection strategy to enhance exploration-exploitation equilibrium.", "configspace": "", "generation": 89, "fitness": 0.24438551340988487, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.001. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "0d0d172d-9fe4-4eaf-9411-6154eb497fd2", "metadata": {"aucs": [0.2433594725251541, 0.24490154804937303, 0.24489551965512746], "final_y": [0.17103979251858348, 0.1673138456245622, 0.16861667664825808]}, "mutation_prompt": null}
{"id": "e08576cb-b0ab-4b2b-b84e-786753aa2ce5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.4 + 0.5 * self.historical_success_rate\n            self.crossover_rate = 0.4 + 0.4 * (1 - self.historical_success_rate)  # Adjusted from 0.5 + 0.3\n            self.resize_population()\n\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate  # Adjusted from 0.05 + 0.1\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Implement stochastic crossover rate adjustment to enhance adaptability and convergence speed.", "configspace": "", "generation": 90, "fitness": 0.24731297875471311, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0d0d172d-9fe4-4eaf-9411-6154eb497fd2", "metadata": {"aucs": [0.2472409288378128, 0.24741273776726525, 0.24728526965906128], "final_y": [0.16485796596033842, 0.16487958104162448, 0.16495059798656908]}, "mutation_prompt": null}
{"id": "cf51ff1c-82c6-4781-a628-d21eb1a02582", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.4 + 0.5 * self.historical_success_rate * diversity  # Line changed\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)  # Adjusted from 0.6 + 0.2\n            self.resize_population()\n\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate  # Adjusted from 0.05 + 0.1\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce diversity-based mutation factor scaling for improved adaptive exploration and exploitation balance.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'diversity' is not defined\").", "error": "NameError(\"name 'diversity' is not defined\")", "parent_id": "0d0d172d-9fe4-4eaf-9411-6154eb497fd2", "metadata": {}, "mutation_prompt": null}
{"id": "fe863826-8864-4f02-a642-f41ec1da83b6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.4 + 0.5 * self.historical_success_rate + 0.1 * np.std(self.fitness)  # Adjusted\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)\n            self.resize_population()\n\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation factor adjustment using diversity and success rate to enhance exploration-exploitation balance.", "configspace": "", "generation": 92, "fitness": 0.24734804048282164, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0d0d172d-9fe4-4eaf-9411-6154eb497fd2", "metadata": {"aucs": [0.2472192244057022, 0.24744057251988005, 0.24738432452288261], "final_y": [0.16487514257000713, 0.16500091329030764, 0.16489690861482253]}, "mutation_prompt": null}
{"id": "a906df27-3820-4fb4-a893-2bb40d9aaad8", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.45 + 0.55 * self.historical_success_rate  # Adjusted from 0.4 + 0.5\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)\n            self.resize_population()\n\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Fine-tune mutation factor to enhance exploration-exploitation balance.", "configspace": "", "generation": 93, "fitness": 0.2473866822862096, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0d0d172d-9fe4-4eaf-9411-6154eb497fd2", "metadata": {"aucs": [0.24726439320606275, 0.24753299779312055, 0.2473626558594455], "final_y": [0.16489479893880077, 0.16486287369701236, 0.1648902976115223]}, "mutation_prompt": null}
{"id": "b9dee746-8614-4eb3-8300-13b40aaddd71", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        random_perturbation = np.random.uniform(\n            -0.1 * self.historical_success_rate, 0.1 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.45 + 0.55 * (1 - self.historical_success_rate)  # Adjusted from 0.45 + 0.55\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)\n            self.resize_population()\n\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced exploration by adjusting mutation factor and elite retention dynamically.", "configspace": "", "generation": 94, "fitness": 0.2473273677805119, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a906df27-3820-4fb4-a893-2bb40d9aaad8", "metadata": {"aucs": [0.24716199315344656, 0.2474063600368358, 0.24741375015125333], "final_y": [0.1650925844592872, 0.16501975950448478, 0.1648579729026547]}, "mutation_prompt": null}
{"id": "dd90ab3e-ece9-4de1-ac13-f844885cd5b4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        random_perturbation = np.random.uniform(\n            -0.2 * self.historical_success_rate, 0.2 * self.historical_success_rate, self.dim)  # Adjusted from 0.1\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        diversity = np.mean(np.std(self.population, axis=0))\n        adaptive_crossover_rate = self.crossover_rate + 0.1 * diversity  # Added adaptive crossover rate\n        crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.45 + 0.55 * self.historical_success_rate\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)\n            self.resize_population()\n\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance mutation strategy using adaptive scaling and diversity-based crossover adjustment.", "configspace": "", "generation": 95, "fitness": 0.24759202271506173, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a906df27-3820-4fb4-a893-2bb40d9aaad8", "metadata": {"aucs": [0.2473757030605429, 0.24767762133122906, 0.2477227437534132], "final_y": [0.1650233076029698, 0.16485624475632255, 0.16485583345594557]}, "mutation_prompt": null}
{"id": "639bbb97-1bb1-404c-b542-beee1311b3e6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        random_perturbation = np.random.uniform(\n            -0.2 * self.historical_success_rate, 0.2 * self.historical_success_rate, self.dim)  # Adjusted from 0.1\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        diversity = np.mean(np.std(self.population, axis=0))\n        adaptive_crossover_rate = self.crossover_rate + 0.1 * diversity  # Added adaptive crossover rate\n        crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.45 + 0.55 * self.historical_success_rate\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)\n            self.resize_population()\n\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce a strategic parameter adaptation to fine-tune the balance between exploration and exploitation.", "configspace": "", "generation": 96, "fitness": 0.24759202271506173, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "dd90ab3e-ece9-4de1-ac13-f844885cd5b4", "metadata": {"aucs": [0.2473757030605429, 0.24767762133122906, 0.2477227437534132], "final_y": [0.1650233076029698, 0.16485624475632255, 0.16485583345594557]}, "mutation_prompt": null}
{"id": "75a77044-e1b9-4c93-b1d1-8a929019cafa", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        random_perturbation = np.random.uniform(\n            -0.2 * self.historical_success_rate, 0.2 * self.historical_success_rate, self.dim)  # Adjusted from 0.1\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        diversity = np.mean(np.std(self.population, axis=0))\n        adaptive_crossover_rate = self.crossover_rate + 0.1 * diversity  # Added adaptive crossover rate\n        crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.45 + 0.55 * self.historical_success_rate * np.random.uniform(0.8, 1.2)  # Added variability to mutation factor\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)\n            self.resize_population()\n\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce variability in mutation_factor to balance exploration and exploitation dynamically.", "configspace": "", "generation": 97, "fitness": 0.24769368093070898, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "dd90ab3e-ece9-4de1-ac13-f844885cd5b4", "metadata": {"aucs": [0.247613578004362, 0.2476849184490062, 0.24778254633875874], "final_y": [0.16486552895703577, 0.16485632777219472, 0.16485581082144818]}, "mutation_prompt": null}
{"id": "14fc8abc-96fd-4f39-931b-54fa4a663067", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        random_perturbation = np.random.uniform(\n            -0.2 * self.historical_success_rate, 0.2 * self.historical_success_rate, self.dim)  # Adjusted from 0.1\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        diversity = np.mean(np.std(self.population, axis=0))\n        adaptive_crossover_rate = self.crossover_rate + 0.1 * diversity  # Added adaptive crossover rate\n        crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.45 + 0.55 * self.historical_success_rate * np.random.uniform(0.8, 1.2)  # Added variability to mutation factor\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)\n            self.resize_population()\n\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate * np.random.uniform(0.9, 1.1)  # Applied variability to elite fraction\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce variability in elite fraction to enhance solution retention based on dynamic success rates.", "configspace": "", "generation": 98, "fitness": 0.2475800868801025, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "75a77044-e1b9-4c93-b1d1-8a929019cafa", "metadata": {"aucs": [0.24749317339372612, 0.24755387825954966, 0.24769320898703173], "final_y": [0.16499894408230775, 0.16489674548661304, 0.1648588233971644]}, "mutation_prompt": null}
{"id": "40317ab7-e79e-42b7-92ec-59275ad76b0b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = None\n        self.bounds = None\n        self.historical_success_rate = 0.5\n        self.elite_fraction = 0.1\n        self.chaotic_sequence = self.generate_chaotic_sequence(budget)\n\n    def generate_chaotic_sequence(self, length):\n        x = 0.4  # Initial value for logistic map\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1.0 - x)\n            sequence.append(x)\n        return np.array(sequence)\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.population_size, self.dim)\n        )\n\n    def mutate(self, target_idx, budget_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        chaotic_factor = self.chaotic_sequence[budget_idx]  # Use chaotic sequence\n        mutant = a + chaotic_factor * (b - c)\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def multi_phase_mutation(self, target_idx):\n        idxs = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        a, b, c, d, e = self.population[idxs]\n        mutant1 = a + self.mutation_factor * (b - c)\n        mutant2 = d + self.mutation_factor * (e - a)\n        mutant3 = b + self.mutation_factor * (c - d)\n        elite = self.population[np.argsort(self.fitness)[:1][0]]\n        random_perturbation = np.random.uniform(\n            -0.2 * self.historical_success_rate, 0.2 * self.historical_success_rate, self.dim)\n        return np.clip((mutant1 + mutant2 + mutant3 + elite) / 4 + random_perturbation, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        diversity = np.mean(np.std(self.population, axis=0))\n        adaptive_crossover_rate = self.crossover_rate + 0.1 * diversity\n        crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def resize_population(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.population_size\n        self.population_size = int(max(self.min_population_size, self.initial_population_size * (0.5 + diversity)))\n        self.population_size = min(self.population_size, self.initial_population_size)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.fitness = np.array([func(ind) for ind in self.population])\n        remaining_budget = self.budget - self.population_size\n\n        while remaining_budget > 0:\n            success_count = 0\n            for i in range(self.population_size):\n                if np.random.rand() > 0.6:\n                    mutant = self.mutate(i, self.budget - remaining_budget)\n                else:\n                    mutant = self.multi_phase_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success_count += 1\n\n                if remaining_budget <= 0:\n                    break\n\n            self.historical_success_rate = 0.8 * self.historical_success_rate + 0.2 * (success_count / self.population_size)\n            self.mutation_factor = 0.45 + 0.55 * self.historical_success_rate * np.random.uniform(0.8, 1.2)\n            self.crossover_rate = 0.5 + 0.3 * (1 - self.historical_success_rate)\n            self.resize_population()\n\n            self.elite_fraction = 0.05 + 0.15 * self.historical_success_rate\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.fitness)[:num_elites]\n            self.population[:num_elites] = self.population[elite_indices]\n            self.fitness[:num_elites] = self.fitness[elite_indices]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate adaptive learning mechanism with chaotic mutation for enhanced convergence and diversity.", "configspace": "", "generation": 99, "fitness": 0.24751802368313056, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "75a77044-e1b9-4c93-b1d1-8a929019cafa", "metadata": {"aucs": [0.247379960131072, 0.2476808306387157, 0.24749328027960393], "final_y": [0.16521112995488696, 0.16486058122390823, 0.16505164180766596]}, "mutation_prompt": null}
