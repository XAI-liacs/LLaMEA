{"id": "c460ea8c-c34b-4618-8e70-165ae1807f51", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax([self.evaluate(lambda x: x, h) for h in self.harmony_memory])\n        if new_fitness < self.evaluate(lambda x: x, self.harmony_memory[worst_idx]):\n            self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-1, 1) * self.bandwidth\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= 0.99  # Decay factor for bandwidth\n        self.PAR = min(1.0, self.PAR + 0.01)  # Incrementally increase PAR\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "An adaptive harmony search algorithm that dynamically adjusts its parameters based on the solution quality to efficiently optimize black-box functions within constrained evaluation budgets.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 192, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 280, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"/home/ian/LLaMEA/benchmarks/tuto_global_optimization_photonics/exp_photonic.py\", line 128, in evaluatePhotonic\n    algorithm(problem)\n  File \"<string>\", line 53, in __call__\n  File \"<string>\", line 26, in update_harmony_memory\n  File \"<string>\", line 26, in <listcomp>\n  File \"<string>\", line 20, in evaluate\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n.", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')Traceback (most recent call last):\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 192, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 280, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"/home/ian/LLaMEA/benchmarks/tuto_global_optimization_photonics/exp_photonic.py\", line 128, in evaluatePhotonic\n    algorithm(problem)\n  File \"<string>\", line 53, in __call__\n  File \"<string>\", line 26, in update_harmony_memory\n  File \"<string>\", line 26, in <listcomp>\n  File \"<string>\", line 20, in evaluate\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "d2c6af6b-eada-4b32-8bda-f97c369b00e6", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax([self.evaluate(lambda x: func(x), h) for h in self.harmony_memory])\n        if new_fitness < self.evaluate(lambda x: func(x), self.harmony_memory[worst_idx]):\n            self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-1, 1) * self.bandwidth\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= 0.99  # Decay factor for bandwidth\n        self.PAR = min(1.0, self.PAR + 0.01)  # Incrementally increase PAR\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhanced Harmony Search with improved fitness evaluation for robust black-box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "c460ea8c-c34b-4618-8e70-165ae1807f51", "metadata": {}, "mutation_prompt": null}
{"id": "a42b2d3e-67c5-463e-a15a-c660beabedd4", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax([self.evaluate(func, h) for h in self.harmony_memory])  # Fixed: use func\n        if new_fitness < self.evaluate(func, self.harmony_memory[worst_idx]):  # Fixed: use func\n            self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-1, 1) * self.bandwidth\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= 0.99  # Decay factor for bandwidth\n        self.PAR = min(1.0, self.PAR + 0.01)  # Incrementally increase PAR\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "A refined Adaptive Harmony Search algorithm that addresses an evaluation error by correctly evaluating harmonies and efficiently optimizes black-box functions.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "c460ea8c-c34b-4618-8e70-165ae1807f51", "metadata": {}, "mutation_prompt": null}
{"id": "35ad8933-9d84-4ea2-a0ad-b653241c148b", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n        if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):  # Correct fitness eval\n            self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-1, 1) * self.bandwidth\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= 0.99  # Decay factor for bandwidth\n        self.PAR = min(1.0, self.PAR + 0.01)  # Incrementally increase PAR\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "An adaptive harmony search algorithm with corrected fitness evaluation to optimize black-box functions within constrained evaluation budgets.", "configspace": "", "generation": 3, "fitness": 0.19873453405529914, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.199 with standard deviation 0.004. And the mean value of best solutions found was 0.497 (0. is the best) with standard deviation 0.047.", "error": "", "parent_id": "c460ea8c-c34b-4618-8e70-165ae1807f51", "metadata": {"aucs": [0.19316186080735986, 0.20311311213501904, 0.1999286292235185], "final_y": [0.559864620644881, 0.4489252364533637, 0.48200973393209434]}, "mutation_prompt": null}
{"id": "7a4202fb-cf31-4aa2-a18b-2af92411bf87", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n        if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):  # Correct fitness eval\n            self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-1, 1) * self.bandwidth\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= 0.99  # Decay factor for bandwidth\n        self.PAR = min(1.0, self.PAR + 0.01)  # Incrementally increase PAR\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n        self.num_harmonies = int(self.budget / 10)  # Dynamic harmony memory size\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with dynamic harmony memory size for improved exploration and exploitation balance.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 515 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 515 is out of bounds for axis 0 with size 10')", "parent_id": "35ad8933-9d84-4ea2-a0ad-b653241c148b", "metadata": {}, "mutation_prompt": null}
{"id": "4baaa8ff-8176-4f05-9802-377252d16ea1", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n        if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):  # Correct fitness eval\n            self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-self.bandwidth, self.bandwidth)  # Adjusted parameter\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= 0.98  # Decay factor for bandwidth updated\n        self.PAR = min(1.0, self.PAR + 0.01)  # Incrementally increase PAR\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "An optimized adaptive harmony search algorithm with enhanced parameter adjustment for improved convergence in black-box optimization within constrained evaluation budgets.", "configspace": "", "generation": 5, "fitness": 0.19873338582198477, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.199 with standard deviation 0.004. And the mean value of best solutions found was 0.497 (0. is the best) with standard deviation 0.046.", "error": "", "parent_id": "35ad8933-9d84-4ea2-a0ad-b653241c148b", "metadata": {"aucs": [0.19316186080735986, 0.20311028410844878, 0.1999280125501457], "final_y": [0.559864620644881, 0.44895340679285456, 0.48201630785281513]}, "mutation_prompt": null}
{"id": "a07f38d8-d0d9-4980-8b46-834cac28a838", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n        if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):  # Correct fitness eval\n            self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-0.5, 0.5) * self.bandwidth  # Adjusted range\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= 0.98  # Adjusted decay factor\n        self.PAR = min(1.0, self.PAR + 0.02)  # Adjusted increment rate\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Improved Adaptive Harmony Search with dynamic parameters for enhanced solution quality and convergence speed.", "configspace": "", "generation": 6, "fitness": 0.19676332742450695, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.197 with standard deviation 0.006. And the mean value of best solutions found was 0.521 (0. is the best) with standard deviation 0.071.", "error": "", "parent_id": "35ad8933-9d84-4ea2-a0ad-b653241c148b", "metadata": {"aucs": [0.19859366690343716, 0.1886953696441369, 0.20300094572594674], "final_y": [0.4960905220721421, 0.6178213060031459, 0.45024423976117056]}, "mutation_prompt": null}
{"id": "735b553d-d3aa-4dcf-a08c-de2b4b33024a", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n        if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):  # Correct fitness eval\n            self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-1, 1) * self.bandwidth\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.98, 1.02)  # Stochastic decay factor for bandwidth\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.005, 0.015))  # Stochastic increment for PAR\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Modified Adaptive Harmony Search with stochastic bandwidth adaptation for improved convergence.", "configspace": "", "generation": 7, "fitness": 0.20111664778763594, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.201 with standard deviation 0.007. And the mean value of best solutions found was 0.475 (0. is the best) with standard deviation 0.072.", "error": "", "parent_id": "35ad8933-9d84-4ea2-a0ad-b653241c148b", "metadata": {"aucs": [0.19316186080735986, 0.21025925170295567, 0.19992883085259228], "final_y": [0.559864620644881, 0.38345722732314413, 0.4820075845257378]}, "mutation_prompt": null}
{"id": "ea2a61f1-b487-4ccb-b13b-fa36df132695", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n        if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):  # Correct fitness eval\n            self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-1, 1) * self.bandwidth\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.95, 1.05)  # Dynamic scaling factor for bandwidth\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.005, 0.02))  # Slightly increased stochastic increment for PAR\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with dynamic bandwidth scaling for accelerated convergence.", "configspace": "", "generation": 8, "fitness": 0.20423210644856535, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.204 with standard deviation 0.010. And the mean value of best solutions found was 0.448 (0. is the best) with standard deviation 0.094.", "error": "", "parent_id": "735b553d-d3aa-4dcf-a08c-de2b4b33024a", "metadata": {"aucs": [0.19316186080735986, 0.2170231444585604, 0.20251131407977574], "final_y": [0.559864620644881, 0.3300010405435272, 0.45517885757344323]}, "mutation_prompt": null}
{"id": "7f8d71b5-2891-486f-be33-752642ee2c9d", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n        if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):  # Correct fitness eval\n            self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-1, 1) * self.bandwidth\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.9, 1.1)  # Dynamic scaling factor for bandwidth\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.01, 0.03))  # Slightly increased stochastic increment for PAR\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Improved pitch adjustment rate and bandwidth scaling for enhanced solution exploration.", "configspace": "", "generation": 9, "fitness": 0.20707479453274005, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.207 with standard deviation 0.002. And the mean value of best solutions found was 0.412 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": "ea2a61f1-b487-4ccb-b13b-fa36df132695", "metadata": {"aucs": [0.20993402835884822, 0.20582380728471994, 0.20546654795465202], "final_y": [0.38611166714673983, 0.4230181262076457, 0.4263626300635789]}, "mutation_prompt": null}
{"id": "a0c51a6f-8930-433d-97ae-82c0b111ae52", "solution": "import numpy as np\n\nclass QuantumInspiredHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.q_bit_representation = np.random.rand(self.num_harmonies, self.dim) < 0.5\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n        if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n            self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            q_bit_choice = self.q_bit_representation[np.random.randint(self.num_harmonies), i]\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[q_bit_choice, i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-1, 1) * self.bandwidth\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.9, 1.1)\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.01, 0.03))\n        self.q_bit_representation = np.random.rand(self.num_harmonies, self.dim) < 0.5  # Update quantum bits\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "QuantumInspiredHarmonySearch", "description": "Quantum-inspired Adaptive Harmony Search enhances solution diversity by simulating quantum superposition and entanglement effects in harmony generation.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('setting an array element with a sequence.').", "error": "ValueError('setting an array element with a sequence.')", "parent_id": "7f8d71b5-2891-486f-be33-752642ee2c9d", "metadata": {}, "mutation_prompt": null}
{"id": "b4042db7-8690-498a-9b69-5fd0318ab42d", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n        if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):  # Correct fitness eval\n            self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-1, 1) * self.bandwidth\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony + np.random.normal(0, self.bandwidth, self.dim), bounds.lb, bounds.ub)  # Adaptive mutation\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.9, 1.1)  # Dynamic scaling factor for bandwidth\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.01, 0.03))  # Slightly increased stochastic increment for PAR\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhanced harmony improvement with adaptive mutation for diverse exploration.", "configspace": "", "generation": 11, "fitness": 0.20266233194194824, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.203 with standard deviation 0.007. And the mean value of best solutions found was 0.460 (0. is the best) with standard deviation 0.077.", "error": "", "parent_id": "7f8d71b5-2891-486f-be33-752642ee2c9d", "metadata": {"aucs": [0.19314493443750003, 0.21138240180264645, 0.20345965958569823], "final_y": [0.5600742015222404, 0.373984190063262, 0.4457826310636094]}, "mutation_prompt": null}
{"id": "f8e74307-7b44-4259-b3c1-3fc368483573", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n        if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n            if len(self.harmony_memory) < self.num_harmonies + 2:  # Dynamically adjust memory size\n                self.harmony_memory = np.append(self.harmony_memory, [new_harmony], axis=0)\n            self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-1, 1) * self.bandwidth\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.9, 1.1)\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.005, 0.02))  # Slightly refined PAR scaling\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with dynamic memory size and adaptive PAR scaling for improved convergence.", "configspace": "", "generation": 12, "fitness": 0.20047294014664438, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.200 with standard deviation 0.006. And the mean value of best solutions found was 0.480 (0. is the best) with standard deviation 0.063.", "error": "", "parent_id": "7f8d71b5-2891-486f-be33-752642ee2c9d", "metadata": {"aucs": [0.19316186080735986, 0.20773237765608632, 0.20052458197648693], "final_y": [0.559864620644881, 0.4055291392398227, 0.4756814082699904]}, "mutation_prompt": null}
{"id": "baabe71f-a0e8-45b6-80e2-8f3db7b98752", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        avg_fitness = np.mean([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n        if new_fitness < avg_fitness:  # Replace if better than average\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-1, 1) * self.bandwidth\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.9, 1.1)  # Dynamic scaling factor for bandwidth\n        self.PAR = max(0.1, self.PAR - np.random.uniform(0.01, 0.03))  # Stochastically decrease PAR\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhanced solution exploration by stochastic PAR reduction and adaptive harmony replacement strategy.", "configspace": "", "generation": 13, "fitness": 0.1996910026722937, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.200 with standard deviation 0.005. And the mean value of best solutions found was 0.488 (0. is the best) with standard deviation 0.056.", "error": "", "parent_id": "7f8d71b5-2891-486f-be33-752642ee2c9d", "metadata": {"aucs": [0.19369992213185816, 0.19889717594540457, 0.2064759099396184], "final_y": [0.5532193218673658, 0.49305908913028584, 0.41688077559934456]}, "mutation_prompt": null}
{"id": "c2041e4f-1070-4994-a7b5-40904a0a9142", "solution": "import numpy as np\n\nclass PheromoneEnhancedHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.pheromones = np.ones((self.num_harmonies, self.dim))  # Initial pheromone levels\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n        if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n            self.harmony_memory[worst_idx] = new_harmony\n            self.pheromones[worst_idx] = np.random.rand(self.dim)  # Update pheromones randomly for new harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                selected_idx = np.random.choice(self.num_harmonies, p=self.pheromones[:, i] / np.sum(self.pheromones[:, i]))\n                new_harmony[i] = self.harmony_memory[selected_idx, i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-1, 1) * self.bandwidth\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.9, 1.1)\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.01, 0.03))\n\n    def update_pheromones(self):\n        # Simulate pheromone evaporation and intensification\n        self.pheromones *= 0.9  # Evaporation\n        for idx, harmony in enumerate(self.harmony_memory):\n            self.pheromones[idx] += 1.0 / (1.0 + np.sum(np.abs(harmony - self.best_solution)))  # Intensification\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            self.update_pheromones()\n            evaluations += 1\n\n        return self.best_solution", "name": "PheromoneEnhancedHarmonySearch", "description": "Pheromone-Enhanced Harmony Search integrates pheromone trails for dynamic solution guidance and exploration.", "configspace": "", "generation": 14, "fitness": 0.19238025008566573, "feedback": "The algorithm PheromoneEnhancedHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.192 with standard deviation 0.003. And the mean value of best solutions found was 0.567 (0. is the best) with standard deviation 0.034.", "error": "", "parent_id": "7f8d71b5-2891-486f-be33-752642ee2c9d", "metadata": {"aucs": [0.19295287409955297, 0.18850916121795513, 0.19567871493948907], "final_y": [0.5622130013902309, 0.6113495311449328, 0.5274160118356415]}, "mutation_prompt": null}
{"id": "9b2d5fe6-276a-4292-b58f-149a4c0281f1", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n        if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):  # Correct fitness eval\n            self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-1, 1) * self.bandwidth\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.9, 1.1)  # Dynamic scaling factor for bandwidth\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.01, 0.03))  # Slightly increased stochastic increment for PAR\n        self.HMCR = min(1.0, self.HMCR + np.random.uniform(-0.01, 0.01))  # Dynamic adjustment for HMCR\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Adaptive parameter tuning with dynamic HMCR for better exploration-exploitation balance.", "configspace": "", "generation": 15, "fitness": 0.20188851059805246, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.202 with standard deviation 0.004. And the mean value of best solutions found was 0.403 (0. is the best) with standard deviation 0.082.", "error": "", "parent_id": "7f8d71b5-2891-486f-be33-752642ee2c9d", "metadata": {"aucs": [0.19695281716311652, 0.20653607599175916, 0.2021766386392817], "final_y": [0.5039767647435429, 0.30204093599587, 0.4023536724514838]}, "mutation_prompt": null}
{"id": "e5b37693-b657-44de-bf5a-f139a58454f4", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n        if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):  # Correct fitness eval\n            self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-1, 1) * self.bandwidth\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        # Adjust bandwidth using a probabilistic factor\n        if np.random.rand() < 0.5:\n            self.bandwidth *= np.random.uniform(0.95, 1.05)  # Probabilistic scaling for bandwidth\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.01, 0.03))  # Slightly increased stochastic increment for PAR\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with a probabilistic bandwidth adjustment to improve exploration and exploitation balance.", "configspace": "", "generation": 16, "fitness": 0.2026471503985685, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.203 with standard deviation 0.012. And the mean value of best solutions found was 0.469 (0. is the best) with standard deviation 0.112.", "error": "", "parent_id": "7f8d71b5-2891-486f-be33-752642ee2c9d", "metadata": {"aucs": [0.19685653679965986, 0.21921853339573683, 0.19186638100030884], "final_y": [0.5158853902134659, 0.31453711522192285, 0.5758607712036573]}, "mutation_prompt": null}
{"id": "1172e8d7-5750-4362-a129-ba9cb67614d2", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_memory_fitness = np.apply_along_axis(self.evaluate, 1, self.harmony_memory)\n\n    def evaluate(self, func, harmony):\n        return func(harmony)\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_memory_fitness)\n        if new_fitness < self.harmony_memory_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_memory_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-1, 1) * self.bandwidth\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.9, 1.1)\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.01, 0.03))\n        # Dynamic adjustment for HMCR\n        self.HMCR = max(0.7, self.HMCR - np.random.uniform(0, 0.01))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            if new_fitness < self.best_fitness:\n                self.best_fitness = new_fitness\n                self.best_solution = new_harmony.copy()\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with dynamic HMCR tuning and elite memory retention for faster convergence.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"AdaptiveHarmonySearch.evaluate() missing 1 required positional argument: 'harmony'\").", "error": "TypeError(\"AdaptiveHarmonySearch.evaluate() missing 1 required positional argument: 'harmony'\")", "parent_id": "7f8d71b5-2891-486f-be33-752642ee2c9d", "metadata": {}, "mutation_prompt": null}
{"id": "3bcb90d8-caa0-46b5-9acc-4dd9e5c78f12", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n        diversity_metric = np.linalg.norm(self.harmony_memory - new_harmony, axis=1).mean()\n        if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]) and diversity_metric > 0.1:  # Add diversity\n            self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-1, 1) * self.bandwidth\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.9, 1.1)  # Dynamic scaling factor for bandwidth\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.01, 0.03))  # Slightly increased stochastic increment for PAR\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Incorporate diversity-driven memory update to enhance exploration and convergence.", "configspace": "", "generation": 18, "fitness": 0.20707479453274005, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.207 with standard deviation 0.002. And the mean value of best solutions found was 0.412 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": "7f8d71b5-2891-486f-be33-752642ee2c9d", "metadata": {"aucs": [0.20993402835884822, 0.20582380728471994, 0.20546654795465202], "final_y": [0.38611166714673983, 0.4230181262076457, 0.4263626300635789]}, "mutation_prompt": null}
{"id": "a5c26381-6254-45c5-a8f4-b8ddbb464b8e", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n        if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):  # Correct fitness eval\n            self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-1, 1) * self.bandwidth\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.95, 1.05)  # Enhanced dynamic scaling factor for bandwidth\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.01, 0.03))  # Slightly increased stochastic increment for PAR\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Adaptive harmony search with enhanced dynamic bandwidth scaling for better exploration.", "configspace": "", "generation": 19, "fitness": 0.20707378303757695, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.207 with standard deviation 0.002. And the mean value of best solutions found was 0.412 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": "7f8d71b5-2891-486f-be33-752642ee2c9d", "metadata": {"aucs": [0.2099348416201806, 0.20581920971627943, 0.20546729777627082], "final_y": [0.3861047106785608, 0.42306123006909646, 0.42635556406894315]}, "mutation_prompt": null}
{"id": "efccecd1-a1a2-416a-b66e-918432b05272", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.1:\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-self.bandwidth, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.95, 1.05)  # Finer dynamic scaling\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.01, 0.03))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhanced selection of harmonies using stochastic acceptance and non-uniform bandwidth adjustment.", "configspace": "", "generation": 20, "fitness": 0.21208539068882235, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.212 with standard deviation 0.005. And the mean value of best solutions found was 0.371 (0. is the best) with standard deviation 0.046.", "error": "", "parent_id": "7f8d71b5-2891-486f-be33-752642ee2c9d", "metadata": {"aucs": [0.20460579195621065, 0.21476490550315996, 0.2168854746070964], "final_y": [0.43461033117098424, 0.34662270347807866, 0.33059791836352037]}, "mutation_prompt": null}
{"id": "62ac0350-39ec-4f0d-a19d-f7e49e8b4fa8", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.1:\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-self.bandwidth, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.95, 1.05)  # Finer dynamic scaling\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.01, 0.03))\n        self.num_harmonies = max(5, min(20, int(self.num_harmonies * np.random.uniform(0.95, 1.05))))  # Dynamic adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Improved Adaptive Harmony Search by enhancing stochastic acceptance and dynamically adjusting harmony memory size.", "configspace": "", "generation": 21, "fitness": 0.21331788628468948, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.213 with standard deviation 0.005. And the mean value of best solutions found was 0.360 (0. is the best) with standard deviation 0.036.", "error": "", "parent_id": "efccecd1-a1a2-416a-b66e-918432b05272", "metadata": {"aucs": [0.20846774320310046, 0.21182475752042285, 0.2196611581305451], "final_y": [0.39872438094965346, 0.3694674862408055, 0.3110859475611031]}, "mutation_prompt": null}
{"id": "8b54d515-d680-41c0-8efa-7dd45658042b", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.2:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-self.bandwidth, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.9, 1.1)  # Broader dynamic scaling\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.02, 0.04))  # Enhanced adjustment\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search by optimizing parameter tuning and memory replacement conditions to improve convergence.", "configspace": "", "generation": 22, "fitness": 0.21390935820344234, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.214 with standard deviation 0.002. And the mean value of best solutions found was 0.353 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "62ac0350-39ec-4f0d-a19d-f7e49e8b4fa8", "metadata": {"aucs": [0.21553814081617273, 0.21513868856481466, 0.2110512452293396], "final_y": [0.34077494017988297, 0.3428891865274062, 0.37612346832873833]}, "mutation_prompt": null}
{"id": "3223c49f-4e41-4496-9eb5-53423e903beb", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.2:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-self.bandwidth, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_factor = 1 - (self.best_fitness / (self.best_fitness + 1e-9))\n        self.bandwidth *= (1.0 + improvement_factor)  # Adjust based on fitness improvement\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.02, 0.04))  # Enhanced adjustment\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Improved Adaptive Harmony Search with dynamic bandwidth adaptation based on fitness improvements to enhance exploration and convergence.", "configspace": "", "generation": 23, "fitness": 0.20235125345913715, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.202 with standard deviation 0.002. And the mean value of best solutions found was 0.457 (0. is the best) with standard deviation 0.020.", "error": "", "parent_id": "8b54d515-d680-41c0-8efa-7dd45658042b", "metadata": {"aucs": [0.2032868375634821, 0.20409927904272884, 0.1996676437712005], "final_y": [0.4473184440235629, 0.43931743753592756, 0.48445451680135776]}, "mutation_prompt": null}
{"id": "d230e941-3971-4066-8aa7-6ca99ad17422", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.2:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.uniform(-self.bandwidth, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.85, 1.15)  # Broader dynamic scaling\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.02, 0.04))  # Enhanced adjustment\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Improved adaptive parameter adjustment for better exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": 0.21391306780659536, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.214 with standard deviation 0.002. And the mean value of best solutions found was 0.353 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "8b54d515-d680-41c0-8efa-7dd45658042b", "metadata": {"aucs": [0.21555197475029986, 0.21514143346394132, 0.2110457952055449], "final_y": [0.34067028082229245, 0.34286812984201964, 0.3761691873066665]}, "mutation_prompt": null}
{"id": "490d5684-bc98-4373-8ee7-c47698fac0a8", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.2:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.85, 1.15)  # Broader dynamic scaling\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.02, 0.04))  # Enhanced adjustment\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhanced neighborhood search and selective pitch adjustment for increased adaptability.", "configspace": "", "generation": 25, "fitness": 0.21794559697423385, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.218 with standard deviation 0.002. And the mean value of best solutions found was 0.323 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "d230e941-3971-4066-8aa7-6ca99ad17422", "metadata": {"aucs": [0.21984098460377544, 0.21853340939145083, 0.21546239692747526], "final_y": [0.3092562897815655, 0.31930930736253915, 0.3414319311181202]}, "mutation_prompt": null}
{"id": "be00fd37-9260-40ef-a18e-27d5e3bfb53d", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.3:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n            else:\n                self.harmony_memory[np.random.randint(self.num_harmonies)] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.90, 1.2)  # Broader dynamic scaling\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.02, 0.04))  # Enhanced adjustment\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with dynamic bandwidth adjustment and greedy memory updating.", "configspace": "", "generation": 26, "fitness": 0.20839258807905234, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.208 with standard deviation 0.007. And the mean value of best solutions found was 0.404 (0. is the best) with standard deviation 0.061.", "error": "", "parent_id": "490d5684-bc98-4373-8ee7-c47698fac0a8", "metadata": {"aucs": [0.2016622213289756, 0.2184301724589791, 0.20508537044920228], "final_y": [0.46334343552631085, 0.3200415193285533, 0.42982845883398435]}, "mutation_prompt": null}
{"id": "673d5ce8-1763-4b9f-8ece-d83d748ebcb9", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.25:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth * np.random.uniform(0.5, 1.5))  # Adaptive bandwidth\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.85, 1.15)  # Broader dynamic scaling\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.02, 0.04))  # Enhanced adjustment\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Adaptive Harmony Search with dynamic pitch adjustment and selective harmony replacement for improved exploration.", "configspace": "", "generation": 27, "fitness": 0.20997523773356289, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.210 with standard deviation 0.004. And the mean value of best solutions found was 0.387 (0. is the best) with standard deviation 0.032.", "error": "", "parent_id": "490d5684-bc98-4373-8ee7-c47698fac0a8", "metadata": {"aucs": [0.21058299706445127, 0.21419780185089887, 0.20514491428533854], "final_y": [0.38005018876747, 0.3510623456055765, 0.42941899949501894]}, "mutation_prompt": null}
{"id": "a260ce73-818b-4a9b-b42b-92666f9d5a16", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.2:\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.8, 1.2)  # Adaptive scaling range\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.02, 0.04))\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))\n        self.HMCR = min(0.95, self.HMCR + np.random.uniform(0.01, 0.03))  # Dynamic adjustment of HMCR\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduce adaptive bandwidth scaling and dynamic harmony memory consideration to enhance exploration.", "configspace": "", "generation": 28, "fitness": 0.21046795463306842, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.210 with standard deviation 0.009. And the mean value of best solutions found was 0.389 (0. is the best) with standard deviation 0.083.", "error": "", "parent_id": "490d5684-bc98-4373-8ee7-c47698fac0a8", "metadata": {"aucs": [0.21863962162920902, 0.21504139485290852, 0.19772284741708768], "final_y": [0.3173150614411292, 0.3448191759735373, 0.5059428639683292]}, "mutation_prompt": null}
{"id": "ab59e689-96e6-44a0-b6a0-df9d5d2e892e", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 12  # Increased harmonies for diversity\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.3:  # Increased acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth * 1.5)  # Increased pitch adjustment\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.9, 1.2)  # Broader dynamic scaling\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.03, 0.05))  # Enhanced adjustment\n        self.num_harmonies = max(6, min(18, int(self.num_harmonies * np.random.uniform(0.95, 1.1))))  # Slightly wider adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Dynamic learning through enhanced diversity and adaptive pitch adjustment in Harmony Search.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 12 is out of bounds for axis 0 with size 12').", "error": "IndexError('index 12 is out of bounds for axis 0 with size 12')", "parent_id": "490d5684-bc98-4373-8ee7-c47698fac0a8", "metadata": {}, "mutation_prompt": null}
{"id": "50879552-4a37-42a0-a706-8a459e1fc8d9", "solution": "import numpy as np\n\nclass CohesivePhaseSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.global_best_position = np.zeros(dim)\n        self.global_best_fitness = float('inf')\n        self.positions = None\n        self.velocities = None\n        self.particle_best_positions = None\n        self.particle_best_fitnesses = np.full(self.num_particles, float('inf'))\n        self.phase_offsets = np.random.uniform(0, 2 * np.pi, self.num_particles)\n\n    def initialize_swarm(self, bounds):\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n\n    def evaluate(self, func):\n        fitnesses = np.array([func(pos) for pos in self.positions])\n        for i, fitness in enumerate(fitnesses):\n            if fitness < self.particle_best_fitnesses[i]:\n                self.particle_best_fitnesses[i] = fitness\n                self.particle_best_positions[i] = self.positions[i].copy()\n            if fitness < self.global_best_fitness:\n                self.global_best_fitness = fitness\n                self.global_best_position = self.positions[i].copy()\n        return fitnesses\n\n    def update_positions(self, bounds):\n        self.positions += self.velocities\n        self.positions = np.clip(self.positions, bounds.lb, bounds.ub)\n\n    def update_velocities(self):\n        w = 0.7  # inertia weight\n        c1 = 1.5  # cognitive coefficient\n        c2 = 1.5  # social coefficient\n        for i in range(self.num_particles):\n            r1, r2 = np.random.rand(), np.random.rand()\n            cognitive_component = c1 * r1 * (self.particle_best_positions[i] - self.positions[i])\n            social_component = c2 * r2 * (self.global_best_position - self.positions[i])\n            phase_influence = np.sin(self.phase_offsets[i]) * np.linalg.norm(social_component)\n            self.velocities[i] = w * self.velocities[i] + cognitive_component + social_component + phase_influence\n\n    def adjust_phases(self):\n        phase_sync_rate = 0.05\n        for i in range(self.num_particles):\n            self.phase_offsets[i] += np.random.normal(0, phase_sync_rate)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_swarm(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            self.evaluate(func)\n            self.update_velocities()\n            self.update_positions(bounds)\n            self.adjust_phases()\n            evaluations += self.num_particles  # Each particle's position update counts as an evaluation\n\n        return self.global_best_position", "name": "CohesivePhaseSwarm", "description": "CohesivePhaseSwarm optimizes by leveraging cooperative phase synchronization and adaptive neighborhood influence.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'NoneType' object does not support item assignment\").", "error": "TypeError(\"'NoneType' object does not support item assignment\")", "parent_id": "490d5684-bc98-4373-8ee7-c47698fac0a8", "metadata": {}, "mutation_prompt": null}
{"id": "784e8377-04af-4afd-9485-85661bb34b68", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.2:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.85, 1.15)  # Broader dynamic scaling\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.02, 0.04))  # Enhanced adjustment\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))  # Tighter adjustment\n        self.HMCR = np.clip(self.HMCR + np.random.uniform(-0.05, 0.05), 0.8, 1.0)  # Dynamic HMCR adjustment\n        self.PAR = np.clip(self.PAR + np.random.uniform(-0.05, 0.05), 0.2, 0.5)  # Dynamic PAR adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduced dynamic pitch adjustment and memory consideration rates for improved adaptability.", "configspace": "", "generation": 31, "fitness": 0.21319008311110751, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.213 with standard deviation 0.004. And the mean value of best solutions found was 0.361 (0. is the best) with standard deviation 0.034.", "error": "", "parent_id": "490d5684-bc98-4373-8ee7-c47698fac0a8", "metadata": {"aucs": [0.21935434027248923, 0.20989580098927285, 0.21032010807156043], "final_y": [0.31337042698691875, 0.38645070359648015, 0.38232655895758827]}, "mutation_prompt": null}
{"id": "f6117115-35ae-4b1f-b1a0-6102347dcd30", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.2:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.9, 1.1)  # Broader dynamic scaling\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.01, 0.03))  # Enhanced adjustment\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.95, 1.05))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Improved parameter adjustment with adaptive learning rate for enhanced convergence.", "configspace": "", "generation": 32, "fitness": 0.2114286200104891, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.211 with standard deviation 0.001. And the mean value of best solutions found was 0.373 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "490d5684-bc98-4373-8ee7-c47698fac0a8", "metadata": {"aucs": [0.21219291506899995, 0.21055054115032268, 0.21154240381214462], "final_y": [0.3670971634552248, 0.3808299365735013, 0.3722592561584862]}, "mutation_prompt": null}
{"id": "f3965c56-d34c-47bc-8b86-dc701c3caaf2", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.2:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, max(0.1, (self.best_fitness / 100)))  # Dynamic adjustment based on fitness\n        self.bandwidth *= np.random.uniform(0.85, 1.15 * improvement_rate)  # Broader dynamic scaling\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.02, 0.04))  # Enhanced adjustment\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduce a dynamic bandwidth adjustment based on fitness improvement rate to enhance adaptability.", "configspace": "", "generation": 33, "fitness": 0.2179660764988428, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.218 with standard deviation 0.002. And the mean value of best solutions found was 0.323 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "490d5684-bc98-4373-8ee7-c47698fac0a8", "metadata": {"aucs": [0.21982670675704563, 0.21856009888056094, 0.21551142385892186], "final_y": [0.30935660012778543, 0.3191203487238353, 0.34106051769413226]}, "mutation_prompt": null}
{"id": "c1f9a6aa-dc79-4d90-8270-58e7c847c337", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.3:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, max(0.1, (self.best_fitness / 100)))  # Dynamic adjustment based on fitness\n        self.bandwidth *= np.random.uniform(0.85, 1.15 * improvement_rate)  # Broader dynamic scaling\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.02, 0.04))  # Enhanced adjustment\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Modify acceptance probability to enhance exploration and exploitation balance.", "configspace": "", "generation": 34, "fitness": 0.20955065878360146, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.210 with standard deviation 0.006. And the mean value of best solutions found was 0.393 (0. is the best) with standard deviation 0.052.", "error": "", "parent_id": "f3965c56-d34c-47bc-8b86-dc701c3caaf2", "metadata": {"aucs": [0.2050314864725491, 0.21856009890483885, 0.20506039097341644], "final_y": [0.4297192239304901, 0.3191203485530011, 0.43006624334494414]}, "mutation_prompt": null}
{"id": "c9f8e360-2357-4766-ab78-d7c8950272d9", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.15:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, max(0.1, (self.best_fitness / 100)))  # Dynamic adjustment based on fitness\n        self.bandwidth *= np.random.uniform(0.8, 1.15 * improvement_rate)  # Broader dynamic scaling\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.02, 0.04))  # Enhanced adjustment\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhanced dynamic bandwidth adjustment with refined harmony replacement for better convergence.", "configspace": "", "generation": 35, "fitness": 0.21563139060033878, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.216 with standard deviation 0.001. And the mean value of best solutions found was 0.340 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "f3965c56-d34c-47bc-8b86-dc701c3caaf2", "metadata": {"aucs": [0.216493344458221, 0.21600647292285424, 0.21439435441994115], "final_y": [0.3333934150370921, 0.337746931948097, 0.34982114376172657]}, "mutation_prompt": null}
{"id": "e6d456d6-b3f4-4d08-b5f5-fc172324beab", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.2:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, max(0.1, (self.best_fitness / 100)))  # Dynamic adjustment based on fitness\n        self.bandwidth *= np.random.uniform(0.85, 1.15 * improvement_rate)  # Broader dynamic scaling\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.02, 0.04))  # Enhanced adjustment\n        fitness_variability = np.std([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1 * (1 + fitness_variability)))))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduce adaptive harmony memory size based on fitness variability to improve exploration-exploitation balance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 11 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 11 is out of bounds for axis 0 with size 10')", "parent_id": "f3965c56-d34c-47bc-8b86-dc701c3caaf2", "metadata": {}, "mutation_prompt": null}
{"id": "e4c92444-c4ce-4258-af87-9194c2432ba7", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.2:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, max(0.1, (self.best_fitness / 100)))  # Dynamic adjustment based on fitness\n        self.bandwidth *= np.random.uniform(0.95, 1.15 * improvement_rate)  # Broader dynamic scaling\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.03, 0.05))  # Enhanced adjustment\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhance exploitation by refining parameter adjustment to leverage recent performance trends.", "configspace": "", "generation": 37, "fitness": 0.20914268725881083, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.209 with standard deviation 0.003. And the mean value of best solutions found was 0.394 (0. is the best) with standard deviation 0.031.", "error": "", "parent_id": "f3965c56-d34c-47bc-8b86-dc701c3caaf2", "metadata": {"aucs": [0.20449209744574115, 0.21278689343763812, 0.21014907089305324], "final_y": [0.4355235069575273, 0.3626697661773608, 0.3835844354619101]}, "mutation_prompt": null}
{"id": "9bf6f199-0b70-4c21-8798-4e3e1a8b14a0", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.2:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, max(0.1, (self.best_fitness / 100)))  # Dynamic adjustment based on fitness\n        self.bandwidth *= np.random.uniform(0.85, 1.15 * improvement_rate)  # Broader dynamic scaling\n        self.HMCR = min(1.0, self.HMCR + np.random.uniform(0.03, 0.05)) # Adjust HMCR for adaptability\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhance adaptability by dynamically adjusting Harmony Memory Consideration Rate (HMCR).", "configspace": "", "generation": 38, "fitness": 0.2144384365784753, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.214 with standard deviation 0.002. And the mean value of best solutions found was 0.350 (0. is the best) with standard deviation 0.019.", "error": "", "parent_id": "f3965c56-d34c-47bc-8b86-dc701c3caaf2", "metadata": {"aucs": [0.21750905519734642, 0.21434309953323383, 0.2114631550048457], "final_y": [0.32637462786080196, 0.35012935623213026, 0.373319900543032]}, "mutation_prompt": null}
{"id": "fdbcb7fd-f5d8-4328-b0f5-c4978b96b26c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.past_fitnesses = []\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n        if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n            self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        if len(self.past_fitnesses) > 5:\n            improvement_trend = np.mean(np.diff(self.past_fitnesses[-5:]))\n            if improvement_trend < 0:  # If recent trend indicates improvement\n                self.bandwidth *= 0.95\n                self.PAR = min(1.0, self.PAR + 0.01)\n            else:  # If recent trend indicates stagnation or deterioration\n                self.bandwidth *= 1.05\n                self.PAR = max(0.1, self.PAR - 0.01)\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.past_fitnesses.append(new_fitness)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "EnhancedAdaptiveHarmonySearch", "description": "Introduce a feedback-driven self-adaptive strategy to dynamically adjust parameters based on historical performance trends.", "configspace": "", "generation": 39, "fitness": 0.20673383609725418, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.207 with standard deviation 0.008. And the mean value of best solutions found was 0.422 (0. is the best) with standard deviation 0.082.", "error": "", "parent_id": "f3965c56-d34c-47bc-8b86-dc701c3caaf2", "metadata": {"aucs": [0.19504977156597336, 0.21095416552743995, 0.21419757119834926], "final_y": [0.536590178329695, 0.377670364963664, 0.3515657842156099]}, "mutation_prompt": null}
{"id": "d72c5b60-cbd1-4e24-9b49-f8f637a919c7", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.2:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, max(0.1, (self.best_fitness / 100)))  # Dynamic adjustment based on fitness\n        self.bandwidth *= np.random.uniform(0.85, 1.15 * improvement_rate)  # Broader dynamic scaling\n        self.PAR = min(1.0, self.PAR * (1.0 + np.random.uniform(0.1, 0.2) * improvement_rate))  # Self-adaptive adjustment\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Implement a self-adaptive pitch adjustment rate to further enhance the adaptability of the search process.", "configspace": "", "generation": 40, "fitness": 0.21492342180932264, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.215 with standard deviation 0.006. And the mean value of best solutions found was 0.348 (0. is the best) with standard deviation 0.047.", "error": "", "parent_id": "f3965c56-d34c-47bc-8b86-dc701c3caaf2", "metadata": {"aucs": [0.20709883789605332, 0.21590917710722712, 0.22176225042468745], "final_y": [0.4106815044895574, 0.3375262727795235, 0.2968259524362842]}, "mutation_prompt": null}
{"id": "ca23f5c2-9327-482f-b6af-81b39a5ce3dd", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.2:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        fitness_variance = np.var([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])  # Calculate variance\n        self.bandwidth *= np.random.uniform(0.85, 1.15 * fitness_variance)  # Adjust bandwidth using variance\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.02, 0.04) * (1.0 if fitness_variance < 0.5 else -1.0))  # Adjust PAR\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhance dynamic adaptation by scaling bandwidth with fitness variance and adjusting PAR based on overall fitness trend.", "configspace": "", "generation": 41, "fitness": 0.21208514130159592, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.212 with standard deviation 0.005. And the mean value of best solutions found was 0.370 (0. is the best) with standard deviation 0.039.", "error": "", "parent_id": "f3965c56-d34c-47bc-8b86-dc701c3caaf2", "metadata": {"aucs": [0.2057831877480879, 0.21659274137589068, 0.21387949478080914], "final_y": [0.42347113563540106, 0.33231342595082225, 0.3538012103891829]}, "mutation_prompt": null}
{"id": "50edaf5f-c937-4783-b7a7-6c3bf2700342", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.2:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        new_harmony = np.clip(new_harmony, bounds.lb, bounds.ub)  # Integrate harmony regeneration mechanism\n        if np.random.rand() < 0.1:  # Introduce a new harmony regeneration chance\n            new_harmony = np.random.uniform(bounds.lb, bounds.ub, self.dim)\n        return new_harmony\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, max(0.1, (self.best_fitness / 100)))  # Dynamic adjustment based on fitness\n        self.bandwidth *= np.random.uniform(0.85, 1.15 * improvement_rate)  # Broader dynamic scaling\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.02, 0.04))  # Enhanced adjustment\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Integrate a diversity-enhancing operator by introducing a novel harmony regeneration mechanism to improve exploration.", "configspace": "", "generation": 42, "fitness": 0.2144614187213099, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.214 with standard deviation 0.001. And the mean value of best solutions found was 0.336 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "f3965c56-d34c-47bc-8b86-dc701c3caaf2", "metadata": {"aucs": [0.2141529327563706, 0.2156951435854858, 0.2135361798220733], "final_y": [0.3292325230339149, 0.32384419093686356, 0.3559147633737825]}, "mutation_prompt": null}
{"id": "bd6e86f8-0002-4da4-bb83-6380b47558e6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_solution = None\n        self.elite_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        if fitness < self.elite_fitness and np.random.rand() < 0.1:  # Ensure occasional update of elite\n            self.elite_fitness = fitness\n            self.elite_solution = harmony.copy()\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.3:\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self, evaluations):\n        self.bandwidth *= np.exp(-evaluations / (0.1 * self.budget))\n        self.PAR = min(1.0, self.PAR + np.exp(-evaluations / self.budget))\n        if evaluations % (self.budget // 10) == 0:\n            self.harmony_memory[np.random.randint(self.num_harmonies)] = self.elite_solution.copy()\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters(evaluations)\n            evaluations += 1\n\n        return self.best_solution", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhance Adaptive Harmony Search by implementing an elite preservation strategy and introducing adaptive pitch adjustment using exponential decay for better convergence.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'NoneType' object has no attribute 'copy'\").", "error": "AttributeError(\"'NoneType' object has no attribute 'copy'\")", "parent_id": "f3965c56-d34c-47bc-8b86-dc701c3caaf2", "metadata": {}, "mutation_prompt": null}
{"id": "eaf6fea5-e772-4d74-ac0c-847cd157c369", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.2:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, max(0.1, (self.best_fitness / 100)))  # Dynamic adjustment based on fitness\n        self.bandwidth *= np.random.uniform(0.85, 1.15 * improvement_rate)  # Broader dynamic scaling\n        diversity = np.std(self.harmony_memory, axis=0).mean()  # Calculate harmony diversity\n        self.PAR = min(1.0, max(0.1, 0.3 + diversity * np.random.uniform(0.01, 0.03)))  # Adaptive PAR based on diversity\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduce adaptive PAR adjustment based on harmony diversity to balance exploration and exploitation.", "configspace": "", "generation": 44, "fitness": 0.20795176893718134, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.208 with standard deviation 0.001. And the mean value of best solutions found was 0.403 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "f3965c56-d34c-47bc-8b86-dc701c3caaf2", "metadata": {"aucs": [0.20920796608705028, 0.20772198638029626, 0.20692535434419745], "final_y": [0.3922778954848859, 0.4053052685872647, 0.41264904139986625]}, "mutation_prompt": null}
{"id": "dd70bda8-61ee-443c-965e-3e67aa00d7c0", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.2:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, max(0.1, (self.best_fitness / 100)))  # Dynamic adjustment based on fitness\n        self.bandwidth *= np.random.uniform(0.85, 1.15 * improvement_rate)  # Broader dynamic scaling\n        self.PAR = min(1.0, max(0.1, self.PAR * (1.0 - 0.1 * improvement_rate)))  # Feedback-driven scaling\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduce feedback-driven pitch adjustment rate scaling based on recent iteration performance.", "configspace": "", "generation": 45, "fitness": 0.2114271925278353, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.211 with standard deviation 0.001. And the mean value of best solutions found was 0.374 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "f3965c56-d34c-47bc-8b86-dc701c3caaf2", "metadata": {"aucs": [0.2112272417102452, 0.21086215033192668, 0.212192185541334], "final_y": [0.3749456555531716, 0.37834897223645025, 0.36735482558451726]}, "mutation_prompt": null}
{"id": "37e49e66-bf9e-4500-b391-8d7a42043bc4", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.2:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, max(0.1, (self.best_fitness / 100)))  # Dynamic adjustment based on fitness\n        self.bandwidth *= np.random.uniform(0.85, 1.15 * improvement_rate)  # Broader dynamic scaling\n        self.HMCR = max(0.7, min(0.95, self.HMCR + np.random.uniform(-0.05, 0.05)))  # Stochastically adapt HMCR\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.02, 0.04))  # Enhanced adjustment\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduce stochastic adaptation of HMCR to improve exploration and exploitation balance dynamically.", "configspace": "", "generation": 46, "fitness": 0.20904226207637563, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.209 with standard deviation 0.004. And the mean value of best solutions found was 0.396 (0. is the best) with standard deviation 0.036.", "error": "", "parent_id": "f3965c56-d34c-47bc-8b86-dc701c3caaf2", "metadata": {"aucs": [0.20465921069312676, 0.20766925297221595, 0.21479832256378417], "final_y": [0.43408160287743347, 0.40588608595324727, 0.34673259827550873]}, "mutation_prompt": null}
{"id": "59fa32a1-baca-4ce8-b029-164e526ef86f", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.2:\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                choice = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    choice += np.random.normal(0, self.bandwidth)\n                new_harmony[i] = choice + 0.1 * (self.best_solution[i] - choice)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, max(0.1, (self.best_fitness / 100)))\n        self.bandwidth *= np.random.uniform(0.85, 1.15 * improvement_rate)\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.02, 0.04))\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Adjust harmony generation to include directed mutation based on past best to improve convergence.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'NoneType' object is not subscriptable\").", "error": "TypeError(\"'NoneType' object is not subscriptable\")", "parent_id": "f3965c56-d34c-47bc-8b86-dc701c3caaf2", "metadata": {}, "mutation_prompt": null}
{"id": "24f5a131-7ecb-4767-9465-c912ef32a38e", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.1  # Changed Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.2:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, max(0.1, (self.best_fitness / 100)))  # Dynamic adjustment based on fitness\n        self.bandwidth *= np.random.uniform(0.85, 1.15 * improvement_rate)  # Broader dynamic scaling\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.02, 0.04))  # Enhanced adjustment\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhance exploration by adjusting the initial bandwidth to improve search space coverage.", "configspace": "", "generation": 48, "fitness": 0.21796606240604913, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.218 with standard deviation 0.002. And the mean value of best solutions found was 0.323 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "f3965c56-d34c-47bc-8b86-dc701c3caaf2", "metadata": {"aucs": [0.2198267031275296, 0.21856009653350483, 0.21551138755711297], "final_y": [0.30935660020396405, 0.31912034783297727, 0.3410607631986782]}, "mutation_prompt": null}
{"id": "e37fa80d-c9e2-47c4-9b56-5897e6c66589", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.2:\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n            if np.random.rand() < 0.1:  # Introduce reshuffling based on fitness\n                self.harmony_memory = self.harmony_memory[np.argsort([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])]\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  \n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, max(0.1, (self.best_fitness / 100)))\n        self.bandwidth *= np.random.uniform(0.85, 1.15 * improvement_rate)\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.02, 0.04))\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduce a fitness-based adaptive memory reshuffling to enhance exploration and exploitation balance.", "configspace": "", "generation": 49, "fitness": 0.20933734173586357, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.209 with standard deviation 0.003. And the mean value of best solutions found was 0.392 (0. is the best) with standard deviation 0.029.", "error": "", "parent_id": "f3965c56-d34c-47bc-8b86-dc701c3caaf2", "metadata": {"aucs": [0.20957857412184078, 0.21335561089910815, 0.20507784018664177], "final_y": [0.3891330252620484, 0.3581820571032689, 0.4297551428420341]}, "mutation_prompt": null}
{"id": "ee978baa-4814-4ed9-be6a-d3ebc48b97e8", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.2:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = self.harmony_memory[np.random.randint(self.num_harmonies), i]\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, max(0.1, (self.best_fitness / 100)))  # Dynamic adjustment based on fitness\n        self.bandwidth *= np.random.uniform(0.85, 1.15 * improvement_rate)  # Broader dynamic scaling\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.02, 0.06))  # Adjusted range for self-adaptation\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.1))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduce a self-adaptive pitch adjustment rate to enhance the exploration-exploitation balance.", "configspace": "", "generation": 50, "fitness": 0.2097311944751544, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.210 with standard deviation 0.005. And the mean value of best solutions found was 0.389 (0. is the best) with standard deviation 0.040.", "error": "", "parent_id": "f3965c56-d34c-47bc-8b86-dc701c3caaf2", "metadata": {"aucs": [0.20449209633421894, 0.21586667123705205, 0.20883481585419217], "final_y": [0.43552350672936857, 0.33783413618003943, 0.3947209710001912]}, "mutation_prompt": null}
{"id": "d83aa69c-0811-4b87-9f19-3b2bf2008246", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.3:  # Slightly increased acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = np.mean(self.harmony_memory[:, i])  # Mean diversity introduction\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, abs(self.best_fitness / 100))  # Absolute dynamic adjustment\n        self.bandwidth *= np.random.uniform(0.8, 1.2 * improvement_rate)  # Stochastic bandwidth adjustment\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.03, 0.05))  # Adjust pitch rate slightly\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.95, 1.05))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduce adaptive harmony diversity and stochastic bandwidth adjustment to enhance exploration and convergence stability.", "configspace": "", "generation": 51, "fitness": 0.2317031429830493, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.232 with standard deviation 0.006. And the mean value of best solutions found was 0.241 (0. is the best) with standard deviation 0.032.", "error": "", "parent_id": "f3965c56-d34c-47bc-8b86-dc701c3caaf2", "metadata": {"aucs": [0.22446849421673765, 0.23946535276210357, 0.23117558197030674], "final_y": [0.2800591591521844, 0.20092615819775383, 0.2415601936899303]}, "mutation_prompt": null}
{"id": "77c4a7ff-1610-46da-8162-a84f91c942cd", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.95  # Harmony Memory Consideration Rate (slightly increased)\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.3:  # Slightly increased acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = np.mean(self.harmony_memory[:, i])  # Mean diversity introduction\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth * (i/self.dim))  # Nonlinear pitch adjustment\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, abs(self.best_fitness / 100))  # Absolute dynamic adjustment\n        self.bandwidth *= np.random.uniform(0.8, 1.2 * improvement_rate)  # Stochastic bandwidth adjustment\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.03, 0.05))  # Adjust pitch rate slightly\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.95, 1.05))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhance harmony memory consideration and introduce nonlinear pitch adjustment for improved performance.", "configspace": "", "generation": 52, "fitness": 0.2305517021693496, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.231 with standard deviation 0.005. And the mean value of best solutions found was 0.246 (0. is the best) with standard deviation 0.027.", "error": "", "parent_id": "d83aa69c-0811-4b87-9f19-3b2bf2008246", "metadata": {"aucs": [0.22410867353471509, 0.23614856863754663, 0.23139786433578702], "final_y": [0.2822947875220506, 0.21632484977755306, 0.24037500321143246]}, "mutation_prompt": null}
{"id": "cfe4cc20-fb8d-498d-b4ae-92929642e60c", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.3:\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        diversity = np.std(self.harmony_memory, axis=0)  # Calculate diversity\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR * (1 + diversity[i]):  # Dynamic PAR adjustment\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, abs(self.best_fitness / 100))\n        self.bandwidth *= np.random.uniform(0.8, 1.2 * improvement_rate)\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.03, 0.05))\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.95, 1.05))))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhance exploration by introducing a dynamic PAR and bandwidth update mechanism based on harmony diversity.", "configspace": "", "generation": 53, "fitness": 0.23105739718240104, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.231 with standard deviation 0.002. And the mean value of best solutions found was 0.242 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "d83aa69c-0811-4b87-9f19-3b2bf2008246", "metadata": {"aucs": [0.22851087396254766, 0.2338684669108666, 0.23079285067378885], "final_y": [0.2560700045746488, 0.22754984937747225, 0.24361406712875566]}, "mutation_prompt": null}
{"id": "67f9210e-c6ab-4a65-8c1a-153a66526fe9", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.85  # Slightly decreased to enhance exploration\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.3:  # Slightly increased acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = np.mean(self.harmony_memory[:, i])  # Mean diversity introduction\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, abs(self.best_fitness / 100))  # Absolute dynamic adjustment\n        self.bandwidth *= np.random.uniform(0.8, 1.2 * improvement_rate)  # Stochastic bandwidth adjustment\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.03, 0.05))  # Adjust pitch rate slightly\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.95, 1.05))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Improve exploration by slightly enhancing random harmony selection probability.", "configspace": "", "generation": 54, "fitness": 0.2265289662264179, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.227 with standard deviation 0.004. And the mean value of best solutions found was 0.269 (0. is the best) with standard deviation 0.025.", "error": "", "parent_id": "d83aa69c-0811-4b87-9f19-3b2bf2008246", "metadata": {"aucs": [0.22374915750337887, 0.23268477280984756, 0.22315296836602727], "final_y": [0.28451343509130855, 0.23351814806450422, 0.2884544300827868]}, "mutation_prompt": null}
{"id": "faf06a38-5713-4ea6-bb81-f5863dd40afe", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.25:  # Reduced acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = np.mean(self.harmony_memory[:, i])  # Mean diversity introduction\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, abs(self.best_fitness / 100))  # Absolute dynamic adjustment\n        self.bandwidth *= np.random.uniform(0.9, 1.1 * improvement_rate)  # Slightly narrower stochastic adjustment\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.03, 0.05))  # Adjust pitch rate slightly\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.95, 1.05))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Improve exploration and convergence by refining parameter adjustment and harmony selection criteria.", "configspace": "", "generation": 55, "fitness": 0.23104200550281198, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.231 with standard deviation 0.002. And the mean value of best solutions found was 0.242 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "d83aa69c-0811-4b87-9f19-3b2bf2008246", "metadata": {"aucs": [0.22909764598867244, 0.2328526594652799, 0.23117571105448365], "final_y": [0.2527424127807426, 0.23262757733672612, 0.24155950521925806]}, "mutation_prompt": null}
{"id": "795af075-c462-41ec-9977-f4cdfde13266", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.25:  # Adjusted acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            self.harmony_memory[worst_idx] = new_harmony  # Direct replacement without extra check\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = np.mean(self.harmony_memory[:, i])  # Mean diversity introduction\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, abs(self.best_fitness / 100))  # Absolute dynamic adjustment\n        self.bandwidth *= np.random.uniform(0.8, 1.2 * improvement_rate)  # Stochastic bandwidth adjustment\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.03, 0.05))  # Adjust pitch rate slightly\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.95, 1.05))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduce an adaptive memory update strategy with a better replacement criterion for increased solution quality.", "configspace": "", "generation": 56, "fitness": 0.2310419593904307, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.231 with standard deviation 0.002. And the mean value of best solutions found was 0.242 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "d83aa69c-0811-4b87-9f19-3b2bf2008246", "metadata": {"aucs": [0.22909763596004373, 0.23285266024094164, 0.23117558197030674], "final_y": [0.2527424716835277, 0.2326275735256872, 0.2415601936899303]}, "mutation_prompt": null}
{"id": "fc92d2c1-6a8b-493a-95d9-7bb3bb5203ae", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.3:  # Slightly increased acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = np.mean(self.harmony_memory[:, i]) + np.random.normal(0, 0.1)  # Directional biasing\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, abs(self.best_fitness / 100))  # Absolute dynamic adjustment\n        self.bandwidth *= np.random.uniform(0.8, 1.2 * improvement_rate)  # Stochastic bandwidth adjustment\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.03, 0.05))  # Adjust pitch rate slightly\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.9, 1.05))))  # Dynamic adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduce dynamic harmony memory size and directional biasing to improve convergence rate.", "configspace": "", "generation": 57, "fitness": 0.22894769307467464, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.229 with standard deviation 0.003. And the mean value of best solutions found was 0.254 (0. is the best) with standard deviation 0.019.", "error": "", "parent_id": "d83aa69c-0811-4b87-9f19-3b2bf2008246", "metadata": {"aucs": [0.22435684716448334, 0.2315171905144462, 0.23096904154509434], "final_y": [0.2806773627661422, 0.2396650359718343, 0.24266638652541384]}, "mutation_prompt": null}
{"id": "ce8a5e90-e110-4a27-9895-bc492cf76ee9", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.3:  # Slightly increased acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            self.harmony_memory[worst_idx] = new_harmony if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]) else self.harmony_memory[worst_idx]\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, abs(self.best_fitness / 100))\n        self.bandwidth *= np.random.uniform(0.8, 1.2 * improvement_rate)\n        self.PAR = min(1.0, self.PAR + np.random.uniform(0.03, 0.05))  \n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.95, 1.05))))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            if evaluations % 10 == 0:  # New line for periodic parameter adjustment\n                self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhance exploration and exploitation with dynamic parameter tuning and memory update integration.", "configspace": "", "generation": 58, "fitness": 0.2286022642215805, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.229 with standard deviation 0.007. And the mean value of best solutions found was 0.258 (0. is the best) with standard deviation 0.039.", "error": "", "parent_id": "d83aa69c-0811-4b87-9f19-3b2bf2008246", "metadata": {"aucs": [0.21972387457382125, 0.23572749828803252, 0.23035541980288776], "final_y": [0.31109840727791116, 0.21833935574548613, 0.24598312029736158]}, "mutation_prompt": null}
{"id": "b6ff9e9d-55dc-429e-b2bb-fc8fa509670c", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.05  # Initial Bandwidth\n        self.num_harmonies = 10  # Number of harmonies in the memory\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()  # Ensure copy of the array is stored\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        if new_fitness < self.best_fitness or np.random.rand() < 0.15:  # Reduced acceptance probability\n            worst_idx = np.argmax([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n            if new_fitness < self.evaluate(lambda x: np.sum(x), self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                new_harmony[i] = np.mean(self.harmony_memory[:, i])  # Mean diversity introduction\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)  # Adjusted from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        improvement_rate = min(1.0, abs(self.best_fitness / 100))  # Absolute dynamic adjustment\n        self.bandwidth *= np.random.uniform(0.8, 1.2 * improvement_rate)  # Stochastic bandwidth adjustment\n        self.PAR = min(1.0, self.PAR + np.random.uniform(-0.02, 0.03))  # Dynamic adjustment with negative drift\n        self.num_harmonies = max(5, min(15, int(self.num_harmonies * np.random.uniform(0.95, 1.05))))  # Tighter adjustment\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduce dynamic PAR adjustment and stricter new harmony acceptance to enhance solution precision and convergence.", "configspace": "", "generation": 59, "fitness": 0.23276556914848825, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.233 with standard deviation 0.005. And the mean value of best solutions found was 0.235 (0. is the best) with standard deviation 0.027.", "error": "", "parent_id": "d83aa69c-0811-4b87-9f19-3b2bf2008246", "metadata": {"aucs": [0.22606254355648803, 0.238848640023119, 0.23338552386585776], "final_y": [0.270122969647133, 0.20367899000762735, 0.22998550326314393]}, "mutation_prompt": null}
{"id": "f243dcd3-93b3-45ed-a7f2-139e093c002d", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2  # New: Elite rate for elite selection\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])  # Track fitness\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:  # Use elite harmonies\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.8, 1.2)\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))  # Adaptive HMCR\n        self.PAR = min(1.0, self.PAR + np.random.uniform(-0.02, 0.03))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Refine AdaptiveHarmonySearch by incorporating elite selection and adaptive HMCR to enhance convergence and precision.", "configspace": "", "generation": 60, "fitness": 0.2450292837838054, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.001. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b6ff9e9d-55dc-429e-b2bb-fc8fa509670c", "metadata": {"aucs": [0.2442431087983108, 0.24516470157408055, 0.24568004097902485], "final_y": [0.1673490517389944, 0.16660938832697358, 0.1675267266142385]}, "mutation_prompt": null}
{"id": "b43e8f71-34d7-4b02-a770-4b9401a76c99", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.base_num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.diversity_threshold = 0.1  # New: Diversity threshold for adaptation\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.base_num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n        self.adjust_memory_size()  # New: Adjust memory size based on diversity\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.base_num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.8, 1.2)\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, self.PAR + np.random.uniform(-0.02, 0.03))\n\n    def adjust_memory_size(self):  # New: Dynamic harmony memory size adjustment\n        diversity = np.std(self.harmony_memory)\n        if diversity < self.diversity_threshold:\n            self.base_num_harmonies = max(5, self.base_num_harmonies - 1)\n        else:\n            self.base_num_harmonies += 1\n        new_capacity = max(5, self.base_num_harmonies)\n        if new_capacity != len(self.harmony_memory):\n            self.harmony_memory = np.resize(self.harmony_memory, (new_capacity, self.dim))\n            self.harmony_fitness = np.resize(self.harmony_fitness, new_capacity)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhance AdaptiveHarmonySearch by embedding dynamic harmony memory size and diversity preservation to boost exploration-exploitation balance.", "configspace": "", "generation": 61, "fitness": 0.23552458367385323, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.236 with standard deviation 0.004. And the mean value of best solutions found was 0.215 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "f243dcd3-93b3-45ed-a7f2-139e093c002d", "metadata": {"aucs": [0.23134344596940704, 0.23418806474987963, 0.24104224030227306], "final_y": [0.22676315457039586, 0.22516203514359867, 0.1923092232760487]}, "mutation_prompt": null}
{"id": "509697f1-9ffa-4c00-a0cf-9d9a6aab9855", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2  # New: Elite rate for elite selection\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])  # Track fitness\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:  # Use elite harmonies\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.8, 1.2)\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))  # Adaptive HMCR\n        self.PAR = min(1.0, self.PAR + np.random.uniform(-0.02, 0.03))\n        self.elite_rate = max(0.1, min(0.5, self.elite_rate + np.random.uniform(-0.01, 0.01)))  # New: Adaptive elite rate\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Improve AdaptiveHarmonySearch by dynamically adjusting the elite rate for better exploration-exploitation balance.", "configspace": "", "generation": 62, "fitness": 0.24517954630481395, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.001. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f243dcd3-93b3-45ed-a7f2-139e093c002d", "metadata": {"aucs": [0.24366978007804185, 0.24592019337086435, 0.24594866546553562], "final_y": [0.1665732339544791, 0.1669221899374509, 0.16676633338277214]}, "mutation_prompt": null}
{"id": "0703b1b0-4c3b-4076-bd0d-b7f9de68fb52", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2  # New: Elite rate for elite selection\n        self.last_improvement = 0  # New: Track last fitness improvement\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])  # Track fitness\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0  # New: Reset improvement counter\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1  # New: Increment if no improvement\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:  # Use elite harmonies\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.random.uniform(0.8, 1.2)\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))  # Adaptive HMCR\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))  # New: Dynamic PAR adjustment\n        self.elite_rate = max(0.1, min(0.5, self.elite_rate + np.random.uniform(-0.01, 0.01)))  # New: Adaptive elite rate\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhance AdaptiveHarmonySearch by introducing a dynamic PAR adjustment based on fitness improvement trends.", "configspace": "", "generation": 63, "fitness": 0.24638434006453244, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "509697f1-9ffa-4c00-a0cf-9d9a6aab9855", "metadata": {"aucs": [0.24708223700188436, 0.24673210567310655, 0.24533867751860639], "final_y": [0.16632775982051995, 0.1654380255434572, 0.16665481982386077]}, "mutation_prompt": null}
{"id": "dca2d550-d619-4c52-8a32-aab71d4e497a", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2  # New: Elite rate for elite selection\n        self.last_improvement = 0  # New: Track last fitness improvement\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])  # Track fitness\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0  # New: Reset improvement counter\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1  # New: Increment if no improvement\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:  # Use elite harmonies\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.02, 0.02))  # Nonlinear decay for bandwidth\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))  # Adaptive HMCR\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))  # New: Dynamic PAR adjustment\n        self.elite_rate = max(0.1, min(0.5, self.elite_rate + np.random.uniform(-0.01, 0.01)))  # New: Adaptive elite rate\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony(bounds)\n            new_fitness = self.evaluate(func, new_harmony)\n            self.update_harmony_memory(new_harmony, new_fitness)\n            self.adjust_parameters()\n            evaluations += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduce a nonlinear decay for bandwidth adjustment to enhance convergence precision.", "configspace": "", "generation": 64, "fitness": 0.24639070054514414, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0703b1b0-4c3b-4076-bd0d-b7f9de68fb52", "metadata": {"aucs": [0.24711904933603668, 0.24674725122161978, 0.245305801077776], "final_y": [0.16616982161991134, 0.16574997923792723, 0.1658448447234716]}, "mutation_prompt": null}
{"id": "9a36c9ec-f358-431f-94db-c215d9179bb5", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2  # New: Number of populations\n        self.mutation_factor = 0.1  # New: Mutation factor\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:  # New: Mutation step\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.02, 0.02))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.1, min(0.5, self.elite_rate + np.random.uniform(-0.01, 0.01)))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):  # New: Multiple populations\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Integrate dynamic multi-population strategy and adaptive mutation to balance exploration and exploitation.", "configspace": "", "generation": 65, "fitness": 0.24639572879567662, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "dca2d550-d619-4c52-8a32-aab71d4e497a", "metadata": {"aucs": [0.24621936452814808, 0.24618407150991983, 0.24678375034896194], "final_y": [0.16691987679370435, 0.16619138118923116, 0.1654318581288554]}, "mutation_prompt": null}
{"id": "2e5298ee-c1f3-41de-8d94-cf532846d174", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.2  # Changed: Initial mutation factor\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.02, 0.02))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.1, min(0.5, self.elite_rate + np.random.uniform(-0.01, 0.01)))\n        self.mutation_factor *= 0.98  # New: Decrease mutation factor\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduce an adaptive mutation factor that decreases over time to enhance convergence in later stages.", "configspace": "", "generation": 66, "fitness": 0.2459368930774235, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "9a36c9ec-f358-431f-94db-c215d9179bb5", "metadata": {"aucs": [0.24506144474819758, 0.2460976931325748, 0.24665154135149814], "final_y": [0.16523446315320278, 0.1663864312504305, 0.1648660261416971]}, "mutation_prompt": null}
{"id": "d1f1a18e-ca2f-4c9f-8a8b-bb8747632a0a", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth * 2, self.dim)  # Modified: Enhanced mutation\n        if np.random.rand() < 0.3:  # New: Elite crossover\n            partner = elite_harmonies[np.random.randint(len(elite_harmonies))]\n            crossover_point = np.random.randint(self.dim)\n            new_harmony[:crossover_point] = partner[:crossover_point]\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.02, 0.02))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.1, min(0.5, self.elite_rate + np.random.uniform(-0.01, 0.01)))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Integrate dynamic multi-population strategy, enhanced adaptive mutation, and elite crossover to balance exploration and exploitation.", "configspace": "", "generation": 67, "fitness": 0.24586685751585666, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9a36c9ec-f358-431f-94db-c215d9179bb5", "metadata": {"aucs": [0.24515839689040742, 0.24718277342680461, 0.24525940223035791], "final_y": [0.16597840730967262, 0.1659846741763804, 0.16526169940496616]}, "mutation_prompt": null}
{"id": "0c324fa3-53f7-43a8-b98d-0c11efab4194", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2  # New: Number of populations\n        self.mutation_factor = 0.1  # New: Mutation factor\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:  # New: Mutation step\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.02, 0.02))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.1, min(0.5, self.elite_rate + np.random.uniform(-0.01, 0.01)))\n        self.num_harmonies = max(5, int(self.num_harmonies * (1 + 0.01 * self.last_improvement)))  # Change\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):  # New: Multiple populations\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhance exploration by dynamically updating the number of harmonies based on improvement rate.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: OverflowError('cannot convert float infinity to integer').", "error": "OverflowError('cannot convert float infinity to integer')", "parent_id": "9a36c9ec-f358-431f-94db-c215d9179bb5", "metadata": {}, "mutation_prompt": null}
{"id": "0b56afeb-b8cb-40b9-89df-b2ee01644245", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.02, 0.02))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.1, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))  # Modified\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))  # Modified\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhance exploration by introducing adaptive elite rate and dynamic mutation factor.", "configspace": "", "generation": 69, "fitness": 0.2471934639044845, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9a36c9ec-f358-431f-94db-c215d9179bb5", "metadata": {"aucs": [0.24611916434758496, 0.24753819369021168, 0.24792303367565682], "final_y": [0.16526278103044012, 0.1656067641345914, 0.16485590091043367]}, "mutation_prompt": null}
{"id": "a2be6434-345b-4067-a864-8cf975f670e8", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i] + np.random.normal(0, self.bandwidth)  # Modified\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.02, 0.02))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.1, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Adaptive Harmony Search with refined exploration through elite harmony diversification.", "configspace": "", "generation": 70, "fitness": 0.24580450040670662, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "0b56afeb-b8cb-40b9-89df-b2ee01644245", "metadata": {"aucs": [0.24571389109818176, 0.24637527661058234, 0.24532433351135574], "final_y": [0.16668343898270344, 0.16500612088242594, 0.16598857253683397]}, "mutation_prompt": null}
{"id": "eed5a67b-1314-4904-a671-738f17e3df47", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.02, 0.02))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.1, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))\n        self.populations = min(5, max(1, self.populations + np.random.choice([-1, 1])))  # Modified\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Improve convergence by dynamically adjusting population and mutation factor.", "configspace": "", "generation": 71, "fitness": 0.246258474561699, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "0b56afeb-b8cb-40b9-89df-b2ee01644245", "metadata": {"aucs": [0.245414658701536, 0.2466195932054246, 0.24674117177813637], "final_y": [0.16601779805843286, 0.1658336279603977, 0.16485596911162448]}, "mutation_prompt": null}
{"id": "77fb7c25-5773-4702-a523-a689ae31c8ff", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness) \n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.6:  # Changed\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= (1 + self.last_improvement / 100)  # Changed\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.1, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))  # Modified\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))  # Modified\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduce adaptive bandwidth scaling and elite harmony influence for improved exploitation.", "configspace": "", "generation": 72, "fitness": 0.2439349905711887, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.001. And the mean value of best solutions found was 0.175 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "0b56afeb-b8cb-40b9-89df-b2ee01644245", "metadata": {"aucs": [0.2427366957732171, 0.24525647351917268, 0.24381180242117628], "final_y": [0.1820224250602338, 0.1722479264501674, 0.17191320082113337]}, "mutation_prompt": null}
{"id": "566a23dc-a065-4ffe-af47-a24c6b3133fe", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor * min(1.0, self.last_improvement / 10.0):  # Modified\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)  # Modified\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.02, 0.02))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.1, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduce a dynamic mutation strategy based on improvement stagnation to enhance diversity.", "configspace": "", "generation": 73, "fitness": 0.2468551665200667, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "0b56afeb-b8cb-40b9-89df-b2ee01644245", "metadata": {"aucs": [0.2462322167798251, 0.24807338741069163, 0.2462598953696834], "final_y": [0.16561066172753725, 0.16485634029198637, 0.16683328021606236]}, "mutation_prompt": null}
{"id": "dcca65c3-657a-4cfc-88cc-5509487bbb6d", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.02, 0.02))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.1, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))\n        self.mutation_factor *= np.exp(-0.1 if self.last_improvement > 5 else 0.1)  # Modified\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Refine exploration and convergence through adaptive mutation factor adjustment based on performance trend.", "configspace": "", "generation": 74, "fitness": 0.24594224595005998, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.000. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "0b56afeb-b8cb-40b9-89df-b2ee01644245", "metadata": {"aucs": [0.24638571747725357, 0.24586648230088282, 0.24557453807204355], "final_y": [0.16622563457343786, 0.16819577489695026, 0.16675676174934273]}, "mutation_prompt": null}
{"id": "268832a0-ea2d-4813-b038-2c38e10183dd", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.02, 0.02))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.1, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))\n        self.bandwidth *= 1 + 0.1 * np.tanh(self.last_improvement / 10.0)  # Modified\n        self.populations = max(1, int(2 + 5 * (1 - self.best_fitness)))  # Modified\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Improve balance between exploration and exploitation using dynamic population size and adaptive bandwidth scaling.", "configspace": "", "generation": 75, "fitness": 0.24527065935173994, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.003. And the mean value of best solutions found was 0.174 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "0b56afeb-b8cb-40b9-89df-b2ee01644245", "metadata": {"aucs": [0.2416800931287908, 0.2468870480654728, 0.24724483686095622], "final_y": [0.18555736001790601, 0.16799933888103102, 0.1675423383558594]}, "mutation_prompt": null}
{"id": "0cf4e182-73f3-4d51-b225-37b705248dd7", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(np.random.choice, h) for h in self.harmony_memory])  # Modified\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.median(self.harmony_memory[:, i])  # Modified\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.02, 0.02))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.1, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))  # Modified\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))  # Modified\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhance exploration by introducing adaptive elite rate and dynamic mutation factor with improved initialization and selection.", "configspace": "", "generation": 76, "fitness": 0.24630350087747968, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0b56afeb-b8cb-40b9-89df-b2ee01644245", "metadata": {"aucs": [0.24472793318671204, 0.24650468487501764, 0.24767788457070938], "final_y": [0.16623660078247904, 0.166199297957063, 0.16537263232582433]}, "mutation_prompt": null}
{"id": "fa4eba86-bdee-474b-bf43-59af6aff4ef6", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(np.clip(self.elite_rate * self.num_harmonies, 1, self.num_harmonies))]  # Modified\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.02, 0.02))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.1, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))  # Modified\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1)) \n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Improve exploration by dynamically adjusting the number of elite harmonies based on performance.", "configspace": "", "generation": 77, "fitness": 0.2471934639044845, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0b56afeb-b8cb-40b9-89df-b2ee01644245", "metadata": {"aucs": [0.24611916434758496, 0.24753819369021168, 0.24792303367565682], "final_y": [0.16526278103044012, 0.1656067641345914, 0.16485590091043367]}, "mutation_prompt": null}
{"id": "0f38c829-8c7e-46f9-9a50-8984f28beb1c", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.02, 0.02))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.1, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))  \n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))  \n        self.populations = 2 + self.last_improvement // 10  # Modified\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduce dynamic population size based on the last improvement to balance exploration and exploitation.", "configspace": "", "generation": 78, "fitness": 0.24716840989002212, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0b56afeb-b8cb-40b9-89df-b2ee01644245", "metadata": {"aucs": [0.24611916434758496, 0.24753819369021168, 0.24784787163226973], "final_y": [0.16526278103044012, 0.1656067641345914, 0.16485590091043367]}, "mutation_prompt": null}
{"id": "c14867b5-2bbc-474d-98ac-9ebf0aebe973", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.02, 0.02))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.1, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1)) * abs(np.sin(self.last_improvement)) # Modified\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhance exploration by incorporating dynamic scaling of the mutation factor based on a sine function.", "configspace": "", "generation": 79, "fitness": 0.2448293443550411, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.003. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "0b56afeb-b8cb-40b9-89df-b2ee01644245", "metadata": {"aucs": [0.2461571093821181, 0.24790418339189224, 0.240426740291113], "final_y": [0.16520034629030933, 0.16547854652371585, 0.16707357668120348]}, "mutation_prompt": null}
{"id": "d87fa908-04df-4e2e-99ac-a8a347b9b5c3", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.02, 0.02))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.1, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))\n        self.mutation_factor *= np.exp(np.random.uniform(-0.05, 0.05))  # Modified\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhance exploration and convergence by fine-tuning the mutation factor scaling range.", "configspace": "", "generation": 80, "fitness": 0.24660015782019773, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0b56afeb-b8cb-40b9-89df-b2ee01644245", "metadata": {"aucs": [0.24550201604558852, 0.24745702171885053, 0.24684143569615413], "final_y": [0.16578443777380847, 0.16543276911591465, 0.16485803052684667]}, "mutation_prompt": null}
{"id": "adbde3de-53c0-4325-861d-3fc4e1b01893", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.02, 0.02))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.1, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))\n        if self.last_improvement > 20:  # New: Reset harmony memory if stagnation detected\n            self.initialize_harmony_memory(self.bounds)\n\n    def __call__(self, func):\n        self.bounds = func.bounds  # New: Store bounds for use in adjust_parameters\n        self.initialize_harmony_memory(self.bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(self.bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhance exploration by introducing adaptive elite rate, dynamic mutation factor, and restarting stagnated harmony memory.", "configspace": "", "generation": 81, "fitness": 0.24351332252950933, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.001. And the mean value of best solutions found was 0.182 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "0b56afeb-b8cb-40b9-89df-b2ee01644245", "metadata": {"aucs": [0.24403963452390365, 0.24168483357314208, 0.2448154994914823], "final_y": [0.1806788738663615, 0.19141369120248108, 0.17312328889720485]}, "mutation_prompt": null}
{"id": "28fd32d9-7ca5-442c-811d-9b8d911941fa", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.02, 0.02))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.1, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))\n        self.populations = max(1, int(self.budget / (self.last_improvement + 1)))  # Modified\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduce an adaptive population size based on current convergence behavior to enhance exploration and exploitation balance.", "configspace": "", "generation": 82, "fitness": 0.22263712921131676, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.223 with standard deviation 0.023. And the mean value of best solutions found was 0.331 (0. is the best) with standard deviation 0.171.", "error": "", "parent_id": "0b56afeb-b8cb-40b9-89df-b2ee01644245", "metadata": {"aucs": [0.19249170741224797, 0.2274966465460455, 0.24792303367565682], "final_y": [0.5671782237846645, 0.2615778814211954, 0.16485590091043367]}, "mutation_prompt": null}
{"id": "b1546b12-2804-41c1-a18e-46474db38313", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)\n            new_harmony += np.random.standard_cauchy(self.dim) * 0.01  # Added multi-mutation strategy\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.02, 0.02))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.1, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Improve local search by introducing a multi-mutation strategy for increased diversity.", "configspace": "", "generation": 83, "fitness": 0.24684681243380338, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0b56afeb-b8cb-40b9-89df-b2ee01644245", "metadata": {"aucs": [0.24666871219648256, 0.24781356286796086, 0.24605816223696675], "final_y": [0.16578281812286844, 0.16497812397733014, 0.16591891828138883]}, "mutation_prompt": null}
{"id": "15801541-d964-4095-9b78-4d0fee4210b3", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.05, 0.05))  # Modified\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.15, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))  # Modified\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))  # Modified\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhance optimization by refining parameter adjustment with adaptive bandwidth scaling and elite harmony selection tuning.", "configspace": "", "generation": 84, "fitness": 0.24725176299241494, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0b56afeb-b8cb-40b9-89df-b2ee01644245", "metadata": {"aucs": [0.24591819495523093, 0.2480433134023099, 0.24779378061970403], "final_y": [0.1648608845763212, 0.1648563871408344, 0.1648642643114273]}, "mutation_prompt": null}
{"id": "adee4ef2-2ee8-4750-840e-393a2255afbb", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.03, 0.03))  # Modified\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.15, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Slightly refine the balance between exploration and exploitation by carefully tuning the bandwidth scaling.", "configspace": "", "generation": 85, "fitness": 0.2472041685511542, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "15801541-d964-4095-9b78-4d0fee4210b3", "metadata": {"aucs": [0.24587146892293754, 0.2479777122294491, 0.24776332450107597], "final_y": [0.16485929763557883, 0.1648572418505614, 0.16485770099215324]}, "mutation_prompt": null}
{"id": "4121c79e-f6cb-45b7-9698-a9cc72fa639f", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.05, 0.05))  # Modified\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.15, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))  # Modified\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))  # Modified\n        self.populations = min(10, max(2, int(self.populations * np.exp(-0.01 * self.last_improvement))))  # Modified\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduced dynamic population size scaling based on performance to improve AdaptiveHarmonySearch's exploration and exploitation balance.", "configspace": "", "generation": 86, "fitness": 0.24725176299241494, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "15801541-d964-4095-9b78-4d0fee4210b3", "metadata": {"aucs": [0.24591819495523093, 0.2480433134023099, 0.24779378061970403], "final_y": [0.1648608845763212, 0.1648563871408344, 0.1648642643114273]}, "mutation_prompt": null}
{"id": "f7c3342a-005a-454b-bbf1-afd49a4a6f21", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        levy_flight = np.random.normal(0, self.bandwidth, self.dim) * np.power(np.random.standard_cauchy(), -1)  # Modified\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += levy_flight  # Modified\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.05, 0.05))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.15, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Improve solution generation by incorporating Levy flights for enhanced exploration and diversity.", "configspace": "", "generation": 87, "fitness": 0.24706502808549566, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "15801541-d964-4095-9b78-4d0fee4210b3", "metadata": {"aucs": [0.24698168820056698, 0.247241009085862, 0.24697238697005797], "final_y": [0.16492319451900772, 0.164855946881035, 0.1653816970434484]}, "mutation_prompt": null}
{"id": "ed0ee1ee-057a-4eac-ba60-875dd18ca699", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.05, 0.05))  # Modified\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.15, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))  # Modified\n        self.mutation_factor *= np.exp(np.random.uniform(-0.05, 0.05))  # Reduced decay rate\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhance optimization by reducing mutation factor decay to boost exploration in early iterations.", "configspace": "", "generation": 88, "fitness": 0.24630780498104657, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "15801541-d964-4095-9b78-4d0fee4210b3", "metadata": {"aucs": [0.24501787359424165, 0.24774768844624817, 0.2461578529026499], "final_y": [0.16574790982400434, 0.16488680755147733, 0.16597937978144828]}, "mutation_prompt": null}
{"id": "abc50abd-a352-4cbf-ab31-4961d12a9f53", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth * 1.5, self.dim)  # Modified\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.05, 0.05))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.15, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.2))  # Modified\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(int(self.populations * (1 + 0.1 * self.last_improvement))):  # Modified\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Improve global search efficiency by introducing dynamic population adjustment and enhanced mutation factor for diverse exploration.", "configspace": "", "generation": 89, "fitness": 0.24616606352963932, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "15801541-d964-4095-9b78-4d0fee4210b3", "metadata": {"aucs": [0.24479428819851756, 0.24785719901714853, 0.24584670337325187], "final_y": [0.16593369425380655, 0.164856076067177, 0.1648571706569596]}, "mutation_prompt": null}
{"id": "d5419d5c-cc7d-4474-9e66-8608c87992dc", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth * (1 + np.log1p(self.last_improvement)), self.dim)  # Modified\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.05, 0.05))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.15, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Improve Adaptive Harmony Search by introducing a dynamic mutation factor based on convergence rate for enhanced exploration.", "configspace": "", "generation": 90, "fitness": 0.2473218377545301, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "15801541-d964-4095-9b78-4d0fee4210b3", "metadata": {"aucs": [0.24601464774269632, 0.24811410791708044, 0.24783675760381352], "final_y": [0.1649967262269828, 0.16486007078019127, 0.16486057042023605]}, "mutation_prompt": null}
{"id": "ed168587-631d-4847-835d-87a45d8ac3bf", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n        self.learning_rate = 0.01  # Added\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth * (1 + np.log1p(self.last_improvement)), self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.05, 0.05))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.15, min(0.5, self.elite_rate + self.learning_rate * (0.5 - self.PAR)))  # Modified\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))\n        self.learning_rate = 0.01 + 0.01 * (self.best_fitness / (1 + self.last_improvement))  # Modified\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhance Adaptive Harmony Search by incorporating a dynamic learning rate and adaptive elitism based on convergence trends for improved exploration and exploitation balance.", "configspace": "", "generation": 91, "fitness": 0.24552406762332316, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "d5419d5c-cc7d-4474-9e66-8608c87992dc", "metadata": {"aucs": [0.24628436921597863, 0.2450809134202231, 0.24520692023376778], "final_y": [0.16487735254660796, 0.16684454089986733, 0.1666504887155148]}, "mutation_prompt": null}
{"id": "3c8e45fa-9225-4f71-903c-ba98a8757bf1", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth * (1 + np.log1p(self.last_improvement) / 2), self.dim)  # Modified\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.05, 0.05))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.15, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhance Adaptive Harmony Search by tweaking the mutation factor adjustment for better convergence.", "configspace": "", "generation": 92, "fitness": 0.24731823115294563, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d5419d5c-cc7d-4474-9e66-8608c87992dc", "metadata": {"aucs": [0.24603348648447498, 0.24808832826980676, 0.24783287870455517], "final_y": [0.16500641281716832, 0.16485960523984888, 0.16486987347437576]}, "mutation_prompt": null}
{"id": "8f62d806-287f-47a4-954d-7a3f77ae1cc0", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth * (1 + np.log1p(self.last_improvement)), self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.05, 0.05))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.15, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))\n        if self.last_improvement >= 20:  # Added line\n            self.populations = min(self.populations + 1, 10)  # Added line\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduced a dynamic population increase mechanism based on stagnation to boost diversity and improve convergence.", "configspace": "", "generation": 93, "fitness": 0.24727172840014067, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d5419d5c-cc7d-4474-9e66-8608c87992dc", "metadata": {"aucs": [0.24593948183731995, 0.24803894575928853, 0.24783675760381352], "final_y": [0.1649967262269828, 0.16486007078019127, 0.16486057042023605]}, "mutation_prompt": null}
{"id": "926c4833-4cf9-49ce-91fa-6d0eb59a3344", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth * np.random.rand())  # Modified\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth * (1 + np.log1p(self.last_improvement)), self.dim)  \n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.05, 0.05))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.15, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Improve exploration by introducing adaptive bandwidth and dynamic harmony memory consideration.", "configspace": "", "generation": 94, "fitness": 0.246707208030879, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d5419d5c-cc7d-4474-9e66-8608c87992dc", "metadata": {"aucs": [0.2467352263008732, 0.2466887274534636, 0.24669767033830026], "final_y": [0.1651028465864237, 0.16487317741749896, 0.16485943889442123]}, "mutation_prompt": null}
{"id": "fcfa7bae-b73d-48d6-b2c5-e125bc9348d6", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth * (1 - np.tanh(self.last_improvement)), self.dim)  # Modified\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.05, 0.05))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.15, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduce adaptive mutation factor reduction for improved convergence in Adaptive Harmony Search.", "configspace": "", "generation": 95, "fitness": 0.24719704248974841, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d5419d5c-cc7d-4474-9e66-8608c87992dc", "metadata": {"aucs": [0.24587311043868465, 0.24794221032114205, 0.24777580670941857], "final_y": [0.16488293260150821, 0.16486042316466598, 0.16486378295040482]}, "mutation_prompt": null}
{"id": "1e08b7f4-2050-4080-b8d3-65f0f6569627", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth * (1 + np.log1p(self.last_improvement)**1.5), self.dim) # Modified\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.05, 0.05))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.15, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Enhance Adaptive Harmony Search by refining the mutation strategy for better convergence handling.", "configspace": "", "generation": 96, "fitness": 0.2473604487090875, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d5419d5c-cc7d-4474-9e66-8608c87992dc", "metadata": {"aucs": [0.24608196705605956, 0.24812092903803307, 0.24787845003316988], "final_y": [0.16503076699478314, 0.16486390032490983, 0.1648596409491725]}, "mutation_prompt": null}
{"id": "58ea2726-7c28-486b-b95e-f4d153c9736d", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        fitness_diff = np.mean(self.harmony_fitness) - self.best_fitness # Modified\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth * (1 + np.log1p(self.last_improvement)**1.5) * fitness_diff, self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.05, 0.05))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.15, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Further refine the mutation strategy by introducing a dynamic scaling factor based on the best and mean harmony fitness.", "configspace": "", "generation": 97, "fitness": 0.24736036415224547, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "1e08b7f4-2050-4080-b8d3-65f0f6569627", "metadata": {"aucs": [0.24637103757461942, 0.2479384086760994, 0.24777164620601755], "final_y": [0.16604020371495254, 0.1648584792408606, 0.16486946639796307]}, "mutation_prompt": null}
{"id": "0b7e765d-e790-41b7-a317-6d5e4741e522", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth * (1 + np.log1p(self.last_improvement)**1.5), self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.05, 0.05))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.15, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))\n        diversity = np.std(self.harmony_memory, axis=0).mean()  # Added\n        self.bandwidth *= (1 + 0.1 * diversity)  # Modified\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Improved Adaptive Harmony Search by incorporating dynamic bandwidth adjustment based on population diversity.", "configspace": "", "generation": 98, "fitness": 0.24528385973637956, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "1e08b7f4-2050-4080-b8d3-65f0f6569627", "metadata": {"aucs": [0.24252770475223284, 0.246277612776868, 0.24704626168003785], "final_y": [0.17835637311651564, 0.16701526144718504, 0.16726992091437864]}, "mutation_prompt": null}
{"id": "ed81e73c-4c0c-4a8e-a471-107b191d7f13", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMCR = 0.9\n        self.PAR = 0.3\n        self.bandwidth = 0.05\n        self.num_harmonies = 10\n        self.harmony_memory = None\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.2\n        self.last_improvement = 0\n        self.populations = 2\n        self.mutation_factor = 0.1\n\n    def initialize_harmony_memory(self, bounds):\n        self.harmony_memory = np.random.uniform(bounds.lb, bounds.ub, (self.num_harmonies, self.dim))\n        self.harmony_fitness = np.array([self.evaluate(lambda x: np.sum(x), h) for h in self.harmony_memory])\n\n    def evaluate(self, func, harmony):\n        fitness = func(harmony)\n        if fitness < self.best_fitness:\n            self.last_improvement = 0\n            self.best_fitness = fitness\n            self.best_solution = harmony.copy()\n        else:\n            self.last_improvement += 1\n        return fitness\n\n    def update_harmony_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.harmony_fitness)\n        if new_fitness < self.harmony_fitness[worst_idx]:\n            self.harmony_memory[worst_idx] = new_harmony\n            self.harmony_fitness[worst_idx] = new_fitness\n\n    def generate_new_harmony(self, bounds):\n        new_harmony = np.zeros(self.dim)\n        elite_harmonies = self.harmony_memory[np.argsort(self.harmony_fitness)][:int(self.elite_rate * self.num_harmonies)]\n        for i in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                if np.random.rand() < 0.5:\n                    selected_harmony = elite_harmonies[np.random.randint(len(elite_harmonies))]\n                    new_harmony[i] = selected_harmony[i]\n                else:\n                    new_harmony[i] = np.mean(self.harmony_memory[:, i])\n                if np.random.rand() < self.PAR:\n                    new_harmony[i] += np.random.normal(0, self.bandwidth)\n            else:\n                new_harmony[i] = np.random.uniform(bounds.lb[i], bounds.ub[i])\n        # Modified line for adaptive mutation strategy\n        if np.random.rand() < self.mutation_factor:\n            new_harmony += np.random.normal(0, self.bandwidth * (1 + np.log1p(self.last_improvement)**1.7), self.dim)\n        return np.clip(new_harmony, bounds.lb, bounds.ub)\n\n    def adjust_parameters(self):\n        self.bandwidth *= np.exp(np.random.uniform(-0.05, 0.05))\n        self.HMCR = min(1.0, max(0.7, self.HMCR + np.random.uniform(-0.01, 0.01)))\n        self.PAR = min(1.0, max(0.1, self.PAR - 0.01 * self.last_improvement))\n        self.elite_rate = max(0.15, min(0.5, self.elite_rate + np.random.uniform(-0.02, 0.02)))\n        self.mutation_factor *= np.exp(np.random.uniform(-0.1, 0.1))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_harmony_memory(bounds)\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for _ in range(self.populations):\n                new_harmony = self.generate_new_harmony(bounds)\n                new_fitness = self.evaluate(func, new_harmony)\n                self.update_harmony_memory(new_harmony, new_fitness)\n                self.adjust_parameters()\n            evaluations += self.populations\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Introduce adaptive mutation scaling based on convergence history to improve solution diversity and convergence rate.", "configspace": "", "generation": 99, "fitness": 0.24730745210105257, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1e08b7f4-2050-4080-b8d3-65f0f6569627", "metadata": {"aucs": [0.24598473806643972, 0.24811325122784078, 0.24782436700887722], "final_y": [0.1655482709269399, 0.16487044759457503, 0.16486214577609704]}, "mutation_prompt": null}
