{"id": "9d259659-811a-47f6-8a30-e9408ea33d0c", "solution": "import numpy as np\n\nclass PeriodicHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMS = 10  # Harmony Memory Size\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3  # Pitch Adjustment Rate\n        self.bandwidth = 0.1  # Bandwidth for pitch adjustment\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(lb, ub, (self.HMS, self.dim))\n        harmony_fitness = np.array([func(h) for h in harmony_memory])\n        self.evaluations += self.HMS\n\n        while self.evaluations < self.budget:\n            # Generate new harmony\n            new_harmony = np.copy(harmony_memory[np.random.randint(self.HMS)])\n            for d in range(self.dim):\n                if np.random.rand() < self.HMCR:\n                    new_harmony[d] = harmony_memory[np.random.randint(self.HMS)][d]\n                    if np.random.rand() < self.PAR:\n                        new_harmony[d] += self.bandwidth * (np.random.rand() - 0.5)\n                else:\n                    new_harmony[d] = np.random.uniform(lb[d], ub[d])\n\n            # Encourage periodicity by rotating the solution\n            if np.random.rand() < 0.5:\n                period = self.dim // 2\n                new_harmony[:period] = new_harmony[period:]\n\n            # Evaluate new harmony\n            new_fitness = func(new_harmony)\n            self.evaluations += 1\n\n            # Update harmony memory\n            if new_fitness > np.min(harmony_fitness):\n                worst_index = np.argmin(harmony_fitness)\n                harmony_memory[worst_index] = new_harmony\n                harmony_fitness[worst_index] = new_fitness\n\n        best_index = np.argmax(harmony_fitness)\n        return harmony_memory[best_index]", "name": "PeriodicHarmonySearch", "description": "\"Harmony Search-Based Metaheuristic with Periodicity Bias for Optimizing Multilayer Structures\"", "configspace": "", "generation": 0, "fitness": 0.21515758887201528, "feedback": "The algorithm PeriodicHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.215 with standard deviation 0.006. And the mean value of best solutions found was 0.332 (0. is the best) with standard deviation 0.039.", "error": "", "parent_id": null, "metadata": {"aucs": [0.20676253673583622, 0.21799188931441726, 0.22071834056579231], "final_y": [0.3876968543695013, 0.3074005999308874, 0.3020036667102153]}, "mutation_prompt": null}
{"id": "10cfc038-b378-48fa-b3b5-6ef715d99e43", "solution": "import numpy as np\n\nclass ImprovedPeriodicHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.HMS = 10  # Harmony Memory Size\n        self.HMCR = 0.9  # Harmony Memory Consideration Rate\n        self.PAR = 0.3  # Pitch Adjustment Rate\n        self.bandwidth = 0.1  # Bandwidth for pitch adjustment\n        self.evaluations = 0\n    \n    def adaptive_params(self, iteration, max_iterations):\n        \"\"\"Adaptive adjustment of Harmony Search parameters.\"\"\"\n        # Gradually decrease the bandwidth to fine-tune exploration over time\n        self.bandwidth = 0.1 * (1 - iteration / max_iterations)\n        # Gradually increase the pitch adjustment rate to focus on exploitation\n        self.PAR = 0.3 + 0.7 * (iteration / max_iterations)\n    \n    def enforce_periodicity(self, harmony):\n        \"\"\"Enforce periodicity in the solution.\"\"\"\n        period = self.dim // 2\n        harmony[:period] = harmony[period:2*period]\n        return harmony\n    \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        max_iterations = (self.budget - self.HMS)\n        \n        # Initialize harmony memory\n        harmony_memory = np.random.uniform(lb, ub, (self.HMS, self.dim))\n        harmony_fitness = np.array([func(h) for h in harmony_memory])\n        self.evaluations += self.HMS\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self.adaptive_params(iteration, max_iterations)\n            \n            # Generate new harmony\n            new_harmony = np.copy(harmony_memory[np.random.randint(self.HMS)])\n            for d in range(self.dim):\n                if np.random.rand() < self.HMCR:\n                    new_harmony[d] = harmony_memory[np.random.randint(self.HMS)][d]\n                    if np.random.rand() < self.PAR:\n                        new_harmony[d] += self.bandwidth * (np.random.rand() - 0.5)\n                else:\n                    new_harmony[d] = np.random.uniform(lb[d], ub[d])\n            \n            # Enforce periodicity in new harmony\n            new_harmony = self.enforce_periodicity(new_harmony)\n\n            # Evaluate new harmony\n            new_fitness = func(new_harmony)\n            self.evaluations += 1\n\n            # Update harmony memory if new harmony is better\n            if new_fitness > np.min(harmony_fitness):\n                worst_index = np.argmin(harmony_fitness)\n                harmony_memory[worst_index] = new_harmony\n                harmony_fitness[worst_index] = new_fitness\n            \n            iteration += 1\n\n        best_index = np.argmax(harmony_fitness)\n        return harmony_memory[best_index]", "name": "ImprovedPeriodicHarmonySearch", "description": "Improved Periodic Harmony Search with Adaptive Parameters and Enhanced Periodicity for Optimizing Multilayer Structures", "configspace": "", "generation": 1, "fitness": 0.2062589545774575, "feedback": "The algorithm ImprovedPeriodicHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.206 with standard deviation 0.006. And the mean value of best solutions found was 0.418 (0. is the best) with standard deviation 0.065.", "error": "", "parent_id": "9d259659-811a-47f6-8a30-e9408ea33d0c", "metadata": {"aucs": [0.19963658436853804, 0.21507500353160303, 0.20406527583223144], "final_y": [0.4851222111652522, 0.32928797000104415, 0.4395681171422591]}, "mutation_prompt": null}
{"id": "0e35d4b4-5928-4ea9-85cb-6769c1359b87", "solution": "import numpy as np\n\nclass PeriodicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential evolution mutation\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n\n                # Crossover\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Periodicity encouragement by shifting elements\n                if np.random.rand() < 0.5:\n                    shift = np.random.randint(1, self.dim // 2)\n                    trial[:shift] = trial[-shift:]\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_fitness > fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "PeriodicDifferentialEvolution", "description": "\"Differential Evolution with Periodic Bias and Adaptive Mutation Strategy for Optimizing Layered Photonic Structures\"", "configspace": "", "generation": 2, "fitness": 0.2165725198765576, "feedback": "The algorithm PeriodicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.217 with standard deviation 0.003. And the mean value of best solutions found was 0.313 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": "9d259659-811a-47f6-8a30-e9408ea33d0c", "metadata": {"aucs": [0.2202226446409502, 0.21420189914481302, 0.21529301584390959], "final_y": [0.3008502759185271, 0.3000791223943158, 0.3391368429423277]}, "mutation_prompt": null}
{"id": "8c357e9c-dc7b-44a9-a2ef-571b1070870b", "solution": "import numpy as np\n\nclass PeriodicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential evolution mutation\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n\n                # Crossover\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Periodicity encouragement by shifting elements based on evaluation count\n                if np.random.rand() < 0.5:\n                    shift = (self.evaluations // self.population_size) % (self.dim // 2) + 1\n                    trial[:shift] = trial[-shift:]\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_fitness > fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "PeriodicDifferentialEvolution", "description": "Enhanced PeriodicDifferentialEvolution with adaptive periodic shift strategy for improved performance.", "configspace": "", "generation": 3, "fitness": 0.22514361800588076, "feedback": "The algorithm PeriodicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.225 with standard deviation 0.003. And the mean value of best solutions found was 0.245 (0. is the best) with standard deviation 0.024.", "error": "", "parent_id": "0e35d4b4-5928-4ea9-85cb-6769c1359b87", "metadata": {"aucs": [0.22725880164640466, 0.22092377742644265, 0.22724827494479494], "final_y": [0.21084275515549744, 0.2609926677535461, 0.2623125342728805]}, "mutation_prompt": null}
{"id": "13d9d4e2-7f78-48a0-9cbd-1ea30cca1348", "solution": "import numpy as np\n\nclass PeriodicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential evolution mutation\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n\n                # Crossover\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Periodicity encouragement by shifting elements based on evaluation count\n                if np.random.rand() < 0.5:\n                    shift = (self.evaluations // self.population_size) % (self.dim // 2) + 2  # changed from +1 to +2\n                    trial[:shift] = trial[-shift:]\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_fitness > fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "PeriodicDifferentialEvolution", "description": "Improved PeriodicDifferentialEvolution with enhanced periodicity encouragement using adaptive shift magnitude.", "configspace": "", "generation": 4, "fitness": 0.22580813666595534, "feedback": "The algorithm PeriodicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.226 with standard deviation 0.004. And the mean value of best solutions found was 0.261 (0. is the best) with standard deviation 0.034.", "error": "", "parent_id": "8c357e9c-dc7b-44a9-a2ef-571b1070870b", "metadata": {"aucs": [0.22847936197233998, 0.2294532201625541, 0.21949182786297194], "final_y": [0.24985952564671865, 0.2249913899554431, 0.3067752670169773]}, "mutation_prompt": null}
{"id": "59512f9b-dc4d-4b12-ad8d-ccec798217e0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.5:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Adaptive Genetic Algorithm with Periodicity Preservation and Local Refinement using BFGS for enhanced reflectivity optimization.", "configspace": "", "generation": 5, "fitness": 0.24608214711057538, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "13d9d4e2-7f78-48a0-9cbd-1ea30cca1348", "metadata": {"aucs": [0.24752028312428487, 0.24332017648384896, 0.2474059817235923], "final_y": [0.16485688671716447, 0.1648573638892309, 0.1648573074351377]}, "mutation_prompt": null}
{"id": "22122d01-d6c4-4ff5-8e45-3c7d8c0c0b75", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.5:\n                    shift = np.random.randint(1, self.dim // 2)\n                    period = individual[:shift]  # Reinforce periodic structure\n                    for j in range(shift, self.dim, shift):\n                        individual[j:j+shift] = period[:min(shift, self.dim-j)]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "An improved Adaptive Genetic Algorithm that includes a periodicity reinforcement strategy during mutation to enhance convergence towards optimal multilayer configurations.", "configspace": "", "generation": 6, "fitness": 0.24364113574142318, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "59512f9b-dc4d-4b12-ad8d-ccec798217e0", "metadata": {"aucs": [0.24691504881241844, 0.24282196508764642, 0.24118639332420466], "final_y": [0.1648571757052737, 0.18187881741229606, 0.16485673723026273]}, "mutation_prompt": null}
{"id": "07860c9c-110b-4af1-865f-20bdfa5106fa", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Periodicity preservation with improved method\n            for individual in new_population:\n                if np.random.rand() < 0.5:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = np.roll(individual, shift)[:shift]  # Changed line\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Adaptive Genetic Algorithm with enhanced Periodicity Preservation and Local Refinement using BFGS for improved reflectivity optimization.", "configspace": "", "generation": 7, "fitness": 0.24608214711057538, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "59512f9b-dc4d-4b12-ad8d-ccec798217e0", "metadata": {"aucs": [0.24752028312428487, 0.24332017648384896, 0.2474059817235923], "final_y": [0.16485688671716447, 0.1648573638892309, 0.1648573074351377]}, "mutation_prompt": null}
{"id": "b8fbe789-698c-48cc-8f96-5441055a3744", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.7:  # Changed from 0.5 to 0.7\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with Improved Periodicity Preservation for superior Bragg mirror optimization.", "configspace": "", "generation": 8, "fitness": 0.2467340736705446, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "59512f9b-dc4d-4b12-ad8d-ccec798217e0", "metadata": {"aucs": [0.24746795126743426, 0.24581423296388716, 0.24692003678031238], "final_y": [0.16485938615213735, 0.16485992098185098, 0.1648566538388293]}, "mutation_prompt": null}
{"id": "4ec18e6b-063c-4cc7-998b-173efe35598d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.2  # Changed from 0.1 to 0.2\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.7:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection (increased pressure)\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Improved Adaptive Genetic Algorithm with Enhanced Mutation Strategy and Selection Pressure for superior Bragg mirror optimization.", "configspace": "", "generation": 9, "fitness": 0.24032034499427915, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.240 with standard deviation 0.006. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {"aucs": [0.24754394840298888, 0.23379491141453068, 0.23962217516531792], "final_y": [0.16485739167959812, 0.1818789057314204, 0.16485646955459965]}, "mutation_prompt": null}
{"id": "c784efee-4aa5-4f65-bb49-8963edfe1bdc", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.15  # Changed from 0.1 to 0.15\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Periodicity preservation with enhanced diversity\n            for individual in new_population:\n                if np.random.rand() < 0.8:  # Changed from 0.7 to 0.8\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:] + np.random.uniform(-0.05, 0.05, shift)  # Added diversity via small adjustments\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Adaptive Genetic Algorithm with Enhanced Diversity Maintenance for improved exploration and solution quality in Bragg mirror optimization.", "configspace": "", "generation": 10, "fitness": 0.24308891748268827, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.243 with standard deviation 0.001. And the mean value of best solutions found was 0.176 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {"aucs": [0.24233016508508542, 0.24209064707358507, 0.24484594028939433], "final_y": [0.18187995106648913, 0.18187923278072282, 0.16485638094985178]}, "mutation_prompt": null}
{"id": "7ebcde1f-c2dc-494e-a1ef-8e5ac817f37e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass SymbioticGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.05\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (rank-based selection)\n            ranks = np.argsort(fitness)\n            selection_prob = np.exp(-np.arange(self.population_size)/self.population_size)\n            selection_prob /= selection_prob.sum()\n            indices = np.random.choice(ranks, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_indices = np.random.randint(self.dim, size=2)\n                    individual[mutation_indices] = np.random.uniform(lb[mutation_indices[0]], ub[mutation_indices[0]])\n\n            # Multi-phase periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:  # Enhanced periodicity preservation\n                    phase_length = np.random.randint(1, self.dim // 4)\n                    for phase in range(0, self.dim, phase_length):\n                        individual[phase:phase+phase_length] = np.roll(individual[phase:phase+phase_length], shift=np.random.randint(1, phase_length))\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Adaptive local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "SymbioticGeneticAlgorithm", "description": "Advanced Symbiotic Genetic Algorithm featuring multi-phase periodicity preservation and adaptive local refinement for optimized Bragg mirror design.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('low >= high').", "error": "ValueError('low >= high')", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {}, "mutation_prompt": null}
{"id": "d65888e0-0a90-4024-a37f-cd80a102a457", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply dynamic mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_indices = np.random.choice(self.dim, np.random.randint(1, self.dim//2), replace=False)\n                    individual[mutation_indices] += np.random.normal(0, 0.1 * (ub[mutation_indices] - lb[mutation_indices]))\n\n            # Harmonic structure preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    period = np.random.randint(1, self.dim // 2)\n                    for j in range(0, self.dim, period):\n                        end = min(self.dim, j + period)\n                        individual[j:end] = individual[j:end][::-1]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced genetic algorithm integrating dynamic mutation rates and harmonic structure preservation for improved optimization in multilayer designs.", "configspace": "", "generation": 12, "fitness": 0.24334741178439723, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.243 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {"aucs": [0.24669924464551363, 0.2411179259152817, 0.24222506479239636], "final_y": [0.1648567138513083, 0.1818792924659013, 0.1648577360456569]}, "mutation_prompt": null}
{"id": "31f25344-2198-44ba-b6a0-dff9469729ac", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Changed from 20 to 30\n        self.mutation_rate = 0.2  # Changed from 0.1 to 0.2\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply dynamic mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    mutation_step = (ub[mutation_index] - lb[mutation_index]) * 0.05  # New mutation step\n                    individual[mutation_index] += np.random.uniform(-mutation_step, mutation_step)\n\n            # Adaptive periodicity preservation\n            for individual in new_population:\n                periodicity_factor = 0.8  # Changed from 0.7 to 0.8\n                if np.random.rand() < periodicity_factor:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with Dynamic Mutation and Adaptive Periodicity Enhancement.", "configspace": "", "generation": 13, "fitness": 0.24629800769825308, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {"aucs": [0.24349992918206576, 0.24783252025066504, 0.24756157366202847], "final_y": [0.16485638204334863, 0.16485606523727414, 0.16485603206185595]}, "mutation_prompt": null}
{"id": "910a3dff-1331-4e76-bac4-4a47c8165c13", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] += np.random.normal(0, 0.1)  # Changed mutation strategy\n\n            # Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.7:  # Changed from 0.5 to 0.7\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with an improved mutation strategy for better exploration of the optimization landscape.", "configspace": "", "generation": 14, "fitness": 0.24522791994915816, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {"aucs": [0.24721309702964578, 0.2418837266615146, 0.2465869361563141], "final_y": [0.1648570458058911, 0.1818792924659013, 0.16485623722013143]}, "mutation_prompt": null}
{"id": "85075e37-5e81-42e2-b463-9a7eaada7c51", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (tournament selection)\n            indices = [\n                max(np.random.choice(self.population_size, 2), key=lambda idx: fitness[idx])\n                for _ in range(self.population_size)\n            ]\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_indices = np.random.choice(self.dim, 2, replace=False)  # Mutate two indices\n                    individual[mutation_indices] = np.random.uniform(lb[mutation_indices], ub[mutation_indices])\n\n            # Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.7:  # Changed from 0.5 to 0.7\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Refined Adaptive Genetic Algorithm with Improved Selection and Mutation Strategies for Enhanced Bragg Mirror Optimization.", "configspace": "", "generation": 15, "fitness": 0.24252634277631016, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.243 with standard deviation 0.003. And the mean value of best solutions found was 0.182 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {"aucs": [0.23912985395865305, 0.2423592705123483, 0.24608990385792917], "final_y": [0.2004458329517983, 0.18187835057072943, 0.16485681091962168]}, "mutation_prompt": null}
{"id": "7002e8ab-cc0d-40da-8e5a-716622ffb5e7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.2  # Adjusted mutation rate\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim - 1)\n                    crossover_point2 = np.random.randint(crossover_point, self.dim)  # Double-point crossover\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:crossover_point2], parent1[crossover_point2:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:crossover_point2], parent2[crossover_point2:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply dynamic mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    mutation_step = (ub - lb) * 0.05  # Dynamic mutation step\n                    individual[mutation_index] = np.clip(individual[mutation_index] + np.random.uniform(-mutation_step[mutation_index], mutation_step[mutation_index]), lb[mutation_index], ub[mutation_index])\n\n            # Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:  # Adjusted to 0.8\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:  # Increased local refinement chance\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Improved Adaptive Genetic Algorithm with Dynamic Mutation and Periodicity-Preserving Crossover for Enhanced Reflectivity Optimization.", "configspace": "", "generation": 16, "fitness": 0.24244503919467256, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.242 with standard deviation 0.003. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {"aucs": [0.2387572806074556, 0.24283712639421084, 0.24574071058235125], "final_y": [0.16485644560633528, 0.18187881005567907, 0.16485663069240497]}, "mutation_prompt": null}
{"id": "0b3a7d00-dc00-483b-8956-b64018d7d944", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_indices = np.random.choice(self.dim, 2, replace=False) # Changed mutation strategy\n                    individual[mutation_indices[0]], individual[mutation_indices[1]] = individual[mutation_indices[1]], individual[mutation_indices[0]]\n\n            # Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.7:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with refined mutation strategy to improve solution diversity and periodicity preservation.", "configspace": "", "generation": 17, "fitness": 0.2448979975679819, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {"aucs": [0.24669599735666292, 0.24265449088165036, 0.24534350446563236], "final_y": [0.1648565471274862, 0.1818792924659013, 0.1648573074351377]}, "mutation_prompt": null}
{"id": "b7c75a91-40fa-43af-825a-6aa7482f3ba6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:  # Changed from 0.7 to 0.8\n                    shift = np.random.randint(1, self.dim // 3)  # Adjusted from self.dim // 2 to self.dim // 3\n                    individual[:shift] = individual[-shift:]\n                else:\n                    # Introduce a random periodic pattern\n                    pattern_length = np.random.randint(2, self.dim // 4)  # New code for diversity\n                    pattern = np.random.uniform(lb, ub, pattern_length)\n                    individual[:pattern_length] = pattern\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Introduced diversity in the population and refined periodicity preservation strategy for improved exploration and convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('low >= high').", "error": "ValueError('low >= high')", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {}, "mutation_prompt": null}
{"id": "4bd6c61c-02c4-40f6-bcd1-f828f0a8b23b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.75:  # Changed from 0.7 to 0.75\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Refined Adaptive Genetic Algorithm with enhanced periodicity preservation probabilities for optimized Bragg mirror design.", "configspace": "", "generation": 19, "fitness": 0.24445173639906334, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.004. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {"aucs": [0.23928779124674315, 0.24714738513871914, 0.2469200328117277], "final_y": [0.18187925936803295, 0.16485633995627924, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "d1b133d9-375b-4a78-84ea-3c1f01abb558", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.5  # Changed from 0.7 to 0.5\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point1 = np.random.randint(1, self.dim - 1)\n                    crossover_point2 = np.random.randint(crossover_point1, self.dim)  # New line for two-point crossover\n                    new_population[i] = np.concatenate((parent1[:crossover_point1], \n                                                        parent2[crossover_point1:crossover_point2], \n                                                        parent1[crossover_point2:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point1], \n                                                            parent1[crossover_point1:crossover_point2], \n                                                            parent2[crossover_point2:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:  # Changed from 0.7 to 0.8\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Refined Adaptive Genetic Algorithm with Enhanced Periodicity and Dynamic Crossover Rate for Optimized Reflectivity in Bragg Mirrors.", "configspace": "", "generation": 20, "fitness": 0.24236840831528386, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.242 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {"aucs": [0.24001985314102925, 0.24184343423256094, 0.24524193757226143], "final_y": [0.16485582944161858, 0.1818792924659013, 0.16485681091962168]}, "mutation_prompt": null}
{"id": "402825b0-7107-4c28-bbbd-1553b37af4b5", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate * (1 - self.evaluations / self.budget):  # Dynamic mutation rate\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.7: \n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection with elitism\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with strategic elitism and dynamic mutation rate for improved periodicity and convergence.", "configspace": "", "generation": 21, "fitness": 0.24585656746953735, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {"aucs": [0.24746795126743426, 0.24318171832945013, 0.2469200328117277], "final_y": [0.16485938615213735, 0.1818793238132389, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "4bd26855-b16e-418c-95f2-e062ad1d73e9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.15  # Changed from 0.1 to 0.15\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (tournament selection)\n            indices = [np.random.choice(self.population_size, 2, replace=False) for _ in range(self.population_size)]\n            indices = [ind[np.argmax(fitness[ind])] for ind in indices]  # Select the best of each pair\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.7:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with refined selection mechanism and elevated mutation rate for superior convergence and reflectivity optimization.", "configspace": "", "generation": 22, "fitness": 0.24495144904196076, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {"aucs": [0.24304049754186485, 0.244141197151173, 0.24767265243284442], "final_y": [0.1818793847123854, 0.16485787248635841, 0.16485723040011457]}, "mutation_prompt": null}
{"id": "471b4588-cfae-4fd8-8806-da56c037cbac", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.15  # Changed from 0.1 to 0.15\n        self.crossover_rate = 0.8  # Changed from 0.7 to 0.8\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point1 = np.random.randint(1, self.dim // 2)  # Changed crossover computation\n                    crossover_point2 = np.random.randint(crossover_point1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point1], parent2[crossover_point1:crossover_point2], parent1[crossover_point2:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point1], parent1[crossover_point1:crossover_point2], parent2[crossover_point2:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_indices = np.random.choice(self.dim, size=2, replace=False)  # Changed to mutate two indices\n                    for mi in mutation_indices:\n                        individual[mi] = np.random.uniform(lb[mi], ub[mi])\n\n            # Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.7:  # Changed from 0.5 to 0.7\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Refined adaptive genetic algorithm with enhanced crossover and mutation strategies for improved Bragg mirror optimization.", "configspace": "", "generation": 23, "fitness": 0.24552144177183052, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {"aucs": [0.24610155006544165, 0.24266505756738366, 0.24779771768266623], "final_y": [0.16485760275668715, 0.16485773882362487, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "ec357a14-7745-4d7e-b458-b2cbe455dcbc", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.75:  # Changed from 0.7 to 0.75\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Minor enhancement in periodicity preservation probability to improve search efficiency.", "configspace": "", "generation": 24, "fitness": 0.24445173639906334, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.004. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {"aucs": [0.23928779124674315, 0.24714738513871914, 0.2469200328117277], "final_y": [0.18187925936803295, 0.16485633995627924, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "b36d08f5-47fd-4857-8132-6ebe7c4ba429", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                dynamic_crossover_rate = self.crossover_rate * (1 - self.evaluations / self.budget)  # Dynamic adjustment\n                if np.random.rand() < dynamic_crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                dynamic_mutation_rate = self.mutation_rate * (self.evaluations / self.budget)  # Dynamic adjustment\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.7:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with Dynamic Crossover and Mutation Rates for Improved Bragg Mirror Optimization.", "configspace": "", "generation": 25, "fitness": 0.24094594317118953, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.241 with standard deviation 0.003. And the mean value of best solutions found was 0.184 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {"aucs": [0.24324609656309837, 0.24229380963619218, 0.23729792331427801], "final_y": [0.1818816497240131, 0.18187839187372168, 0.18813164728110932]}, "mutation_prompt": null}
{"id": "31d5bf92-c795-4231-a829-98111c5f45fe", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            for individual in new_population:\n                adaptive_mutation_rate = 0.1 + (0.9 * (1 - np.std(fitness) / np.mean(fitness)))\n                if np.random.rand() < adaptive_mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.7:  # Changed from 0.5 to 0.7\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Enhanced local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.2 and self.evaluations < self.budget:  # Changed from 0.1 to 0.2\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Improved Adaptive Genetic Algorithm with Adaptive Mutation and Enhanced Local Refinement for optimized Bragg mirror solutions.", "configspace": "", "generation": 26, "fitness": 0.24536391788676382, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {"aucs": [0.24504726590297143, 0.24369773043169596, 0.24734675732562406], "final_y": [0.16485675577389614, 0.16485724741009933, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "36eff4e5-221a-4852-bc25-1990afb01fbd", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] += np.random.normal(0, 0.1)  # Changed mutation strategy\n\n            # Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.7:  # Changed from 0.5 to 0.7\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Optimized mutation strategy for enhanced exploration and convergence in Bragg mirror optimization.", "configspace": "", "generation": 27, "fitness": 0.24522791994915816, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {"aucs": [0.24721309702964578, 0.2418837266615146, 0.2465869361563141], "final_y": [0.1648570458058911, 0.1818792924659013, 0.16485623722013143]}, "mutation_prompt": null}
{"id": "641f519b-7a83-43a3-92da-ae75ec6edbeb", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.7:  # Changed from 0.5 to 0.7\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]\n", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with Improved Periodicity and Mutation Rate Adjustment for superior Bragg mirror optimization.", "configspace": "", "generation": 28, "fitness": 0.2467340736705446, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {"aucs": [0.24746795126743426, 0.24581423296388716, 0.24692003678031238], "final_y": [0.16485938615213735, 0.16485992098185098, 0.1648566538388293]}, "mutation_prompt": null}
{"id": "d002abe7-fa0c-4877-a8c8-801dd4aaf3c6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (tournament selection)\n            tournament_size = 3\n            indices = [np.random.choice(np.argsort(fitness)[-tournament_size:]) for _ in range(self.population_size)]\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:  # Changed from 0.7 to 0.8\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with improved selection strategy and refined periodicity enforcement for superior Bragg mirror optimization.", "configspace": "", "generation": 29, "fitness": 0.24404555104790057, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.001. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {"aucs": [0.2433672693751434, 0.24316224103362294, 0.24560714273493534], "final_y": [0.16485760275668715, 0.1818792924659013, 0.16485681091962168]}, "mutation_prompt": null}
{"id": "25b89e26-5891-4acf-8cfc-505d87b76737", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = 1 - (fitness / total_fitness)  # Improved selection strategy\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.normal(individual[mutation_index], 0.1)  # Enhanced mutation strategy\n\n            # Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.7:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced population selection and mutation strategy for improved convergence in Bragg mirror optimization.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities do not sum to 1').", "error": "ValueError('probabilities do not sum to 1')", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {}, "mutation_prompt": null}
{"id": "8f7c518d-86a1-4a2c-97ce-21f8f04a1b71", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:  # Changed from 0.7 to 0.8\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:  # Changed from 0.1 to 0.15\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Improved Adaptive Genetic Algorithm with Enhanced Periodicity and Local Search Efficiency.", "configspace": "", "generation": 31, "fitness": 0.24717842506660107, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b8fbe789-698c-48cc-8f96-5441055a3744", "metadata": {"aucs": [0.2467552496009734, 0.24785999278710213, 0.2469200328117277], "final_y": [0.16485828004194358, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "f63c5d92-d2b8-4580-8b10-7f91a5139a5e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_indices = np.random.choice(self.dim, int(0.15 * self.dim), replace=False)  # Updated mutation strategy\n                    individual[mutation_indices] += np.random.uniform(-0.05, 0.05, mutation_indices.shape)  # Allow small perturbations\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.2 and self.evaluations < self.budget:  # Dynamic local search probability\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with Improved Mutation Strategy and Dynamic Local Search Integration.", "configspace": "", "generation": 32, "fitness": 0.24463071698399894, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "8f7c518d-86a1-4a2c-97ce-21f8f04a1b71", "metadata": {"aucs": [0.24668017083714877, 0.24170310637209036, 0.24550887374275765], "final_y": [0.16485760275668715, 0.1818792924659013, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "cbe3bef5-00e9-4530-8e7b-cb748ae87a46", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population with quasi-oppositional strategy\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        opposition_population = lb + ub - population  # Added line\n        population = np.vstack((population, opposition_population))[:self.population_size]  # Added line\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with Improved Initialization and Periodicity Handling.", "configspace": "", "generation": 33, "fitness": 0.24717842506660107, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8f7c518d-86a1-4a2c-97ce-21f8f04a1b71", "metadata": {"aucs": [0.2467552496009734, 0.24785999278710213, 0.2469200328117277], "final_y": [0.16485828004194358, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "e22ff8b6-8a7f-4438-8aa5-f0b57b3fff4b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.75:  # Changed from 0.8 to 0.75\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.2 and self.evaluations < self.budget:  # Changed from 0.15 to 0.2\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Refined Adaptive Genetic Algorithm with Improved Selection and Local Search Intensification.", "configspace": "", "generation": 34, "fitness": 0.24600718914134376, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8f7c518d-86a1-4a2c-97ce-21f8f04a1b71", "metadata": {"aucs": [0.24423792276247758, 0.24714734551017414, 0.24663629915137952], "final_y": [0.16485649591069074, 0.16485651325243045, 0.16485636490145228]}, "mutation_prompt": null}
{"id": "88ff9b2f-9b32-4aed-8075-f12c60b29ea8", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / (total_fitness + 1e-6)  # Changed to add a small constant to avoid division by zero\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:  # Changed from 0.7 to 0.8\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:  # Changed from 0.1 to 0.15\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Fine-tuned selection probability calculation to enhance diversity and convergence in the genetic algorithm.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities do not sum to 1').", "error": "ValueError('probabilities do not sum to 1')", "parent_id": "8f7c518d-86a1-4a2c-97ce-21f8f04a1b71", "metadata": {}, "mutation_prompt": null}
{"id": "cee0edeb-b874-489b-a649-251b536f5bc7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    # Modified line: increased mutation range for more variability\n                    individual[mutation_index] += np.random.uniform(-0.1, 0.1) \n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:  # Changed from 0.7 to 0.8\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:  # Changed from 0.1 to 0.15\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Genetic Algorithm with Improved Mutational Variability.", "configspace": "", "generation": 36, "fitness": 0.24655130723039362, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8f7c518d-86a1-4a2c-97ce-21f8f04a1b71", "metadata": {"aucs": [0.2467552931521172, 0.24628175186867207, 0.24661687667039156], "final_y": [0.16485819711766414, 0.16486224278548056, 0.16485595482137083]}, "mutation_prompt": null}
{"id": "076919a3-f71a-4fc3-981e-47f6bbe978d3", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:  # Changed from 0.7 to 0.8\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.2 and self.evaluations < self.budget:  # Changed from 0.15 to 0.2\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with Improved Local Search Strategy for Multilayer Reflectivity Optimization.", "configspace": "", "generation": 37, "fitness": 0.24648150830041363, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8f7c518d-86a1-4a2c-97ce-21f8f04a1b71", "metadata": {"aucs": [0.24494827485893378, 0.24785999278710213, 0.246636257255205], "final_y": [0.16485828004194358, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "cc453b82-7c14-4516-a30f-ed78f5f83d2a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.15  # Changed from 0.1 to 0.15\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (stochastic universal sampling)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.argsort(selection_prob)[-self.population_size:]  # Changed from np.random.choice to sorting\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.85:  # Changed from 0.8 to 0.85\n                    shift = np.random.randint(1, self.dim // 3)  # Changed from self.dim // 2 to self.dim // 3\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced selection strategy and improved periodicity preservation for better exploitation of promising solutions.", "configspace": "", "generation": 38, "fitness": 0.2458451028052883, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8f7c518d-86a1-4a2c-97ce-21f8f04a1b71", "metadata": {"aucs": [0.24584133515820772, 0.24406163871857878, 0.2476323345390784], "final_y": [0.16485797257694568, 0.1648564236684561, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "95d4ab31-dfd4-4265-b361-b42484de594f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.85:  # Changed from 0.8 to 0.85\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with Improved Selection Strategy and Periodic Alignment.", "configspace": "", "generation": 39, "fitness": 0.24600021715510936, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8f7c518d-86a1-4a2c-97ce-21f8f04a1b71", "metadata": {"aucs": [0.24687167785028752, 0.24785999278710213, 0.24326898082793846], "final_y": [0.16485765085810644, 0.16485651325243045, 0.1648573074351377]}, "mutation_prompt": null}
{"id": "40588225-043d-473c-abb0-2e58828fd63f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75  # Changed from 0.7 to 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] += np.random.normal(scale=0.1)  # Changed mutation strategy\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.85:  # Changed from 0.8 to 0.85\n                    shift = np.random.randint(1, self.dim // 3)  # Changed from dim//2 to dim//3\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with Improved Mutation Strategy and Periodicity Refinement.", "configspace": "", "generation": 40, "fitness": 0.24496066338702469, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8f7c518d-86a1-4a2c-97ce-21f8f04a1b71", "metadata": {"aucs": [0.2458151997763779, 0.24529543426093658, 0.24377135612375955], "final_y": [0.1648558675240247, 0.16485615170947443, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "2ea88c94-b5e2-44c8-a5f8-f2c362971024", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.12  # Changed from 0.1 to 0.12\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:  # Changed from 0.7 to 0.8\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:  # Changed from 0.1 to 0.15\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Minor mutation rate enhancement to improve exploration capability.", "configspace": "", "generation": 41, "fitness": 0.2470203963486306, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8f7c518d-86a1-4a2c-97ce-21f8f04a1b71", "metadata": {"aucs": [0.24628116344706197, 0.24785999278710213, 0.2469200328117277], "final_y": [0.16485828004194358, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "cb4b2d7d-d978-4edb-b5f7-2efb66697716", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index] + 0.02)\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.85:  # Changed from 0.8 to 0.85\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with Improved Diversity Maintenance and Periodicity Preservation.", "configspace": "", "generation": 42, "fitness": 0.2459670050713109, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8f7c518d-86a1-4a2c-97ce-21f8f04a1b71", "metadata": {"aucs": [0.24687168134855753, 0.24786001473712427, 0.2431693191282509], "final_y": [0.16485765085810644, 0.16485651325243045, 0.1648573074351377]}, "mutation_prompt": null}
{"id": "a58d1722-5169-42da-90cf-70f9bf4feb63", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    # Two-point crossover strategy\n                    point1, point2 = sorted(np.random.choice(self.dim, 2, replace=False))\n                    new_population[i] = np.concatenate((parent1[:point1], parent2[point1:point2], parent1[point2:]))\n                    new_population[i + 1] = np.concatenate((parent2[:point1], parent1[point1:point2], parent2[point2:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:  # Changed from 0.7 to 0.8\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:  # Changed from 0.1 to 0.15\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced crossover strategy by introducing a two-point crossover for increased genetic diversity.", "configspace": "", "generation": 43, "fitness": 0.24668714323409957, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8f7c518d-86a1-4a2c-97ce-21f8f04a1b71", "metadata": {"aucs": [0.24638074256141984, 0.24613151895619934, 0.24754916818467954], "final_y": [0.16485688136761445, 0.16485658592280417, 0.16485659396053332]}, "mutation_prompt": null}
{"id": "5fa2f398-344d-461a-921a-24649e9b3be2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.9:  # Changed from 0.8 to 0.9\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with Improved Periodicity Preservation.", "configspace": "", "generation": 44, "fitness": 0.24356527035606776, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "8f7c518d-86a1-4a2c-97ce-21f8f04a1b71", "metadata": {"aucs": [0.2457526249205586, 0.24175620898094508, 0.24318697716669957], "final_y": [0.16485699863676861, 0.1818792924659013, 0.16485615964475409]}, "mutation_prompt": null}
{"id": "c00e2468-b76b-4cb3-b803-58e3a77ca8b3", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75  # Changed from 0.7 to 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Improved Adaptive Genetic Algorithm with optimized crossover rate for better exploration and exploitation balance.", "configspace": "", "generation": 45, "fitness": 0.24744682749085634, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8f7c518d-86a1-4a2c-97ce-21f8f04a1b71", "metadata": {"aucs": [0.24756045687373918, 0.24785999278710213, 0.2469200328117277], "final_y": [0.1648566417777665, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "6f9509b3-10a7-4d40-8286-33e8927e735d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75  # Changed from 0.7 to 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_indices = np.random.choice(self.dim, size=2, replace=False)\n                    individual[mutation_indices] = np.random.uniform(lb[mutation_indices], ub[mutation_indices])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with reinforced periodicity preservation and improved mutation strategy.", "configspace": "", "generation": 46, "fitness": 0.24687414235527147, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c00e2468-b76b-4cb3-b803-58e3a77ca8b3", "metadata": {"aucs": [0.24756045687373918, 0.24640666716304882, 0.24665530302902638], "final_y": [0.1648566417777665, 0.16485973715072222, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "321cf1b7-3a85-4e8b-8ba3-b7cc7bceb8a1", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (tournament)\n            indices = np.random.randint(self.population_size, size=self.population_size)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    # Gaussian mutation for smoother search\n                    individual[mutation_index] += np.random.normal(0, 0.1)\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with improved selection and mutation strategies for better exploration-exploitation balance.", "configspace": "", "generation": 47, "fitness": 0.24644063952641992, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c00e2468-b76b-4cb3-b803-58e3a77ca8b3", "metadata": {"aucs": [0.24724589710969058, 0.2451029624891934, 0.2469730589803758], "final_y": [0.16485607963506266, 0.16485890582106155, 0.16485610308481158]}, "mutation_prompt": null}
{"id": "ffba1357-3778-48df-a37b-1404a49176d3", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass SymbioticHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            new_population = np.empty_like(population)\n\n            # Differential Evolution\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = x0 + self.mutation_factor * (x1 - x2)\n                mutant = np.clip(mutant, lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                if trial_fitness > fitness[i]:\n                    new_population[i] = trial\n                else:\n                    new_population[i] = population[i]\n\n            # Symbiosis Phase: Mimicry-inspired Diversity Enhancement\n            for j in range(self.population_size):\n                if np.random.rand() < 0.5:\n                    mimic_partner = new_population[np.random.randint(self.population_size)]\n                    shift = np.random.randint(1, self.dim // 2)\n                    new_population[j][:shift] = mimic_partner[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "SymbioticHybridMetaheuristic", "description": "Symbiotic Hybrid Metaheuristic combines Differential Evolution with a mimicry-inspired symbiosis phase to enhance solution diversity and leverage constructive interference for periodicity.", "configspace": "", "generation": 48, "fitness": 0.24419861611850568, "feedback": "The algorithm SymbioticHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "c00e2468-b76b-4cb3-b803-58e3a77ca8b3", "metadata": {"aucs": [0.24441977067290865, 0.2416235310535526, 0.2465525466290558], "final_y": [0.16485732244181628, 0.1818792924659013, 0.16485684150542457]}, "mutation_prompt": null}
{"id": "0e08882b-61a5-4a25-9836-ae24888c2ae8", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([1 / (1 + func(ind)) for ind in population])  # Improved fitness scaling\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    periodic_shift = self.dim // 2  # Promote half-length periodicity\n                    individual[:periodic_shift] = individual[-periodic_shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([1 / (1 + func(ind)) for ind in new_population])  # Improved fitness scaling\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = 1 / (1 + res.fun)  # Improved fitness scaling\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with improved fitness evaluation and periodicity promotion for better performance and robustness.", "configspace": "", "generation": 49, "fitness": 0.24694735707385454, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c00e2468-b76b-4cb3-b803-58e3a77ca8b3", "metadata": {"aucs": [0.2476617405483208, 0.24720039571413122, 0.24597993495911163], "final_y": [0.16485604295595546, 0.16485638579569883, 0.16485620741662876]}, "mutation_prompt": null}
{"id": "f52924cb-7a2d-409f-97a2-30e8a0768b48", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (tournament selection)\n            tournament_size = 3\n            indices = [np.argmax(np.random.choice(fitness, tournament_size)) for _ in range(self.population_size)]\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Refined Adaptive Genetic Algorithm with enhanced parent selection using tournament selection for improved convergence.", "configspace": "", "generation": 50, "fitness": 0.24544546998611808, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c00e2468-b76b-4cb3-b803-58e3a77ca8b3", "metadata": {"aucs": [0.24371700133704777, 0.24591764743367694, 0.24670176118762954], "final_y": [0.16485688136761445, 0.16485620449911753, 0.1648565797085053]}, "mutation_prompt": null}
{"id": "85d8a225-b7fc-447a-9d2c-9bb7dd85938e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75  # Changed from 0.7 to 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.25 and self.evaluations < self.budget:  # Changed from 0.15 to 0.25\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Modified Adaptive Genetic Algorithm with increased local refinement probability to enhance fine-tuning of solutions.", "configspace": "", "generation": 51, "fitness": 0.2473522356386821, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c00e2468-b76b-4cb3-b803-58e3a77ca8b3", "metadata": {"aucs": [0.24756045687373918, 0.24785999278710213, 0.246636257255205], "final_y": [0.1648566417777665, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "6092b40e-b33e-4e09-9998-5b87140753f1", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.15  # Changed from 0.1 to 0.15\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.9:  # Changed from 0.8 to 0.9\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with adjusted mutation and periodicity preservation rates for improved exploration of near-optimal solutions.", "configspace": "", "generation": 52, "fitness": 0.24268365295909947, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.243 with standard deviation 0.001. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "c00e2468-b76b-4cb3-b803-58e3a77ca8b3", "metadata": {"aucs": [0.24255633392429077, 0.2417560856125831, 0.24373853934042455], "final_y": [0.16485749843106068, 0.1818792924659013, 0.16485615964475409]}, "mutation_prompt": null}
{"id": "3e9e413f-f720-43f3-9860-9e050a1a64a2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75  # Changed from 0.7 to 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    # Change the way shift is calculated to enhance periodicity\n                    shift = np.random.randint(1, self.dim // 3) \n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Adaptive Genetic Algorithm with enhanced periodicity shift for improved multilayer structure optimization.", "configspace": "", "generation": 53, "fitness": 0.2436486225064608, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.003. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "c00e2468-b76b-4cb3-b803-58e3a77ca8b3", "metadata": {"aucs": [0.24666516005422368, 0.23980412065609813, 0.2444765868090606], "final_y": [0.16485695635599074, 0.18187921046468836, 0.16485588561534037]}, "mutation_prompt": null}
{"id": "1f598a61-390f-4f22-bb52-f75c30c84238", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased from 20 to 25\n        self.mutation_rate = 0.12  # Increased from 0.1 to 0.12\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with improved mutation strategy and dynamic population size for better exploration and convergence.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 25 is out of bounds for axis 0 with size 25').", "error": "IndexError('index 25 is out of bounds for axis 0 with size 25')", "parent_id": "c00e2468-b76b-4cb3-b803-58e3a77ca8b3", "metadata": {}, "mutation_prompt": null}
{"id": "61dfc9f1-861c-48b2-9808-681307fb7127", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.8  # Increased from 0.75 to 0.8\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation with adaptive rate\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    mutation_value = np.random.uniform(lb[mutation_index], ub[mutation_index])\n                    individual[mutation_index] = 0.5 * (individual[mutation_index] + mutation_value)  # Adjust mutation\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    repetition_size = self.dim // shift\n                    for j in range(shift):\n                        individual[j::shift] = individual[j]  # Uniform block copy\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Genetic Algorithm with adaptive mutation and periodicity incorporation for improved Bragg mirror design.", "configspace": "", "generation": 55, "fitness": 0.24699100099806345, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c00e2468-b76b-4cb3-b803-58e3a77ca8b3", "metadata": {"aucs": [0.24814017049103088, 0.24496784376485947, 0.24786498873829999], "final_y": [0.1648566668362026, 0.16485664832524882, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "a89fe52e-536a-45f6-8141-cb7d8a8494a7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Symmetric Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    half_dim = self.dim // 2\n                    individual[:half_dim] = individual[half_dim:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with improved symmetry preservation in periodic solutions.", "configspace": "", "generation": 56, "fitness": 0.24293332395281222, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.243 with standard deviation 0.002. And the mean value of best solutions found was 0.176 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "c00e2468-b76b-4cb3-b803-58e3a77ca8b3", "metadata": {"aucs": [0.24219767455203478, 0.24609912898493214, 0.24050316832146978], "final_y": [0.181880914844205, 0.1648566771201213, 0.1818799581447087]}, "mutation_prompt": null}
{"id": "05774d74-1f41-4b65-a3af-d72ca21a16b2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75  # Changed from 0.7 to 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Adaptive mutation based on diversity\n            diversity = np.mean(np.std(population, axis=0))  # Calculate diversity as standard deviation\n            adaptive_mutation_rate = 0.1 + 0.4 * (1 - diversity)  # Adjust mutation rate based on diversity\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Introduce adaptive mutation rate based on population diversity for enhanced exploration-exploitation balance.", "configspace": "", "generation": 57, "fitness": 0.24565683978759204, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c00e2468-b76b-4cb3-b803-58e3a77ca8b3", "metadata": {"aucs": [0.24756045687373918, 0.24318275979546877, 0.24622730269356818], "final_y": [0.1648566417777665, 0.16485844343246658, 0.1648573074351377]}, "mutation_prompt": null}
{"id": "cb9d77ec-8065-4e3c-88c9-d90dbc9517d5", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.15  # Changed from 0.1 to 0.15\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.9:  # Changed from 0.8 to 0.9\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm optimizing mutation rate and periodicity preservation for improved exploration.", "configspace": "", "generation": 58, "fitness": 0.24268365295909947, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.243 with standard deviation 0.001. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "c00e2468-b76b-4cb3-b803-58e3a77ca8b3", "metadata": {"aucs": [0.24255633392429077, 0.2417560856125831, 0.24373853934042455], "final_y": [0.16485749843106068, 0.1818792924659013, 0.16485615964475409]}, "mutation_prompt": null}
{"id": "d50e259d-6081-4355-b38c-761ed9136c2e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] += np.random.normal(0, 0.1 * (ub[mutation_index] - lb[mutation_index]))\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with strategic mutation and periodicity adjustment.", "configspace": "", "generation": 59, "fitness": 0.24718406080413502, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c00e2468-b76b-4cb3-b803-58e3a77ca8b3", "metadata": {"aucs": [0.24756045687373918, 0.24627862645429832, 0.24771309908436756], "final_y": [0.1648566417777665, 0.16485793688560957, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "1d244aee-a128-4782-a872-25d26b85253b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75 \n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Dual initialization with symmetric population\n        population = np.random.uniform(lb, ub, (self.population_size//2, self.dim))\n        population = np.vstack([population, lb + ub - population])  # Symmetrical counterpart\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Refined mutation strategy\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_indices = np.random.choice(self.dim, 2, replace=False)\n                    individual[mutation_indices] = np.random.uniform(lb[mutation_indices], ub[mutation_indices])\n\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Improved Adaptive Genetic Algorithm with enhanced symmetry and periodicity through dual initialization and refined mutation strategies for improved convergence.", "configspace": "", "generation": 60, "fitness": 0.2449503330214312, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c00e2468-b76b-4cb3-b803-58e3a77ca8b3", "metadata": {"aucs": [0.2408599449124016, 0.2469238964665299, 0.24706715768536214], "final_y": [0.164858245833287, 0.16485747269229123, 0.16485638792708912]}, "mutation_prompt": null}
{"id": "709dc455-8e66-4620-9cdf-0ee6ecf33d92", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75  # Changed from 0.7 to 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation with adaptive strategy\n            self.mutation_rate = max(0.01, 0.1 * (1 - self.evaluations / self.budget))  # Adaptive mutation rate\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Refined Adaptive Genetic Algorithm with enhanced periodicity and adaptive mutation rate for improved convergence.", "configspace": "", "generation": 61, "fitness": 0.24744682749085634, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c00e2468-b76b-4cb3-b803-58e3a77ca8b3", "metadata": {"aucs": [0.24756045687373918, 0.24785999278710213, 0.2469200328117277], "final_y": [0.1648566417777665, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "ae6d868f-eb0c-4897-bc20-bcf88774f966", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75  # Changed from 0.7 to 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (stochastic universal sampling)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply mutation\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced exploration using stochastic selection to improve diversity in Adaptive Genetic Algorithm.", "configspace": "", "generation": 62, "fitness": 0.24744682749085634, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c00e2468-b76b-4cb3-b803-58e3a77ca8b3", "metadata": {"aucs": [0.24756045687373918, 0.24785999278710213, 0.2469200328117277], "final_y": [0.1648566417777665, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "3e251de6-88b2-442c-9a41-c90d1ce1cc5f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.05  # Reduced from 0.1 to 0.05\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            selection_prob = fitness / np.sum(fitness)\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < self.crossover_rate:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            for individual in new_population:\n                if np.random.rand() < self.mutation_rate:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            for i, individual in enumerate(new_population):\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    period = individual[:shift]\n                    individual[:shift], individual[-shift:] = period, period\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n            # Apply elitism to retain the best solution found so far\n            best_index = np.argmax(fitness)\n            elite_individual = population[best_index]\n            elite_fitness = fitness[best_index]\n\n        return elite_individual", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with elitist selection and adaptive mutation rate for superior exploitation and exploration.", "configspace": "", "generation": 63, "fitness": 0.2441848471373134, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.004. And the mean value of best solutions found was 0.173 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "c00e2468-b76b-4cb3-b803-58e3a77ca8b3", "metadata": {"aucs": [0.2454046992193557, 0.24783118073498778, 0.23931866145759673], "final_y": [0.16485695635599074, 0.16485651325243045, 0.18813164728110932]}, "mutation_prompt": null}
{"id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Genetic Algorithm with adaptive mutation and crossover rates to better navigate optimization landscapes and maintain diversity.", "configspace": "", "generation": 64, "fitness": 0.24744682788364894, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c00e2468-b76b-4cb3-b803-58e3a77ca8b3", "metadata": {"aucs": [0.24756045805211702, 0.24785999278710213, 0.2469200328117277], "final_y": [0.16485663395379402, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "e4c20686-f07d-4d83-8a71-03cd549f849f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation based on diversity\n            population_std = np.std(population, axis=0)\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)) * np.mean(population_std), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced mutation strategy by dynamically adjusting based on population diversity.", "configspace": "", "generation": 65, "fitness": 0.24319689312748813, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.243 with standard deviation 0.002. And the mean value of best solutions found was 0.176 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24161954959050658, 0.24145736651964078, 0.246513763272317], "final_y": [0.1818789809917718, 0.1818792924659013, 0.16485623722013143]}, "mutation_prompt": null}
{"id": "09bef217-ae20-462f-bd69-f3df657abf8a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Genetic Algorithm with adaptive mutation and crossover rates, integrating periodicity preservation to better navigate complex optimization landscapes.", "configspace": "", "generation": 66, "fitness": 0.24744682788364894, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24756045805211702, 0.24785999278710213, 0.2469200328117277], "final_y": [0.16485663395379402, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "a1dd9051-9b78-4ecc-802a-002961b3554b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n                    \n            # Symmetry enhancement strategy\n            if np.random.rand() < 0.5:\n                for individual in new_population:\n                    half = self.dim // 2\n                    individual[half:] = individual[:half][::-1]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Genetic Algorithm with adaptive operators and periodicity encouragement using local symmetries to boost solution quality in layered optimization problems.", "configspace": "", "generation": 67, "fitness": 0.24731443286129903, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.2469408632715604, 0.2472354446261984, 0.24776699068613828], "final_y": [0.164856127919366, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "5d428883-edc4-4444-a569-5d6e97584ff2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.9:  # Adjusted probability for better periodicity encouragement\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Genetic Algorithm with improved periodicity encouragement by adjusting the periodicity preservation probability.", "configspace": "", "generation": 68, "fitness": 0.24446771098957534, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.2473449916817293, 0.24175620898094508, 0.24430193230605168], "final_y": [0.16485629492029918, 0.1818792924659013, 0.16485615964475409]}, "mutation_prompt": null}
{"id": "f5e750c3-9731-4c63-bc82-b880e3bf8fd6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n        self.periodicity_preservation_prob = 0.9  # increased from 0.8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < self.periodicity_preservation_prob:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.2 and self.evaluations < self.budget:  # increased from 0.15\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Adaptive Genetic Algorithm with enhanced modular periodicity and refined local search strategy for better convergence.", "configspace": "", "generation": 69, "fitness": 0.24513725621680718, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.2473449916817293, 0.24247727411033337, 0.2455895028583589], "final_y": [0.16485629492029918, 0.1648577029224182, 0.16485615964475409]}, "mutation_prompt": null}
{"id": "b98698e3-f329-4b7b-820e-dc41877c3b59", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:] * (np.sin(np.pi*shift/self.dim) + 1) # Updated\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Improved Adaptive Genetic Algorithm with periodicity enhancement for better solution convergence.", "configspace": "", "generation": 70, "fitness": 0.24600576968778443, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24552566347031857, 0.24789368513957866, 0.24459796045345605], "final_y": [0.1648559917804442, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "6d9e595d-a2ab-4de9-8466-64df11301e6e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Dynamic mutation scaling based on phase shift alignment\n            for individual in new_population:\n                phase_shift = (np.sin(np.pi * np.sum(individual)) ** 2)\n                individual = np.clip(individual + adaptive_mutation * phase_shift * (ub - lb), lb, ub)\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Incorporate dynamic mutation scaling based on phase shift alignment to enhance convergence in complex wave problems.", "configspace": "", "generation": 71, "fitness": 0.24744682788364894, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24756045805211702, 0.24785999278710213, 0.2469200328117277], "final_y": [0.16485663395379402, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "3123f7e3-6fbd-46e5-9cb2-e1933268a542", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population with symmetric initialization strategy\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        population = np.vstack((population, lb + ub - population))[:self.population_size]  # Symmetric init\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Adaptive elitism\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            if self.evaluations < self.budget * 0.9:  # Adjust elitism near the end\n                population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Genetic Algorithm refined with symmetric initialization and adaptive elitism for improved convergence.", "configspace": "", "generation": 72, "fitness": 0.24744682788364894, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24756045805211702, 0.24785999278710213, 0.2469200328117277], "final_y": [0.16485663395379402, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "b46ff0d0-bdca-4a80-8d79-3b47aaa7e28c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n            # Dynamic population size adjustment\n            self.population_size = np.clip(int(20 * (1 + 0.5 * (self.evaluations / self.budget))), 15, 25)\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Improved AdaptiveGeneticAlgorithm with dynamic population size adjustments for enhanced exploration.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"'a' and 'p' must have same size\").", "error": "ValueError(\"'a' and 'p' must have same size\")", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {}, "mutation_prompt": null}
{"id": "397d275d-0afd-45f0-a3e6-45474684717e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point1 = np.random.randint(1, self.dim - 1)  # Changed line\n                    crossover_point2 = np.random.randint(crossover_point1, self.dim)  # Changed line\n                    new_population[i] = np.concatenate((parent1[:crossover_point1], parent2[crossover_point1:crossover_point2], parent1[crossover_point2:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point1], parent1[crossover_point1:crossover_point2], parent2[crossover_point2:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Genetic Algorithm with periodicity encouragement and dual-point crossover for improved reflectivity optimization in multilayered photonic design.", "configspace": "", "generation": 74, "fitness": 0.24547560730247997, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24535894093183186, 0.24502715315806178, 0.24604072781754627], "final_y": [0.16485645983324992, 0.16485617356042992, 0.16485612823663254]}, "mutation_prompt": null}
{"id": "54aca341-589c-4d7b-a69f-583ab09b1f6f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Oppositional initialization\n        population = np.random.uniform(lb, ub, (self.population_size // 2, self.dim))\n        opposite_population = lb + ub - population\n        population = np.vstack((population, opposite_population))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Hybrid Genetic Algorithm with Oppositional Initialization and Gradient-Based Local Search for improved exploration and exploitation balance.", "configspace": "", "generation": 75, "fitness": 0.2422073735563192, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.242 with standard deviation 0.003. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24221721146662722, 0.2386664896367111, 0.24573841956561926], "final_y": [0.16485607963506266, 0.1818792924659013, 0.16485640985672]}, "mutation_prompt": null}
{"id": "9f1c5af3-3001-43bb-8115-57a0b21a1ac3", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[shift:shift+shift]  # Promote periodicity\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Genetic Algorithm with periodicity promotion and improved local search integration.", "configspace": "", "generation": 76, "fitness": 0.24500668183885, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.2455406372483364, 0.24267946020016196, 0.2467999480680516], "final_y": [0.16485656712414087, 0.1648572305446151, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "2d8b04eb-c057-454e-864a-698a1ab0f382", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation with cosine annealing\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (1 + np.cos(np.pi * self.evaluations / self.budget)) / 2), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Improved adaptive mutation by incorporating cosine annealing for smoother exploration and exploitation balance.", "configspace": "", "generation": 77, "fitness": 0.24637251059534718, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24756045805211702, 0.24532964264477952, 0.24622743108914502], "final_y": [0.16485663395379402, 0.16485793688560957, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "ef3ef534-de5b-4cf9-97e9-6fe52b382e45", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = np.roll(individual, shift)[:shift]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Genetic Algorithm with adaptive mutation and crossover rates, improved diversity through dynamic periodicity preservation.", "configspace": "", "generation": 78, "fitness": 0.24744682788364894, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24756045805211702, 0.24785999278710213, 0.2469200328117277], "final_y": [0.16485663395379402, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "0fdb8fe3-1a77-4ee9-8efe-082ab7d6ec5d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[:shift] + (np.mean(individual) - individual[-shift:])\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Improved Enhanced Genetic Algorithm by fine-tuning periodicity and local adjustment integration to better navigate complex optimization landscapes.", "configspace": "", "generation": 79, "fitness": 0.24653338519782195, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.247656257346622, 0.24784937696188836, 0.24409452128495546], "final_y": [0.1648563198250952, 0.16485651325243045, 0.1648573074351377]}, "mutation_prompt": null}
{"id": "a0228f81-f0b9-4eab-8491-fbda108adc5b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[shift:2*shift]  # Adjusted line to enhance periodicity\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Genetic Algorithm with stronger periodicity preservation by adjusting how periodic solutions are constructed.", "configspace": "", "generation": 80, "fitness": 0.24500668183885, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.2455406372483364, 0.24267946020016196, 0.2467999480680516], "final_y": [0.16485656712414087, 0.1648572305446151, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "5623a8ed-5bfb-42a8-8522-d93c261662ba", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.2 and self.evaluations < self.budget:  # Changed probability\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Adaptive Genetic Algorithm with refined local search probability to improve solution quality.", "configspace": "", "generation": 81, "fitness": 0.24735225773333713, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24756045687373918, 0.24786005907106723, 0.246636257255205], "final_y": [0.1648566417777665, 0.16485619838287224, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "3031787e-ca57-4aaf-8131-245f639d7a1c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel with niche preservation)\n            total_fitness = np.sum(fitness)\n            selection_prob = (fitness / total_fitness) * (1 + np.var(fitness))\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using Multi-objective BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Hybrid Genetic Algorithm integrating niche preservation and adaptive multi-objective local refinement to enhance solution quality in complex landscapes.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities do not sum to 1').", "error": "ValueError('probabilities do not sum to 1')", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {}, "mutation_prompt": null}
{"id": "e43c8cd7-907c-4148-b02a-0a993a094af6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.2 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Genetic Algorithm with adaptive mutation and crossover rates, improved by integrating periodic pattern enforcement and more robust local search.", "configspace": "", "generation": 83, "fitness": 0.24735225773333713, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24756045687373918, 0.24786005907106723, 0.246636257255205], "final_y": [0.1648566417777665, 0.16485619838287224, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "7aca0234-4b1f-4c09-b76e-d8f98426f209", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = np.tile(individual[-shift:], self.dim // shift)[:shift]  # Changed line\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Genetic Algorithm with improved periodicity preservation to better exploit known optimal structures in the solution space.", "configspace": "", "generation": 84, "fitness": 0.24744682788364894, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24756045805211702, 0.24785999278710213, 0.2469200328117277], "final_y": [0.16485663395379402, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "8d703ddf-412c-453b-b08b-743663546b1a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n        self.restart_frequency = budget // 5  # Adaptive restart strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n            # Periodic restarts to explore new regions\n            if self.evaluations % self.restart_frequency == 0:\n                population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.evaluations += self.population_size\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Adaptive Genetic Algorithm with Iterative Periodic Restarts to enhance exploration and convergence.", "configspace": "", "generation": 85, "fitness": 0.24744682788364894, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24756045805211702, 0.24785999278710213, 0.2469200328117277], "final_y": [0.16485663395379402, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "10088176-5469-4e77-b843-be20ef80ddae", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_indices = np.random.choice(self.dim, 2, replace=False)  # Modified\n                    individual[mutation_indices[0]] = np.random.uniform(lb[mutation_indices[0]], ub[mutation_indices[0]])\n                    individual[mutation_indices[1]] = np.random.uniform(lb[mutation_indices[1]], ub[mutation_indices[1]])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]  # Modified to enhance periodicity\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Adaptive Genetic Algorithm with enhanced periodicity and dynamic mutation strategies for improved optimization in complex landscapes.", "configspace": "", "generation": 86, "fitness": 0.24578123008186906, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24756045687373918, 0.24312786601972824, 0.24665536735213978], "final_y": [0.1648566417777665, 0.18187834319778584, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "c1606d52-ed5b-4fa1-94fc-18dff007a370", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation with periodicity\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n                    # Enhance periodicity using wavelet-based mutation\n                    if np.random.rand() < 0.5:\n                        individual = np.fft.ifft(np.fft.fft(individual) * np.exp(2j * np.pi * np.random.rand(self.dim))).real\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Genetic Algorithm with periodicity enhancement through wavelet-based mutation to better capture constructive interference.", "configspace": "", "generation": 87, "fitness": 0.24495862812468475, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24756046144854538, 0.24332590139613575, 0.24398952152937314], "final_y": [0.1648565986467776, 0.18187835568383448, 0.16485612823663254]}, "mutation_prompt": null}
{"id": "ff3f5a71-1be2-48ae-8a63-11d7b48e6a77", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Symmetric initialization of population\n        population = np.random.uniform(lb, ub, (self.population_size // 2, self.dim))\n        symmetric_population = lb + ub - population\n        population = np.vstack((population, symmetric_population))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Genetic Algorithm with adaptive rates and symmetry-enforced population initialization to boost convergence in complex optimization landscapes.", "configspace": "", "generation": 88, "fitness": 0.2422073735563192, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.242 with standard deviation 0.003. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24221721146662722, 0.2386664896367111, 0.24573841956561926], "final_y": [0.16485607963506266, 0.1818792924659013, 0.16485640985672]}, "mutation_prompt": null}
{"id": "cb334712-7563-4b44-86a1-1e4d7cf38318", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation with symmetry consideration\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n                    # Maintain symmetry in mutation\n                    individual[-(mutation_index+1)] = individual[mutation_index]\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Refined AdaptiveGeneticAlgorithm with enhanced symmetry-preserving crossover and targeted mutation.", "configspace": "", "generation": 89, "fitness": 0.24473515781501656, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.004. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.247560547998253, 0.23972489263506902, 0.2469200328117277], "final_y": [0.1648560544395794, 0.1818875247896733, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "4afb303e-1e2e-47f9-a02d-7d349937f9d5", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    period_length = np.random.randint(1, self.dim // 2)\n                    individual = np.tile(individual[:period_length], self.dim // period_length)[:self.dim]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.12 and self.evaluations < self.budget:  # Adjusted refinement probability\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Genetic Algorithm with improved periodicity preservation and adaptive local refinement to increase the efficiency of finding high-performing solutions.", "configspace": "", "generation": 90, "fitness": 0.2422073114018551, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.242 with standard deviation 0.003. And the mean value of best solutions found was 0.178 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24580124147527493, 0.24287918350137794, 0.23794150922891244], "final_y": [0.16485695635599074, 0.1818795064601061, 0.18813164728110932]}, "mutation_prompt": null}
{"id": "cc0d1629-1d35-4ad3-933b-04f9030b3580", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population with symmetry considerations\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Improved parent selection (tournament)\n            indices = np.random.choice(self.population_size, (self.population_size, 2))\n            selected_indices = np.array([index_pair[np.argmax(fitness[index_pair])] for index_pair in indices])\n            \n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[selected_indices[i]], population[selected_indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Diversity-driven adaptive mutation\n            diversity_factor = np.std(population, axis=0).mean()\n            adaptive_mutation = np.clip(self.mutation_rate * diversity_factor, 0.05, 0.25)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Improved Genetic Algorithm incorporating enhanced periodicity preservation and diversity-driven adaptive mutation rates.  ", "configspace": "", "generation": 91, "fitness": 0.2454408852342778, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24530151909770725, 0.24597285518872336, 0.24504828141640278], "final_y": [0.16485644340404626, 0.16485634103671531, 0.16485743639751205]}, "mutation_prompt": null}
{"id": "371e4f59-8f91-4436-8f4a-80e55f03f1b1", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.25 and self.evaluations < self.budget:  # Changed line\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Genetic Algorithm with adaptive mutation and crossover rates, improved periodicity enforcement, and stochastic local search to better navigate optimization landscapes.", "configspace": "", "generation": 92, "fitness": 0.2473522356386821, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24756045687373918, 0.24785999278710213, 0.246636257255205], "final_y": [0.1648566417777665, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "54ec7e3f-5e2c-4946-a61c-acf5cd7bd604", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.95:  # Increase periodic preservation chance\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Adaptive Genetic Algorithm with enhanced periodic preservation and tuning for improved discovery of near-optimal configurations.", "configspace": "", "generation": 93, "fitness": 0.24566722224929352, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24621095417510097, 0.24785999278710213, 0.24293071978567748], "final_y": [0.1648572157220738, 0.16485651325243045, 0.16485615964475409]}, "mutation_prompt": null}
{"id": "0bf11d44-562c-4bdf-a8d9-df5cafae6cd1", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (weighted roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation with mutation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = np.roll(individual, shift)[:shift]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Genetic Algorithm with weighted selection and periodicity-based mutation for improved convergence.", "configspace": "", "generation": 94, "fitness": 0.24744682788364894, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24756045805211702, 0.24785999278710213, 0.2469200328117277], "final_y": [0.16485663395379402, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "cf824d00-4e25-4e75-a70e-7e70352806d5", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_points = sorted(np.random.choice(self.dim, 2, replace=False))  # Adjusted for more diverse crossover\n                    new_population[i] = np.concatenate((parent1[:crossover_points[0]], parent2[crossover_points[0]:crossover_points[1]], parent1[crossover_points[1]:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_points[0]], parent1[crossover_points[0]:crossover_points[1]], parent2[crossover_points[1]:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Slightly adjusted the crossover strategy to improve convergence by allowing more diverse offsprings.", "configspace": "", "generation": 95, "fitness": 0.24648101786143906, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24597780605481945, 0.24613152791223325, 0.24733371961726447], "final_y": [0.16485688136761445, 0.16485640325027806, 0.1648573074351377]}, "mutation_prompt": null}
{"id": "5a93d8a6-337c-43d4-9a14-3db69f68c589", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - np.sqrt(self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Refined adaptive crossover rate formula to improve exploration and convergence balance.", "configspace": "", "generation": 96, "fitness": 0.2472592447383041, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.2469977086160825, 0.24785999278710213, 0.2469200328117277], "final_y": [0.16485659561673882, 0.16485651325243045, 0.16485668047782742]}, "mutation_prompt": null}
{"id": "09778b33-1dab-4741-afe7-6a57d97bb0e9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population with enhanced diversity\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        if self.population_size > 2:\n            population[:2] = np.array([(lb + ub) / 2, np.random.uniform(lb, ub)])\n\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS with adaptive inertia\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    inertia_weight = 1.0 - (self.evaluations / self.budget)  # Adaptive inertia\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B', options={'disp': False, 'maxcor': 10 * int(inertia_weight)})\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhanced Genetic Algorithm with adaptive mutation and crossover rates, improved by strategic initial population diversity and adaptive inertia in local search.", "configspace": "", "generation": 97, "fitness": 0.2057249922642083, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.206 with standard deviation 0.004. And the mean value of best solutions found was 0.420 (0. is the best) with standard deviation 0.035.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.20850200626214355, 0.19983070143658554, 0.2088422690938958], "final_y": [0.39857693023181484, 0.4694996587134329, 0.39324033370450107]}, "mutation_prompt": null}
{"id": "dc88a26d-6150-4b34-8a95-3c4a87020d7b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] = np.random.uniform(lb[mutation_index], ub[mutation_index])\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n            # Enforce periodicity by averaging layer thicknesses for even-numbered layers.\n            for individual in population:\n                if self.evaluations < self.budget:\n                    individual[0:self.dim:2] = np.mean(individual[0:self.dim:2]) # Enforce periodicity\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Adaptive Genetic Algorithm with periodicity constraint to enhance constructive interference in multilayer structures.", "configspace": "", "generation": 98, "fitness": 0.24744690612998588, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a8e8bfd9-3949-4320-b77e-e7026990a537", "metadata": {"aucs": [0.24756061734535761, 0.24786005336148442, 0.2469200476831156], "final_y": [0.16485589132549516, 0.16485621310495824, 0.16485657762054273]}, "mutation_prompt": null}
{"id": "2c66ee4f-31e1-41de-9e31-a74147b28409", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Parent selection (roulette wheel)\n            total_fitness = np.sum(fitness)\n            selection_prob = fitness / total_fitness\n            indices = np.random.choice(self.population_size, self.population_size, p=selection_prob)\n\n            # Apply crossover with adaptive rate\n            adaptive_crossover = np.clip(self.crossover_rate * (1 - (self.evaluations / self.budget)), 0.6, 0.9)\n            new_population = np.empty_like(population)\n            for i in range(0, self.population_size, 2):\n                parent1, parent2 = population[indices[i]], population[indices[i + 1]]\n                if np.random.rand() < adaptive_crossover:\n                    crossover_point = np.random.randint(1, self.dim)\n                    new_population[i] = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                    new_population[i + 1] = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n                else:\n                    new_population[i], new_population[i + 1] = parent1, parent2\n\n            # Apply adaptive mutation\n            adaptive_mutation = np.clip(self.mutation_rate * (1 - (self.evaluations / self.budget)), 0.05, 0.2)\n            for individual in new_population:\n                if np.random.rand() < adaptive_mutation:\n                    mutation_index = np.random.randint(self.dim)\n                    individual[mutation_index] += np.random.normal(0, (ub[mutation_index] - lb[mutation_index]) / 10.0)  # Gaussian perturbation\n\n            # Enhanced Periodicity preservation\n            for individual in new_population:\n                if np.random.rand() < 0.8:\n                    shift = np.random.randint(1, self.dim // 2)\n                    individual[:shift] = individual[-shift:]\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            self.evaluations += self.population_size\n\n            # Selection\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            best_indices = np.argsort(combined_fitness)[-self.population_size:]\n            population, fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            # Local refinement using BFGS\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15 and self.evaluations < self.budget:\n                    res = minimize(func, population[i], bounds=list(zip(lb, ub)), method='L-BFGS-B')\n                    if res.success:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        self.evaluations += res.nfev\n\n            # Enforce periodicity by averaging layer thicknesses for even-numbered layers.\n            for individual in population:\n                if self.evaluations < self.budget:\n                    individual[0:self.dim:2] = np.mean(individual[0:self.dim:2]) # Enforce periodicity\n\n        best_index = np.argmax(fitness)\n        return population[best_index]", "name": "AdaptiveGeneticAlgorithm", "description": "Enhancing the mutation strategy by introducing Gaussian perturbation for better local search capability.", "configspace": "", "generation": 99, "fitness": 0.24702608568329087, "feedback": "The algorithm AdaptiveGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "dc88a26d-6150-4b34-8a95-3c4a87020d7b", "metadata": {"aucs": [0.24756061711887756, 0.24580445063724343, 0.24771318929375163], "final_y": [0.16485589132549516, 0.16485621310495824, 0.16485622516800968]}, "mutation_prompt": null}
