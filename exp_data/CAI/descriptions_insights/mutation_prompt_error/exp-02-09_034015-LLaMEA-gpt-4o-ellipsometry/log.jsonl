{"id": "9d01c2cc-bd70-4d29-ad0f-61f9d8e637e6", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)\n        self.par = max(0.1, self.par - 0.01)\n        self.bandwidth = max(0.05, self.bandwidth - 0.005)", "name": "AdaptiveHarmonySearch", "description": "The Adaptive Harmony Search (AHS) algorithm dynamically adjusts harmony memory parameters to explore and exploit the search space efficiently for diverse optimization problems.", "configspace": "", "generation": 0, "fitness": 0.19275745965030022, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.193 with standard deviation 0.025. And the mean value of best solutions found was 0.203 (0. is the best) with standard deviation 0.153.", "error": "", "parent_id": null, "metadata": {"aucs": [0.15719621450782795, 0.21126285265094602, 0.2098133117921267], "final_y": [0.4071844864544586, 0.04085895242260223, 0.15969508605440125]}, "mutation_prompt": null}
{"id": "f175dc68-62f1-4715-8af0-ee2a722e06b1", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.4   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Adjusted bandwidth\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        dynamic_bandwidth = self.bandwidth * np.exp(-0.1 * eval_count / self.budget)\n                        new_harmony[i] += dynamic_bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            diversity_index = np.std(harmony_memory, axis=0).mean()  # Added diversity measurement\n            if new_fitness < fitness[np.argmax(fitness)] or diversity_index < 0.1:\n                worst_idx = np.random.choice(np.where(fitness < np.median(fitness))[0])\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.005)\n        self.par = max(0.1, self.par - 0.005)\n        self.bandwidth = max(0.05, self.bandwidth - 0.0025)", "name": "AdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search (EAHS) introduces dynamic bandwidth and diversity-driven selection to improve convergence and solution quality.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"'a' cannot be empty unless no samples are taken\").", "error": "ValueError(\"'a' cannot be empty unless no samples are taken\")", "parent_id": "9d01c2cc-bd70-4d29-ad0f-61f9d8e637e6", "metadata": {}, "mutation_prompt": null}
{"id": "cf9e463b-c445-4f60-a806-b5437ba36428", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:  # (1)\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9\n        self.par = 0.3\n        self.bandwidth = 0.1\n        self.elitism_rate = 0.2  # (2)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            self._update_harmony_memory(new_harmony, new_fitness, fitness, harmony_memory)  # (3)\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)\n        self.par = max(0.1, self.par - 0.01)\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # (4)\n\n    def _update_harmony_memory(self, new_harmony, new_fitness, fitness, harmony_memory):  # (5)\n        sorted_indices = np.argsort(fitness)\n        worst_idx = sorted_indices[-int(self.elitism_rate * self.harmony_memory_size)]  # (6)\n        if new_fitness < fitness[worst_idx]:\n            harmony_memory[worst_idx, :] = new_harmony\n            fitness[worst_idx] = new_fitness", "name": "EnhancedAdaptiveHarmonySearch", "description": "The Enhanced Adaptive Harmony Search (EAHS) algorithm includes a dynamic evaluation of harmony memory fitness, adaptive pitch adjustment with a cooling schedule, and elitist strategy to enhance convergence speed and solution quality.", "configspace": "", "generation": 2, "fitness": 0.1808298740872909, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.181 with standard deviation 0.067. And the mean value of best solutions found was 0.666 (0. is the best) with standard deviation 0.871.", "error": "", "parent_id": "9d01c2cc-bd70-4d29-ad0f-61f9d8e637e6", "metadata": {"aucs": [0.09672189393671715, 0.25943508498052037, 0.18633264334463517], "final_y": [1.8971476932025355, 0.015399611164329374, 0.08498187810919945]}, "mutation_prompt": null}
{"id": "3fbd5e97-8cad-4777-86e6-a2c29e47b438", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.1\n        self.memory_consideration_decay = 0.01  # Added for dynamic decay\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])\n\n            perturbation = np.random.normal(0, 0.01, self.dim)  # Added stochastic perturbation\n            new_harmony += perturbation\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr - self.memory_consideration_decay)  # Decay applied\n        self.par = max(0.1, self.par + 0.05)  # Increased adaptability\n        self.bandwidth = max(0.05, self.bandwidth - 0.005)", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search (EAHS) incorporates dynamic parameter tuning with stochastic perturbations to improve exploration and convergence.", "configspace": "", "generation": 3, "fitness": 0.13525779845514288, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.135 with standard deviation 0.019. And the mean value of best solutions found was 0.766 (0. is the best) with standard deviation 0.664.", "error": "", "parent_id": "9d01c2cc-bd70-4d29-ad0f-61f9d8e637e6", "metadata": {"aucs": [0.12482600301569824, 0.11968157881864538, 0.16126581353108504], "final_y": [0.27838457136396483, 1.7051676045862945, 0.31537292583838933]}, "mutation_prompt": null}
{"id": "200f1b4a-1787-43ad-8186-7ed8fea868ae", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.normal(lb[i], ub[i])  # Normal distribution for exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth - 0.01)  # Faster reduction of bandwidth", "name": "EnhancedAdaptiveHarmonySearch", "description": "The Enhanced Adaptive Harmony Search (EAHS) algorithm introduces strategic diversity injection and adaptive parameter tuning to improve solution quality and convergence speed.", "configspace": "", "generation": 4, "fitness": 0.19873531012847345, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.199 with standard deviation 0.040. And the mean value of best solutions found was 0.239 (0. is the best) with standard deviation 0.140.", "error": "", "parent_id": "9d01c2cc-bd70-4d29-ad0f-61f9d8e637e6", "metadata": {"aucs": [0.16059063434169885, 0.25371327004282374, 0.18190202600089778], "final_y": [0.3440551523379419, 0.04050062543892439, 0.33171171135139654]}, "mutation_prompt": null}
{"id": "8ff455b5-2e2e-4281-b176-779261c18c87", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10 + int(dim / 2)  # Dynamic memory size based on dimension\n        self.hmcr = 0.85\n        self.par = 0.35\n        self.bandwidth = 0.2  # Adjusted bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n\n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * np.random.normal(0, 1) * (ub[i] - lb[i])  # Adjusted randomness\n                else:\n                    new_harmony[i] = np.random.normal((ub[i] + lb[i]) / 2, (ub[i] - lb[i]) / 2)  # Centralized normal distribution\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            if new_fitness < fitness.max():\n                worst_idx = np.argmax(fitness)\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Adjusted adaptation of HMCR\n        self.par = max(0.15, self.par - 0.005)  # Adjusted reduction of PAR\n        self.bandwidth = max(0.1, self.bandwidth - 0.005)  # Adjusted reduction of bandwidth", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with Intelligent Parameter Tuning and Memory-Enhanced Exploration introduces dynamic memory size adjustment and adaptive bandwidth recalibration for improved exploration and exploitation balance.", "configspace": "", "generation": 5, "fitness": 0.1483296394817426, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.148 with standard deviation 0.024. And the mean value of best solutions found was 1.078 (0. is the best) with standard deviation 0.441.", "error": "", "parent_id": "200f1b4a-1787-43ad-8186-7ed8fea868ae", "metadata": {"aucs": [0.17489323450494942, 0.11721551687028764, 0.15288016706999075], "final_y": [0.5900975379450014, 1.658713547368481, 0.985355867304003]}, "mutation_prompt": null}
{"id": "bf806208-3276-4089-b2a9-283a89a9153d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.normal(lb[i], ub[i]) + 0.01 * np.random.randn() # Enhanced exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth - 0.01)  # Faster reduction of bandwidth\n        self.harmony_memory_size = int(max(5, self.harmony_memory_size * 0.99))  # Dynamic reduction of memory size", "name": "EnhancedAdaptiveHarmonySearch", "description": "Introducing dynamic harmony memory size adaptation and enhanced exploration through noise injection.", "configspace": "", "generation": 6, "fitness": 0.14608430849075602, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.146 with standard deviation 0.051. And the mean value of best solutions found was 1.518 (0. is the best) with standard deviation 1.596.", "error": "", "parent_id": "200f1b4a-1787-43ad-8186-7ed8fea868ae", "metadata": {"aucs": [0.07417747071680336, 0.18586804363548082, 0.17820741111998384], "final_y": [3.7737507232263106, 0.3566408545887104, 0.4223460853042069]}, "mutation_prompt": null}
{"id": "51233a15-64e4-4472-a6c2-002e86141bc1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.normal((lb[i] + ub[i]) / 2, (ub[i] - lb[i]) / 6)  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth - 0.01)  # Faster reduction of bandwidth", "name": "EnhancedAdaptiveHarmonySearch", "description": "An enhanced harmony search with strategic diversity and adaptive tuning, refining exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.24689979553733507, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.063. And the mean value of best solutions found was 0.062 (0. is the best) with standard deviation 0.053.", "error": "", "parent_id": "200f1b4a-1787-43ad-8186-7ed8fea868ae", "metadata": {"aucs": [0.3171104850680959, 0.16407327285561202, 0.25951562868829725], "final_y": [0.020398690940726782, 0.13725495513877706, 0.028068433320324125]}, "mutation_prompt": null}
{"id": "f3e856f7-b8c2-4e5c-8bbb-d9d81a9e70d1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.normal((lb[i] + ub[i]) / 2, (ub[i] - lb[i]) / 6)  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters(eval_count)  # Adjust parameters based on eval_count\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self, eval_count):\n        self.hmcr = min(1.0, self.hmcr + 0.015 * (1 - eval_count / self.budget))  # Dynamic adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005 * (eval_count / self.budget))  # Dynamic reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth - 0.01 * (eval_count / self.budget))  # Dynamic reduction of bandwidth", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced harmony search with dynamic parameter adaptation, improving convergence speed and solution quality.", "configspace": "", "generation": 8, "fitness": 0.18914347503245332, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.189 with standard deviation 0.047. And the mean value of best solutions found was 0.332 (0. is the best) with standard deviation 0.204.", "error": "", "parent_id": "51233a15-64e4-4472-a6c2-002e86141bc1", "metadata": {"aucs": [0.24501701944697585, 0.12894596651443835, 0.19346743913594577], "final_y": [0.06697653272962306, 0.5628394963390848, 0.367312084549222]}, "mutation_prompt": null}
{"id": "8e768eea-b3b1-4bff-9269-37c930f5a69d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12\n        self.hmcr = 0.85\n        self.par = 0.35\n        self.bandwidth = 0.15\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += np.random.normal(0, self.bandwidth) * (ub[i] - lb[i])  # Stochastic perturbation\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Uniform exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n        self._adjust_parameters(eval_count)\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self, eval_count):\n        self.hmcr = min(1.0, 0.85 + 0.15 * (eval_count / self.budget))  # Dynamic HMCR\n        self.par = max(0.1, 0.35 - 0.25 * (eval_count / self.budget))  # Dynamic PAR\n        self.bandwidth = max(0.05, self.bandwidth - 0.01)", "name": "EnhancedAdaptiveHarmonySearch", "description": "Improved harmony search using dynamic parameter adaptation and stochastic perturbation for enhanced convergence.", "configspace": "", "generation": 9, "fitness": 0.24369740481873445, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.011. And the mean value of best solutions found was 0.087 (0. is the best) with standard deviation 0.017.", "error": "", "parent_id": "51233a15-64e4-4472-a6c2-002e86141bc1", "metadata": {"aucs": [0.22826641786507462, 0.25371479075551884, 0.24911100583560986], "final_y": [0.10094779646292569, 0.06277721287463443, 0.09744242591730155]}, "mutation_prompt": null}
{"id": "0f46ee75-8f50-4422-a34b-325546f3688c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Enhanced exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.02)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.007)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth - 0.01)  # Faster reduction of bandwidth", "name": "EnhancedAdaptiveHarmonySearch", "description": "Improved adaptive parameter tuning with enhanced exploration strategy in harmony search.", "configspace": "", "generation": 10, "fitness": 0.18693035025662144, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.187 with standard deviation 0.034. And the mean value of best solutions found was 0.460 (0. is the best) with standard deviation 0.307.", "error": "", "parent_id": "51233a15-64e4-4472-a6c2-002e86141bc1", "metadata": {"aucs": [0.17487988686505618, 0.15278395577912485, 0.23312720812568333], "final_y": [0.7282037730129769, 0.6214086875076495, 0.029601215057345934]}, "mutation_prompt": null}
{"id": "d1c15433-01ed-43f3-b4f7-6a40dadd4abb", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.normal((lb[i] + ub[i]) / 2, (ub[i] - lb[i]) / 6)  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n            # Dynamic adjustment of harmony memory size\n            self.harmony_memory_size = min(20, max(6, int(self.harmony_memory_size * (1 + 0.01 * (new_fitness / (best_fitness + 1e-9))))))\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth - 0.01)  # Faster reduction of bandwidth", "name": "EnhancedAdaptiveHarmonySearch", "description": "Introduced a dynamic adjustment mechanism for the harmony memory size to enhance adaptability to diverse problem landscapes.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 14 is out of bounds for axis 0 with size 12').", "error": "IndexError('index 14 is out of bounds for axis 0 with size 12')", "parent_id": "51233a15-64e4-4472-a6c2-002e86141bc1", "metadata": {}, "mutation_prompt": null}
{"id": "f8357c3f-dc56-46b5-81b7-1e4aa63ecd20", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.normal((lb[i] + ub[i]) / 2, (ub[i] - lb[i]) / 6)  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = min(0.2, self.bandwidth + 0.01)  # Adaptive increase of bandwidth", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced harmony search with adaptive bandwidth increasing to improve exploration in high-dimensional spaces.", "configspace": "", "generation": 12, "fitness": 0.21116923920215247, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.211 with standard deviation 0.018. And the mean value of best solutions found was 0.151 (0. is the best) with standard deviation 0.037.", "error": "", "parent_id": "51233a15-64e4-4472-a6c2-002e86141bc1", "metadata": {"aucs": [0.2038714787711322, 0.23624505235098336, 0.19339118648434184], "final_y": [0.17767848145074808, 0.09879390448309545, 0.17758771569307583]}, "mutation_prompt": null}
{"id": "16c16b7a-da35-4051-b987-1fa5d66f218d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Changed initialization strategy\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slightly less aggressive adaptation\n        self.par = max(0.1, self.par - 0.007)  # Slightly more aggressive reduction\n        self.bandwidth = max(0.05, self.bandwidth - 0.01)  # Faster reduction of bandwidth", "name": "EnhancedAdaptiveHarmonySearch", "description": "Modified parameter adjustment strategy and harmony initialization to enhance adaptive tuning and diversity.", "configspace": "", "generation": 13, "fitness": 0.12009958895200346, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.120 with standard deviation 0.032. And the mean value of best solutions found was 1.564 (0. is the best) with standard deviation 1.166.", "error": "", "parent_id": "51233a15-64e4-4472-a6c2-002e86141bc1", "metadata": {"aucs": [0.11087732479738266, 0.08685151138466984, 0.16256993067395786], "final_y": [1.3814343409207588, 3.0744231568349774, 0.23634136982561219]}, "mutation_prompt": null}
{"id": "91ad06bf-74e1-4d47-b56a-71662a1c201b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.normal((lb[i] + ub[i]) / 2, (ub[i] - lb[i]) / 6)  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with dynamic bandwidth scaling for improved exploration-exploitation balance.", "configspace": "", "generation": 14, "fitness": 0.30685875292477066, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.307 with standard deviation 0.046. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "51233a15-64e4-4472-a6c2-002e86141bc1", "metadata": {"aucs": [0.2725811224390221, 0.37169240750802823, 0.2763027288272616], "final_y": [0.001385342800615515, 0.004226045196172438, 0.0014542869133139977]}, "mutation_prompt": null}
{"id": "2d76f7a5-76d2-4fd0-95f8-e251c555e995", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12\n        self.hmcr = 0.85\n        self.par = 0.35\n        self.bandwidth = 0.15\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.choice(np.argsort(fitness)[:5])  # Select from top harmonies\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.normal((lb[i] + ub[i]) / 2, (ub[i] - lb[i]) / 6)\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)\n        self.par = max(0.1, self.par - 0.005)\n        self.bandwidth = max(0.05, self.bandwidth * 0.98)  # Slightly more dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Refined Enhanced Adaptive Harmony Search with advanced memory selection and adaptive pitch adjustment for improved convergence.", "configspace": "", "generation": 15, "fitness": 0.13850864897835247, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.139 with standard deviation 0.054. And the mean value of best solutions found was 1.065 (0. is the best) with standard deviation 1.322.", "error": "", "parent_id": "91ad06bf-74e1-4d47-b56a-71662a1c201b", "metadata": {"aucs": [0.06705618624434273, 0.15117606059547517, 0.1972937000952395], "final_y": [2.930608492059234, 0.02666984330770836, 0.23686522267318974]}, "mutation_prompt": null}
{"id": "05fdab19-1cb3-4221-8b45-41c3571c1c59", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.normal((lb[i] + ub[i]) / 2, (ub[i] - lb[i]) / 6)  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.007)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "An improved adaptive strategy by adjusting pitch adjustment rate (PAR) decay for better convergence.", "configspace": "", "generation": 16, "fitness": 0.2374434855629506, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.237 with standard deviation 0.058. And the mean value of best solutions found was 0.099 (0. is the best) with standard deviation 0.093.", "error": "", "parent_id": "91ad06bf-74e1-4d47-b56a-71662a1c201b", "metadata": {"aucs": [0.26544727936328527, 0.15659508662512722, 0.29028809070043937], "final_y": [0.05457931801827885, 0.22749995211086563, 0.013480144326342989]}, "mutation_prompt": null}
{"id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with refined new harmony generation for improved convergence speed.", "configspace": "", "generation": 17, "fitness": 0.3078708395624937, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.308 with standard deviation 0.074. And the mean value of best solutions found was 0.006 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "91ad06bf-74e1-4d47-b56a-71662a1c201b", "metadata": {"aucs": [0.23732161839484234, 0.40998817146537725, 0.2763027288272616], "final_y": [0.01573769694040645, 0.0013629706656397551, 0.0014542869133139977]}, "mutation_prompt": null}
{"id": "6f6c3f35-e8fa-4f83-81a8-b6459bc95e8a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n            if eval_count % 50 == 0 and self.harmony_memory_size > 4:  # Reduce size periodically\n                self.harmony_memory_size -= 1\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Introduced a dynamic harmony memory size reduction technique to enhance diversity and convergence.", "configspace": "", "generation": 18, "fitness": 0.1921325637622331, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.192 with standard deviation 0.064. And the mean value of best solutions found was 0.678 (0. is the best) with standard deviation 0.890.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.21907930289478617, 0.10398662574664941, 0.2533317626452637], "final_y": [0.09142215069447217, 1.9363579869150538, 0.006813220076849026]}, "mutation_prompt": null}
{"id": "1c015028-9fcb-49e9-9ff8-67dc3a53439a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n            self.harmony_memory_size = min(self.harmony_memory_size + 1, 20)  # Dynamic memory size adjustment\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Refined Adaptive Harmony Search with dynamic adjustment of harmony memory size for enhanced exploration-exploitation balance.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 12 is out of bounds for axis 0 with size 12').", "error": "IndexError('index 12 is out of bounds for axis 0 with size 12')", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {}, "mutation_prompt": null}
{"id": "55d3758d-33a9-41e9-96e7-7d77b78f613b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() * 2 - 1) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i] + 0.1 * (ub[i] - lb[i]))\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Improved diversity and exploration using dynamic bandwidth and exploration enhancement.", "configspace": "", "generation": 20, "fitness": 0.22134171187045967, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.221 with standard deviation 0.068. And the mean value of best solutions found was 0.295 (0. is the best) with standard deviation 0.294.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.1413499814877366, 0.30728058582982587, 0.21539456829381654], "final_y": [0.7050018656256728, 0.028420399290157418, 0.15129007013757073]}, "mutation_prompt": null}
{"id": "e624e185-402e-4366-8a73-5bab499fe72d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters(best_fitness, new_fitness)\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self, best_fitness, new_fitness):\n        self.hmcr += 0.015 if new_fitness < best_fitness else -0.01  # Adaptive HMCR update\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with adaptive HMCR update using a performance-based feedback mechanism for improved convergence.", "configspace": "", "generation": 21, "fitness": 0.16880960441288215, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.169 with standard deviation 0.016. And the mean value of best solutions found was 0.576 (0. is the best) with standard deviation 0.415.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.1693168608792608, 0.14856185470316263, 0.188550097656223], "final_y": [0.29245834120348146, 1.1629620988616816, 0.2717425816225475]}, "mutation_prompt": null}
{"id": "b133947c-1b6e-4254-a916-39275bc46b79", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.02)  # Faster adaptation of HMCR\n        self.par = max(0.15, self.par - 0.004)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.98)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Improved parameter adaptation and harmony diversity to enhance convergence robustness.", "configspace": "", "generation": 22, "fitness": 0.08263785117302054, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.083 with standard deviation 0.016. And the mean value of best solutions found was 3.320 (0. is the best) with standard deviation 1.902.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.08651615241749411, 0.06086401350333559, 0.10053338759823194], "final_y": [2.4917152408734577, 5.949772836394409, 1.517652609683308]}, "mutation_prompt": null}
{"id": "bac1b048-2710-4201-b0d9-f2e2ee352ac1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Improved dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with improved bandwidth adjustment for better exploration-exploitation balance.", "configspace": "", "generation": 23, "fitness": 0.19404416274385017, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.194 with standard deviation 0.023. And the mean value of best solutions found was 0.301 (0. is the best) with standard deviation 0.168.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.2186227862798963, 0.20083538140748147, 0.16267432054417275], "final_y": [0.25070011078855686, 0.12477152897329298, 0.5265296438390534]}, "mutation_prompt": null}
{"id": "c03e26ad-cd70-4116-9312-12eb98385360", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i] + np.random.normal(0, 0.1)  # Added mutation\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Improve convergence by dynamically adjusting harmony memory and incorporating mutation strategy.", "configspace": "", "generation": 24, "fitness": 0.219500194605985, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.220 with standard deviation 0.017. And the mean value of best solutions found was 0.093 (0. is the best) with standard deviation 0.089.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.2242887770920402, 0.19658427460783823, 0.23762753211807652], "final_y": [0.05973416727704914, 0.21508974766220726, 0.004066795872948813]}, "mutation_prompt": null}
{"id": "c8b0bd8e-5cf4-4ce6-bd21-a7c83db52177", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr + 0.05:  # Adjusted HMCR for better exploration\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Improved Harmony Memory initialization and adaptive parameter tuning enhance the convergence and diversity balance.", "configspace": "", "generation": 25, "fitness": 0.19061539578089845, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.191 with standard deviation 0.023. And the mean value of best solutions found was 0.261 (0. is the best) with standard deviation 0.182.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.18536690388866017, 0.2204196813973256, 0.16605960205670955], "final_y": [0.06955715475137378, 0.20891579346963002, 0.505681447516439]}, "mutation_prompt": null}
{"id": "c100a166-11bb-4b21-93ff-a3f97ce46f5d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx] or eval_count % 10 == 0:  # Dynamic memory update strategy\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Improved convergence by introducing a dynamic memory update strategy based on iteration count.", "configspace": "", "generation": 26, "fitness": 0.15199117573656604, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.152 with standard deviation 0.023. And the mean value of best solutions found was 0.517 (0. is the best) with standard deviation 0.185.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.16384413665532893, 0.119403522315641, 0.17272586823872815], "final_y": [0.3984817972254666, 0.7778971140571249, 0.37313217831111567]}, "mutation_prompt": null}
{"id": "66da4476-61be-4dfd-ae02-6faae591a5e4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 16  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with increased harmony memory size for diversity.", "configspace": "", "generation": 27, "fitness": 0.16605812795394959, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.166 with standard deviation 0.059. And the mean value of best solutions found was 0.646 (0. is the best) with standard deviation 0.415.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.11685851337245157, 0.1329278254507109, 0.24838804503868628], "final_y": [1.0789242430211539, 0.7730803072553687, 0.08712356672062643]}, "mutation_prompt": null}
{"id": "4cb96596-fba5-471c-8834-0c1c482ee2dd", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * np.random.uniform(0.98, 1.0))  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Incorporate dynamic bandwidth adjustment to enhance exploration-exploitation balance during optimization.", "configspace": "", "generation": 28, "fitness": 0.15778145868977322, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.158 with standard deviation 0.042. And the mean value of best solutions found was 0.774 (0. is the best) with standard deviation 0.721.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.20817858414226775, 0.1592595053128547, 0.10590628661419721], "final_y": [0.1839758194349596, 0.3480384291660974, 1.7890346306319047]}, "mutation_prompt": null}
{"id": "66747fbd-cc9b-4ab1-afbf-f0ab74ca9a0a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.004)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with slightly improved pitch adjustment rate strategy for better solution refinement.", "configspace": "", "generation": 29, "fitness": 0.2069774825835741, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.207 with standard deviation 0.014. And the mean value of best solutions found was 0.159 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.1874412999334072, 0.21563818446389504, 0.21785296335342008], "final_y": [0.15864196654802382, 0.1762644671956902, 0.14078615635198782]}, "mutation_prompt": null}
{"id": "268054cc-6836-4449-a2eb-62caef44e72b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 14  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with dynamic adjustment to the harmony memory size for improved exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": 0.15422987528248203, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.154 with standard deviation 0.052. And the mean value of best solutions found was 0.832 (0. is the best) with standard deviation 0.656.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.12632218042201449, 0.22656499788079587, 0.10980244754463575], "final_y": [0.5577437778838605, 0.20239225718949777, 1.7372174751883944]}, "mutation_prompt": null}
{"id": "3790b6bd-a719-4343-aae0-98f57ec0fbc8", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters(new_fitness, best_fitness)  # Modified to feedback-driven adjustment\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self, new_fitness, best_fitness):\n        if new_fitness < best_fitness:\n            self.hmcr = min(1.0, self.hmcr + 0.01)  # Adjust HMCR based on feedback\n            self.par = max(0.1, self.par - 0.002)  # Adjust PAR slower to improve convergence\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with feedback-driven parameter tuning for improved exploration-exploitation balance.", "configspace": "", "generation": 31, "fitness": 0.2338525020194354, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.234 with standard deviation 0.038. And the mean value of best solutions found was 0.055 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.2359346002868884, 0.2793866747586595, 0.1862362310127582], "final_y": [0.0659505078076229, 0.046402316676060915, 0.051570094078451825]}, "mutation_prompt": null}
{"id": "dc97efbc-ddf8-4385-a002-372d3540271d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12\n        self.hmcr = 0.85\n        self.par = 0.35\n        self.bandwidth = 0.15\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        last_improvement = 0\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n                last_improvement = eval_count\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters(eval_count, last_improvement)\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self, eval_count, last_improvement):\n        improvement_gap = eval_count - last_improvement\n        self.hmcr = min(1.0, self.hmcr + 0.015 - 0.01 * (improvement_gap / self.budget))\n        self.par = max(0.1, self.par - 0.005 + 0.003 * (improvement_gap / self.budget))\n        self.bandwidth = max(0.05, self.bandwidth * (0.99 + 0.01 * (improvement_gap / self.budget)))", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with dynamic parameter adaptation based on current solution quality for improved convergence performance.", "configspace": "", "generation": 32, "fitness": 0.23275586492108977, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.233 with standard deviation 0.054. And the mean value of best solutions found was 0.035 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.23772142208509317, 0.16455098870909568, 0.2959951839690804], "final_y": [0.03689462619062995, 0.04036066589321376, 0.027321361421533776]}, "mutation_prompt": null}
{"id": "28af94a1-3fa6-465f-8d03-00705611e9ba", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.02)  # Modified adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Modified reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Improved parameter adaptation and diversity with stochastic adjustment.", "configspace": "", "generation": 33, "fitness": 0.14250772464332517, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.143 with standard deviation 0.034. And the mean value of best solutions found was 0.842 (0. is the best) with standard deviation 0.823.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.16550764130216966, 0.09387925764490246, 0.1681362749829034], "final_y": [0.41347016075193466, 1.993744941655417, 0.11871460863713626]}, "mutation_prompt": null}
{"id": "152ec3db-3d4d-4adc-838a-3f76eaa7073c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i]) + 0.1 * (np.random.rand() - 0.5) * (ub[i] - lb[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with hybrid mutation step for improved diversity.", "configspace": "", "generation": 34, "fitness": 0.24611097881393942, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.059. And the mean value of best solutions found was 0.028 (0. is the best) with standard deviation 0.024.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.2159935754095732, 0.32808340617327614, 0.19425595485896896], "final_y": [0.06184567434020109, 0.007267264844378627, 0.014145775277727724]}, "mutation_prompt": null}
{"id": "9eb0f196-bb9a-42a7-bbab-44bb420626e2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 14  # Increased memory size\n        self.hmcr = 0.9  # Increased Harmony Memory Considering Rate\n        self.par = 0.3   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.2  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adaptive_parameter_scaling()\n\n        return best_harmony, best_fitness\n\n    def _adaptive_parameter_scaling(self):\n        self.hmcr = min(1.0, self.hmcr + 0.02)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Slower reduction of PAR\n        self.bandwidth *= 0.98  # Enhanced dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Improved Enhanced Adaptive Harmony Search with adaptive parameter scaling and elite selection for better convergence.", "configspace": "", "generation": 35, "fitness": 0.08072154429526208, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.081 with standard deviation 0.027. And the mean value of best solutions found was 7.828 (0. is the best) with standard deviation 3.588.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.061177918493970584, 0.06148136936644777, 0.11950534502536792], "final_y": [10.319154310106454, 10.40961770823681, 2.753958500920661]}, "mutation_prompt": null}
{"id": "79ab06a8-4487-4da9-ac4c-4463638390f4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 14  # Increased memory size\n        self.hmcr = 0.9  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.3   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.1  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n                # Elitism: Ensure best harmony is always in memory\n                harmony_memory[\n                    np.argmax(fitness)\n                ] = best_harmony\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.02)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)\n        self.bandwidth = max(0.05, self.bandwidth * 0.98)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with dynamic parameter adjustment and elitism to improve exploration and exploitation balance.", "configspace": "", "generation": 36, "fitness": 0.23112248375395705, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.231 with standard deviation 0.012. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.072.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.23946488781963027, 0.23971931801147728, 0.2141832454307636], "final_y": [0.1679734666524527, 0.16919572635132496, 0.016602020433162626]}, "mutation_prompt": null}
{"id": "b71075bc-82c2-48e9-abc8-51b3c8cb788a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.choice(np.argsort(fitness)[:3])  # Select from best 3 harmonies\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with an adjusted harmony memory strategy for better exploitation and exploration balance.", "configspace": "", "generation": 37, "fitness": 0.14444160265339404, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.049. And the mean value of best solutions found was 1.342 (0. is the best) with standard deviation 1.307.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.20443665732820648, 0.14526909596110293, 0.08361905467087272], "final_y": [0.34992141874208854, 0.4874951029079604, 3.1896560142365376]}, "mutation_prompt": null}
{"id": "2d1b6a53-8813-47df-bf34-dabce6ff025c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i]) + ((best_harmony[i] - lb[i]) / (ub[i] - lb[i])) # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with dynamic harmony memory size and improved exploration balancing.", "configspace": "", "generation": 38, "fitness": 0.1609715644156385, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.161 with standard deviation 0.069. And the mean value of best solutions found was 1.903 (0. is the best) with standard deviation 2.153.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.07308394371647065, 0.2428548890773673, 0.16697586045307755], "final_y": [4.930758509455322, 0.11820615021729723, 0.6587670822461624]}, "mutation_prompt": null}
{"id": "6f84b614-d6f7-41a5-85d2-d3e3f7f8dd8d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 14  # Increased memory size for diversity\n        self.hmcr = 0.9  # Increased Harmony Memory Considering Rate\n        self.par = 0.3   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.1  # Decreased initial bandwidth for precision\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i]) \n            \n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.02)  # Faster adaptation of HMCR\n        self.par = max(0.05, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.02, self.bandwidth * 0.98)  # More dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Introducing adaptive bandwidth scaling and memory enhancement for improved convergence performance.", "configspace": "", "generation": 39, "fitness": 0.1957772939326348, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.196 with standard deviation 0.073. And the mean value of best solutions found was 0.690 (0. is the best) with standard deviation 0.621.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.28595153064186063, 0.1934130652261683, 0.10796728592987548], "final_y": [0.048187100673403704, 0.49212919581294173, 1.5311098133859427]}, "mutation_prompt": null}
{"id": "c2ee0aa7-8053-466d-ac29-6ee5ff87f498", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.2  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Refined Adaptive Harmony Search with increased exploration through dynamic bandwidth adjustment.", "configspace": "", "generation": 40, "fitness": 0.11339588993100198, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.113 with standard deviation 0.024. And the mean value of best solutions found was 1.810 (0. is the best) with standard deviation 0.804.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.10984195799826246, 0.0860408071740757, 0.1443049046206678], "final_y": [1.8054342384052358, 2.7977433722754026, 0.8276138360803414]}, "mutation_prompt": null}
{"id": "d6ae1f6e-e4d7-4c84-8903-ebe141b48adf", "solution": "import numpy as np\n\nclass EnhancedStochasticHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12\n        self.hmcr = 0.85\n        self.par = 0.35\n        self.bandwidth = 0.15\n        self.resample_rate = 0.1  # New stochastic resampling parameter\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])\n\n            new_harmony = self._stochastic_resample(new_harmony, lb, ub)\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)\n        self.par = max(0.1, self.par - 0.005)\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)\n\n    def _stochastic_resample(self, harmony, lb, ub):\n        for i in range(self.dim):\n            if np.random.rand() < self.resample_rate:\n                harmony[i] = np.random.uniform(lb[i], ub[i])\n        return harmony", "name": "EnhancedStochasticHarmonySearch", "description": "Enhanced Adaptive Harmony Search with stochastic resampling for improved balance between exploration and exploitation.", "configspace": "", "generation": 41, "fitness": 0.18974821617741897, "feedback": "The algorithm EnhancedStochasticHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.190 with standard deviation 0.068. And the mean value of best solutions found was 0.318 (0. is the best) with standard deviation 0.289.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.16920144847410656, 0.11894632381022785, 0.28109687624792246], "final_y": [0.20411756410131737, 0.7148211908919407, 0.03583542900706276]}, "mutation_prompt": null}
{"id": "c10660fa-f2ca-4160-8606-7ac84d695144", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.randn()) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with adaptive dynamic bandwidth scaling for refined exploration and exploitation balance.", "configspace": "", "generation": 42, "fitness": 0.2137936336876852, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.214 with standard deviation 0.016. And the mean value of best solutions found was 0.263 (0. is the best) with standard deviation 0.118.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.19190678832189711, 0.22617600855259967, 0.22329810418855878], "final_y": [0.42680377970676525, 0.1526312270640344, 0.2100747419035239]}, "mutation_prompt": null}
{"id": "ac7bbe02-87fa-493b-b0af-1cf1f4de3a08", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * np.tanh(np.random.rand() - 0.5) * (ub[i] - lb[i])  # Used tanh for diversity control\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with refined memory consideration and diversity control for improved convergence.", "configspace": "", "generation": 43, "fitness": 0.19711072164710539, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.197 with standard deviation 0.015. And the mean value of best solutions found was 0.402 (0. is the best) with standard deviation 0.070.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.21567752241982907, 0.19620554564930648, 0.17944909687218058], "final_y": [0.30612244951620415, 0.4304416336849013, 0.47054608214053245]}, "mutation_prompt": null}
{"id": "3710aa33-e053-462c-b86d-3e297c887889", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.005)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.99)  # Dynamic bandwidth scaling\n        self.harmony_memory_size = max(8, self.harmony_memory_size + 1)  # Dynamic memory adaptation", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with dynamic memory adaptation for improved exploration-exploitation balance.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 12 is out of bounds for axis 0 with size 12').", "error": "IndexError('index 12 is out of bounds for axis 0 with size 12')", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {}, "mutation_prompt": null}
{"id": "8d1a474c-50b8-4c8e-a302-cfdd110e3a17", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.02)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Slower reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.98)  # Dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with improved parameter dynamics for faster convergence and better solution quality.", "configspace": "", "generation": 45, "fitness": 0.15807208459503622, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.158 with standard deviation 0.044. And the mean value of best solutions found was 0.758 (0. is the best) with standard deviation 0.772.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.09711289885239527, 0.18104750707641049, 0.19605584785630292], "final_y": [1.8476820180498772, 0.25906570411999286, 0.16637405458095106]}, "mutation_prompt": null}
{"id": "9e50c6fe-31d7-4f27-a4ab-4d4a2506e879", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Increased memory size\n        self.hmcr = 0.85  # Adjusted Harmony Memory Considering Rate\n        self.par = 0.35   # Adjusted Pitch Adjustment Rate\n        self.bandwidth = 0.15  # Increased bandwidth for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.007)  # Enhanced dynamic pitch adjustment\n        self.bandwidth = max(0.07, self.bandwidth * 0.98)  # Enhanced dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with dynamic pitch adjustment and enhanced diversity strategy.", "configspace": "", "generation": 46, "fitness": 0.2606057192633598, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.261 with standard deviation 0.040. And the mean value of best solutions found was 0.030 (0. is the best) with standard deviation 0.021.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.20408516690509804, 0.2964789063158709, 0.28125308456911047], "final_y": [0.05835460006284004, 0.024820039770481923, 0.007240301341902709]}, "mutation_prompt": null}
{"id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Refined Enhanced Adaptive Harmony Search with adaptive parameter adjustment and diversity control for improved exploration-exploitation balance.", "configspace": "", "generation": 47, "fitness": 0.3098029602439509, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.310 with standard deviation 0.091. And the mean value of best solutions found was 0.008 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "4d8f6ae1-0a07-4984-8bda-82607667b138", "metadata": {"aucs": [0.37739248582986873, 0.3710215066745345, 0.18099488822744947], "final_y": [0.0021471733236450075, 0.0034151699231131727, 0.017521694200005575]}, "mutation_prompt": null}
{"id": "91f70256-9854-47a6-b5e8-ae8fdda64ab4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributors = np.random.choice(self.harmony_memory_size, 2, replace=False)\n                    new_harmony[i] = np.mean(harmony_memory[contributors, i])  # Consider multiple contributors\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Optimized Harmony Search with enhanced diversity through adaptive memory consideration.", "configspace": "", "generation": 48, "fitness": 0.12809263600710105, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.128 with standard deviation 0.041. And the mean value of best solutions found was 2.040 (0. is the best) with standard deviation 1.122.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.10431866282871938, 0.09380339452801634, 0.1861558506645674], "final_y": [2.5092310071409987, 3.1169845743054365, 0.4928271630500313]}, "mutation_prompt": null}
{"id": "8572c6a2-91cc-43bc-b062-aae0916c14cb", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * (0.995 if np.random.rand() > 0.5 else 1.005))  # Strategic dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Refined Enhanced Adaptive Harmony Search with strategic dynamic bandwidth scaling for improved solution quality.", "configspace": "", "generation": 49, "fitness": 0.1810849717021058, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.181 with standard deviation 0.044. And the mean value of best solutions found was 0.561 (0. is the best) with standard deviation 0.323.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.18525036879122903, 0.23330779517466405, 0.12469675114042433], "final_y": [0.595619566965816, 0.1487364069595949, 0.9373889683092828]}, "mutation_prompt": null}
{"id": "a5e31d9a-648f-47ae-b733-f2f7da5cb4f8", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters(best_fitness, new_fitness)\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self, best_fitness, new_fitness):\n        self.hmcr = min(1.0, self.hmcr + 0.01) if new_fitness < best_fitness else max(0.8, self.hmcr - 0.01)\n        self.par = max(0.1, self.par - 0.01)\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with dynamic exploration-exploitation adjustment based on performance feedback.", "configspace": "", "generation": 50, "fitness": 0.21149277610219908, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.211 with standard deviation 0.049. And the mean value of best solutions found was 0.229 (0. is the best) with standard deviation 0.114.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.2807036361686346, 0.18003498491095338, 0.17373970722700927], "final_y": [0.06869463146009126, 0.3257409170298496, 0.2928001839436069]}, "mutation_prompt": null}
{"id": "fc2485c4-9507-4a8e-862f-f01cf2a6bdc8", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12  # Reduced memory size for quicker adaptation\n        self.hmcr = 0.92  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.008)  # Slightly increased reduction rate of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "A refined Enhanced Adaptive Harmony Search with tighter parameter adaptation and reduced memory size for improved convergence and robustness.", "configspace": "", "generation": 51, "fitness": 0.19388501826305102, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.194 with standard deviation 0.053. And the mean value of best solutions found was 0.377 (0. is the best) with standard deviation 0.280.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.12621813495180845, 0.20005952641198277, 0.2553773934253618], "final_y": [0.7533632489371995, 0.2958302101911482, 0.08079717681079301]}, "mutation_prompt": null}
{"id": "a49852c1-d810-4315-8766-8651546bbd66", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling\n        self.harmony_memory_size = min(20, self.harmony_memory_size + 1)  # Dynamic adjustment of harmony memory size", "name": "EnhancedAdaptiveHarmonySearch", "description": "Refined Enhanced Adaptive Harmony Search with improved balance between exploration and exploitation using dynamic harmony memory size.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 15 is out of bounds for axis 0 with size 15').", "error": "IndexError('index 15 is out of bounds for axis 0 with size 15')", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {}, "mutation_prompt": null}
{"id": "bd113d14-fe8a-43ed-a387-92a7f2e290d5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10 + dim // 2  # Adaptive memory size based on problem dimension\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3   # Pitch Adjustment Rate\n        self.bandwidth = 0.2 / np.sqrt(dim)  # Dynamic bandwidth scaling for dimensional consistency\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters(eval_count)\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self, eval_count):\n        self.hmcr = min(1.0, self.hmcr + 0.005 * (eval_count / self.budget))  # Adaptive HMCR increment\n        self.par = max(0.1, self.par - 0.005 * (eval_count / self.budget))  # Adaptive PAR decrement\n        self.bandwidth = max(0.01, self.bandwidth * 0.99)  # Continuous bandwidth reduction", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Harmony Search leveraging adaptive memory size and dynamic bandwidth scaling for better solution quality.", "configspace": "", "generation": 53, "fitness": 0.13249244783660563, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.132 with standard deviation 0.077. And the mean value of best solutions found was 5.201 (0. is the best) with standard deviation 5.903.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.04473901870290997, 0.23157500110697382, 0.1211633236999331], "final_y": [13.479753187472205, 0.1353697931704956, 1.9875966158442793]}, "mutation_prompt": null}
{"id": "3f2c8141-0955-4d66-8ee1-bb52909129bb", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters(best_fitness, new_fitness)\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self, best_fitness, new_fitness):\n        improvement = abs(best_fitness - new_fitness) / (abs(best_fitness) + np.finfo(float).eps)\n        self.hmcr = min(1.0, self.hmcr + 0.01 * improvement)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01 * improvement)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * (0.995 + 0.005 * improvement))  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Improved exploration-exploitation balance by dynamically adjusting parameters based on performance variations.", "configspace": "", "generation": 54, "fitness": 0.12641768241300053, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.126 with standard deviation 0.036. And the mean value of best solutions found was 1.148 (0. is the best) with standard deviation 0.808.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.08973536236808355, 0.11500402830489231, 0.1745136565660257], "final_y": [2.185298294405583, 1.04403923183267, 0.2144740442767743]}, "mutation_prompt": null}
{"id": "fe86ac25-0ae2-4f5b-a368-b1e279a6b05e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n            self.harmony_memory_size = min(30, self.harmony_memory_size + 1)  # Dynamic harmony memory size adjustment\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with dynamically adjusted harmony memory size for better exploration-exploitation balance.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 15 is out of bounds for axis 0 with size 15').", "error": "IndexError('index 15 is out of bounds for axis 0 with size 15')", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {}, "mutation_prompt": null}
{"id": "ec23be52-53c5-48cc-90fe-3890961a8dcf", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters(fitness)\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self, fitness):\n        diversity = np.std(fitness)\n        self.hmcr = min(1.0, self.hmcr + 0.01 * diversity)  # Adjust HMCR based on diversity\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with dynamic diversity control and feedback mechanism for parameter adjustment.", "configspace": "", "generation": 56, "fitness": 0.08203634406091631, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.082 with standard deviation 0.030. And the mean value of best solutions found was 5.308 (0. is the best) with standard deviation 3.107.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.052952801568716845, 0.06951499196526179, 0.1236412386487703], "final_y": [9.167617734245646, 5.19614123658298, 1.5590062970065708]}, "mutation_prompt": null}
{"id": "ca3baa8a-85c2-4c65-b1b9-711c27ed45a0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  \n        self.hmcr = 0.9  \n        self.par = 0.3   \n        self.bandwidth = 0.1  \n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.02)  # Faster adaptation of HMCR\n        self.par = max(0.05, self.par - 0.02)  # More aggressive reduction of PAR\n        self.bandwidth = max(0.03, self.bandwidth * 0.99)  # Aggressive dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Optimized Enhanced Adaptive Harmony Search with improved parameter adjustment rates for better convergence and solution accuracy.", "configspace": "", "generation": 57, "fitness": 0.12574140464570616, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.126 with standard deviation 0.050. And the mean value of best solutions found was 2.366 (0. is the best) with standard deviation 1.731.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.09664116892612995, 0.0841973350570876, 0.19638570995390092], "final_y": [2.2308877516328183, 4.549762642256413, 0.316818603879283]}, "mutation_prompt": null}
{"id": "3f644765-9b7d-413c-99e9-baaf93c93687", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n            fitness = np.apply_along_axis(func, 1, harmony_memory)  # Change: Re-evaluated fitness with stochastic ranking\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Improved diversity by refining fitness evaluation strategy using stochastic ranking within Enhanced Adaptive Harmony Search.", "configspace": "", "generation": 58, "fitness": 0.05728588337817856, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.057 with standard deviation 0.017. And the mean value of best solutions found was 11.459 (0. is the best) with standard deviation 3.781.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.04101073916853293, 0.050540280715418495, 0.08030663025058427], "final_y": [14.85475145573854, 13.33798339480558, 6.183233929095188]}, "mutation_prompt": null}
{"id": "f02b1953-e301-4afd-af87-0012c45c8540", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * (0.995 if np.random.rand() < 0.5 else 1.005))  # Dual-bandwidth adjustment", "name": "EnhancedAdaptiveHarmonySearch", "description": "EnhancedAdaptiveHarmonySearch with dual-bandwidth adjustment for improved convergence by utilizing two separate band modifications.", "configspace": "", "generation": 59, "fitness": 0.1877822177263596, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.188 with standard deviation 0.058. And the mean value of best solutions found was 0.359 (0. is the best) with standard deviation 0.307.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.24686309423842112, 0.20674128127357339, 0.10974227766708433], "final_y": [0.10903114343521986, 0.17692170314739833, 0.7916328454042874]}, "mutation_prompt": null}
{"id": "3382723a-921a-4a93-81b7-ab5918a9da3b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n            if eval_count % (self.budget // 10) == 0:  # Dynamically adjust harmony memory size\n                self.harmony_memory_size = min(30, self.harmony_memory_size + 1)\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with dynamic memory size adjustment for improved adaptation and convergence.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 15 is out of bounds for axis 0 with size 15').", "error": "IndexError('index 15 is out of bounds for axis 0 with size 15')", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {}, "mutation_prompt": null}
{"id": "d3121776-bd8c-42a2-ad59-cb936d33aa3a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with optimized initial harmony memory distribution for improved exploration.", "configspace": "", "generation": 61, "fitness": 0.18939376686422746, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.189 with standard deviation 0.049. And the mean value of best solutions found was 0.286 (0. is the best) with standard deviation 0.158.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.25829937757393906, 0.16362522601449225, 0.14625669700425104], "final_y": [0.09187534456439253, 0.2869366654162406, 0.4777981765862685]}, "mutation_prompt": null}
{"id": "53e082ed-af02-43b5-ba4d-b6d13cb41c56", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 20  # Increased memory size for more solutions\n        self.hmcr = 0.85  # Slightly adjusted HMCR for exploration balance\n        self.par = 0.2   # Further reduced PAR for enhanced exploitation\n        self.bandwidth = 0.15  # Increased bandwidth for adaptive exploration\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.randn() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.02)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.015)  # More gradual reduction of PAR\n        self.bandwidth = max(0.1, self.bandwidth * 0.99)  # Dynamic bandwidth adjustment", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Harmony Search with dynamic population variance, adaptive learning, and custom convergence control for better accuracy and robustness.", "configspace": "", "generation": 62, "fitness": 0.12511512914727255, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.125 with standard deviation 0.017. And the mean value of best solutions found was 2.087 (0. is the best) with standard deviation 1.211.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.12371252416798617, 0.1044619531322567, 0.1471709101415748], "final_y": [2.2130998155701898, 3.5026966319932313, 0.545330836861265]}, "mutation_prompt": null}
{"id": "2252a84e-04d9-40e2-a0fc-270551e698a1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling\n        self.harmony_memory_size = min(20, self.harmony_memory_size + 1)  # Increasing memory size over time", "name": "EnhancedAdaptiveHarmonySearch", "description": "Refined Enhanced Adaptive Harmony Search with adaptive parameter adjustment and dynamic memory update for improved exploration-exploitation balance.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 15 is out of bounds for axis 0 with size 15').", "error": "IndexError('index 15 is out of bounds for axis 0 with size 15')", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {}, "mutation_prompt": null}
{"id": "a6bcd5f5-b2d5-4ca2-8db4-77d74f8f4024", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.92  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.005)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Modified Enhanced Adaptive Harmony Search with improved parameter adaptation for enhanced convergence balance.", "configspace": "", "generation": 64, "fitness": 0.07899094572953402, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.079 with standard deviation 0.024. And the mean value of best solutions found was 5.178 (0. is the best) with standard deviation 3.045.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.052952801568716845, 0.07398461845028836, 0.11003541716959686], "final_y": [9.167617734245646, 4.584747287711858, 1.7804861823777787]}, "mutation_prompt": null}
{"id": "677d38b6-3dec-4278-aec1-cb20e5f8cbec", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth - 0.001)  # Slower dynamic bandwidth scaling with linear decrement", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with adaptive bandwidth adjustment for improved exploitation in optimization.", "configspace": "", "generation": 65, "fitness": 0.12524582904913176, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.125 with standard deviation 0.033. And the mean value of best solutions found was 1.359 (0. is the best) with standard deviation 0.624.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.10443409454210673, 0.0995123880429215, 0.17179100456236707], "final_y": [1.4104312083661414, 2.09561549221059, 0.5702119989049393]}, "mutation_prompt": null}
{"id": "e9cba58b-ac1c-4f2d-8143-65eb18738b3a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * np.random.normal() * (ub[i] - lb[i])  # Use normal distribution for bandwidth\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995 + 0.001)  # Dynamic increase in bandwidth", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced exploitation with dynamic bandwidth and memory competition to improve convergence.", "configspace": "", "generation": 66, "fitness": 0.16883661981379863, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.169 with standard deviation 0.012. And the mean value of best solutions found was 0.443 (0. is the best) with standard deviation 0.154.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.18572780530019228, 0.16212927449448344, 0.1586527796467202], "final_y": [0.2629579121430999, 0.6382240678783311, 0.42821784026376347]}, "mutation_prompt": null}
{"id": "b5a81aa2-b97a-4b01-b6a1-2888e8a072dc", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15\n        self.hmcr = 0.9\n        self.par = 0.3\n        self.bandwidth = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    # Changed the selection mechanism to stochastic selection\n                    contributor = np.random.choice(np.arange(self.harmony_memory_size), p=fitness/fitness.sum())\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        # Introduced dynamic band adjustment\n                        dynamic_bandwidth = self.bandwidth * (1 - eval_count/self.budget)\n                        new_harmony[i] += dynamic_bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)\n        self.par = max(0.1, self.par - 0.01)\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)", "name": "EnhancedAdaptiveHarmonySearch", "description": "EnhancedAdaptiveHarmonySearch with dynamic band adjustment and stochastic selection to improve exploration-exploitation balance.", "configspace": "", "generation": 67, "fitness": 0.16736661417703924, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.167 with standard deviation 0.054. And the mean value of best solutions found was 1.055 (0. is the best) with standard deviation 0.805.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.24233837498077082, 0.11796014444282088, 0.14180132310752602], "final_y": [0.09409148300961237, 2.0642021891847273, 1.0072390788728516]}, "mutation_prompt": null}
{"id": "2d360795-9c24-41d7-8c8f-9c643506b7ae", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = min(0.15, self.bandwidth * 1.005)  # Adaptive bandwidth increase for improved exploration", "name": "EnhancedAdaptiveHarmonySearch", "description": "Refined Enhanced Adaptive Harmony Search with improved exploration by adaptive bandwidth increase for better global search capability.", "configspace": "", "generation": 68, "fitness": 0.24608944147651504, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.024. And the mean value of best solutions found was 0.067 (0. is the best) with standard deviation 0.025.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.24029409161299176, 0.27747573511708745, 0.22049849769946595], "final_y": [0.08939152914167836, 0.031457362083126314, 0.07974215691009202]}, "mutation_prompt": null}
{"id": "89b46e04-9b04-4f17-8b25-40f67e22c9cc", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.02)  # Slightly faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with slightly adjusted parameter adaptation for improved performance.", "configspace": "", "generation": 69, "fitness": 0.12893029458864577, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.129 with standard deviation 0.039. And the mean value of best solutions found was 1.316 (0. is the best) with standard deviation 0.853.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.10458443697487219, 0.09804974997839311, 0.184156696812672], "final_y": [1.3132142209650202, 2.362958597167818, 0.27274397347199564]}, "mutation_prompt": null}
{"id": "a16d567a-2f4d-430c-9f1c-cdbefc1aed86", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 20  # Changed memory size for better exploration\n        self.hmcr = 0.92  # Adjusted HMCR for improved solution diversity\n        self.par = 0.25   # Modified PAR for balanced exploration and exploitation\n        self.bandwidth = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)\n        self.par = max(0.1, self.par - 0.01)\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)", "name": "EnhancedAdaptiveHarmonySearch", "description": "Improved Adaptive Harmony Search with dynamic memory consideration and refined parameter tuning for enhanced optimization efficiency.", "configspace": "", "generation": 70, "fitness": 0.1869431438825664, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.187 with standard deviation 0.047. And the mean value of best solutions found was 0.632 (0. is the best) with standard deviation 0.606.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.2171847128406793, 0.2226338927972985, 0.12101082600972135], "final_y": [0.25462383265381844, 0.15388015180058756, 1.4869363200232844]}, "mutation_prompt": null}
{"id": "a1df3098-3008-486d-8316-ad9261729fe9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 20  # Increased memory size for genetic diversity\n        self.hmcr = 0.85  # Slightly adjusted HMCR for improved convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Faster adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Fine-tuned Enhanced Adaptive Harmony Search with improved parameter adaptation and increased harmony diversity for better solution exploration.", "configspace": "", "generation": 71, "fitness": 0.12460321162273813, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.125 with standard deviation 0.022. And the mean value of best solutions found was 1.592 (0. is the best) with standard deviation 0.734.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.10494919920343937, 0.155767046185728, 0.11309338947904701], "final_y": [2.162229818393475, 0.5552590514770436, 2.0574056647584205]}, "mutation_prompt": null}
{"id": "9f06b11a-51b1-46c4-93cc-fddb0cd4a835", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.02)  # Slower adaptation of HMCR\n        self.bandwidth = max(0.05, self.bandwidth * 0.998)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced parameter adjustment and adaptive memory update to improve exploration-exploitation balance.", "configspace": "", "generation": 72, "fitness": 0.14463771016028795, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.145 with standard deviation 0.027. And the mean value of best solutions found was 0.637 (0. is the best) with standard deviation 0.382.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.17169655544670936, 0.10787948180680751, 0.154337093227347], "final_y": [0.465323286051876, 1.1666415474162226, 0.2802084990983176]}, "mutation_prompt": null}
{"id": "52b15139-0e14-4f8d-9b6b-97306da9ad37", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 20  # Adjusted memory size for better exploration\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.02)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Harmony Search with dynamic memory size adjustment and improved parameter fine-tuning for better optimization.", "configspace": "", "generation": 73, "fitness": 0.19463700947543747, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.195 with standard deviation 0.040. And the mean value of best solutions found was 0.246 (0. is the best) with standard deviation 0.170.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.2515758700505685, 0.16444908755679932, 0.16788607081894458], "final_y": [0.011322151639587915, 0.40750885443752294, 0.3179582374286193]}, "mutation_prompt": null}
{"id": "7086532d-80fd-47bf-b093-14a53fed1004", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub) + np.random.normal(0, 0.01, self.dim)  # Added Gaussian noise\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Introduced diversity boosting by adding Gaussian noise for more varied exploration in the harmony memory.", "configspace": "", "generation": 74, "fitness": 0.1200114203310807, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.120 with standard deviation 0.022. And the mean value of best solutions found was 1.587 (0. is the best) with standard deviation 0.848.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.13704238530822, 0.08920138609651229, 0.1337904895885098], "final_y": [0.8628782155664335, 2.7773281126704354, 1.120513008106865]}, "mutation_prompt": null}
{"id": "1ada9672-bf27-4a94-b250-4bd2b160e0f3", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * (0.995 + 0.0005 * (1 - np.var(fitness))))  # Memory-based bandwidth adjustment", "name": "EnhancedAdaptiveHarmonySearch", "description": "Introduced memory consideration for bandwidth adjustment to improve local search adaptability. ", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'fitness' is not defined\").", "error": "NameError(\"name 'fitness' is not defined\")", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {}, "mutation_prompt": null}
{"id": "73f600c3-ad60-4d71-bace-6779b21fea5d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 20  # Increased memory size further for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i] - 0.1 * (ub[i] - lb[i]), ub[i] + 0.1 * (ub[i] - lb[i]))  # Enhanced exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with refined exploration capabilities for improved convergence.", "configspace": "", "generation": 76, "fitness": 0.1858453158295115, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.186 with standard deviation 0.074. And the mean value of best solutions found was 1.301 (0. is the best) with standard deviation 1.703.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.26261582027691666, 0.2081626941454633, 0.08675743306615458], "final_y": [0.04905748198006789, 0.1448896905921129, 3.708528395801902]}, "mutation_prompt": null}
{"id": "fce2aa05-69ed-4ee3-b21f-be8c5e1cd063", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.992)  # Adaptive dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced solution diversification via adaptive dynamic bandwidth scaling for refined exploration-exploitation equilibrium.", "configspace": "", "generation": 77, "fitness": 0.10749443888227221, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.107 with standard deviation 0.013. And the mean value of best solutions found was 2.183 (0. is the best) with standard deviation 0.885.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.11355388537225497, 0.08960847223955204, 0.11932095903500961], "final_y": [1.6334554254108224, 3.4315804181343017, 1.4832753034837522]}, "mutation_prompt": null}
{"id": "f4c9d286-232e-49a8-8409-df4eaeb75ad7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters(eval_count)  # Adjust parameters based on evaluations\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self, eval_count):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling\n        if eval_count % 20 == 0:\n            self.harmony_memory_size = min(30, self.harmony_memory_size + 1)  # Increase memory size", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with dynamic memory size adjustment for diverse exploration.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 15 is out of bounds for axis 0 with size 15').", "error": "IndexError('index 15 is out of bounds for axis 0 with size 15')", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {}, "mutation_prompt": null}
{"id": "d2a40698-9532-4efb-bc18-e039dd5fc78e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.02)  # Slightly faster reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Refinement of Enhanced Adaptive Harmony Search with modified parameter adjustment for improved adaptability and convergence.", "configspace": "", "generation": 79, "fitness": 0.15143049105520254, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.151 with standard deviation 0.025. And the mean value of best solutions found was 0.416 (0. is the best) with standard deviation 0.176.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.12102235121172378, 0.1831985312688318, 0.15007059068505202], "final_y": [0.5043947123645728, 0.17060345772776297, 0.5733195966335771]}, "mutation_prompt": null}
{"id": "4887321b-d6d7-43d7-9477-b67d189f66a1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with refined selective memory update strategy for improved convergence.", "configspace": "", "generation": 80, "fitness": 0.12434753834172356, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.124 with standard deviation 0.033. And the mean value of best solutions found was 1.368 (0. is the best) with standard deviation 0.791.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.10458443697487219, 0.09804974997839311, 0.17040842807190537], "final_y": [1.3132142209650202, 2.362958597167818, 0.42878540563551676]}, "mutation_prompt": null}
{"id": "ce0bd668-44fa-48f8-9ec5-55b9dd6460be", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(max(1, self.harmony_memory_size // 2))  # Elite selection\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n            self.harmony_memory_size = min(30, self.harmony_memory_size + 1)  # Dynamic memory size\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with dynamic memory size and elite selection for improved convergence.", "configspace": "", "generation": 81, "fitness": 0.1284194491408124, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.128 with standard deviation 0.010. And the mean value of best solutions found was 0.946 (0. is the best) with standard deviation 0.306.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.1271797637499713, 0.11656235360542244, 0.1415162300670435], "final_y": [1.0140146462194841, 1.28123124813953, 0.5417348060191928]}, "mutation_prompt": null}
{"id": "6d7886bd-387b-4a05-a241-275d32935a8b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15\n        self.hmcr = 0.9\n        self.par = 0.3\n        self.bandwidth = 0.1\n        self.success_rate_threshold = 0.2\n        self.adaptive_factor = 0.01\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        success_count = 0\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n                success_count += 1\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            if eval_count % self.harmony_memory_size == 0:\n                self._adjust_parameters(success_count / self.harmony_memory_size)\n                success_count = 0\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self, success_rate):\n        if success_rate < self.success_rate_threshold:\n            self.hmcr = min(1.0, self.hmcr + self.adaptive_factor)\n            self.par = max(0.1, self.par - self.adaptive_factor)\n            self.bandwidth = max(0.05, self.bandwidth * 0.995)\n        else:\n            self.hmcr = max(0.8, self.hmcr - self.adaptive_factor)\n            self.par = min(0.5, self.par + self.adaptive_factor)\n            self.bandwidth = min(0.2, self.bandwidth * 1.005)", "name": "EnhancedAdaptiveHarmonySearchV2", "description": "Enhanced Harmony Search with dynamic success-based adaptation for improved convergence and solution diversity.", "configspace": "", "generation": 82, "fitness": 0.19495613126430714, "feedback": "The algorithm EnhancedAdaptiveHarmonySearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.195 with standard deviation 0.040. And the mean value of best solutions found was 0.358 (0. is the best) with standard deviation 0.362.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.24516170382085645, 0.1912066938989322, 0.1484999960731328], "final_y": [0.14061902106547733, 0.06539921016606155, 0.8682640323920872]}, "mutation_prompt": null}
{"id": "6e698799-985e-4e3d-905c-1bccd2341b1e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 16  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Improved Enhanced Adaptive Harmony Search with a slight increase in memory size for greater diversity.", "configspace": "", "generation": 83, "fitness": 0.15821945588570563, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.158 with standard deviation 0.032. And the mean value of best solutions found was 0.403 (0. is the best) with standard deviation 0.327.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.17184390528832394, 0.1135935375913828, 0.18922092477741015], "final_y": [0.18438809200246756, 0.8650602572467934, 0.15971322705500957]}, "mutation_prompt": null}
{"id": "edfc0603-f52a-478b-a854-74c4fa33e5e2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling\n        self.bandwidth *= 1.01  # Dynamic range scaling for enhanced adaptability", "name": "EnhancedAdaptiveHarmonySearch", "description": "Refined Enhanced Adaptive Harmony Search with adaptive parameter adjustment, diversity control, and dynamic range scaling for improved balance and convergence.", "configspace": "", "generation": 84, "fitness": 0.19252219774061433, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.193 with standard deviation 0.032. And the mean value of best solutions found was 0.566 (0. is the best) with standard deviation 0.334.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.14910255775522596, 0.2257906249527729, 0.20267341051384413], "final_y": [1.028712043735094, 0.25330211633077876, 0.41632239431842955]}, "mutation_prompt": null}
{"id": "18426168-9c45-4de6-adec-0e37891b3d1d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n            \n            # Incremental memory consideration\n            if eval_count % 20 == 0:\n                fitness += 0.01 * np.random.randn(self.harmony_memory_size)\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Improved Enhanced Adaptive Harmony Search with incremental memory consideration for enhanced convergence.", "configspace": "", "generation": 85, "fitness": 0.15757385935498028, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.158 with standard deviation 0.032. And the mean value of best solutions found was 0.757 (0. is the best) with standard deviation 0.716.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.1864468328963773, 0.11235142412355126, 0.1739233210450123], "final_y": [0.1633392466783258, 1.7637149976043769, 0.34347683963579323]}, "mutation_prompt": null}
{"id": "2b54ec25-9aa7-4aca-bd26-f78625e859a7", "solution": "import numpy as np\n\nclass QuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.alpha = 0.1  # Quantum rotation angle\n        self.beta = 0.9   # Collapse probability factor\n    \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        theta = np.random.uniform(0, np.pi, (self.population_size, self.dim))\n        population = np.zeros((self.population_size, self.dim))\n        \n        for i in range(self.population_size):\n            population[i] = lb + (ub - lb) * (np.sin(theta[i]) ** 2)\n        \n        fitness = np.apply_along_axis(func, 1, population)\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                theta[i] += self.alpha * (2 * np.pi * np.random.rand(self.dim) - np.pi)\n                new_population[i] = lb + (ub - lb) * (np.sin(theta[i]) ** 2)\n\n            if np.random.rand() < self.beta:\n                collapse_idx = np.random.randint(self.population_size)\n                theta[collapse_idx] = np.arctan2(np.sqrt(np.random.rand(self.dim)), np.ones(self.dim))\n                new_population[collapse_idx] = lb + (ub - lb) * (np.sin(theta[collapse_idx]) ** 2)\n\n            new_population = np.clip(new_population, lb, ub)\n            new_fitness = np.apply_along_axis(func, 1, new_population)\n            eval_count += self.population_size\n\n            for i in range(self.population_size):\n                if new_fitness[i] < fitness[i]:\n                    population[i] = new_population[i]\n                    fitness[i] = new_fitness[i]\n                    if new_fitness[i] < best_fitness:\n                        best_solution = new_population[i].copy()\n                        best_fitness = new_fitness[i]\n\n        return best_solution, best_fitness", "name": "QuantumInspiredEvolutionaryAlgorithm", "description": "Quantum-Inspired Evolutionary Algorithm using quantum rotation gates and position collapse mechanism to enhance exploration and exploitation in black box optimization.", "configspace": "", "generation": 86, "fitness": 0.15094931702018347, "feedback": "The algorithm QuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.151 with standard deviation 0.008. And the mean value of best solutions found was 0.814 (0. is the best) with standard deviation 0.368.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.14554486138994427, 0.16246219355482316, 0.144840896115783], "final_y": [1.318329772131684, 0.6699240679805644, 0.4525704884155842]}, "mutation_prompt": null}
{"id": "a238c521-3fab-4552-89cb-64ad1861a193", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.015)  # Slightly faster adaptation of HMCR\n        self.par = max(0.05, self.par - 0.02)  # Increased reduction rate of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Improved convergence of Enhanced Adaptive Harmony Search using refined parameter dynamics for better balance.", "configspace": "", "generation": 87, "fitness": 0.1854075423646575, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.185 with standard deviation 0.010. And the mean value of best solutions found was 0.498 (0. is the best) with standard deviation 0.175.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.17413438951950333, 0.1988769123410532, 0.183211325233416], "final_y": [0.7449344058530903, 0.370383184320758, 0.378211695506841]}, "mutation_prompt": null}
{"id": "f6346e59-a064-445c-b291-e8b918aa0f47", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.92  # Slightly increased HMCR for better convergence\n        self.par = 0.32   # Slightly increased PAR for more balanced exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Slightly increased HMCR and PAR for improved exploration and exploitation balance.", "configspace": "", "generation": 88, "fitness": 0.09162935625169495, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.092 with standard deviation 0.036. And the mean value of best solutions found was 4.103 (0. is the best) with standard deviation 2.604.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.0598596171822553, 0.07309855885895733, 0.14192989271387224], "final_y": [7.026335930125599, 4.581922652552613, 0.701873197233435]}, "mutation_prompt": null}
{"id": "5ba9c6a7-7438-4ca5-9ded-1b6768270174", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n            \n            # Dynamic adjustment of memory size\n            if eval_count % 10 == 0:\n                self.harmony_memory_size = min(30, self.harmony_memory_size + 1)\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "EnhancedAdaptiveHarmonySearch with dynamic memory adjustment and adaptive exploration-exploitation.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 15 is out of bounds for axis 0 with size 15').", "error": "IndexError('index 15 is out of bounds for axis 0 with size 15')", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {}, "mutation_prompt": null}
{"id": "2503ef62-645f-4b61-ab5a-e4e2acfca22c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.02)  # Slightly faster adaptation of HMCR\n        self.par = max(0.05, self.par - 0.02)  # More significant reduction of PAR\n        self.bandwidth = max(0.025, self.bandwidth * 0.99)  # Faster dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Further optimization through dynamic parameter tuning and enhanced local search strategy.", "configspace": "", "generation": 90, "fitness": 0.09047447255862857, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.090 with standard deviation 0.061. And the mean value of best solutions found was 7.396 (0. is the best) with standard deviation 5.341.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.04867798018415548, 0.045633924283812966, 0.1771115132079173], "final_y": [9.464051247828529, 12.65454802065932, 0.07037281500235781]}, "mutation_prompt": null}
{"id": "6e4c2820-1e8d-481c-965b-372e8128de1a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10 + dim  # Dynamic memory size based on problem dimension\n        self.hmcr = 0.85  # Slightly adjusted HMCR for exploration-exploitation balance\n        self.par = 0.35   # Modified PAR for better balance\n        self.bandwidth = 0.2  # Increased bandwidth for initial exploration\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters(eval_count)\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self, eval_count):\n        self.hmcr = min(1.0, self.hmcr + 0.01)\n        self.par = max(0.1, self.par - 0.01)\n        self.bandwidth = max(0.05, self.bandwidth * 0.99 + 0.001 * eval_count/self.budget)  # Adaptive diversification", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with dynamic memory size and adaptive diversification strategy for improved optimization.", "configspace": "", "generation": 91, "fitness": 0.10364827792755422, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.104 with standard deviation 0.033. And the mean value of best solutions found was 2.328 (0. is the best) with standard deviation 1.390.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.08421831855180617, 0.07711169027383069, 0.14961482495702583], "final_y": [2.5132924911055734, 3.930940993330658, 0.5403733825396463]}, "mutation_prompt": null}
{"id": "ae734113-8155-422a-b98b-f89146a73871", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling\n        if np.random.rand() < 0.05:  # Random chance to adjust memory size\n            self.harmony_memory_size = max(10, self.harmony_memory_size + np.random.choice([-1, 1]))", "name": "EnhancedAdaptiveHarmonySearch", "description": "Refined Enhanced Adaptive Harmony Search with dynamic harmony memory size adjustment for improved adaptability.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 16 is out of bounds for axis 0 with size 15').", "error": "IndexError('index 16 is out of bounds for axis 0 with size 15')", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {}, "mutation_prompt": null}
{"id": "3f101c5c-9ea8-4b73-98c9-0b73378f498c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters(eval_count / self.budget)\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self, eval_ratio):\n        self.hmcr = min(1.0, 0.9 + 0.1 * eval_ratio)  # Dynamic adaptation of HMCR based on evaluation ratio\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Improved Enhanced Adaptive Harmony Search using dynamic HMCR based on evaluation coverage to balance exploration and exploitation.", "configspace": "", "generation": 93, "fitness": 0.14543681633881847, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.145 with standard deviation 0.032. And the mean value of best solutions found was 0.683 (0. is the best) with standard deviation 0.525.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.12514675809705866, 0.12032221602739579, 0.19084147489200098], "final_y": [0.5018608178119313, 1.3976835851919702, 0.1504084632980186]}, "mutation_prompt": null}
{"id": "7f9de971-5a75-45f3-ac43-10c3194802ea", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 15  # Increased memory size for genetic diversity\n        self.hmcr = 0.9  # Slightly increased HMCR for better convergence\n        self.par = 0.3   # Reduced PAR for more exploitation\n        self.bandwidth = 0.1  # Reduced bandwidth to focus on exploitation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    contributor = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = harmony_memory[contributor, i]\n                    if np.random.rand() < self.par:\n                        new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n                else:\n                    new_harmony[i] = np.random.uniform(lb[i], ub[i])  # Adjusted exploration\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n            self.harmony_memory_size = min(30, self.harmony_memory_size + 1)  # Dynamic memory adjustment\n\n        return best_harmony, best_fitness\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01)  # Slower adaptation of HMCR\n        self.par = max(0.1, self.par - 0.01)  # Added more gradual reduction of PAR\n        self.bandwidth = max(0.05, self.bandwidth * 0.995)  # Slower dynamic bandwidth scaling", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with dynamic memory adjustment for improved performance.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 15 is out of bounds for axis 0 with size 15').", "error": "IndexError('index 15 is out of bounds for axis 0 with size 15')", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {}, "mutation_prompt": null}
{"id": "6aada7a1-4f8b-4702-abca-c6ef4ab49b6d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 20  # Increased memory size for genetic diversity\n        self.hmcr = 0.95  # Slightly increased HMCR for better convergence\n        self.par = 0.4   # Increased PAR for more exploration\n        self.bandwidth = 0.05  # Reduced bandwidth for fine-tuning\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            if np.random.rand() < 0.5:  # Introduce a dual strategy with probability\n                new_harmony = self._differential_evolution_step(harmony_memory, lb, ub, func)\n            else:\n                new_harmony = self._harmony_search_step(harmony_memory, lb, ub)\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _harmony_search_step(self, harmony_memory, lb, ub):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                contributor = np.random.randint(self.harmony_memory_size)\n                new_harmony[i] = harmony_memory[contributor, i]\n                if np.random.rand() < self.par:\n                    new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n            else:\n                new_harmony[i] = np.random.uniform(lb[i], ub[i])\n        return new_harmony\n\n    def _differential_evolution_step(self, harmony_memory, lb, ub, func):\n        idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n        a, b, c = harmony_memory[idxs]\n        F = 0.8  # Differential weight\n        trial = np.clip(a + F * (b - c), lb, ub)\n        return trial\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01) \n        self.par = max(0.2, self.par - 0.01)  # Adjusted more gradual reduction of PAR\n        self.bandwidth = max(0.01, self.bandwidth * 0.995)", "name": "EnhancedAdaptiveHarmonySearch", "description": "A Dual Strategy Enhanced Adaptive Harmony Search combining dynamic parameter adjustment and differential evolution techniques for efficient exploration-exploitation balance.", "configspace": "", "generation": 95, "fitness": 0.37860747707053594, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.379 with standard deviation 0.080. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "2d01a6a0-d4cf-45a4-a2e0-3a4acbc6a707", "metadata": {"aucs": [0.26619217637378134, 0.4393596905639582, 0.43027056427386823], "final_y": [0.0011954253110954649, 2.6932158139604384e-06, 2.496413423139983e-06]}, "mutation_prompt": null}
{"id": "70ea0b15-45bc-4139-b9d6-dbffdd9dba7d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 20  # Increased memory size for genetic diversity\n        self.hmcr = 0.95  # Slightly increased HMCR for better convergence\n        self.par = 0.4   # Increased PAR for more exploration\n        self.bandwidth = 0.05  # Reduced bandwidth for fine-tuning\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            if np.random.rand() < 0.5:  # Introduce a dual strategy with probability\n                new_harmony = self._differential_evolution_step(harmony_memory, lb, ub, func)\n            else:\n                new_harmony = self._harmony_search_step(harmony_memory, lb, ub)\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _harmony_search_step(self, harmony_memory, lb, ub):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                contributor = np.random.randint(self.harmony_memory_size)\n                new_harmony[i] = harmony_memory[contributor, i]\n                if np.random.rand() < self.par:\n                    new_harmony[i] += self.bandwidth * (np.random.rand() - 0.5) * (ub[i] - lb[i])\n            else:\n                new_harmony[i] = np.random.uniform(lb[i], ub[i])\n        return new_harmony\n\n    def _differential_evolution_step(self, harmony_memory, lb, ub, func):\n        idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n        a, b, c = harmony_memory[idxs]\n        F = np.random.uniform(0.6, 0.9)  # Dynamic differential weight\n        trial = np.clip(a + F * (b - c), lb, ub)\n        return trial\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01) \n        self.par = max(0.2, self.par - 0.02)  # Adjusted more gradual reduction of PAR\n        self.bandwidth = max(0.01, self.bandwidth * 0.995)", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with dynamic selection of differential weight and adaptive parameter tuning for improved performance.", "configspace": "", "generation": 96, "fitness": 0.3887226496784881, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.389 with standard deviation 0.027. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6aada7a1-4f8b-4702-abca-c6ef4ab49b6d", "metadata": {"aucs": [0.3509327994579907, 0.401602063315154, 0.41363308626231954], "final_y": [5.5037183764109854e-05, 1.615071396979854e-05, 2.916343649811748e-06]}, "mutation_prompt": null}
{"id": "6647ae35-c332-44f4-aa1f-d98287422d3d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 25  # Adjusted memory size for more genetic diversity\n        self.hmcr = 0.9  # Adjusted HMCR for exploration-exploitation balance\n        self.par = 0.5   # Adjusted PAR for increased exploration\n        self.bandwidth = 0.025  # Adjusted bandwidth for finer exploration\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            if np.random.rand() < 0.7:  # Enhanced probability towards DE strategy\n                new_harmony = self._differential_evolution_step(harmony_memory, lb, ub, func)\n            else:\n                new_harmony = self._harmony_search_step(harmony_memory, lb, ub)\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _harmony_search_step(self, harmony_memory, lb, ub):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                contributor = np.random.randint(self.harmony_memory_size)\n                new_harmony[i] = harmony_memory[contributor, i]\n                if np.random.rand() < self.par:\n                    new_harmony[i] += self.bandwidth * np.random.randn() * (ub[i] - lb[i])  # Gaussian mutation\n            else:\n                new_harmony[i] = np.random.uniform(lb[i], ub[i])\n        return new_harmony\n\n    def _differential_evolution_step(self, harmony_memory, lb, ub, func):\n        idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n        a, b, c = harmony_memory[idxs]\n        F = np.random.uniform(0.5, 0.8)  # Dynamic differential weight\n        trial = np.clip(a + F * (b - c), lb, ub)\n        return trial\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01) \n        self.par = max(0.25, self.par - 0.01)  # Adjusted more gradual reduction of PAR\n        self.bandwidth = max(0.01, self.bandwidth * 0.99)  # Slightly adjusted bandwidth reduction", "name": "EnhancedAdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with stochastic gradient-informed mutations and dynamic memory adaptation for improved exploration-exploitation balance.", "configspace": "", "generation": 97, "fitness": 0.4463217021001981, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.446 with standard deviation 0.027. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "70ea0b15-45bc-4139-b9d6-dbffdd9dba7d", "metadata": {"aucs": [0.4280595335789198, 0.48505003448475215, 0.42585553823692235], "final_y": [3.4777496751048102e-06, 1.2603440829731768e-06, 1.7066803649964487e-06]}, "mutation_prompt": null}
{"id": "73ba210d-c11f-48fe-a65b-0916527e6fb4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 25  # Adjusted memory size for more genetic diversity\n        self.hmcr = 0.9  # Adjusted HMCR for exploration-exploitation balance\n        self.par = 0.5   # Adjusted PAR for increased exploration\n        self.bandwidth = 0.025  # Adjusted bandwidth for finer exploration\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            if np.random.rand() < 0.6:  # Enhanced probability towards DE strategy\n                new_harmony = self._differential_evolution_step(harmony_memory, lb, ub, func)\n            else:\n                new_harmony = self._harmony_search_step(harmony_memory, lb, ub)\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _harmony_search_step(self, harmony_memory, lb, ub):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                contributor = np.random.randint(self.harmony_memory_size)\n                new_harmony[i] = harmony_memory[contributor, i]\n                if np.random.rand() < self.par:\n                    new_harmony[i] += self.bandwidth * np.random.randn() * (ub[i] - lb[i])  # Gaussian mutation\n            else:\n                new_harmony[i] = np.random.uniform(lb[i], ub[i])\n        return new_harmony\n\n    def _differential_evolution_step(self, harmony_memory, lb, ub, func):\n        idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n        a, b, c = harmony_memory[idxs]\n        F = np.random.uniform(0.6, 0.9)  # Dynamic differential weight\n        trial = np.clip(a + F * (b - c), lb, ub)\n        return trial\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01) \n        self.par = max(0.25, self.par - 0.01)  # Adjusted more gradual reduction of PAR\n        self.bandwidth = max(0.01, self.bandwidth * 0.99)  # Slightly adjusted bandwidth reduction", "name": "EnhancedAdaptiveHarmonySearch", "description": "Improved Enhanced Adaptive Harmony Search with adjusted mutation strategies for enhanced convergence speed and solution accuracy.", "configspace": "", "generation": 98, "fitness": 0.37051719371466213, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.371 with standard deviation 0.032. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6647ae35-c332-44f4-aa1f-d98287422d3d", "metadata": {"aucs": [0.40664558759256164, 0.37702630578261864, 0.32787968776880616], "final_y": [1.3957563594127848e-05, 2.431502715526689e-05, 0.0003701351298974813]}, "mutation_prompt": null}
{"id": "af93faf4-3fb6-4b66-807b-b82859ab8efa", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 25  # Adjusted memory size for more genetic diversity\n        self.hmcr = 0.9  # Adjusted HMCR for exploration-exploitation balance\n        self.par = 0.5   # Adjusted PAR for increased exploration\n        self.bandwidth = 0.025  # Adjusted bandwidth for finer exploration\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        harmony_memory = np.random.uniform(lb, ub, (self.harmony_memory_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, harmony_memory)\n        \n        eval_count = self.harmony_memory_size\n        best_idx = np.argmin(fitness)\n        best_harmony = harmony_memory[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while eval_count < self.budget:\n            if np.random.rand() < 0.7:  # Enhanced probability towards DE strategy\n                new_harmony = self._differential_evolution_step(harmony_memory, lb, ub, func)\n            else:\n                new_harmony = self._harmony_search_step(harmony_memory, lb, ub)\n\n            new_harmony = np.clip(new_harmony, lb, ub)\n            new_fitness = func(new_harmony)\n            eval_count += 1\n\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony.copy()\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(fitness)\n            if new_fitness < fitness[worst_idx]:\n                harmony_memory[worst_idx, :] = new_harmony\n                fitness[worst_idx] = new_fitness\n\n            self._adjust_parameters()\n\n        return best_harmony, best_fitness\n\n    def _harmony_search_step(self, harmony_memory, lb, ub):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                contributor = np.random.randint(self.harmony_memory_size)\n                new_harmony[i] = harmony_memory[contributor, i]\n                if np.random.rand() < self.par:\n                    new_harmony[i] += self.bandwidth * np.random.randn() * (ub[i] - lb[i]) * np.random.uniform(0.9, 1.1)  # Modified Gaussian mutation\n            else:\n                new_harmony[i] = np.random.uniform(lb[i], ub[i])\n        return new_harmony\n\n    def _differential_evolution_step(self, harmony_memory, lb, ub, func):\n        idxs = np.random.choice(self.harmony_memory_size, 3, replace=False)\n        a, b, c = harmony_memory[idxs]\n        F = np.random.uniform(0.5, 0.8)  # Dynamic differential weight\n        trial = np.clip(a + F * (b - c), lb, ub)\n        return trial\n\n    def _adjust_parameters(self):\n        self.hmcr = min(1.0, self.hmcr + 0.01) \n        self.par = max(0.25, self.par - 0.01)  # Adjusted more gradual reduction of PAR\n        self.bandwidth = max(0.01, self.bandwidth * 0.99)  # Slightly adjusted bandwidth reduction", "name": "EnhancedAdaptiveHarmonySearch", "description": "Modified bandwidth to introduce random fluctuation for adaptive exploration.", "configspace": "", "generation": 99, "fitness": 0.4030119968946715, "feedback": "The algorithm EnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.403 with standard deviation 0.032. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6647ae35-c332-44f4-aa1f-d98287422d3d", "metadata": {"aucs": [0.44563853274927745, 0.39435820918806297, 0.36903924874667415], "final_y": [7.37701749064033e-06, 9.040495857800995e-05, 4.736819897662732e-05]}, "mutation_prompt": null}
