{"id": "5a6504fc-1d60-4814-ba1d-502314d414dc", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.7  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), lower_bound, upper_bound)\n                \n                # Adaptive crossover rate\n                self.CR = np.random.rand()  # Randomly adapt crossover rate\n                \n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "A hybrid metaheuristic algorithm combining differential evolution with adaptive mutation and crossover strategies for efficient exploration and exploitation across varying dimensions.", "configspace": "", "generation": 0, "fitness": 0.6820121492668956, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.682 with standard deviation 0.032. And the mean value of best solutions found was 0.252 (0. is the best) with standard deviation 0.020.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6737381993196039, 0.6470764727336016, 0.7252217757474813], "final_y": [0.2625407614313444, 0.26892952507130063, 0.22397195912839085]}, "mutation_prompt": null}
{"id": "85b7746e-bbe4-4af5-b3bd-6c10f06a75a4", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.7  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.elite_size = max(1, dim // 10)  # Number of elite solutions to retain\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Sort population by fitness and select elites\n            elite_indices = np.argsort(fitness)[:self.elite_size]\n            elites = population[elite_indices]\n            \n            for i in range(self.population_size):\n                # Mutation with elite guidance\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                if i in elite_indices:\n                    # Guide elites with other elites\n                    x1 = x3 = elites[np.random.randint(0, self.elite_size)]\n                \n                mutant = np.clip(x1 + self.F * (x2 - x3), lower_bound, upper_bound)\n                \n                # Adaptive crossover rate\n                self.CR = np.random.rand()  # Randomly adapt crossover rate\n                \n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if evaluations >= self.budget:\n                    break\n            \n            # Dynamic population resizing to focus search\n            if evaluations % (self.budget // 10) == 0:\n                self.population_size = max(self.elite_size, int(self.population_size * 0.9))\n                population = np.concatenate((population[:self.population_size], elites))\n                fitness = np.array([func(ind) for ind in population])\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with dynamic population resizing and elitism for improved convergence and exploration-exploitation balance.", "configspace": "", "generation": 1, "fitness": 0.689650529766419, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.690 with standard deviation 0.030. And the mean value of best solutions found was 0.223 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "5a6504fc-1d60-4814-ba1d-502314d414dc", "metadata": {"aucs": [0.7318074401890411, 0.6756097803356217, 0.6615343687745946], "final_y": [0.2210254462367247, 0.22133231216646554, 0.22757335130974898]}, "mutation_prompt": null}
{"id": "94cce3e5-641f-4a89-9cd3-07c059523e77", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * (self.global_best_position - positions[i])\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Quantum-Inspired Particle Swarm Optimization with adaptive quantum potential fields for enhanced exploration and convergence.", "configspace": "", "generation": 2, "fitness": 0.9555559710620777, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.956 with standard deviation 0.026. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "85b7746e-bbe4-4af5-b3bd-6c10f06a75a4", "metadata": {"aucs": [0.9184248172145796, 0.9708307118127185, 0.9774123841589348], "final_y": [0.18213086900027764, 0.16748701793930076, 0.164857501670009]}, "mutation_prompt": null}
{"id": "0e56551b-e34b-4b07-9889-522ae4ae316d", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * (self.global_best_position - positions[i])\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * quantum_potential * np.random.rand()\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic learning factor for improved adaptability.", "configspace": "", "generation": 3, "fitness": 0.944117742078903, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.944 with standard deviation 0.039. And the mean value of best solutions found was 0.176 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "94cce3e5-641f-4a89-9cd3-07c059523e77", "metadata": {"aucs": [0.8889637149676096, 0.97759100246987, 0.9657985087992292], "final_y": [0.19496392643278182, 0.16558065079612672, 0.16626412723933892]}, "mutation_prompt": null}
{"id": "fc65dee0-9ed4-4d38-8b93-23ff9829ea7b", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.mutation_rate = 0.1  # Probability of mutation\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * (self.global_best_position - positions[i])\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * quantum_potential\n                \n                # Introduce mutation for better exploration\n                if np.random.rand() < self.mutation_rate:\n                    mutation = np.random.uniform(-1, 1, self.dim) * (upper_bound - lower_bound) * 0.1\n                    velocities[i] += mutation\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "EnhancedQuantumInspiredPSO", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic social learning and adaptive mutation for improved exploration and convergence.", "configspace": "", "generation": 4, "fitness": 0.9108289115367944, "feedback": "The algorithm EnhancedQuantumInspiredPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.911 with standard deviation 0.044. And the mean value of best solutions found was 0.188 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "94cce3e5-641f-4a89-9cd3-07c059523e77", "metadata": {"aucs": [0.8551518363541417, 0.9160021498489719, 0.9613327484072692], "final_y": [0.20790339526051693, 0.18229149435938596, 0.17256802719372133]}, "mutation_prompt": null}
{"id": "63fecfd7-5fd0-490d-8171-4e7443a5c9ec", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                self.alpha = 0.5 + 0.5 * (self.budget - evaluations) / self.budget  # Dynamic alpha adjustment\n                quantum_potential = self.alpha * (self.global_best_position - positions[i])\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced exploration by increasing quantum potential influence with dynamic alpha adjustment in Quantum-Inspired Particle Swarm Optimization.", "configspace": "", "generation": 5, "fitness": 0.8764855371325715, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.876 with standard deviation 0.100. And the mean value of best solutions found was 0.202 (0. is the best) with standard deviation 0.041.", "error": "", "parent_id": "94cce3e5-641f-4a89-9cd3-07c059523e77", "metadata": {"aucs": [0.7395932132862408, 0.9132228355808097, 0.9766405625306639], "final_y": [0.25984653355125353, 0.18187810791904713, 0.1648691653530142]}, "mutation_prompt": null}
{"id": "eef14f8a-91d6-4b5d-ba19-2c7e5b692954", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * (self.global_best_position - positions[i])\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n                \n                # Introduce adaptive mutation to enhance exploration\n                if np.random.rand() < 0.05:  # Mutation probability\n                    positions[i] = positions[i] + np.random.normal(0, 0.1, self.dim)\n          \n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with adaptive mutation to improve exploration and convergence. ", "configspace": "", "generation": 6, "fitness": 0.9492310193028185, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.949 with standard deviation 0.025. And the mean value of best solutions found was 0.173 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "94cce3e5-641f-4a89-9cd3-07c059523e77", "metadata": {"aucs": [0.9700870324214972, 0.9139661964128827, 0.9636398290740757], "final_y": [0.16486387351802823, 0.18236088570182474, 0.1712744240863101]}, "mutation_prompt": null}
{"id": "014cf00d-63ed-42cf-b58f-72fc6f6d1841", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * (self.global_best_position - positions[i])\n                self.beta = 2.0 - (1.5 * evaluations / self.budget)  # Dynamic adaptation\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic adaptation of the learning factor for improved convergence.", "configspace": "", "generation": 7, "fitness": 0.9389377366185846, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.939 with standard deviation 0.026. And the mean value of best solutions found was 0.177 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "94cce3e5-641f-4a89-9cd3-07c059523e77", "metadata": {"aucs": [0.9186369393741737, 0.9218165485022685, 0.9763597219793116], "final_y": [0.18190437262906478, 0.18529268854236391, 0.16488758459143493]}, "mutation_prompt": null}
{"id": "b2d846f8-9fd5-4923-a827-5e5d2273506b", "solution": "import numpy as np\n\nclass AdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_prob = 0.2  # Probability of local search\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                idxs = np.random.choice(range(self.population_size), 3, replace=False)\n                a, b, c = population[idxs[0]], population[idxs[1]], population[idxs[2]]\n                mutant = np.clip(a + self.F * (b - c), lower_bound, upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Local search\n                if np.random.rand() < self.local_search_prob:\n                    trial = self.local_search(trial, func, lower_bound, upper_bound)\n                    trial_fitness = func(trial)\n                    evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def local_search(self, individual, func, lb, ub):\n        # Simple hill-climbing local search\n        step_size = (ub - lb) * 0.05\n        for _ in range(10):\n            candidate = individual + np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(candidate, lb, ub)\n            if func(candidate) < func(individual):\n                individual = candidate\n        return individual", "name": "AdaptiveMemeticDifferentialEvolution", "description": "Adaptive Memetic Differential Evolution (AMDE) combines differential evolution with local search to enhance exploitation and exploration in optimization tasks.", "configspace": "", "generation": 8, "fitness": 0.7005371811833493, "feedback": "The algorithm AdaptiveMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.701 with standard deviation 0.057. And the mean value of best solutions found was 0.238 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "94cce3e5-641f-4a89-9cd3-07c059523e77", "metadata": {"aucs": [0.6949922105185573, 0.7724309809078804, 0.6341883521236098], "final_y": [0.24785962220841762, 0.23959160613777453, 0.22614849326254194]}, "mutation_prompt": null}
{"id": "1971d31a-a126-4e6d-86fe-3136c90f9931", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, budget // 2)  # Adjust population size based on budget\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * (self.global_best_position - positions[i])\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic population size adaptation for improved convergence efficiency.", "configspace": "", "generation": 9, "fitness": 0.9555559710620777, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.956 with standard deviation 0.026. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "94cce3e5-641f-4a89-9cd3-07c059523e77", "metadata": {"aucs": [0.9184248172145796, 0.9708307118127185, 0.9774123841589348], "final_y": [0.18213086900027764, 0.16748701793930076, 0.164857501670009]}, "mutation_prompt": null}
{"id": "d0823c2d-0292-4f04-b141-ac2d71e20848", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n        self.inertia = 0.9  # Inertia weight for velocity update\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * (self.global_best_position - positions[i])\n                velocities[i] = self.inertia * velocities[i] + r1 * velocities[i] + r2 * self.beta * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired PSO with adaptive inertia for improved exploration-exploitation balance.", "configspace": "", "generation": 10, "fitness": 0.8261488709975743, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.826 with standard deviation 0.079. And the mean value of best solutions found was 0.223 (0. is the best) with standard deviation 0.033.", "error": "", "parent_id": "94cce3e5-641f-4a89-9cd3-07c059523e77", "metadata": {"aucs": [0.7146898879438599, 0.8806371757803355, 0.8831195492685273], "final_y": [0.2702835445171765, 0.200308878922403, 0.1984688511066912]}, "mutation_prompt": null}
{"id": "793afb1d-3bba-4a45-8c6e-2f7ca762e09c", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * (self.global_best_position - positions[i])\n                velocities[i] = r1 * velocities[i] + r2 * np.random.uniform(1.5, 2.5) * quantum_potential  # Change 1\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with stochastic adaptation for balance between exploration and exploitation.", "configspace": "", "generation": 11, "fitness": 0.9326082663885672, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.933 with standard deviation 0.035. And the mean value of best solutions found was 0.181 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "94cce3e5-641f-4a89-9cd3-07c059523e77", "metadata": {"aucs": [0.922530416492639, 0.9794298188143464, 0.8958645638587163], "final_y": [0.18188121671831015, 0.16494226485368135, 0.19505622801330058]}, "mutation_prompt": null}
{"id": "94a49c7c-b4e3-41fd-aabc-5c410162c3e1", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta_min = 0.5  # Updated minimum learning factor\n        self.beta_max = 2.5  # Updated maximum learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update dynamic learning factor\n                self.beta = self.beta_min + (self.beta_max - self.beta_min) * (self.budget - evaluations) / self.budget\n                \n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * (self.global_best_position - positions[i])\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic learning factors for improved adaptability and convergence.", "configspace": "", "generation": 12, "fitness": 0.9394516275129394, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.939 with standard deviation 0.025. And the mean value of best solutions found was 0.176 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "94cce3e5-641f-4a89-9cd3-07c059523e77", "metadata": {"aucs": [0.9236357616635889, 0.9206598523442521, 0.9740592685309776], "final_y": [0.18188074679955513, 0.18189796179801077, 0.16490746626519115]}, "mutation_prompt": null}
{"id": "352e2101-3648-4034-b62a-bb5aa1dd6655", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Modified line\n                quantum_potential = self.alpha * (self.global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + r1 * self.beta * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Quantum-Inspired Particle Swarm Optimization with adaptive quantum potential fields and modified inertia weight for enhanced exploration and convergence.", "configspace": "", "generation": 13, "fitness": 0.8800676464974647, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.880 with standard deviation 0.065. And the mean value of best solutions found was 0.201 (0. is the best) with standard deviation 0.024.", "error": "", "parent_id": "94cce3e5-641f-4a89-9cd3-07c059523e77", "metadata": {"aucs": [0.8917192661296004, 0.795741755433204, 0.9527419179295897], "final_y": [0.195234295505049, 0.23258995549025963, 0.1755458232582977]}, "mutation_prompt": null}
{"id": "ab210814-1649-4e17-a1dd-72eda4347951", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                self.beta = 2.0 + 0.5 * np.sin(evaluations / self.budget * np.pi)  # Dynamic beta\n                quantum_potential = self.alpha * (self.global_best_position - positions[i]) * np.random.normal()\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired PSO with dynamic beta and stochastic quantum influence for improved exploration and convergence.", "configspace": "", "generation": 14, "fitness": 0.9011146680286745, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.901 with standard deviation 0.052. And the mean value of best solutions found was 0.187 (0. is the best) with standard deviation 0.017.", "error": "", "parent_id": "94cce3e5-641f-4a89-9cd3-07c059523e77", "metadata": {"aucs": [0.8274839275611081, 0.9308793369071523, 0.9449807396177631], "final_y": [0.21124541857211887, 0.17845584363535283, 0.17117840693980613]}, "mutation_prompt": null}
{"id": "4d36c613-7c30-45a9-945a-2684e2b3d707", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * (self.global_best_position - positions[i])\n                self.beta = 2.0 - (evaluations / self.budget)  # Dynamic adjustment of beta\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization using dynamic learning factor adjustment based on convergence rate for improved adaptability and performance.", "configspace": "", "generation": 15, "fitness": 0.9561099444649521, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.956 with standard deviation 0.027. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "94cce3e5-641f-4a89-9cd3-07c059523e77", "metadata": {"aucs": [0.9182873682094592, 0.9755677881632704, 0.9744746770221264], "final_y": [0.18196120298823615, 0.16531104631371296, 0.1648747642851478]}, "mutation_prompt": null}
{"id": "868623e4-eeb8-445b-a093-0c9263c295db", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i])  # Change 1/2\n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)  # Change 2/2\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Improved Quantum-Inspired Particle Swarm Optimization with adaptive quantum potential scaling and dynamic velocity influence to enhance exploration and convergence.", "configspace": "", "generation": 16, "fitness": 0.9731775999308931, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.973 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4d36c613-7c30-45a9-945a-2684e2b3d707", "metadata": {"aucs": [0.9680739679383876, 0.9769975584561379, 0.9744612733981537], "final_y": [0.1650089527077836, 0.1651933298678887, 0.1649044136402532]}, "mutation_prompt": null}
{"id": "25bcecdb-2cdc-48e9-873f-e5c2cfc08d25", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i])  # Change 1/2\n                inertia_weight = 0.5 + 0.5 * (self.budget - evaluations) / self.budget  # Change 1/1\n                velocities[i] = inertia_weight * velocities[i] + r2 * self.beta * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization by introducing dynamic inertia weight for improved exploration and convergence.", "configspace": "", "generation": 17, "fitness": 0.9058451038808949, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.906 with standard deviation 0.040. And the mean value of best solutions found was 0.190 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "868623e4-eeb8-445b-a093-0c9263c295db", "metadata": {"aucs": [0.9460776174001482, 0.8514105873711657, 0.920047106871371], "final_y": [0.17563505965508375, 0.21026614213168848, 0.18423865818741958]}, "mutation_prompt": null}
{"id": "6ca8c757-0234-40e3-865c-595eb7ea6a0a", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i])  # Change 1/2\n                self.beta = 1.5 + 0.5 * np.sin(2 * np.pi * evaluations / self.budget)  # Change 1 line\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Modified Quantum-Inspired PSO with enhanced dynamic velocity influence for improved convergence accuracy.", "configspace": "", "generation": 18, "fitness": 0.9411132667274015, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.941 with standard deviation 0.031. And the mean value of best solutions found was 0.177 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "868623e4-eeb8-445b-a093-0c9263c295db", "metadata": {"aucs": [0.8981286212584114, 0.9575040851633091, 0.9677070937604838], "final_y": [0.19320183666504398, 0.17310068876732465, 0.16489226509064836]}, "mutation_prompt": null}
{"id": "04f3f301-59e2-4ffd-ad86-1af2cc5e38c7", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i])  # Change 1/2\n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)  # Change 2/2\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * quantum_potential + 0.1 * r1 * (personal_best_positions[i] - positions[i])  # Changed line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization by dynamically adjusting the influence of personal best positions for improved convergence and exploration.", "configspace": "", "generation": 19, "fitness": 0.9704494157275599, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.970 with standard deviation 0.004. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "868623e4-eeb8-445b-a093-0c9263c295db", "metadata": {"aucs": [0.9650676301739995, 0.9716430586878749, 0.9746375583208053], "final_y": [0.16491223212198447, 0.16692384714790343, 0.16489248370396958]}, "mutation_prompt": null}
{"id": "1f8cf3a3-ef9e-43c8-b44b-d99c03b7a584", "solution": "import numpy as np\n\nclass AdaptiveGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_rate = 0.1\n        self.elitism_rate = 0.1\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(fitness)\n            self.global_best_position = population[best_index]\n            global_best_fitness = fitness[best_index]\n\n        while evaluations < self.budget:\n            # Select parents using tournament selection\n            parents = self.tournament_selection(population, fitness)\n\n            # Generate offspring using crossover\n            offspring = self.crossover(parents)\n\n            # Apply mutation\n            self.dynamic_mutation_rate(evaluations)\n            offspring = self.mutation(offspring, lower_bound, upper_bound)\n\n            # Evaluate fitness of offspring\n            offspring_fitness = np.array([func(ind) for ind in offspring])\n            evaluations += len(offspring)\n\n            # Combine population and select next generation with elitism\n            combined_population = np.vstack((population, offspring))\n            combined_fitness = np.hstack((fitness, offspring_fitness))\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            best_indices = np.argpartition(combined_fitness, elite_count)[:elite_count]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            # Update global best\n            if fitness[0] < global_best_fitness:\n                self.global_best_position = population[0]\n                global_best_fitness = fitness[0]\n\n            if evaluations >= self.budget:\n                break\n\n        return self.global_best_position, global_best_fitness\n\n    def tournament_selection(self, population, fitness):\n        # Tournament selection implementation\n        selected_parents = []\n        for _ in range(self.population_size):\n            competitors_idx = np.random.choice(range(self.population_size), 3, replace=False)\n            winner_idx = competitors_idx[np.argmin(fitness[competitors_idx])]\n            selected_parents.append(population[winner_idx])\n        return np.array(selected_parents)\n\n    def crossover(self, parents):\n        # Single-point crossover implementation\n        offspring = []\n        for i in range(0, self.population_size, 2):\n            parent1, parent2 = parents[i], parents[i + 1]\n            point = np.random.randint(1, self.dim)\n            child1 = np.hstack((parent1[:point], parent2[point:]))\n            child2 = np.hstack((parent2[:point], parent1[point:]))\n            offspring.extend([child1, child2])\n        return np.array(offspring)\n\n    def mutation(self, offspring, lower_bound, upper_bound):\n        # Mutation implementation with dynamic mutation rate\n        for i in range(len(offspring)):\n            if np.random.rand() < self.mutation_rate:\n                mutate_dim = np.random.randint(0, self.dim)\n                offspring[i][mutate_dim] += np.random.uniform(-1.0, 1.0) * (upper_bound[mutate_dim] - lower_bound[mutate_dim]) * 0.1\n                offspring[i] = np.clip(offspring[i], lower_bound, upper_bound)\n        return offspring\n\n    def dynamic_mutation_rate(self, evaluations):\n        # Adjust mutation rate based on progress\n        self.mutation_rate = 0.1 * (1 - evaluations / self.budget)", "name": "AdaptiveGeneticAlgorithm", "description": "Adaptive Genetic Algorithm with a dynamic mutation rate and elitism for improved exploration and exploitation balance in optimization under limited evaluations.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 28 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 28 is out of bounds for axis 0 with size 10')", "parent_id": "868623e4-eeb8-445b-a093-0c9263c295db", "metadata": {}, "mutation_prompt": null}
{"id": "0cd488c1-d1ac-491e-95c2-3db6a14df57a", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2, r3 = np.random.rand(3)  # Added r3 for stochastic personal influence\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i])  # Change 1/2\n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)  # Change 2/2\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * quantum_potential + r3 * (personal_best_positions[i] - positions[i])  # Added stochastic personal influence\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with stochastic personal influence to improve solution diversity and convergence.", "configspace": "", "generation": 21, "fitness": 0.9515796468174124, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.952 with standard deviation 0.026. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "868623e4-eeb8-445b-a093-0c9263c295db", "metadata": {"aucs": [0.9145360478989174, 0.9668110136315958, 0.9733918789217239], "final_y": [0.18189607169266853, 0.16553517797490358, 0.1650052717481446]}, "mutation_prompt": null}
{"id": "efbc115c-777e-4484-abb9-5e00c40679f6", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                stochastic_control = np.random.normal(0, 1, self.dim)  # Change 1/4\n                self.beta = 1.5 + 0.7 * np.cos(np.pi * evaluations / self.budget)  # Change 2/4\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * quantum_potential + 0.1 * stochastic_control  # Change 3/4\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Hybrid Quantum-Inspired Particle Swarm Optimization combining adaptive quantum potential with stochastic search for enhanced exploration and convergence.", "configspace": "", "generation": 22, "fitness": 0.9486786708314351, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.949 with standard deviation 0.030. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "868623e4-eeb8-445b-a093-0c9263c295db", "metadata": {"aucs": [0.9615355405772368, 0.9074497101147408, 0.9770507618023276], "final_y": [0.1649245281032845, 0.18192692097009455, 0.16585978869371476]}, "mutation_prompt": null}
{"id": "529c35af-71e0-4fe3-b28f-b81c8521a4d8", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i])  # Change 1/3\n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)  # Change 2/3\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Refined Quantum-Inspired Particle Swarm Optimization with adaptive boundary-aware exploration to enhance convergence.", "configspace": "", "generation": 23, "fitness": 0.9731775999308931, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.973 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "868623e4-eeb8-445b-a093-0c9263c295db", "metadata": {"aucs": [0.9680739679383876, 0.9769975584561379, 0.9744612733981537], "final_y": [0.1650089527077836, 0.1651933298678887, 0.1649044136402532]}, "mutation_prompt": null}
{"id": "b33c2677-6a0c-48d6-a176-0a183b46e3c7", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n        self.inertia_weight = 0.9  # Adaptive inertia weight\n    \n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        convergence_threshold = 1e-5  # Threshold for convergence improvement\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i])\n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                self.inertia_weight = 0.4 + 0.5 * (1 - evaluations / self.budget)  # Update inertia\n                velocities[i] = self.inertia_weight * velocities[i] + r2 * self.beta * quantum_potential\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                fitness = func(positions[i])\n                evaluations += 1\n                \n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget or abs(global_best_fitness - fitness) < convergence_threshold:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization using adaptive inertia weight and convergence threshold for improved exploration-exploitation balance.", "configspace": "", "generation": 24, "fitness": 0.7732086440290118, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.773 with standard deviation 0.054. And the mean value of best solutions found was 0.244 (0. is the best) with standard deviation 0.025.", "error": "", "parent_id": "868623e4-eeb8-445b-a093-0c9263c295db", "metadata": {"aucs": [0.7636098538141541, 0.7126960440501416, 0.8433200342227394], "final_y": [0.24466125855967713, 0.2736377853526528, 0.2132137587247056]}, "mutation_prompt": null}
{"id": "6612d4c0-72f4-4a3e-8524-64b1df108f55", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Quantum-Inspired Particle Swarm Optimization with enhanced velocity update using time-varying quantum potential influence for improved exploration.", "configspace": "", "generation": 25, "fitness": 0.9738779998815609, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.974 with standard deviation 0.006. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "868623e4-eeb8-445b-a093-0c9263c295db", "metadata": {"aucs": [0.9719450486155709, 0.98198324815869, 0.9677057028704219], "final_y": [0.16487604799815325, 0.1648567369230517, 0.1648697917606351]}, "mutation_prompt": null}
{"id": "7c63a2bc-3be5-439d-822b-af9e6832dedc", "solution": "import numpy as np\n\nclass AdvancedQuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n        self.inertia_weight = 0.9  # Initial inertia weight\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential and adaptive inertia weight\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i])\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 r1 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential)\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "AdvancedQuantumInspiredParticleSwarmOptimization", "description": "Advanced Quantum-Inspired Particle Swarm Optimization with adaptive inertia weight and enhanced quantum potential for dynamic exploration and exploitation balance.", "configspace": "", "generation": 26, "fitness": 0.8598680904931513, "feedback": "The algorithm AdvancedQuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.860 with standard deviation 0.034. And the mean value of best solutions found was 0.207 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "6612d4c0-72f4-4a3e-8524-64b1df108f55", "metadata": {"aucs": [0.8234199554973006, 0.9051891766674054, 0.8509951393147478], "final_y": [0.22057183602394126, 0.18990802451947797, 0.20962305000650416]}, "mutation_prompt": null}
{"id": "f3beade8-a50c-47be-89a1-2824c600da20", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)  # Adaptive inertia weight\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = inertia_weight * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Quantum-Inspired Particle Swarm Optimization with adaptive inertia weight for enhanced balance between exploration and exploitation.", "configspace": "", "generation": 27, "fitness": 0.9377697445900358, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.938 with standard deviation 0.031. And the mean value of best solutions found was 0.179 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "6612d4c0-72f4-4a3e-8524-64b1df108f55", "metadata": {"aucs": [0.8959667158268159, 0.9716606646565746, 0.945681853286717], "final_y": [0.19264772863785717, 0.16877131870983708, 0.17538151347134645]}, "mutation_prompt": null}
{"id": "b5dff138-ee4a-4dd6-92dc-551c29aa6b02", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n                \n                # Adjust population size adaptively\n                self.population_size = max(5, int(0.9 * self.population_size))\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Introduced adaptive particle population size adjustment based on convergence for improved efficiency and exploration.", "configspace": "", "generation": 28, "fitness": 0.8774039050915241, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.877 with standard deviation 0.025. And the mean value of best solutions found was 0.201 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "6612d4c0-72f4-4a3e-8524-64b1df108f55", "metadata": {"aucs": [0.8724422237415684, 0.9098523116467501, 0.849917179886254], "final_y": [0.20179168647127554, 0.18988987957623427, 0.21120825278771815]}, "mutation_prompt": null}
{"id": "762b7833-7a39-4451-8905-c7af735acc1d", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)  # Changed from sin to cos\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced exploration by adjusting the velocity update factor using a cosine decay function for improved convergence.", "configspace": "", "generation": 29, "fitness": 0.9506032480805028, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.951 with standard deviation 0.027. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "6612d4c0-72f4-4a3e-8524-64b1df108f55", "metadata": {"aucs": [0.912618856057134, 0.9678813328088877, 0.9713095553754866], "final_y": [0.1826257693554444, 0.16510964677791484, 0.16488106178745132]}, "mutation_prompt": null}
{"id": "a5efde14-537c-4700-b059-8e742fc49d85", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                self.alpha = 0.5 + 0.5 * np.sin(2 * np.pi * evaluations / self.budget)  # Modified line\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Implemented dynamic alpha scaling with sinusoidal modulation to enhance exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": 0.9493764816900256, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.949 with standard deviation 0.033. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "6612d4c0-72f4-4a3e-8524-64b1df108f55", "metadata": {"aucs": [0.9032760905849876, 0.9718617874541314, 0.9729915670309579], "final_y": [0.1825595568620556, 0.16494580020262062, 0.16576336286050442]}, "mutation_prompt": null}
{"id": "e028617e-8c1d-46da-9cdc-f646c6fd959c", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 * dim * (1 + 0.01 * np.sin(np.pi * budget / 1000)))  # Modified line\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced particle exploration by dynamically adjusting the population size for better convergence.", "configspace": "", "generation": 31, "fitness": 0.9738779998815609, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.974 with standard deviation 0.006. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6612d4c0-72f4-4a3e-8524-64b1df108f55", "metadata": {"aucs": [0.9719450486155709, 0.98198324815869, 0.9677057028704219], "final_y": [0.16487604799815325, 0.1648567369230517, 0.1648697917606351]}, "mutation_prompt": null}
{"id": "f82aff41-edba-4976-af0e-e3b1aa6b73f4", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n\n                # Adaptive inertia weight\n                inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)  # New line\n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = inertia_weight * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with adaptive inertia weight for improved balance between exploration and exploitation.", "configspace": "", "generation": 32, "fitness": 0.9609759542382559, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.961 with standard deviation 0.011. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "6612d4c0-72f4-4a3e-8524-64b1df108f55", "metadata": {"aucs": [0.9659787513964964, 0.9718111583288906, 0.9451379529893806], "final_y": [0.16752203771599627, 0.1687206942546603, 0.17556975929924146]}, "mutation_prompt": null}
{"id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with adaptive population size for better resource utilization and convergence.", "configspace": "", "generation": 33, "fitness": 0.97542098802544, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.975 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6612d4c0-72f4-4a3e-8524-64b1df108f55", "metadata": {"aucs": [0.9729193963798364, 0.978274898782796, 0.9750686689136877], "final_y": [0.16559020401933833, 0.16495075776007495, 0.1657089211637094]}, "mutation_prompt": null}
{"id": "a23d351b-702e-413c-a2c2-b055f2d5e70c", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                velocities[i] += 0.1 * (positions[i] - personal_best_positions[i])  # Added momentum term\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Modified the velocity update rule to incorporate an additional momentum term for enhanced exploration.", "configspace": "", "generation": 34, "fitness": 0.9407114741982702, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.941 with standard deviation 0.039. And the mean value of best solutions found was 0.178 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.8859970966621147, 0.9640332368402633, 0.9721040890924323], "final_y": [0.19818577936839843, 0.16978339885140925, 0.16556309099297872]}, "mutation_prompt": null}
{"id": "fcfe8676-99b9-46c8-8959-2991536179fc", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                inertia_weight = 0.9 - (0.5 * evaluations / self.budget)  # New line for dynamic inertia weight\n                velocities[i] = inertia_weight * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic inertia weight for improved convergence efficiency.", "configspace": "", "generation": 35, "fitness": 0.842284509566194, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.012. And the mean value of best solutions found was 0.216 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.8452613465622401, 0.8268856757925018, 0.8547065063438403], "final_y": [0.2142262356808703, 0.22095630422063772, 0.21144314880344206]}, "mutation_prompt": null}
{"id": "3d5a400b-5edd-4872-8eaa-3925997dd623", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = 0.9 * r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with adaptive velocity scaling for improved convergence.", "configspace": "", "generation": 36, "fitness": 0.9595902288872656, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.960 with standard deviation 0.012. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9473654130599596, 0.9764447753756323, 0.954960498226205], "final_y": [0.17399792362000566, 0.1656414868005498, 0.17216967834475283]}, "mutation_prompt": null}
{"id": "a6c655b8-a451-48a2-be7e-600bb0b47ed7", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                local_influence = 0.5 * np.cos(np.pi * personal_best_fitness[i] / global_best_fitness)  # Modified line\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + local_influence) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with adaptive particle influence based on local and global history.", "configspace": "", "generation": 37, "fitness": 0.9280721937101549, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.928 with standard deviation 0.057. And the mean value of best solutions found was 0.183 (0. is the best) with standard deviation 0.022.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9665843158136959, 0.8469243850418557, 0.9707078802749133], "final_y": [0.16912568660872973, 0.21373263447663415, 0.16614738474802793]}, "mutation_prompt": null}
{"id": "f23cfe53-0369-4a15-a583-fc707e920152", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)  # Modified line for dynamic adjustment\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic learning factor adjustment for improved convergence.", "configspace": "", "generation": 38, "fitness": 0.9485921783783787, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.949 with standard deviation 0.025. And the mean value of best solutions found was 0.175 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9522659080086086, 0.9162770406319847, 0.9772335864945428], "final_y": [0.17464101393423725, 0.18293832681105027, 0.16632056577260146]}, "mutation_prompt": null}
{"id": "29422889-ebb0-42a1-a6a2-45a9decdffb3", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                dynamic_factor = 0.1 * np.tanh(evaluations / self.budget)  # Added dynamic factor to velocity computation\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential + dynamic_factor * (personal_best_positions[i] - positions[i])\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Improved adaptability in velocity update by integrating a new dynamic factor.", "configspace": "", "generation": 39, "fitness": 0.9689757333689456, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.969 with standard deviation 0.008. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9588231636576555, 0.9779145299730267, 0.9701895064761549], "final_y": [0.1709635302709258, 0.16511906839508084, 0.1662688757031806]}, "mutation_prompt": null}
{"id": "6982b8ae-b483-4d28-a9ef-566ab3e7c02d", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.2 + 0.8 * np.cos(np.pi * evaluations / self.budget)  # Changed line for adaptive beta\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1.2 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with adaptive beta factor and exploration-exploitation balance.", "configspace": "", "generation": 40, "fitness": 0.964405460078695, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.964 with standard deviation 0.021. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9731957500657005, 0.9349961308032706, 0.9850244993671142], "final_y": [0.16642236595766824, 0.17637714920914194, 0.16510707511568445]}, "mutation_prompt": null}
{"id": "f963cd98-d227-4a84-9bb4-2e5d723e6cd6", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)\n        self.alpha = 0.5\n        self.beta = 2.0\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                inertia_weight = 0.9 - (0.5 * evaluations / self.budget)  # Added line for dynamic inertia weight\n                velocities[i] = inertia_weight * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Further refined Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic inertia weight adjustment for improved convergence and exploration.", "configspace": "", "generation": 41, "fitness": 0.842284509566194, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.012. And the mean value of best solutions found was 0.216 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.8452613465622401, 0.8268856757925018, 0.8547065063438403], "final_y": [0.2142262356808703, 0.22095630422063772, 0.21144314880344206]}, "mutation_prompt": null}
{"id": "5b9af4c0-dcae-4257-b713-a3d536ef983d", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)  # New line: adaptive inertia weight\n                velocities[i] = inertia_weight * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Improved Quantum-Inspired Particle Swarm Optimization by incorporating adaptive inertia weight for enhanced convergence speed and precision.", "configspace": "", "generation": 42, "fitness": 0.842284509566194, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.012. And the mean value of best solutions found was 0.216 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.8452613465622401, 0.8268856757925018, 0.8547065063438403], "final_y": [0.2142262356808703, 0.22095630422063772, 0.21144314880344206]}, "mutation_prompt": null}
{"id": "31c6e41c-b7cc-45a4-83e6-3d9c4f8d32ca", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)  # Modified line\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with adaptive learning factor for improved convergence control.", "configspace": "", "generation": 43, "fitness": 0.9485921783783787, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.949 with standard deviation 0.025. And the mean value of best solutions found was 0.175 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9522659080086086, 0.9162770406319847, 0.9772335864945428], "final_y": [0.17464101393423725, 0.18293832681105027, 0.16632056577260146]}, "mutation_prompt": null}
{"id": "9b2a7fcf-efa8-4535-b198-757390e275d0", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)  # New dynamic inertia weight\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = inertia_weight * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic inertia weight for better convergence.", "configspace": "", "generation": 44, "fitness": 0.842284509566194, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.012. And the mean value of best solutions found was 0.216 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.8452613465622401, 0.8268856757925018, 0.8547065063438403], "final_y": [0.2142262356808703, 0.22095630422063772, 0.21144314880344206]}, "mutation_prompt": null}
{"id": "2f48122d-7c89-48a9-9f4a-434b0789ef0f", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.inertia_weight = 0.9  # New line for adaptive inertia weight\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)  # Modified line for inertia weight\n                velocities[i] = self.inertia_weight * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with adaptive inertia weight for improved convergence and exploration.", "configspace": "", "generation": 45, "fitness": 0.842284509566194, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.012. And the mean value of best solutions found was 0.216 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.8452613465622401, 0.8268856757925018, 0.8547065063438403], "final_y": [0.2142262356808703, 0.22095630422063772, 0.21144314880344206]}, "mutation_prompt": null}
{"id": "05aae850-88a3-4b2b-bbe2-6692e72deefc", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential * (0.8 + 0.2 * evaluations / self.budget)  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with adaptive quantum potential based on evaluations for improved convergence.", "configspace": "", "generation": 46, "fitness": 0.9184271097864345, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.918 with standard deviation 0.070. And the mean value of best solutions found was 0.188 (0. is the best) with standard deviation 0.026.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9601278510280546, 0.9750684397424852, 0.8200850385887636], "final_y": [0.17380841404433822, 0.16569341373936963, 0.22409100202664223]}, "mutation_prompt": null}
{"id": "edbba536-ea97-4ce1-a78b-36329e3fdd8a", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocity_scale = np.random.uniform(0.5, 1.5)  # New line for stochastic velocity scaling\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential * velocity_scale  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced exploration by introducing stochastic scaling to particle velocities for superior convergence.", "configspace": "", "generation": 47, "fitness": 0.9675875721991675, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.968 with standard deviation 0.001. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9688953053148278, 0.9676355833416731, 0.9662318279410012], "final_y": [0.1677104516043023, 0.17044222418226196, 0.16984614590947433]}, "mutation_prompt": null}
{"id": "4d03eeef-4267-40cd-b98c-995bd032fd5b", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.0 + np.sin(np.pi * evaluations / (2 * self.budget))  # Modified line for dynamic beta adjustment\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic beta adjustment for improved convergence.", "configspace": "", "generation": 48, "fitness": 0.959193499135195, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.959 with standard deviation 0.021. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9774437567428182, 0.9705743053159878, 0.9295624353467795], "final_y": [0.16580990354994818, 0.16577788832667673, 0.17759806479872453]}, "mutation_prompt": null}
{"id": "eac13454-e81c-4813-90e3-2c1a642be77b", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential + 0.05 * np.random.randn(self.dim)  # Added random perturbation for diversity\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Incorporate a diversity-enhancing mechanism by adding random perturbation to velocities, preventing premature convergence.", "configspace": "", "generation": 49, "fitness": 0.9338663616035516, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.934 with standard deviation 0.065. And the mean value of best solutions found was 0.182 (0. is the best) with standard deviation 0.024.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9820103388325175, 0.8421818583314088, 0.9774068876467286], "final_y": [0.16485729005589056, 0.2152221326726923, 0.16485698802525106]}, "mutation_prompt": null}
{"id": "e88e3a0a-50a0-4794-a55a-d1f43000ad89", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                scaling_factor = 0.5 + 0.5 * evaluations / self.budget  # New line for dynamic scaling factor\n                velocities[i] = scaling_factor * (r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential)  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Introduced a dynamic scaling factor to improve velocity adjustment for enhanced convergence.", "configspace": "", "generation": 50, "fitness": 0.9462359599831275, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.946 with standard deviation 0.022. And the mean value of best solutions found was 0.175 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9653445778507941, 0.9585103862219018, 0.9148529158766866], "final_y": [0.1693241938488682, 0.16926431668656916, 0.18540442978030303]}, "mutation_prompt": null}
{"id": "c7ecc194-e77f-43b6-90ab-cb121498fdd3", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                \n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Refined Quantum-Inspired Particle Swarm Optimization with adaptive velocity damping to enhance convergence stability and precision.", "configspace": "", "generation": 51, "fitness": 0.97542098802544, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.975 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9729193963798364, 0.978274898782796, 0.9750686689136877], "final_y": [0.16559020401933833, 0.16495075776007495, 0.1657089211637094]}, "mutation_prompt": null}
{"id": "8e08bda3-e0c6-4a1f-8314-16c5991d8faf", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                self.alpha = 0.3 + 0.2 * np.cos(2 * np.pi * evaluations / self.budget)  # Modified line for dynamic alpha adjustment\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic alpha adjustment for improved convergence.", "configspace": "", "generation": 52, "fitness": 0.9686994882675956, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.969 with standard deviation 0.004. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.970202818204523, 0.9726522971412456, 0.9632433494570177], "final_y": [0.16689414289181914, 0.16667666579353657, 0.16943197215065064]}, "mutation_prompt": null}
{"id": "1a1db77b-4fd9-4415-9c2b-a6a484a096ae", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)  # Modified line for decaying inertia weight\n                velocities[i] = inertia_weight * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced particle velocity update using a decaying inertia weight for improved convergence balance.", "configspace": "", "generation": 53, "fitness": 0.8593967923612503, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.859 with standard deviation 0.079. And the mean value of best solutions found was 0.211 (0. is the best) with standard deviation 0.031.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9431837381693001, 0.754146665478574, 0.880859973435877], "final_y": [0.17899612783492047, 0.25371871547958025, 0.20121520047609243]}, "mutation_prompt": null}
{"id": "f0fea2e5-83d5-4b92-9130-4e6341d3e014", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential + 0.05 * (personal_best_positions[i] - positions[i])  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic adaptive velocity adjustment for improved convergence and solution quality.", "configspace": "", "generation": 54, "fitness": 0.9685852797561613, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.969 with standard deviation 0.006. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.960186703191841, 0.9716592498282777, 0.9739098862483652], "final_y": [0.1696161151925183, 0.1661961343071927, 0.16613687639143282]}, "mutation_prompt": null}
{"id": "2d030c5f-229d-4f05-91f5-f4ffe82da61b", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                # Modified line for dynamic inertia\n                inertia = 0.9 - (0.5 * evaluations / self.budget)  \n                velocities[i] = inertia * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  \n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic inertia for improved exploration-exploitation balance.", "configspace": "", "generation": 55, "fitness": 0.842284509566194, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.012. And the mean value of best solutions found was 0.216 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.8452613465622401, 0.8268856757925018, 0.8547065063438403], "final_y": [0.2142262356808703, 0.22095630422063772, 0.21144314880344206]}, "mutation_prompt": null}
{"id": "2e78a7ef-9382-481d-8495-7319e19347a2", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                self.alpha = 0.5 + 0.25 * np.cos(np.pi * evaluations / self.budget)  # Modified line for dynamic alpha adjustment\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Improved Quantum-Inspired PSO with dynamic alpha adjustment for enhanced exploration and exploitation balance.", "configspace": "", "generation": 56, "fitness": 0.9706771289210274, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.971 with standard deviation 0.014. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9757467469448539, 0.9513203362045258, 0.9849643036137026], "final_y": [0.16513382279633493, 0.16842370456233557, 0.1650221545861773]}, "mutation_prompt": null}
{"id": "ae59a1fe-5f09-4641-bb28-d2f553182cfe", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.05 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Quantum-Inspired Particle Swarm Optimization with further refined quantum potential decay to enhance convergence speed and accuracy.", "configspace": "", "generation": 57, "fitness": 0.9725067221707219, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.973 with standard deviation 0.006. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9641118325803486, 0.9739248140690151, 0.9794835198628016], "final_y": [0.16888071276981798, 0.16666661827368723, 0.16518670494895793]}, "mutation_prompt": null}
{"id": "0097b8b7-2ff7-417d-a1bc-011c981445fa", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            w = 0.9 - 0.5 * (evaluations / self.budget)  # Dynamic inertia weight\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = w * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic inertia weight for improved exploration and exploitation balance.", "configspace": "", "generation": 58, "fitness": 0.8483343662224122, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.848 with standard deviation 0.015. And the mean value of best solutions found was 0.213 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.8630063821152589, 0.8272249334489215, 0.8547717831030559], "final_y": [0.207179869795319, 0.22081624238002429, 0.2114167630675826]}, "mutation_prompt": null}
{"id": "84406229-d261-4c0e-b294-566b9356a999", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = (0.5 + 0.5 * np.cos(2 * np.pi * evaluations / self.budget)) * r2 * (self.global_best_position - positions[i])  # Modified line\n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic adjustment of the quantum potential coefficient for improved exploration-exploitation balance.", "configspace": "", "generation": 59, "fitness": 0.9363977642437921, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.936 with standard deviation 0.014. And the mean value of best solutions found was 0.179 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9437006103434145, 0.9174046840510837, 0.9480879983368781], "final_y": [0.1764470803099194, 0.1827903905058862, 0.17719943525215154]}, "mutation_prompt": null}
{"id": "6c8ef7db-a61c-4d6b-a510-d00c7956db85", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget) * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget))  # Modified line\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic learning factor adaptation for accelerated convergence.", "configspace": "", "generation": 60, "fitness": 0.96500392537137, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.965 with standard deviation 0.007. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.955133978828511, 0.9699115542972181, 0.9699662429883807], "final_y": [0.1711534449730293, 0.1670783031584009, 0.16651135364084657]}, "mutation_prompt": null}
{"id": "8ed36d2c-1994-4fcd-a353-0741ed0787de", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                chaotic_factor = 4 * r1 * (1 - r1)  # Logistic map for chaos\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential * chaotic_factor  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Introduced a chaotic factor to enhance exploration by using a logistic map in velocity updates to improve convergence.", "configspace": "", "generation": 61, "fitness": 0.944087883276603, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.944 with standard deviation 0.021. And the mean value of best solutions found was 0.175 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9266812582783203, 0.9738084383485724, 0.9317739532029159], "final_y": [0.18283632106235437, 0.166711576050103, 0.17621785020815983]}, "mutation_prompt": null}
{"id": "f13cf6aa-cc04-40d1-8e2d-fc7bcc2af5b2", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Improved Enhanced Quantum-Inspired Particle Swarm Optimization by modifying velocity update to enhance exploration.", "configspace": "", "generation": 62, "fitness": 0.9702463778918822, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.970 with standard deviation 0.010. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9564606232022609, 0.9785349289300139, 0.9757435815433718], "final_y": [0.1709108929355121, 0.16486978633504046, 0.16539631807982025]}, "mutation_prompt": null}
{"id": "9bb696c7-cb76-4e72-80ae-32996194ec9c", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                scaling_factor = 1.0 + 0.1 * np.cos(np.pi * evaluations / self.budget)  # Modified line\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * scaling_factor * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with adaptive velocity scaling for improved search efficiency.", "configspace": "", "generation": 63, "fitness": 0.9702463778918822, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.970 with standard deviation 0.010. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9564606232022609, 0.9785349289300139, 0.9757435815433718], "final_y": [0.1709108929355121, 0.16486978633504046, 0.16539631807982025]}, "mutation_prompt": null}
{"id": "7a41f671-37a1-4f1d-9643-97f770f3d735", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential * np.cos(quantum_potential)  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with adaptive velocity update using cosine proximity to maintain diversity.", "configspace": "", "generation": 64, "fitness": 0.715832288468162, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.716 with standard deviation 0.136. And the mean value of best solutions found was 0.259 (0. is the best) with standard deviation 0.090.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.8173463397605364, 0.806084989181145, 0.5240655364628045], "final_y": [0.19490648906586916, 0.1950973577716283, 0.3860481956539389]}, "mutation_prompt": null}
{"id": "78de8acc-a08a-42cd-aa98-c5702ae4902b", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                self.alpha = 0.5 * (1 - evaluations / self.budget)  # Modified line for dynamic alpha coefficient\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Introduced a dynamic alpha coefficient to adaptively adjust the influence of quantum potential based on the optimization progress, enhancing convergence.", "configspace": "", "generation": 65, "fitness": 0.9653779465914295, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.965 with standard deviation 0.010. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9535944151538002, 0.9769335540503761, 0.9656058705701124], "final_y": [0.1728248858713891, 0.1654445646312822, 0.16862722794916596]}, "mutation_prompt": null}
{"id": "7e59df3f-8de7-44f0-a37a-806ca308d967", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i])\n                inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)  # Modified line for dynamic inertia weight\n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = inertia_weight * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic inertia weight for improved exploration and exploitation balance.", "configspace": "", "generation": 66, "fitness": 0.842284509566194, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.012. And the mean value of best solutions found was 0.216 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.8452613465622401, 0.8268856757925018, 0.8547065063438403], "final_y": [0.2142262356808703, 0.22095630422063772, 0.21144314880344206]}, "mutation_prompt": null}
{"id": "22036f93-3adb-4942-b341-c1f8996c93a5", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                self.alpha = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)  # Modified line for dynamic alpha adjustment\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic alpha adjustment for improved convergence.", "configspace": "", "generation": 67, "fitness": 0.9398779380476897, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.940 with standard deviation 0.053. And the mean value of best solutions found was 0.178 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9746038566510686, 0.8650507589096258, 0.9799791985823748], "final_y": [0.16541725708007626, 0.20383875403518992, 0.1653588170767032]}, "mutation_prompt": null}
{"id": "3db7f6cb-8a82-4c71-9980-a7992c12983d", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            inertia_weight = 0.9 - 0.7 * (evaluations / self.budget)  # Dynamic inertia weight\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = inertia_weight * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Improved Quantum-Inspired Particle Swarm Optimization by incorporating dynamic inertia weight for balancing exploration and exploitation.", "configspace": "", "generation": 68, "fitness": 0.842785646569589, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.843 with standard deviation 0.011. And the mean value of best solutions found was 0.215 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.8452962499488615, 0.8281647264519393, 0.854895963307966], "final_y": [0.2142124846132233, 0.22042796359745365, 0.2113699354244165]}, "mutation_prompt": null}
{"id": "3dc1164a-eec6-498a-88cb-40e525145f6a", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)  # Modified line\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = inertia_weight * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Quantum-Inspired Particle Swarm Optimization with adaptive inertia weight for improved balance between exploration and exploitation.", "configspace": "", "generation": 69, "fitness": 0.842284509566194, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.012. And the mean value of best solutions found was 0.216 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.8452613465622401, 0.8268856757925018, 0.8547065063438403], "final_y": [0.2142262356808703, 0.22095630422063772, 0.21144314880344206]}, "mutation_prompt": null}
{"id": "78a9db7a-8f7e-4676-bacd-1f2a4228695e", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i] + np.random.normal(0, 0.01, self.dim)  # Modified line for Gaussian mutation\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Refined Quantum-Inspired Particle Swarm Optimization with improved mutation strategy using Gaussian noise for enhanced exploration.", "configspace": "", "generation": 70, "fitness": 0.9554181705133998, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.955 with standard deviation 0.033. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9813357695423343, 0.9088006289166057, 0.9761181130812595], "final_y": [0.1650285462737734, 0.1840657215257302, 0.16490215773102324]}, "mutation_prompt": null}
{"id": "d01ff57e-908c-4136-8d36-134749be7a42", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n\n                inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)  # Modified line for adaptive inertia weight\n                velocities[i] = inertia_weight * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n\n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with adaptive inertia weight for improved exploration and exploitation balance.", "configspace": "", "generation": 71, "fitness": 0.842284509566194, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.012. And the mean value of best solutions found was 0.216 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.8452613465622401, 0.8268856757925018, 0.8547065063438403], "final_y": [0.2142262356808703, 0.22095630422063772, 0.21144314880344206]}, "mutation_prompt": null}
{"id": "985d5bb6-011c-4bfc-8037-8883efcb8591", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                self.alpha = 0.5 + 0.5 * np.cos(2 * np.pi * evaluations / self.budget)  # Adjusted alpha dynamically\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i])\n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Introduced dynamic adjustment of quantum potential coefficient to enhance convergence speed in the optimization process.", "configspace": "", "generation": 72, "fitness": 0.9363977642437921, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.936 with standard deviation 0.014. And the mean value of best solutions found was 0.179 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9437006103434145, 0.9174046840510837, 0.9480879983368781], "final_y": [0.1764470803099194, 0.1827903905058862, 0.17719943525215154]}, "mutation_prompt": null}
{"id": "c9b4f2d6-9cbf-4c5d-9db3-984dab967a3b", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.inertia_weight = 0.9  # Added line for dynamic inertia weight\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = self.inertia_weight * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic inertia weight for improved exploration-exploitation balance.", "configspace": "", "generation": 73, "fitness": 0.8365990806997701, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.837 with standard deviation 0.010. And the mean value of best solutions found was 0.218 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.8486131018628815, 0.8245225122482776, 0.8366616279881511], "final_y": [0.21287902978127027, 0.221936696206806, 0.2187391293393096]}, "mutation_prompt": null}
{"id": "6afee08f-01bf-4b5f-a1a1-336d581f3b0e", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                self.alpha = 0.5 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)  # Modified line for dynamic alpha\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamically adjusting quantum potential for improved convergence.", "configspace": "", "generation": 74, "fitness": 0.9371624739848059, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.937 with standard deviation 0.015. And the mean value of best solutions found was 0.179 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9526159474745001, 0.9416881473337951, 0.9171833271461226], "final_y": [0.1731578156490612, 0.17566284781616515, 0.18725572383941358]}, "mutation_prompt": null}
{"id": "ea827516-64a3-4486-9603-65cca18946ab", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                self.alpha = 0.5 + 0.1 * np.sin(2 * np.pi * evaluations / self.budget)  # Modified line\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Refined Quantum-Inspired Particle Swarm Optimization with dynamically updated alpha for enhanced exploration capabilities.", "configspace": "", "generation": 75, "fitness": 0.9644049213432684, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.964 with standard deviation 0.010. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9499853242950798, 0.9708208961918999, 0.9724085435428258], "final_y": [0.1715238102170703, 0.1663992843913179, 0.16657165618136505]}, "mutation_prompt": null}
{"id": "fb134469-0aec-4da6-8f18-d9e7743b2041", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                inertia_weight = 0.9 - (0.5 * evaluations / self.budget)  # New line for dynamic inertia weight\n                velocities[i] = inertia_weight * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with adaptive population size and dynamic inertia weight for improved convergence.", "configspace": "", "generation": 76, "fitness": 0.842284509566194, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.012. And the mean value of best solutions found was 0.216 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.8452613465622401, 0.8268856757925018, 0.8547065063438403], "final_y": [0.2142262356808703, 0.22095630422063772, 0.21144314880344206]}, "mutation_prompt": null}
{"id": "044d1df7-b0d6-49e2-9b0e-1ade714b4994", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                # Use cosine similarity for velocity control\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential * np.cos(np.dot(self.global_best_position, positions[i]) / (np.linalg.norm(self.global_best_position) * np.linalg.norm(positions[i]) + 1e-8)) # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with adaptive velocity control based on cosine similarity for improved convergence. ", "configspace": "", "generation": 77, "fitness": 0.9252375934026351, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.925 with standard deviation 0.038. And the mean value of best solutions found was 0.183 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.871174747856564, 0.957709061800161, 0.9468289705511804], "final_y": [0.20452320188971163, 0.16982684696589945, 0.17442090547733813]}, "mutation_prompt": null}
{"id": "171368b0-dd27-423a-b0af-05a50f012fa3", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                self.alpha = 0.5 + 0.5 * (evaluations / self.budget)  # Modified line for dynamic alpha\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic alpha for improved exploration-exploitation balance.", "configspace": "", "generation": 78, "fitness": 0.9664527859497443, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.966 with standard deviation 0.005. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9602544959616326, 0.9716665263843005, 0.9674373355032998], "final_y": [0.16833462016814182, 0.16644874675897703, 0.16771919278174563]}, "mutation_prompt": null}
{"id": "37ee5b47-5ddd-4fc0-8985-81056db280e0", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                self.alpha = 0.5 + 0.5 * (evaluations / self.budget)  # Modified line\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Implement a dynamic alpha to enhance exploratory behavior and convergence control.", "configspace": "", "generation": 79, "fitness": 0.9664527859497443, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.966 with standard deviation 0.005. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9602544959616326, 0.9716665263843005, 0.9674373355032998], "final_y": [0.16833462016814182, 0.16644874675897703, 0.16771919278174563]}, "mutation_prompt": null}
{"id": "a311fb4d-1626-4a0c-8322-6d895dbdb66a", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.cos(np.pi * (evaluations / self.budget)**2)  # Modified line\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  \n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Improved Quantum-Inspired Particle Swarm Optimization with dynamic learning factor adjustment and enhanced convergence rate.", "configspace": "", "generation": 80, "fitness": 0.9566352586847663, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.957 with standard deviation 0.028. And the mean value of best solutions found was 0.172 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9724927821454494, 0.9172789762990088, 0.9801340176098404], "final_y": [0.16743234085770542, 0.18275428092223378, 0.16517324828755076]}, "mutation_prompt": null}
{"id": "859028d3-d2a9-44f8-a780-1465c0b30796", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                self.alpha = 0.5 * (1 + np.cos(np.pi * evaluations / self.budget))  # Modified line\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Introduced dynamic self.alpha adjustment using cosine annealing to improve exploration-exploitation trade-off in Quantum-Inspired Particle Swarm Optimization.", "configspace": "", "generation": 81, "fitness": 0.9398779380476897, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.940 with standard deviation 0.053. And the mean value of best solutions found was 0.178 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9746038566510686, 0.8650507589096258, 0.9799791985823748], "final_y": [0.16541725708007626, 0.20383875403518992, 0.1653588170767032]}, "mutation_prompt": null}
{"id": "066a1d6e-18b3-4c6a-869e-22e49c086c10", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)\n        self.alpha = 0.5\n        self.beta_min = 1.5\n        self.beta_max = 2.5   # Changed max beta value\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = self.beta_min + (self.beta_max - self.beta_min) * (1 - evaluations / self.budget)  # Dynamic beta\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n\n                # Introduce mutation\n                mutation_prob = 0.1  # Added mutation probability\n                if np.random.rand() < mutation_prob:  # Mutation condition\n                    velocities[i] += np.random.normal(0, 0.1, self.dim)  # Mutation effect\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                fitness = func(positions[i])\n                evaluations += 1\n                \n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Optimized Quantum-Inspired Particle Swarm Optimization with dynamic learning factors and mutation for enhanced exploration and exploitation balance.", "configspace": "", "generation": 82, "fitness": 0.9286254628942671, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.929 with standard deviation 0.043. And the mean value of best solutions found was 0.184 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9319714876106229, 0.8739715177329864, 0.9799333833391918], "final_y": [0.18315414624165904, 0.2025837335418338, 0.16485603222756806]}, "mutation_prompt": null}
{"id": "3cad42f5-565a-4953-a2bf-9f2df5cc757e", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) * (1 + 0.05 * np.sin(2 * np.pi * evaluations / self.budget))  # Modified line\n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential \n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic quantum potential scaling for improved convergence precision.", "configspace": "", "generation": 83, "fitness": 0.9630617308492209, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.963 with standard deviation 0.016. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9399300768084932, 0.9747413253719454, 0.9745137903672243], "final_y": [0.17602658256106196, 0.16568516226811036, 0.16567362720269196]}, "mutation_prompt": null}
{"id": "523497cf-ebc1-4f6e-8a15-4d72ea2b10eb", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)  # New line added\n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = inertia_weight * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Introduced inertia weight to balance exploration and exploitation in particle velocity update.", "configspace": "", "generation": 84, "fitness": 0.842284509566194, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.012. And the mean value of best solutions found was 0.216 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.8452613465622401, 0.8268856757925018, 0.8547065063438403], "final_y": [0.2142262356808703, 0.22095630422063772, 0.21144314880344206]}, "mutation_prompt": null}
{"id": "64f81e65-7ea8-46a1-9567-606338135657", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            decay = 1 - evaluations / self.budget  # Added line for decay factor\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = decay * (r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential)  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhance global convergence by adding a decay factor to dynamically reduce velocity, improving exploration-exploitation balance.", "configspace": "", "generation": 85, "fitness": 0.9566204313687448, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.957 with standard deviation 0.009. And the mean value of best solutions found was 0.172 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9580459793712431, 0.966461529196853, 0.9453537855381381], "final_y": [0.1711081070060131, 0.1692059437228789, 0.17604734961566415]}, "mutation_prompt": null}
{"id": "c1e9d860-8bb0-4cc0-9166-5208d1425bff", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                self.alpha = 0.5 + 0.5 * np.cos(2 * np.pi * evaluations / self.budget)  # Modified line\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Introduced a nonlinear dynamic adaptation of the alpha coefficient for enhanced exploration-exploitation balance.", "configspace": "", "generation": 86, "fitness": 0.9363977642437921, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.936 with standard deviation 0.014. And the mean value of best solutions found was 0.179 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9437006103434145, 0.9174046840510837, 0.9480879983368781], "final_y": [0.1764470803099194, 0.1827903905058862, 0.17719943525215154]}, "mutation_prompt": null}
{"id": "e012097f-add3-411b-8bb6-f3266879aa4b", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of alpha\n            self.alpha = 0.3 + 0.2 * (1 - evaluations / self.budget)  # Modified line for dynamic alpha\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired PSO with dynamic alpha adjustment for improved convergence.", "configspace": "", "generation": 87, "fitness": 0.9721767843590751, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.972 with standard deviation 0.003. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9726984265648283, 0.9750910343437171, 0.9687408921686798], "final_y": [0.16584257495021826, 0.1654856394253803, 0.16790768182726656]}, "mutation_prompt": null}
{"id": "f7758801-c823-47cb-bf10-fb1e68d924af", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.15 * np.sin(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired PSO with sinusoidal velocity update for improved exploration and convergence.", "configspace": "", "generation": 88, "fitness": 0.9483762895445049, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.948 with standard deviation 0.032. And the mean value of best solutions found was 0.175 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9035098871502092, 0.9741418226207563, 0.9674771588625493], "final_y": [0.1922608976516874, 0.16561152475199425, 0.16700948086102907]}, "mutation_prompt": null}
{"id": "6390afc7-26f6-45ed-af34-b3bf994e0e7e", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                self.alpha = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)  # Dynamic adjustment of alpha\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic alpha adjustment for improved exploration and convergence.", "configspace": "", "generation": 89, "fitness": 0.9398779380476897, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.940 with standard deviation 0.053. And the mean value of best solutions found was 0.178 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9746038566510686, 0.8650507589096258, 0.9799791985823748], "final_y": [0.16541725708007626, 0.20383875403518992, 0.1653588170767032]}, "mutation_prompt": null}
{"id": "990607a9-8960-4608-afca-fc3d44cd5e5c", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                dynamic_alpha = self.alpha * (1 - evaluations / self.budget)  # Modified line\n                quantum_potential = dynamic_alpha * r2 * (self.global_best_position - positions[i])\n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Introduced a dynamic coefficient for quantum potential to improve exploration and convergence.", "configspace": "", "generation": 90, "fitness": 0.9653779465914295, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.965 with standard deviation 0.010. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9535944151538002, 0.9769335540503761, 0.9656058705701124], "final_y": [0.1728248858713891, 0.1654445646312822, 0.16862722794916596]}, "mutation_prompt": null}
{"id": "376030ca-fd08-4917-bfc5-bf89c4a295cb", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                self.alpha = 0.3 + 0.2 * np.cos(np.pi * evaluations / self.budget)  # Changed line\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Introduced dynamic adjustment of quantum potential coefficient to improve convergence.", "configspace": "", "generation": 91, "fitness": 0.9661624450621212, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.966 with standard deviation 0.011. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9518583562728946, 0.9784984182099936, 0.9681305607034756], "final_y": [0.17269070566544975, 0.16492670136001608, 0.16803058102907997]}, "mutation_prompt": null}
{"id": "cc84910f-f3f3-47fe-9d00-173d6e2d1bb9", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            fitness_variance = np.var(personal_best_fitness)  # New line\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget) * (1 + fitness_variance)  # Modified line\n                \n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Refined Quantum-Inspired Particle Swarm Optimization with dynamic learning factor based on fitness variance for improved convergence.", "configspace": "", "generation": 92, "fitness": 0.970028214014965, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.970 with standard deviation 0.009. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9568469045510938, 0.9782368312149042, 0.9750009062788968], "final_y": [0.170837167016762, 0.16493710587508315, 0.16574693890349168]}, "mutation_prompt": null}
{"id": "85466c55-edb7-4af6-abf9-0344657a0eec", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget) ** (1.0 / (1 + evaluations))  # Modified line\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  \n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Improved Quantum-Inspired Particle Swarm Optimization by adjusting learning factor dynamically for enhanced convergence.", "configspace": "", "generation": 93, "fitness": 0.9531649446267982, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.953 with standard deviation 0.033. And the mean value of best solutions found was 0.173 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9729674274187508, 0.9063173602499495, 0.9802100462116944], "final_y": [0.166755327717371, 0.1858385654219602, 0.16505664128995312]}, "mutation_prompt": null}
{"id": "5b44eca6-b6e0-4d7c-8b97-e2c94b04a626", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * (0.9 ** (evaluations / self.budget)) * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization using adaptive velocity influence for improved convergence.", "configspace": "", "generation": 94, "fitness": 0.9727318070154939, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.973 with standard deviation 0.004. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9701690576340019, 0.9783573172268797, 0.9696690461855999], "final_y": [0.16653839930496372, 0.16491957703636806, 0.16690233571908997]}, "mutation_prompt": null}
{"id": "43585748-b1f7-41a3-ad7c-d6e0399f9b38", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * (evaluations/self.budget)**2)  # Modified line for dynamic learning factor\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with dynamic learning factor to improve convergence.", "configspace": "", "generation": 95, "fitness": 0.9694816615603372, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.969 with standard deviation 0.006. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.963116845277395, 0.976921649187189, 0.9684064902164276], "final_y": [0.16913397094639315, 0.16545586661024148, 0.16765104655902163]}, "mutation_prompt": null}
{"id": "258aabc4-a7b9-4b09-8323-3f0e53304a18", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget) * (0.5 + 0.5 * r1)  # Modified line\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Improved convergence by incorporating a dynamic adjustment factor in the velocity update formula.", "configspace": "", "generation": 96, "fitness": 0.973251159436828, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.973 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9727072967494785, 0.9744733222313946, 0.972572859329611], "final_y": [0.1657347405685483, 0.16581804773753828, 0.16642903231557293]}, "mutation_prompt": null}
{"id": "d5916f11-0a0b-4a03-bb67-ba18b474a911", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                dynamic_alpha = self.alpha * (1 + 0.1 * np.sin(2 * np.pi * evaluations / self.budget))  # Modified line\n                quantum_potential = dynamic_alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Quantum-Inspired Particle Swarm Optimization enhanced with dynamic quantum potential adaptation for improved exploration and convergence.", "configspace": "", "generation": 97, "fitness": 0.9573042048684073, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.957 with standard deviation 0.025. And the mean value of best solutions found was 0.172 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9213723522408361, 0.9758041516001809, 0.974736110764205], "final_y": [0.18440464356671826, 0.16546582184059744, 0.16566045017287123]}, "mutation_prompt": null}
{"id": "f86eeefb-0f74-4730-b20b-ece224ae4192", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)  # Modified line\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Revised Quantum-Inspired Particle Swarm Optimization with dynamic learning factor variation to enhance exploration and exploitation balance.", "configspace": "", "generation": 98, "fitness": 0.9485921783783787, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.949 with standard deviation 0.025. And the mean value of best solutions found was 0.175 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.9522659080086086, 0.9162770406319847, 0.9772335864945428], "final_y": [0.17464101393423725, 0.18293832681105027, 0.16632056577260146]}, "mutation_prompt": null}
{"id": "24cb7492-eb97-48d2-a18e-a430156dfb80", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10 * dim // 2, 10)  # Modified line for adaptive population size\n        self.alpha = 0.5  # Coefficient for quantum potential\n        self.beta = 2.0   # Learning factor\n        self.global_best_position = None\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n        \n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_fitness = np.array([func(ind) for ind in positions])\n        evaluations = self.population_size\n        \n        if self.global_best_position is None:\n            best_index = np.argmin(personal_best_fitness)\n            self.global_best_position = personal_best_positions[best_index]\n            global_best_fitness = personal_best_fitness[best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocities using quantum potential\n                r1, r2 = np.random.rand(2)\n                quantum_potential = self.alpha * r2 * (self.global_best_position - positions[i]) \n                self.beta = 1.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n                velocities[i] = r1 * velocities[i] + r2 * self.beta * (1 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)) * quantum_potential * (1 + 0.1)  # Modified line\n                \n                # Update positions based on new velocities\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lower_bound, upper_bound)\n                \n                # Evaluate fitness\n                fitness = func(positions[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_fitness[i] = fitness\n\n                if fitness < global_best_fitness:\n                    self.global_best_position = positions[i]\n                    global_best_fitness = fitness\n                \n                if evaluations >= self.budget:\n                    break\n\n        return self.global_best_position, global_best_fitness", "name": "QuantumInspiredParticleSwarmOptimization", "description": "Enhanced Quantum-Inspired Particle Swarm Optimization with adaptive quantum potential scaling for improved convergence.", "configspace": "", "generation": 99, "fitness": 0.8913081662228421, "feedback": "The algorithm QuantumInspiredParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.891 with standard deviation 0.054. And the mean value of best solutions found was 0.197 (0. is the best) with standard deviation 0.021.", "error": "", "parent_id": "becb7dd3-3f21-436b-9b2f-2f6cd92dd6a5", "metadata": {"aucs": [0.8677179301898652, 0.8401440112744458, 0.9660625572042156], "final_y": [0.2060698967756025, 0.21550852146381494, 0.16803740221441144]}, "mutation_prompt": null}
