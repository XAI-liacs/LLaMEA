{"id": "d1de836f-8596-4c40-aadd-c6cef6b46f74", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate:\n                    # Choose from memory\n                    idx = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Harmony Search Inspired by Quantum Superposition for Efficient Exploration and Exploitation", "configspace": "", "generation": 0, "fitness": 0.10609983503555147, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.106 with standard deviation 0.004. And the mean value of best solutions found was 3.232 (0. is the best) with standard deviation 0.703.", "error": "", "parent_id": null, "metadata": {"aucs": [0.10973035348221116, 0.10753360231955378, 0.10103554930488945], "final_y": [3.2717055305623433, 2.351361158361254, 4.072663967656473]}, "mutation_prompt": null}
{"id": "3fadb132-9c62-4876-829e-94949b42fcde", "solution": "import numpy as np\n\nclass EnhancedQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.initial_improv_rate = 0.9\n        self.final_improv_rate = 0.7\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for iteration in range(self.budget):\n            improv_rate = self.initial_improv_rate - (iteration / self.budget) * (self.initial_improv_rate - self.final_improv_rate)\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < improv_rate:\n                    idx = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "EnhancedQuantumHarmonySearch", "description": "Enhanced QuantumHarmonySearch with Adaptive Harmony Memory Parameters for Improved Convergence and Solution Quality", "configspace": "", "generation": 1, "fitness": 0.09543248719116885, "feedback": "The algorithm EnhancedQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.095 with standard deviation 0.038. And the mean value of best solutions found was 3.980 (0. is the best) with standard deviation 2.488.", "error": "", "parent_id": "d1de836f-8596-4c40-aadd-c6cef6b46f74", "metadata": {"aucs": [0.14862965634702696, 0.07132940086809514, 0.06633840435838445], "final_y": [0.473041859799487, 5.988338748380865, 5.47729249346202]}, "mutation_prompt": null}
{"id": "23b7ac60-5f55-423c-a971-4e58a4f2e5a8", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate:\n                    # Choose from memory\n                    idx = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.pitch_adjust_rate = 0.3 + 0.2 * np.random.rand()  # Adaptive change\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Improved QuantumHarmonySearch with adaptive pitch adjustment for enhanced exploration.", "configspace": "", "generation": 2, "fitness": 0.11323936580554528, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.113 with standard deviation 0.049. And the mean value of best solutions found was 1.589 (0. is the best) with standard deviation 1.165.", "error": "", "parent_id": "d1de836f-8596-4c40-aadd-c6cef6b46f74", "metadata": {"aucs": [0.1814619291782521, 0.07263986067838313, 0.0856163075600006], "final_y": [0.1058790014606174, 1.7117757881276188, 2.9507595580596817]}, "mutation_prompt": null}
{"id": "7ea58ecd-1742-4ffb-bfaa-3f0c498f60ee", "solution": "import numpy as np\n\nclass QuantumHarmonySearchEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n        self.best_solutions_history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for eval_count in range(self.budget):\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate:\n                    idx = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.pitch_adjust_rate = 0.3 + 0.2 * np.random.rand()\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n                self.best_solutions_history.append(best_fitness)\n            \n            dynamic_memory_size = max(1, int(self.harmony_memory_size * (1 - np.tanh(eval_count / self.budget))))\n            self.harmony_memory_improv_rate = 0.5 + 0.4 * np.cos(np.pi * eval_count / self.budget)\n            \n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n            if len(self.best_solutions_history) > 10 and np.std(self.best_solutions_history[-10:]) < 0.01:\n                if dynamic_memory_size > 1:\n                    self.harmony_memory = self.harmony_memory[:dynamic_memory_size]\n\n        return best_solution", "name": "QuantumHarmonySearchEnhanced", "description": "Quantum Harmony Search with historical learning and dynamic memory adaptation for improved exploration and exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.11242851076916686, "feedback": "The algorithm QuantumHarmonySearchEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.112 with standard deviation 0.016. And the mean value of best solutions found was 2.745 (0. is the best) with standard deviation 1.706.", "error": "", "parent_id": "23b7ac60-5f55-423c-a971-4e58a4f2e5a8", "metadata": {"aucs": [0.12146916000406538, 0.09044712919909526, 0.12536924310433994], "final_y": [0.9281818607407997, 5.027341961037148, 2.2797625736321536]}, "mutation_prompt": null}
{"id": "093c19be-8053-483c-bacf-de42d858c05a", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate:\n                    # Choose from memory\n                    idx = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.05 * (1 - _ / self.budget)  # Dynamic bandwidth adaptation\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhanced QuantumHarmonySearch with dynamic bandwidth adaptation for improved exploitation-exploration balance.", "configspace": "", "generation": 4, "fitness": 0.11307097538041011, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.113 with standard deviation 0.027. And the mean value of best solutions found was 3.491 (0. is the best) with standard deviation 1.699.", "error": "", "parent_id": "23b7ac60-5f55-423c-a971-4e58a4f2e5a8", "metadata": {"aucs": [0.09478360214135706, 0.09337825967286162, 0.15105106432701165], "final_y": [4.896830095274024, 4.474488124830724, 1.1006298409252466]}, "mutation_prompt": null}
{"id": "5d6094a8-0b95-4818-8f80-acbf14891d69", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate:\n                    # Choose from memory\n                    idx = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.pitch_adjust_rate = 0.1 + 0.4 * np.random.rand()  # Refined adaptive change\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "QuantumHarmonySearch with refined adaptive pitch adjustment for better convergence.", "configspace": "", "generation": 5, "fitness": 0.12438413411535083, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.124 with standard deviation 0.041. And the mean value of best solutions found was 1.545 (0. is the best) with standard deviation 1.572.", "error": "", "parent_id": "23b7ac60-5f55-423c-a971-4e58a4f2e5a8", "metadata": {"aucs": [0.18290921859938014, 0.09841967215600034, 0.09182351159067204], "final_y": [0.02122780491898777, 0.9060518623824331, 3.7082699358277327]}, "mutation_prompt": null}
{"id": "47c8b153-48bf-4d95-bbeb-d8156afe5759", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate:\n                    # Choose from memory\n                    idx = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.01 + 0.1 * np.random.rand()  # Optimized bandwidth adaptation\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "QuantumHarmonySearch with optimized bandwidth adaptation for enhanced search efficiency.", "configspace": "", "generation": 6, "fitness": 0.10871235032037159, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.109 with standard deviation 0.032. And the mean value of best solutions found was 4.143 (0. is the best) with standard deviation 2.723.", "error": "", "parent_id": "5d6094a8-0b95-4818-8f80-acbf14891d69", "metadata": {"aucs": [0.10454955924661691, 0.07218059855333303, 0.14940689316116484], "final_y": [3.1491852035427903, 7.861295100115629, 1.4176499080766876]}, "mutation_prompt": null}
{"id": "8138607e-384c-4ad1-b5d3-23a81651ad66", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate:\n                    # Choose from memory\n                    idx = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.02 + 0.06 * np.random.rand()  # Enhanced adaptive bandwidth\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "QuantumHarmonySearch with enhanced adaptive bandwidth modulation for improved exploration.", "configspace": "", "generation": 7, "fitness": 0.13109442671428806, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.131 with standard deviation 0.007. And the mean value of best solutions found was 0.692 (0. is the best) with standard deviation 0.180.", "error": "", "parent_id": "5d6094a8-0b95-4818-8f80-acbf14891d69", "metadata": {"aucs": [0.13037774359712184, 0.14050938852283523, 0.1223961480229071], "final_y": [0.5536205784370674, 0.5753525837999165, 0.9465461186488267]}, "mutation_prompt": null}
{"id": "da4fe1c5-c977-482c-8e22-7bd18ec92a91", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):  # Modified line\n                    # Choose from memory\n                    idx = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.02 + 0.06 * np.random.rand()  # Enhanced adaptive bandwidth\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "QuantumHarmonySearch with optimized memory consideration during harmony selection for better convergence.", "configspace": "", "generation": 8, "fitness": 0.13464631461366094, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.135 with standard deviation 0.011. And the mean value of best solutions found was 1.379 (0. is the best) with standard deviation 0.422.", "error": "", "parent_id": "8138607e-384c-4ad1-b5d3-23a81651ad66", "metadata": {"aucs": [0.11929353824447364, 0.13940382113857808, 0.14524158445793112], "final_y": [1.9080811087593965, 1.3542653709183958, 0.8756663266353752]}, "mutation_prompt": null}
{"id": "1aae90a1-868e-45f4-b23b-c6542e1b9ecb", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):  # Modified line\n                    # Choose from memory\n                    idx = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.02 + 0.06 * np.random.rand()  # Enhanced adaptive bandwidth\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n            # Dynamic adjustment of pitch_adjust_rate\n            self.pitch_adjust_rate = 0.1 + 0.2 * np.random.rand()  # Change made here\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "QuantumHarmonySearch with dynamic pitch adjustment rate for improved exploration and convergence.", "configspace": "", "generation": 9, "fitness": 0.1034877524641145, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.103 with standard deviation 0.014. And the mean value of best solutions found was 3.214 (0. is the best) with standard deviation 1.674.", "error": "", "parent_id": "da4fe1c5-c977-482c-8e22-7bd18ec92a91", "metadata": {"aucs": [0.11840105178995797, 0.10728226339670288, 0.08477994220568263], "final_y": [1.0890228258300154, 3.3727898155929465, 5.1800702736538105]}, "mutation_prompt": null}
{"id": "dddc7d23-07f8-45fc-9a31-e58c4e7842a5", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = max(5, int(0.1 * dim))  # Dynamic harmony memory size\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):  # Modified line\n                    # Choose from memory\n                    idx = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.02 + 0.06 * np.random.rand()  # Enhanced adaptive bandwidth\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhanced QuantumHarmonySearch with dynamic harmony memory size for improved adaptability.", "configspace": "", "generation": 10, "fitness": 0.11878385109071347, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.119 with standard deviation 0.018. And the mean value of best solutions found was 1.538 (0. is the best) with standard deviation 0.761.", "error": "", "parent_id": "da4fe1c5-c977-482c-8e22-7bd18ec92a91", "metadata": {"aucs": [0.11219664288279685, 0.1439120671464038, 0.10024284324293975], "final_y": [1.1834868433793628, 0.835549533235611, 2.595216390185575]}, "mutation_prompt": null}
{"id": "fcf05674-bd0a-4f09-8671-6103ae5a9b4a", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate * (1 - i/self.dim)):  # Modified line\n                    # Choose from memory\n                    idx = np.random.randint(self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.02 + 0.06 * np.random.rand()  # Enhanced adaptive bandwidth\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhanced QuantumHarmonySearch with adaptive pitch-adjustment using dynamic memory selection probability.", "configspace": "", "generation": 11, "fitness": 0.0909580432289993, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.091 with standard deviation 0.012. And the mean value of best solutions found was 4.491 (0. is the best) with standard deviation 2.474.", "error": "", "parent_id": "da4fe1c5-c977-482c-8e22-7bd18ec92a91", "metadata": {"aucs": [0.10049588161154943, 0.07425843085858963, 0.0981198172168588], "final_y": [3.7233185538228217, 7.8307832830717725, 1.919639787112243]}, "mutation_prompt": null}
{"id": "57e17735-188c-404d-848c-a487e9f6847c", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):\n                    # Choose from memory\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size)/self.harmony_memory_size)  # Modified line\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.02 + 0.06 * np.random.rand()\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Adaptive harmony memory consideration with improved randomness for robust convergence.", "configspace": "", "generation": 12, "fitness": 0.15064700659611371, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.151 with standard deviation 0.013. And the mean value of best solutions found was 0.759 (0. is the best) with standard deviation 0.091.", "error": "", "parent_id": "da4fe1c5-c977-482c-8e22-7bd18ec92a91", "metadata": {"aucs": [0.167675984304551, 0.13535001618994347, 0.14891501929384665], "final_y": [0.8774882245941134, 0.6556328587714045, 0.7433424761676872]}, "mutation_prompt": null}
{"id": "3cf698b8-57b1-4f56-bb16-bad0aa3d32ba", "solution": "import numpy as np\n\nclass EnhancedQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 12\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory_improv_rate = 0.95\n        self.pitch_adjust_rate = 0.35\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for eval_count in range(self.budget):\n            new_harmony = np.zeros(self.dim)\n            dynamic_improv_rate = self.harmony_memory_improv_rate * (1 - eval_count / self.budget)\n            for i in range(self.dim):\n                if np.random.rand() < dynamic_improv_rate:\n                    idx = np.random.choice(self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        dynamic_bandwidth = self.bandwidth * (1 - eval_count / self.budget)\n                        new_harmony[i] += dynamic_bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if fitness < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "EnhancedQuantumHarmonySearch", "description": "Enhanced Quantum Harmony Search with dynamic memory adaption and self-tuning randomness for improved exploration-exploitation balance.", "configspace": "", "generation": 13, "fitness": 0.08702872736440022, "feedback": "The algorithm EnhancedQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.087 with standard deviation 0.018. And the mean value of best solutions found was 4.561 (0. is the best) with standard deviation 0.846.", "error": "", "parent_id": "57e17735-188c-404d-848c-a487e9f6847c", "metadata": {"aucs": [0.078016122593348, 0.07106398413610793, 0.11200607536374474], "final_y": [4.971611539554767, 5.330026253551285, 3.3822274099118217]}, "mutation_prompt": null}
{"id": "98a963ab-581b-4281-8403-0bed149a53d3", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):\n                    # Choose from memory\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size)/self.harmony_memory_size)  # Modified line\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.02 + 0.06 * np.random.rand()\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n            # Dynamically adjust pitch adjustment rate\n            self.pitch_adjust_rate *= 0.99\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "QuantumHarmonySearch with dynamically adaptive pitch adjustment for enhanced exploration.", "configspace": "", "generation": 14, "fitness": 0.13534397272980217, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.135 with standard deviation 0.003. And the mean value of best solutions found was 1.344 (0. is the best) with standard deviation 0.529.", "error": "", "parent_id": "57e17735-188c-404d-848c-a487e9f6847c", "metadata": {"aucs": [0.1370141962484246, 0.13163691318995208, 0.13738080875102987], "final_y": [0.6505381880402132, 1.447334625209817, 1.9333537758071795]}, "mutation_prompt": null}
{"id": "d8894b14-3fe6-4dab-af6b-c40466df8222", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):\n                    # Choose from memory\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size)/self.harmony_memory_size)  # Modified line\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.02 + 0.06 * np.random.rand()\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n            \n            self.harmony_memory_improv_rate = 0.8 + 0.2 * np.random.rand()  # Added line for dynamic adaptation\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhanced memory consideration by introducing dynamic adaptation of improvement rate to maintain diversity.", "configspace": "", "generation": 15, "fitness": 0.09267640104769104, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.093 with standard deviation 0.035. And the mean value of best solutions found was 2.474 (0. is the best) with standard deviation 2.135.", "error": "", "parent_id": "57e17735-188c-404d-848c-a487e9f6847c", "metadata": {"aucs": [0.09718905623236296, 0.1328775780419722, 0.047962568868737954], "final_y": [1.6429010183877064, 0.3750595678914278, 5.40390922404712]}, "mutation_prompt": null}
{"id": "c8cce1c7-f100-4b50-b6c9-b1ed50aab07a", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.35  # Changed line\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):\n                    # Choose from memory\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size)/self.harmony_memory_size)  # Modified line\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.03 + 0.04 * np.random.rand()  # Changed line\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhanced randomness and adaptive pitch adjustment to improve convergence efficiency.", "configspace": "", "generation": 16, "fitness": 0.11988155721934424, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.120 with standard deviation 0.014. And the mean value of best solutions found was 2.002 (0. is the best) with standard deviation 0.649.", "error": "", "parent_id": "57e17735-188c-404d-848c-a487e9f6847c", "metadata": {"aucs": [0.10094283459136444, 0.1244201475103569, 0.13428168955631137], "final_y": [2.875752829633815, 1.8076555981246774, 1.3229047831542067]}, "mutation_prompt": null}
{"id": "da7960c7-5abb-4f6e-883e-ce5c0ab096c2", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):\n                    # Choose from memory with enhanced selection probability\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size)/self.harmony_memory_size + 0.02)  # Modified line\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.02 + 0.06 * np.random.rand()\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "QuantumHarmonySearch with enhanced selection probability for improved convergence.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities do not sum to 1').", "error": "ValueError('probabilities do not sum to 1')", "parent_id": "57e17735-188c-404d-848c-a487e9f6847c", "metadata": {}, "mutation_prompt": null}
{"id": "c0c7acd9-b841-483a-b6e6-cd6b11ceae3e", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):\n                    # Choose from memory\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size)/self.harmony_memory_size)  # Modified line\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.01 + 0.1 * np.random.rand()  # Change 1: Adjusted bandwidth range\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            if func(new_harmony) < func(self.harmony_memory[np.argmax([func(h) for h in self.harmony_memory])]):  # Change 2: Simplified comparison\n                worst_idx = np.random.choice(np.arange(self.harmony_memory_size), replace=False)  # Change 3: Dynamic replacement strategy\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhanced random pitch adjustment and dynamic memory replacement for better exploration and exploitation.", "configspace": "", "generation": 18, "fitness": 0.10469268371378442, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.105 with standard deviation 0.008. And the mean value of best solutions found was 3.974 (0. is the best) with standard deviation 0.598.", "error": "", "parent_id": "57e17735-188c-404d-848c-a487e9f6847c", "metadata": {"aucs": [0.09671921968393282, 0.10222279171297943, 0.11513603974444098], "final_y": [4.6081218995055755, 4.1429815444805635, 3.1722112648751115]}, "mutation_prompt": null}
{"id": "50c735b8-7d15-4584-9f94-a44120596671", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.4  # Adjusted value\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Adjust harmony memory size dynamically\n            self.harmony_memory_size = max(5, int(0.05 * self.budget))  # Dynamic adjustment\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size)/self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.02 + 0.08 * np.random.rand()  # Adjusted value\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "QuantumHarmonySearch is refined with improved diversity through dynamic harmony memory size and adaptive bandwidth tuning.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 39 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 39 is out of bounds for axis 0 with size 10')", "parent_id": "57e17735-188c-404d-848c-a487e9f6847c", "metadata": {}, "mutation_prompt": null}
{"id": "3f9ed7d7-9886-4b7c-a838-c1e94df84d6c", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):\n                    # Choose from memory\n                    fitness_scores = np.array([func(h) for h in self.harmony_memory])\n                    probabilities = np.exp(-fitness_scores) / np.sum(np.exp(-fitness_scores))\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=probabilities)  # Modified line\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.02 + 0.06 * np.random.rand()\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhanced selection of harmonies with probabilistic bias toward better solutions for improved convergence.", "configspace": "", "generation": 20, "fitness": 0.11811029908742103, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.118 with standard deviation 0.034. And the mean value of best solutions found was 1.311 (0. is the best) with standard deviation 1.430.", "error": "", "parent_id": "57e17735-188c-404d-848c-a487e9f6847c", "metadata": {"aucs": [0.08412117434804511, 0.16500586956040275, 0.10520385335381521], "final_y": [0.31177326573025754, 0.2878618735269595, 3.3329523941863792]}, "mutation_prompt": null}
{"id": "029dd48e-422d-443b-ad7f-2bc14d6e0f34", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                dynamic_improv_rate = self.harmony_memory_improv_rate * (1 - (_ / self.budget))  # Modified line\n                if np.random.rand() < dynamic_improv_rate * (1 - self.pitch_adjust_rate):\n                    # Choose from memory\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size)/self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.02 + 0.06 * np.random.rand()\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "QuantumHarmonySearch with dynamic harmony memory improv rate for enhanced adaptability.", "configspace": "", "generation": 21, "fitness": 0.12781426225493517, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.128 with standard deviation 0.006. And the mean value of best solutions found was 1.538 (0. is the best) with standard deviation 0.676.", "error": "", "parent_id": "57e17735-188c-404d-848c-a487e9f6847c", "metadata": {"aucs": [0.12262358613464464, 0.13570062679932615, 0.1251185738308347], "final_y": [1.9227521356661446, 0.5883889712127817, 2.103167116428446]}, "mutation_prompt": null}
{"id": "a1289faf-5436-41f8-9782-c7a4388945e2", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.35  # Changed line\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):\n                    # Choose from memory\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size)/self.harmony_memory_size)  # Modified line\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.01 + 0.09 * np.random.rand()  # Changed line\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhanced randomness in pitch adjustment and dynamic bandwidth adaptation for improved convergence.", "configspace": "", "generation": 22, "fitness": 0.14585674481526759, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.146 with standard deviation 0.009. And the mean value of best solutions found was 0.829 (0. is the best) with standard deviation 0.037.", "error": "", "parent_id": "57e17735-188c-404d-848c-a487e9f6847c", "metadata": {"aucs": [0.15603030962247932, 0.14774276077019388, 0.13379716405312958], "final_y": [0.863298684388017, 0.8455686682137742, 0.7780253692411379]}, "mutation_prompt": null}
{"id": "1b12b1ee-005a-41ac-954a-43dc3b58c0a8", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):\n                    # Choose from memory\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size)/self.harmony_memory_size)  # Modified line\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.01 + 0.08 * np.random.rand()  # Adjusted bandwidth line\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhanced pitch adjustment using a dynamic bandwidth strategy for improved exploration.", "configspace": "", "generation": 23, "fitness": 0.14570489035599185, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.146 with standard deviation 0.027. And the mean value of best solutions found was 0.831 (0. is the best) with standard deviation 0.198.", "error": "", "parent_id": "57e17735-188c-404d-848c-a487e9f6847c", "metadata": {"aucs": [0.15876148386109368, 0.10766066643002692, 0.17069252077685493], "final_y": [0.619280283593256, 1.095669922957126, 0.7780253692411379]}, "mutation_prompt": null}
{"id": "a73b39f4-14c3-47f0-9eff-f257dfcf5afd", "solution": "import numpy as np\n\nclass ProbabilisticSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.velocities = np.zeros((self.harmony_memory_size, self.dim))\n        self.harmony_memory_improv_rate = 0.85\n        self.inertia_weight = 0.7\n        self.personal_best_positions = self.harmony_memory.copy()\n        self.global_best_position = None\n        self.personal_best_scores = np.full(self.harmony_memory_size, float('inf'))\n        self.global_best_score = float('inf')\n        self.bandwidth = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        for _ in range(self.budget):\n            for i in range(self.harmony_memory_size):\n                # Generate new harmony using probabilistic approach\n                new_harmony = np.copy(self.harmony_memory[i])\n                if np.random.rand() < self.harmony_memory_improv_rate:\n                    idx = np.random.choice(self.harmony_memory_size)\n                    new_harmony += self.inertia_weight * self.velocities[i] + \\\n                                   self.bandwidth * (np.random.rand(self.dim) - 0.5)\n                    new_harmony = np.clip(new_harmony, lb, ub)\n                \n                # Evaluate new harmony\n                fitness = func(new_harmony)\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = new_harmony\n                    if fitness < self.global_best_score:\n                        self.global_best_score = fitness\n                        self.global_best_position = new_harmony\n                \n                # Update velocities\n                cognitive_component = np.random.rand(self.dim) * (self.personal_best_positions[i] - self.harmony_memory[i])\n                social_component = np.random.rand(self.dim) * (self.global_best_position - self.harmony_memory[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return self.global_best_position", "name": "ProbabilisticSwarmHarmonySearch", "description": "Probabilistic Swarm Harmony Search combines swarm intelligence with adaptive memory search to enhance exploration and convergence.", "configspace": "", "generation": 24, "fitness": 0.12794785839450395, "feedback": "The algorithm ProbabilisticSwarmHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.128 with standard deviation 0.034. And the mean value of best solutions found was 1.609 (0. is the best) with standard deviation 1.597.", "error": "", "parent_id": "57e17735-188c-404d-848c-a487e9f6847c", "metadata": {"aucs": [0.11326111438142816, 0.0960944132199697, 0.174488047582114], "final_y": [0.6671200092874566, 3.857237051303884, 0.30236621337459263]}, "mutation_prompt": null}
{"id": "659be0b2-2c4f-4b9b-8068-77d6f9fdca75", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.4  # Changed from 0.3 to 0.4\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):\n                    # Choose from memory\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size)/self.harmony_memory_size)  # Modified line\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.02 + 0.08 * np.random.rand()  # Changed from 0.06 to 0.08\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhanced harmonic balance using dynamic pitch adjustment and intensified memory selection.", "configspace": "", "generation": 25, "fitness": 0.12635604366407005, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.126 with standard deviation 0.027. And the mean value of best solutions found was 1.898 (0. is the best) with standard deviation 0.909.", "error": "", "parent_id": "57e17735-188c-404d-848c-a487e9f6847c", "metadata": {"aucs": [0.10440971021495005, 0.1106269098978957, 0.1640315108793644], "final_y": [1.4573536777177039, 3.163610915239781, 1.0720739149610092]}, "mutation_prompt": null}
{"id": "ac551def-ac7b-4196-a8f3-e1f98173bf40", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):\n                    # Choose from memory\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size)/self.harmony_memory_size)  # Modified line\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand()  # Refined line\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Refined pitch adjustment with adaptive bandwidth for enhanced precision.", "configspace": "", "generation": 26, "fitness": 0.15365980425039386, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.154 with standard deviation 0.012. And the mean value of best solutions found was 1.128 (0. is the best) with standard deviation 0.474.", "error": "", "parent_id": "57e17735-188c-404d-848c-a487e9f6847c", "metadata": {"aucs": [0.1540616683624032, 0.16792211253908318, 0.1389956318496952], "final_y": [1.211611233069367, 0.5101207410657592, 1.6609135394133603]}, "mutation_prompt": null}
{"id": "2df42c59-4212-4f04-9e9e-b810ce3032b5", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * np.sin(np.pi * self.pitch_adjust_rate):  # Modified line\n                    # Choose from memory\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size)/self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand()\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhanced exploration with dynamic adjustment of harmony selection probability.", "configspace": "", "generation": 27, "fitness": 0.11882713449481352, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.119 with standard deviation 0.035. And the mean value of best solutions found was 3.149 (0. is the best) with standard deviation 1.855.", "error": "", "parent_id": "ac551def-ac7b-4196-a8f3-e1f98173bf40", "metadata": {"aucs": [0.16478289177945482, 0.07966845283617696, 0.11203005886880879], "final_y": [0.7689943546848637, 5.294914760826429, 3.3822274099118217]}, "mutation_prompt": null}
{"id": "5b5e0c13-620a-4f5c-8c9b-8ed8098eca04", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):\n                    # Choose from memory\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size)/self.harmony_memory_size)  # Modified line\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        fitness_improvement = max(0, best_fitness - func(new_harmony))  # Modified line\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand() * fitness_improvement  # Refined line\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhance exploration with dynamic pitch adjustment based on fitness improvement.", "configspace": "", "generation": 28, "fitness": 0.13695329145137783, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.008. And the mean value of best solutions found was 0.877 (0. is the best) with standard deviation 0.342.", "error": "", "parent_id": "ac551def-ac7b-4196-a8f3-e1f98173bf40", "metadata": {"aucs": [0.12653738253099955, 0.13703179122828213, 0.14729070059485183], "final_y": [1.092349551621509, 1.1448468185690028, 0.39374007457160665]}, "mutation_prompt": null}
{"id": "f867610d-d8f6-46ca-8058-aa6b4d3c9251", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.95  # Adjusted line\n        self.pitch_adjust_rate = 0.4  # Adjusted line\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):\n                    # Choose weighted selection from memory\n                    fitness_values = np.array([func(h) for h in self.harmony_memory])\n                    fitness_weights = np.max(fitness_values) - fitness_values\n                    fitness_weights /= np.sum(fitness_weights)\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=fitness_weights)  # Adjusted line\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand()  # Refined line\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhanced selection and dynamic pitch adjustment to improve convergence speed and accuracy.", "configspace": "", "generation": 29, "fitness": 0.06881029945365151, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.069 with standard deviation 0.012. And the mean value of best solutions found was 6.306 (0. is the best) with standard deviation 1.148.", "error": "", "parent_id": "ac551def-ac7b-4196-a8f3-e1f98173bf40", "metadata": {"aucs": [0.08002755013684293, 0.07369609233986618, 0.05270725588424541], "final_y": [5.233058403397351, 7.89699040749876, 5.7872915671020175]}, "mutation_prompt": null}
{"id": "cea8c13c-4df9-4cb8-adab-3944b27b0489", "solution": "import numpy as np\n\nclass DynamicQuantumGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.entanglement_factor = 0.7\n        self.mutation_rate = 0.1\n        self.mutation_adaptation_rate = 0.03\n        self.population = np.random.rand(self.population_size, self.dim)\n        self.population *= (1 + 1) - 1\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _select_parents(self, fitness):\n        idx = np.argsort(fitness)\n        return self.population[idx][:self.population_size // 2]\n\n    def _crossover(self, parents):\n        offspring = []\n        for _ in range(self.population_size - len(parents)):\n            if np.random.rand() < self.entanglement_factor:\n                parent1, parent2 = np.random.choice(parents, 2, replace=False)\n                cross_point = np.random.randint(0, self.dim)\n                child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n                offspring.append(child)\n        return np.array(offspring)\n\n    def _mutate(self, population, lb, ub):\n        for individual in population:\n            if np.random.rand() < self.mutation_rate:\n                mutation_vector = np.random.normal(0, 1, self.dim)\n                individual += self.mutation_adaptation_rate * mutation_vector\n                np.clip(individual, lb, ub, out=individual)\n        return population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.population = lb + (ub - lb) * self.population\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            fitness = self._evaluate_population(func)\n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_fitness = fitness[best_idx]\n                best_solution = self.population[best_idx]\n\n            parents = self._select_parents(fitness)\n            offspring = self._crossover(parents)\n            self.population = np.vstack((parents, offspring))\n            self.population = self._mutate(self.population, lb, ub)\n\n        return best_solution", "name": "DynamicQuantumGeneticAlgorithm", "description": "Dynamic Quantum Genetic Algorithm (DQGA) with adaptive mutation and entangled crossover for robust optimization.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "ac551def-ac7b-4196-a8f3-e1f98173bf40", "metadata": {}, "mutation_prompt": null}
{"id": "6408c269-ab75-4ae6-a647-e3971951577d", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            if _ % 10 == 0 and self.harmony_memory_size < 20: # New line: Adaptive memory size increase\n                self.harmony_memory_size += 1\n                self.harmony_memory = np.vstack((self.harmony_memory, np.random.rand(1, self.dim)))\n\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size)/self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand()\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if fitness < func(self.harmony_memory[worst_idx]): # Modified line to use cached fitness\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhanced Quantum Harmony Search with adaptive harmony memory size and dynamic pitch adjustment.", "configspace": "", "generation": 31, "fitness": 0.09894464115533341, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.099 with standard deviation 0.026. And the mean value of best solutions found was 3.253 (0. is the best) with standard deviation 1.777.", "error": "", "parent_id": "ac551def-ac7b-4196-a8f3-e1f98173bf40", "metadata": {"aucs": [0.06489882289114624, 0.12717489847967656, 0.10476020209517745], "final_y": [5.757387635555758, 1.820606978301864, 2.18237477873178]}, "mutation_prompt": null}
{"id": "626c31a2-54a2-40e8-bbff-3be22df0d44e", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):\n                    # Choose from memory\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size)/self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand()\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            fitness_values = [func(h) for h in self.harmony_memory]\n            worst_idx = np.argmax(fitness_values)\n            diversity_idx = np.random.choice(np.arange(self.harmony_memory_size))  # New line for diversity\n            if func(new_harmony) < min(func(self.harmony_memory[worst_idx]), func(self.harmony_memory[diversity_idx])):  # Modified line\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhanced memory consideration with diversity-driven selection for convergence improvement.", "configspace": "", "generation": 32, "fitness": 0.12098397907028868, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.121 with standard deviation 0.039. And the mean value of best solutions found was 2.865 (0. is the best) with standard deviation 3.085.", "error": "", "parent_id": "ac551def-ac7b-4196-a8f3-e1f98173bf40", "metadata": {"aucs": [0.07645843295035415, 0.17092554400812643, 0.11556796025238547], "final_y": [7.176975252293611, 0.1377702249358603, 1.2799735287842027]}, "mutation_prompt": null}
{"id": "be5f0848-120e-4436-9399-ce58af3ff028", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):\n                    # Choose from memory\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.random.dirichlet(np.ones(self.harmony_memory_size)))  # Modified line\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand()  # Refined line\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Introduced stochastic selection bias for improved diversity in harmony generation.", "configspace": "", "generation": 33, "fitness": 0.13765852398141457, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.138 with standard deviation 0.006. And the mean value of best solutions found was 1.202 (0. is the best) with standard deviation 0.446.", "error": "", "parent_id": "ac551def-ac7b-4196-a8f3-e1f98173bf40", "metadata": {"aucs": [0.14111878852701532, 0.14324493700971352, 0.12861184640751488], "final_y": [1.0058939246285858, 0.7812961593997223, 1.8201388938871559]}, "mutation_prompt": null}
{"id": "eb595da5-cc0a-4149-917b-bbf1bac1af6d", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):\n                    # Choose from memory\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.argsort([func(h) for h in self.harmony_memory]) / np.sum(np.argsort([func(h) for h in self.harmony_memory])))  # Modified line\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand()  # Refined line\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhanced quantum harmony search with adaptive memory consideration for improved solution diversity.", "configspace": "", "generation": 34, "fitness": 0.11746300815975297, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.117 with standard deviation 0.026. And the mean value of best solutions found was 3.489 (0. is the best) with standard deviation 2.277.", "error": "", "parent_id": "ac551def-ac7b-4196-a8f3-e1f98173bf40", "metadata": {"aucs": [0.14380403185982105, 0.12696449720275782, 0.08162049541668004], "final_y": [1.662243015490298, 2.105104027944023, 6.698614179556867]}, "mutation_prompt": null}
{"id": "3a426385-d607-4fd6-944e-e5c7ebae9016", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = int(10 + np.log1p(budget))  # Modified line\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):\n                    # Choose from memory\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size)/self.harmony_memory_size)  # Modified line\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand()  # Refined line\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhanced the balance between exploration and exploitation by adjusting the memory size dynamically.", "configspace": "", "generation": 35, "fitness": 0.11074097377749714, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.111 with standard deviation 0.018. And the mean value of best solutions found was 2.983 (0. is the best) with standard deviation 0.595.", "error": "", "parent_id": "ac551def-ac7b-4196-a8f3-e1f98173bf40", "metadata": {"aucs": [0.13147074608791687, 0.08718601976209961, 0.11356615548247495], "final_y": [2.2159925987073397, 3.6654177613416605, 3.067303514805555]}, "mutation_prompt": null}
{"id": "ad25e33d-f5b5-4b7e-89e8-8c5e9b9d5660", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_improv_rate * (1 - self.pitch_adjust_rate):\n                    # Choose from memory\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size)/self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.01 + 0.03 * np.sqrt(np.random.rand())  # Refined line\n                        new_harmony[i] += self.bandwidth * np.random.normal(0, 1)  # Refined line\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhanced adaptive bandwidth with dynamic pitch adjustment for improved precision.", "configspace": "", "generation": 36, "fitness": 0.12517842628643827, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.125 with standard deviation 0.025. And the mean value of best solutions found was 2.495 (0. is the best) with standard deviation 1.721.", "error": "", "parent_id": "ac551def-ac7b-4196-a8f3-e1f98173bf40", "metadata": {"aucs": [0.1509377680507732, 0.09222764373421766, 0.13236986707432397], "final_y": [0.7756163126927375, 4.846901940051419, 1.8635399525515686]}, "mutation_prompt": null}
{"id": "5724e1cf-7b88-40d1-bfd4-79972893d36d", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < (self.harmony_memory_improv_rate + 0.05) * (1 - self.pitch_adjust_rate):  # Modified line\n                    # Choose from memory\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size)/self.harmony_memory_size)  # Modified line\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand()  # Refined line\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Fine-tune harmony selection probability for improved balance between exploration and exploitation.", "configspace": "", "generation": 37, "fitness": 0.154251110000612, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.154 with standard deviation 0.005. And the mean value of best solutions found was 0.849 (0. is the best) with standard deviation 0.243.", "error": "", "parent_id": "ac551def-ac7b-4196-a8f3-e1f98173bf40", "metadata": {"aucs": [0.15973487597390734, 0.1476034450532746, 0.1554150089746541], "final_y": [1.1858573361854936, 0.6190363354555055, 0.7433424761676872]}, "mutation_prompt": null}
{"id": "ac1f27e2-0f39-441f-8a71-49cd7c77d013", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory *= (1 + 1) - 1\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        # Initialize harmony memory with random solutions\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * (2 * np.random.rand(self.harmony_memory_size, self.dim) - 0.5)  # Modified line\n\n        best_solution = None\n        best_fitness = float('inf')\n\n        for _ in range(self.budget):\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < (self.harmony_memory_improv_rate + 0.05) * (1 - self.pitch_adjust_rate):\n                    # Choose from memory\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size)/self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    if np.random.rand() < self.pitch_adjust_rate:\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand()\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    # Randomly generate new component\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            # Evaluate the new harmony\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            # Update harmony memory\n            worst_idx = np.argmax([func(h) for h in self.harmony_memory])\n            if func(new_harmony) < func(self.harmony_memory[worst_idx]):\n                self.harmony_memory[worst_idx] = new_harmony\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Improve solution diversity by adjusting harmony memory initialization range.", "configspace": "", "generation": 38, "fitness": 0.09900314762957378, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.099 with standard deviation 0.032. And the mean value of best solutions found was 2.250 (0. is the best) with standard deviation 1.704.", "error": "", "parent_id": "5724e1cf-7b88-40d1-bfd4-79972893d36d", "metadata": {"aucs": [0.08254875758116276, 0.07134826433716912, 0.14311242097038945], "final_y": [4.552554372194555, 0.48459983854147426, 1.7132713071545647]}, "mutation_prompt": null}
{"id": "d77443d6-fe4f-4486-bcae-05bb3a3517b5", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n        fitness_memory = np.array([func(h) for h in self.harmony_memory])\n\n        for _ in range(self.budget):\n            # Calculate adaptive rates\n            sorted_indices = np.argsort(fitness_memory)\n            improv_rate_adaptive = self.harmony_memory_improv_rate * (1 - sorted_indices / self.harmony_memory_size)\n            pitch_adjust_adaptive = self.pitch_adjust_rate * (sorted_indices / self.harmony_memory_size)\n\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < improv_rate_adaptive[i]:\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size) / self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    \n                    if np.random.rand() < pitch_adjust_adaptive[i]:\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand()\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax(fitness_memory)\n            if fitness < fitness_memory[worst_idx]:\n                self.harmony_memory[worst_idx] = new_harmony\n                fitness_memory[worst_idx] = fitness\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhance pitch-adjustment and memory consideration via adaptive rates based on harmony fitness to improve exploration-exploitation balance.", "configspace": "", "generation": 39, "fitness": 0.1968024093761631, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.197 with standard deviation 0.026. And the mean value of best solutions found was 0.336 (0. is the best) with standard deviation 0.215.", "error": "", "parent_id": "5724e1cf-7b88-40d1-bfd4-79972893d36d", "metadata": {"aucs": [0.1894965416945491, 0.23136313331501213, 0.1695475531189281], "final_y": [0.2656153537618613, 0.11502608099156002, 0.6262992489415262]}, "mutation_prompt": null}
{"id": "afaee57d-3aa6-4d19-b126-6980f6b04021", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n        fitness_memory = np.array([func(h) for h in self.harmony_memory])\n\n        for _ in range(self.budget):\n            # Calculate adaptive rates\n            sorted_indices = np.argsort(fitness_memory)\n            improv_rate_adaptive = self.harmony_memory_improv_rate * (1 - sorted_indices / self.harmony_memory_size)\n            pitch_adjust_adaptive = self.pitch_adjust_rate * (sorted_indices / self.harmony_memory_size)\n\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < improv_rate_adaptive[i]:\n                    idx = np.random.choice(sorted_indices[:self.harmony_memory_size//2])  # Focus on top performers\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    \n                    if np.random.rand() < pitch_adjust_adaptive[i]:\n                        adaptive_bandwidth = self.bandwidth * (1 - fitness_memory[idx] / best_fitness)\n                        new_harmony[i] += adaptive_bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax(fitness_memory)\n            if fitness < fitness_memory[worst_idx]:\n                self.harmony_memory[worst_idx] = new_harmony\n                fitness_memory[worst_idx] = fitness\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Introduce adaptive bandwidth based on harmony quality and modify memory consideration to focus on top performers for enhanced convergence.", "configspace": "", "generation": 40, "fitness": 0.14793432282846478, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.148 with standard deviation 0.029. And the mean value of best solutions found was 1.666 (0. is the best) with standard deviation 0.749.", "error": "", "parent_id": "d77443d6-fe4f-4486-bcae-05bb3a3517b5", "metadata": {"aucs": [0.1274549625594058, 0.12734043994884903, 0.18900756597713952], "final_y": [2.2429641298829313, 2.1474370175437607, 0.6090586604103801]}, "mutation_prompt": null}
{"id": "7602f0c3-85b4-45bc-8ff5-9cb7e0f10c9e", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n        fitness_memory = np.array([func(h) for h in self.harmony_memory])\n\n        for _ in range(self.budget):\n            # Calculate adaptive rates\n            sorted_indices = np.argsort(fitness_memory)\n            improv_rate_adaptive = self.harmony_memory_improv_rate * (1 - sorted_indices / self.harmony_memory_size)\n            improv_rate_adaptive = 1 - improv_rate_adaptive  # Invert adaptive rate based on rank\n            pitch_adjust_adaptive = self.pitch_adjust_rate * (sorted_indices / self.harmony_memory_size)\n\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < improv_rate_adaptive[i]:\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size) / self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    \n                    if np.random.rand() < pitch_adjust_adaptive[i]:\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand()\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax(fitness_memory)\n            if fitness < fitness_memory[worst_idx]:\n                self.harmony_memory[worst_idx] = new_harmony\n                fitness_memory[worst_idx] = fitness\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Incorporate dynamic harmony memory consideration using fitness rank inversion to enhance adaptive exploration-exploitation balance.", "configspace": "", "generation": 41, "fitness": 0.2308390745260699, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.231 with standard deviation 0.013. And the mean value of best solutions found was 0.114 (0. is the best) with standard deviation 0.034.", "error": "", "parent_id": "d77443d6-fe4f-4486-bcae-05bb3a3517b5", "metadata": {"aucs": [0.2133460284228582, 0.23592352786289295, 0.2432476672924585], "final_y": [0.15565045813617018, 0.07239698312387245, 0.11406800298081435]}, "mutation_prompt": null}
{"id": "dbb8dfeb-4916-4752-a44b-f6de1e3bc667", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n        fitness_memory = np.array([func(h) for h in self.harmony_memory])\n\n        for _ in range(self.budget):\n            # Calculate adaptive rates\n            sorted_indices = np.argsort(fitness_memory)\n            improv_rate_adaptive = self.harmony_memory_improv_rate * (1 - sorted_indices / self.harmony_memory_size)\n            improv_rate_adaptive = 1 - improv_rate_adaptive  # Invert adaptive rate based on rank\n            pitch_adjust_adaptive = self.pitch_adjust_rate * (sorted_indices / self.harmony_memory_size)\n\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < improv_rate_adaptive[i]:\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size) / self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    \n                    if np.random.rand() < pitch_adjust_adaptive[i]:\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand() * (fitness_memory[idx] / np.max(fitness_memory))  # Change\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax(fitness_memory)\n            if fitness < fitness_memory[worst_idx]:\n                self.harmony_memory[worst_idx] = new_harmony\n                fitness_memory[worst_idx] = fitness\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Introduce dynamic pitch adjustment with fitness-dependent scaling to enhance the adaptive exploitation in the search process.", "configspace": "", "generation": 42, "fitness": 0.22493163458280266, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.225 with standard deviation 0.018. And the mean value of best solutions found was 0.147 (0. is the best) with standard deviation 0.045.", "error": "", "parent_id": "7602f0c3-85b4-45bc-8ff5-9cb7e0f10c9e", "metadata": {"aucs": [0.1996026250293621, 0.23710799132225946, 0.23808428739678644], "final_y": [0.19676455005236868, 0.08846968315139139, 0.15649464319112982]}, "mutation_prompt": null}
{"id": "eb7ad4c8-2b68-4707-9af1-8ebbbc412888", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n        fitness_memory = np.array([func(h) for h in self.harmony_memory])\n\n        for _ in range(self.budget):\n            # Calculate adaptive rates\n            sorted_indices = np.argsort(fitness_memory)\n            improv_rate_adaptive = self.harmony_memory_improv_rate * (1 - sorted_indices / self.harmony_memory_size)\n            improv_rate_adaptive = 1 - improv_rate_adaptive  # Invert adaptive rate based on rank\n            pitch_adjust_adaptive = self.pitch_adjust_rate * (sorted_indices / self.harmony_memory_size)\n\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < improv_rate_adaptive[i]:\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size) / self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    \n                    if np.random.rand() < pitch_adjust_adaptive[i]:\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand()\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1) * np.random.rand()  # Added randomization\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax(fitness_memory)\n            if fitness < fitness_memory[worst_idx]:\n                self.harmony_memory[worst_idx] = new_harmony\n                fitness_memory[worst_idx] = fitness\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhance pitch adjustment with randomization for adaptive exploration.", "configspace": "", "generation": 43, "fitness": 0.18571692080915006, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.186 with standard deviation 0.026. And the mean value of best solutions found was 0.419 (0. is the best) with standard deviation 0.072.", "error": "", "parent_id": "7602f0c3-85b4-45bc-8ff5-9cb7e0f10c9e", "metadata": {"aucs": [0.19635239691474937, 0.15049991997560863, 0.2102984455370922], "final_y": [0.5085764734242703, 0.41681604355700574, 0.3318076356686697]}, "mutation_prompt": null}
{"id": "c150803f-6802-4f20-865a-7232fb91fbe6", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n        fitness_memory = np.array([func(h) for h in self.harmony_memory])\n\n        for _ in range(self.budget):\n            # Calculate adaptive rates\n            sorted_indices = np.argsort(fitness_memory)\n            improv_rate_adaptive = self.harmony_memory_improv_rate * (1 - sorted_indices / self.harmony_memory_size)\n            improv_rate_adaptive = 1 - improv_rate_adaptive  # Invert adaptive rate based on rank\n            pitch_adjust_adaptive = self.pitch_adjust_rate * (sorted_indices / self.harmony_memory_size)\n\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < improv_rate_adaptive[i]:\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size) / self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    \n                    if np.random.rand() < pitch_adjust_adaptive[i]:\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand() * (best_fitness - fitness_memory.mean()) / (np.std(fitness_memory) + 1e-6)\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax(fitness_memory)\n            if fitness < fitness_memory[worst_idx]:\n                self.harmony_memory[worst_idx] = new_harmony\n                fitness_memory[worst_idx] = fitness\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhance convergence by introducing elitist selection and adaptive dynamic bandwidth adjustment.", "configspace": "", "generation": 44, "fitness": 0.22736174404693774, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.227 with standard deviation 0.016. And the mean value of best solutions found was 0.154 (0. is the best) with standard deviation 0.046.", "error": "", "parent_id": "7602f0c3-85b4-45bc-8ff5-9cb7e0f10c9e", "metadata": {"aucs": [0.24554295229518952, 0.2289135428767446, 0.20762873696887907], "final_y": [0.11884526907421981, 0.12541435892192337, 0.21913256706685386]}, "mutation_prompt": null}
{"id": "8df1b22b-3f33-4d57-acd3-1acdf5f14d5d", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n        fitness_memory = np.array([func(h) for h in self.harmony_memory])\n\n        for _ in range(self.budget):\n            # Calculate adaptive rates\n            sorted_indices = np.argsort(fitness_memory)\n            improv_rate_adaptive = self.harmony_memory_improv_rate * (1 - sorted_indices / self.harmony_memory_size)\n            improv_rate_adaptive = 1 - improv_rate_adaptive  # Invert adaptive rate based on rank\n            pitch_adjust_adaptive = self.pitch_adjust_rate * (sorted_indices / self.harmony_memory_size)\n\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < improv_rate_adaptive[i]:\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size) / self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    \n                    if np.random.rand() < pitch_adjust_adaptive[i]:\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand()\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax(fitness_memory)\n            if fitness < fitness_memory[worst_idx]:\n                self.harmony_memory[worst_idx] = new_harmony\n                fitness_memory[worst_idx] = fitness\n\n        # Adjust harmony memory size based on fitness variance\n        self.harmony_memory_size = max(5, int(np.var(fitness_memory) * 5))\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhance diversity by dynamically adjusting the harmony memory size based on fitness variance.", "configspace": "", "generation": 45, "fitness": 0.13967154241608284, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.140 with standard deviation 0.015. And the mean value of best solutions found was 1.165 (0. is the best) with standard deviation 0.092.", "error": "", "parent_id": "7602f0c3-85b4-45bc-8ff5-9cb7e0f10c9e", "metadata": {"aucs": [0.15560186959986366, 0.11927578208218725, 0.14413697556619764], "final_y": [1.1491550929109737, 1.284894014264525, 1.0609340277824386]}, "mutation_prompt": null}
{"id": "f751516a-1b67-45b5-ab8a-0d6244490b12", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n        fitness_memory = np.array([func(h) for h in self.harmony_memory])\n\n        for _ in range(self.budget):\n            # Calculate adaptive rates\n            sorted_indices = np.argsort(fitness_memory)\n            improv_rate_adaptive = self.harmony_memory_improv_rate * (1 - sorted_indices / self.harmony_memory_size)\n            improv_rate_adaptive = 1 - improv_rate_adaptive  # Invert adaptive rate based on rank\n            pitch_adjust_adaptive = self.pitch_adjust_rate * (sorted_indices / self.harmony_memory_size)\n\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < improv_rate_adaptive[i]:\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size) / self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    \n                    if np.random.rand() < pitch_adjust_adaptive[i]:\n                        self.bandwidth = 0.01 + 0.1 * (1 - sorted_indices[i] / self.harmony_memory_size)\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax(fitness_memory)\n            if fitness < fitness_memory[worst_idx]:\n                self.harmony_memory[worst_idx] = new_harmony\n                fitness_memory[worst_idx] = fitness\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Improve exploration via dynamic bandwidth adjustment and rank-based random pitch adjustment.", "configspace": "", "generation": 46, "fitness": 0.16651961367860757, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.167 with standard deviation 0.018. And the mean value of best solutions found was 0.810 (0. is the best) with standard deviation 0.317.", "error": "", "parent_id": "7602f0c3-85b4-45bc-8ff5-9cb7e0f10c9e", "metadata": {"aucs": [0.19212074900230613, 0.15533599614230964, 0.15210209589120693], "final_y": [0.3991046381240523, 0.857833784705047, 1.1719942013350033]}, "mutation_prompt": null}
{"id": "62ee3cb4-2279-4ca6-84f1-bc2cc8292b98", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n        fitness_memory = np.array([func(h) for h in self.harmony_memory])\n\n        for _ in range(self.budget):\n            # Calculate adaptive rates\n            sorted_indices = np.argsort(fitness_memory)\n            improv_rate_adaptive = self.harmony_memory_improv_rate * (1 - sorted_indices / self.harmony_memory_size)\n            improv_rate_adaptive = 1 - improv_rate_adaptive  # Invert adaptive rate based on rank\n            pitch_adjust_adaptive = self.pitch_adjust_rate * (1 - sorted_indices / self.harmony_memory_size)  # Changed this line\n\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < improv_rate_adaptive[i]:\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size) / self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    \n                    if np.random.rand() < pitch_adjust_adaptive[i]:\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand()\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax(fitness_memory)\n            if fitness < fitness_memory[worst_idx]:\n                self.harmony_memory[worst_idx] = new_harmony\n                fitness_memory[worst_idx] = fitness\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhance adaptive exploration using dynamic pitch adjustment rate control.", "configspace": "", "generation": 47, "fitness": 0.16503210541797028, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.165 with standard deviation 0.013. And the mean value of best solutions found was 0.688 (0. is the best) with standard deviation 0.278.", "error": "", "parent_id": "7602f0c3-85b4-45bc-8ff5-9cb7e0f10c9e", "metadata": {"aucs": [0.18212141589231234, 0.15170397642227673, 0.16127092393932174], "final_y": [0.4247244325066645, 1.0730818236098296, 0.5672405907805036]}, "mutation_prompt": null}
{"id": "0059a57f-acaa-400d-95bf-2b83910e1e64", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n        fitness_memory = np.array([func(h) for h in self.harmony_memory])\n\n        for _ in range(self.budget):\n            # Calculate adaptive rates\n            sorted_indices = np.argsort(fitness_memory)\n            improv_rate_adaptive = self.harmony_memory_improv_rate * (1 - sorted_indices / self.harmony_memory_size)\n            improv_rate_adaptive = 1 - improv_rate_adaptive  # Invert adaptive rate based on rank\n            pitch_adjust_adaptive = self.pitch_adjust_rate * (sorted_indices / self.harmony_memory_size)\n\n            # Adjust bandwidth based on variance\n            self.bandwidth = max(0.01, 0.05 * np.var(self.harmony_memory))\n\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < improv_rate_adaptive[i]:\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size) / self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    \n                    if np.random.rand() < pitch_adjust_adaptive[i]:\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax(fitness_memory)\n            if fitness < fitness_memory[worst_idx]:\n                self.harmony_memory[worst_idx] = new_harmony\n                fitness_memory[worst_idx] = fitness\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhance exploration phase by introducing dynamic pitch-adjustment based on variance within harmony memory.", "configspace": "", "generation": 48, "fitness": 0.17409895057798722, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.174 with standard deviation 0.011. And the mean value of best solutions found was 0.501 (0. is the best) with standard deviation 0.102.", "error": "", "parent_id": "7602f0c3-85b4-45bc-8ff5-9cb7e0f10c9e", "metadata": {"aucs": [0.1866829897484975, 0.16015734502778012, 0.17545651695768405], "final_y": [0.42039195958306985, 0.438009664509419, 0.6458837251294666]}, "mutation_prompt": null}
{"id": "b22cb91b-3f69-4d7d-835b-4ce9b27c5b50", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n        fitness_memory = np.array([func(h) for h in self.harmony_memory])\n\n        for _ in range(self.budget):\n            # Dynamically adjust harmony memory size based on fitness improvement\n            if _ > 0 and np.min(fitness_memory) < best_fitness:\n                # Increase memory size when improvement is observed\n                self.harmony_memory_size = min(self.harmony_memory_size + 1, len(fitness_memory))\n                new_memory = np.random.rand(self.harmony_memory_size, self.dim)\n                self.harmony_memory = np.vstack((self.harmony_memory, new_memory))[:self.harmony_memory_size]\n\n            # Calculate adaptive rates\n            sorted_indices = np.argsort(fitness_memory)\n            improv_rate_adaptive = self.harmony_memory_improv_rate * (1 - sorted_indices / self.harmony_memory_size)\n            improv_rate_adaptive = 1 - improv_rate_adaptive  # Invert adaptive rate based on rank\n            pitch_adjust_adaptive = self.pitch_adjust_rate * (sorted_indices / self.harmony_memory_size)\n\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < improv_rate_adaptive[i]:\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size) / self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    \n                    if np.random.rand() < pitch_adjust_adaptive[i]:\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand()\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax(fitness_memory)\n            if fitness < fitness_memory[worst_idx]:\n                self.harmony_memory[worst_idx] = new_harmony\n                fitness_memory[worst_idx] = fitness\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Utilize harmony memory diversity by dynamically adjusting harmony memory size based on recent performance.", "configspace": "", "generation": 49, "fitness": 0.18937848671864396, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.189 with standard deviation 0.034. And the mean value of best solutions found was 0.277 (0. is the best) with standard deviation 0.168.", "error": "", "parent_id": "7602f0c3-85b4-45bc-8ff5-9cb7e0f10c9e", "metadata": {"aucs": [0.2376269783591929, 0.16865635499192577, 0.1618521268048132], "final_y": [0.04056335435465281, 0.37786888456142376, 0.41290519289744343]}, "mutation_prompt": null}
{"id": "38d48b4b-667e-449b-bd94-dca25549d866", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n        fitness_memory = np.array([func(h) for h in self.harmony_memory])\n\n        for _ in range(self.budget):\n            # Calculate adaptive rates\n            sorted_indices = np.argsort(fitness_memory)\n            improv_rate_adaptive = self.harmony_memory_improv_rate * (1 - sorted_indices / self.harmony_memory_size)\n            improv_rate_adaptive = 1 - improv_rate_adaptive  # Invert adaptive rate based on rank\n            pitch_adjust_adaptive = self.pitch_adjust_rate * (sorted_indices / self.harmony_memory_size)\n\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < improv_rate_adaptive[i]:\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size) / self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    \n                    if np.random.rand() < pitch_adjust_adaptive[i]:\n                        self.bandwidth *= 0.99  # Apply exponential decay to bandwidth\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax(fitness_memory)\n            if fitness < fitness_memory[worst_idx]:\n                self.harmony_memory[worst_idx] = new_harmony\n                fitness_memory[worst_idx] = fitness\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Introducing adaptive bandwidth scaling using exponential decay to enhance local search precision over time.", "configspace": "", "generation": 50, "fitness": 0.2190909381164795, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.219 with standard deviation 0.024. And the mean value of best solutions found was 0.221 (0. is the best) with standard deviation 0.123.", "error": "", "parent_id": "7602f0c3-85b4-45bc-8ff5-9cb7e0f10c9e", "metadata": {"aucs": [0.2524013376594303, 0.20737277399039322, 0.197498702699615], "final_y": [0.07204232260837606, 0.21593942651226478, 0.3738312343126181]}, "mutation_prompt": null}
{"id": "ba22f785-c3bf-4c2a-ae57-d3eefc808f91", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n        fitness_memory = np.array([func(h) for h in self.harmony_memory])\n\n        for iteration in range(self.budget):\n            # Adjust harmony memory size over time\n            self.harmony_memory_size = 10 + int(iteration / self.budget * 5)  # Increase size\n\n            # Calculate adaptive rates\n            sorted_indices = np.argsort(fitness_memory)\n            improv_rate_adaptive = self.harmony_memory_improv_rate * (1 - sorted_indices / self.harmony_memory_size)\n            improv_rate_adaptive = 1 - improv_rate_adaptive  # Invert adaptive rate based on rank\n            pitch_adjust_adaptive = self.pitch_adjust_rate * (sorted_indices / self.harmony_memory_size)\n\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < improv_rate_adaptive[i]:\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size) / self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    \n                    if np.random.rand() < pitch_adjust_adaptive[i]:\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand()\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax(fitness_memory)\n            if fitness < fitness_memory[worst_idx]:\n                self.harmony_memory[worst_idx] = new_harmony\n                fitness_memory[worst_idx] = fitness\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhance dynamic exploration and exploitation balance by adjusting harmony memory size based on iteration progress.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "7602f0c3-85b4-45bc-8ff5-9cb7e0f10c9e", "metadata": {}, "mutation_prompt": null}
{"id": "ff600794-c74e-422c-98e7-8afcbaa94ecd", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * np.random.rand(self.harmony_memory_size, self.dim)  # Changed line\n\n        best_solution = None\n        best_fitness = float('inf')\n        fitness_memory = np.array([func(h) for h in self.harmony_memory])\n\n        for _ in range(self.budget):\n            # Calculate adaptive rates\n            sorted_indices = np.argsort(fitness_memory)\n            improv_rate_adaptive = self.harmony_memory_improv_rate * (1 - sorted_indices / self.harmony_memory_size)\n            improv_rate_adaptive = 1 - improv_rate_adaptive  # Invert adaptive rate based on rank\n            pitch_adjust_adaptive = self.pitch_adjust_rate * (sorted_indices / self.harmony_memory_size)\n\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < improv_rate_adaptive[i]:\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size) / self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    \n                    if np.random.rand() < pitch_adjust_adaptive[i]:\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand()\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax(fitness_memory)\n            if fitness < fitness_memory[worst_idx]:\n                self.harmony_memory[worst_idx] = new_harmony\n                fitness_memory[worst_idx] = fitness\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhance boundary handling and exploration by modifying harmony memory initialization to start from the entire search space rather than a random subset.", "configspace": "", "generation": 52, "fitness": 0.2014921384221502, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.201 with standard deviation 0.008. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.021.", "error": "", "parent_id": "7602f0c3-85b4-45bc-8ff5-9cb7e0f10c9e", "metadata": {"aucs": [0.1917155023355911, 0.20120906001680472, 0.21155185291405476], "final_y": [0.15649075404225585, 0.10560318754497529, 0.14013298518238526]}, "mutation_prompt": null}
{"id": "f2b9f31c-4419-434c-96e2-1c3abcef0dc0", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n        fitness_memory = np.array([func(h) for h in self.harmony_memory])\n\n        for _ in range(self.budget):\n            # Calculate adaptive rates\n            sorted_indices = np.argsort(fitness_memory)\n            improv_rate_adaptive = self.harmony_memory_improv_rate * (1 - sorted_indices / self.harmony_memory_size)\n            improv_rate_adaptive = 1 - improv_rate_adaptive  # Invert adaptive rate based on rank\n            pitch_adjust_adaptive = self.pitch_adjust_rate * (sorted_indices / self.harmony_memory_size)\n\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < improv_rate_adaptive[i]:\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size) / self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    \n                    if np.random.rand() < pitch_adjust_adaptive[i]:\n                        self.bandwidth = 0.01 + 0.04 * (1 - sorted_indices[i] / self.harmony_memory_size) # Adaptive bandwidth\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax(fitness_memory)\n            if fitness < fitness_memory[worst_idx]:\n                self.harmony_memory[worst_idx] = new_harmony\n                fitness_memory[worst_idx] = fitness\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Introduce adaptive bandwidth scaling based on fitness rank to enhance pitch adjustment precision.", "configspace": "", "generation": 53, "fitness": 0.1729220440796588, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.173 with standard deviation 0.014. And the mean value of best solutions found was 0.462 (0. is the best) with standard deviation 0.172.", "error": "", "parent_id": "7602f0c3-85b4-45bc-8ff5-9cb7e0f10c9e", "metadata": {"aucs": [0.19259143015212798, 0.16152840799810853, 0.16464629408873988], "final_y": [0.25071597107929716, 0.4620616700641692, 0.6722804849537588]}, "mutation_prompt": null}
{"id": "fc0ae368-fbf6-409a-a2e3-91ef7b6092c3", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n        fitness_memory = np.array([func(h) for h in self.harmony_memory])\n\n        for _ in range(self.budget):\n            sorted_indices = np.argsort(fitness_memory)\n            improv_rate_adaptive = self.harmony_memory_improv_rate * (1 - sorted_indices / self.harmony_memory_size)\n            improv_rate_adaptive = 1 - improv_rate_adaptive\n            pitch_adjust_adaptive = self.pitch_adjust_rate * (sorted_indices / self.harmony_memory_size)\n\n            memory_weights = (1 / (1 + fitness_memory)) / np.sum(1 / (1 + fitness_memory))\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < improv_rate_adaptive[i]:\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=memory_weights)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    \n                    if np.random.rand() < pitch_adjust_adaptive[i]:\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand()\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax(fitness_memory)\n            if fitness < fitness_memory[worst_idx]:\n                self.harmony_memory[worst_idx] = new_harmony\n                fitness_memory[worst_idx] = fitness\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhance local exploration by introducing a memory-based perturbation mechanism and adaptive fitness weighting.", "configspace": "", "generation": 54, "fitness": 0.14649275446052554, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.146 with standard deviation 0.015. And the mean value of best solutions found was 0.611 (0. is the best) with standard deviation 0.194.", "error": "", "parent_id": "7602f0c3-85b4-45bc-8ff5-9cb7e0f10c9e", "metadata": {"aucs": [0.15264433454424753, 0.1252688182036823, 0.16156511063364676], "final_y": [0.8226276108559654, 0.654919245031097, 0.35410306873107267]}, "mutation_prompt": null}
{"id": "f3d11be3-3460-4938-a6d1-8bd3b3a2a1a7", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = int(10 + 0.1 * dim)  # Adjust memory size based on dimension\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n        fitness_memory = np.array([func(h) for h in self.harmony_memory])\n\n        for _ in range(self.budget):\n            # Calculate adaptive rates\n            sorted_indices = np.argsort(fitness_memory)\n            improv_rate_adaptive = self.harmony_memory_improv_rate * (1 - sorted_indices / self.harmony_memory_size)\n            improv_rate_adaptive = 1 - improv_rate_adaptive  # Invert adaptive rate based on rank\n            pitch_adjust_adaptive = self.pitch_adjust_rate * (sorted_indices / self.harmony_memory_size)\n\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < improv_rate_adaptive[i]:\n                    idx_probs = 1 / (1 + fitness_memory[sorted_indices])  # Probabilities based on fitness\n                    idx_probs /= np.sum(idx_probs)\n                    idx = np.random.choice(sorted_indices, p=idx_probs)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    \n                    if np.random.rand() < pitch_adjust_adaptive[i]:\n                        self.bandwidth = 0.01 + 0.04 * np.random.rand()\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax(fitness_memory)\n            if fitness < fitness_memory[worst_idx]:\n                self.harmony_memory[worst_idx] = new_harmony\n                fitness_memory[worst_idx] = fitness\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Enhance exploration by dynamically adjusting memory size and incorporating fitness-based selection.", "configspace": "", "generation": 55, "fitness": 0.22159934796111114, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.222 with standard deviation 0.027. And the mean value of best solutions found was 0.176 (0. is the best) with standard deviation 0.087.", "error": "", "parent_id": "7602f0c3-85b4-45bc-8ff5-9cb7e0f10c9e", "metadata": {"aucs": [0.2058085905209921, 0.19931611067451582, 0.2596733426878255], "final_y": [0.19947292361580252, 0.26924127120742564, 0.05943099222902649]}, "mutation_prompt": null}
{"id": "791cd76a-98ba-44f0-936a-d381fb15bec9", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n        fitness_memory = np.array([func(h) for h in self.harmony_memory])\n\n        for _ in range(self.budget):\n            # Calculate adaptive rates\n            sorted_indices = np.argsort(fitness_memory)\n            improv_rate_adaptive = self.harmony_memory_improv_rate * (1 - sorted_indices / self.harmony_memory_size)\n            improv_rate_adaptive = 1 - improv_rate_adaptive  # Invert adaptive rate based on rank\n            pitch_adjust_adaptive = self.pitch_adjust_rate * (sorted_indices / self.harmony_memory_size)\n\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < improv_rate_adaptive[i]:\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size) / self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    \n                    if np.random.rand() < pitch_adjust_adaptive[i]:\n                        self.bandwidth = np.random.uniform(0.01, 0.06)  # Stochastic bandwidth adjustment\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax(fitness_memory)\n            if fitness < fitness_memory[worst_idx]:\n                self.harmony_memory[worst_idx] = new_harmony\n                fitness_memory[worst_idx] = fitness\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Employ a stochastic bandwidth adjustment and dynamic pitch memory to enhance search robustness and adaptability.", "configspace": "", "generation": 56, "fitness": 0.24708343322327944, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.009. And the mean value of best solutions found was 0.072 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "7602f0c3-85b4-45bc-8ff5-9cb7e0f10c9e", "metadata": {"aucs": [0.25958895920992886, 0.2366076153243688, 0.2450537251355407], "final_y": [0.055967174013826136, 0.08959656542567394, 0.07062164975062504]}, "mutation_prompt": null}
{"id": "31b6fe98-7d8a-4e46-bc2a-443cd4558bed", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.rand(self.harmony_memory_size, self.dim)\n        self.harmony_memory_improv_rate = 0.9\n        self.pitch_adjust_rate = 0.3\n        self.bandwidth = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.harmony_memory = lb + (ub - lb) * self.harmony_memory\n\n        best_solution = None\n        best_fitness = float('inf')\n        fitness_memory = np.array([func(h) for h in self.harmony_memory])\n\n        for _ in range(self.budget):\n            if np.std(fitness_memory) > 0.1:  # Adjust memory size based on solution diversity\n                self.harmony_memory_size = min(15, self.harmony_memory_size + 1)\n            else:\n                self.harmony_memory_size = max(5, self.harmony_memory_size - 1)\n            \n            sorted_indices = np.argsort(fitness_memory)\n            improv_rate_adaptive = self.harmony_memory_improv_rate * (1 - sorted_indices / self.harmony_memory_size)\n            improv_rate_adaptive = 1 - improv_rate_adaptive  # Invert adaptive rate based on rank\n            pitch_adjust_adaptive = self.pitch_adjust_rate * (sorted_indices / self.harmony_memory_size)\n\n            # Generate new harmony\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < improv_rate_adaptive[i]:\n                    idx = np.random.choice(np.arange(self.harmony_memory_size), p=np.ones(self.harmony_memory_size) / self.harmony_memory_size)\n                    new_harmony[i] = self.harmony_memory[idx, i]\n                    \n                    if np.random.rand() < pitch_adjust_adaptive[i]:\n                        self.bandwidth = np.random.uniform(0.01, 0.06)  # Stochastic bandwidth adjustment\n                        new_harmony[i] += self.bandwidth * np.random.uniform(-1, 1)\n                        new_harmony[i] = np.clip(new_harmony[i], lb[i], ub[i])\n                else:\n                    new_harmony[i] = lb[i] + (ub[i] - lb[i]) * np.random.rand()\n\n            fitness = func(new_harmony)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = new_harmony\n\n            worst_idx = np.argmax(fitness_memory)\n            if fitness < fitness_memory[worst_idx]:\n                self.harmony_memory[worst_idx] = new_harmony\n                fitness_memory[worst_idx] = fitness\n\n        return best_solution", "name": "QuantumHarmonySearch", "description": "Introduce a dynamic harmony memory size adjustment based on the diversity of the solutions.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 12 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 12 is out of bounds for axis 0 with size 10')", "parent_id": "791cd76a-98ba-44f0-936a-d381fb15bec9", "metadata": {}, "mutation_prompt": null}
{"id": "4559e42d-c3a7-4b96-a196-58112c37eb88", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445  # Cognitive coefficient\n        self.social_coef = 1.49445  # Social coefficient\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            # Evaluate current positions\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            # Update global best\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            # Adaptive adjustment of coefficients\n            self.cognitive_coef = np.random.uniform(1.4, 2.0)\n            self.social_coef = np.random.uniform(1.4, 2.0)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Utilize adaptive swarm intelligence with dynamic neighbor influence and mutation to explore high-dimensional search spaces efficiently.", "configspace": "", "generation": 58, "fitness": 0.26634969801034847, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.266 with standard deviation 0.026. And the mean value of best solutions found was 0.015 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "791cd76a-98ba-44f0-936a-d381fb15bec9", "metadata": {"aucs": [0.24503397446168373, 0.2516158399335785, 0.30239927963578317], "final_y": [0.014570283573793608, 0.027572196360174484, 0.003375775845503601]}, "mutation_prompt": null}
{"id": "f9c5f6e6-ce29-4d7e-95ef-3a18ed32587b", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445  # Cognitive coefficient\n        self.social_coef = 1.49445  # Social coefficient\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for iter_num in range(self.budget):\n            # Evaluate current positions\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            # Update global best\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            # Adaptive adjustment of coefficients\n            self.cognitive_coef = np.random.uniform(1.4, 2.0)\n            self.social_coef = np.random.uniform(1.4, 2.0)\n            # Adjust inertia weight dynamically\n            self.inertia_weight = 0.9 - iter_num * (0.9 - 0.4) / self.budget\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Enhance AdaptiveSwarmOptimization by tuning inertia weight dynamically based on the iteration progress for better exploration-exploitation balance.", "configspace": "", "generation": 59, "fitness": 0.20845154062396576, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.208 with standard deviation 0.028. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.073.", "error": "", "parent_id": "4559e42d-c3a7-4b96-a196-58112c37eb88", "metadata": {"aucs": [0.18388938016170597, 0.19440963345707096, 0.24705560825312034], "final_y": [0.24661745201074417, 0.13025799807664656, 0.07214556845177968]}, "mutation_prompt": null}
{"id": "8a3fce6a-44e1-47fb-97f6-d5f7e2667d7e", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445  # Cognitive coefficient\n        self.social_coef = 1.49445  # Social coefficient\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        prev_best_score = self.global_best_score  # New line\n\n        for _ in range(self.budget):\n            # Evaluate current positions\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            # Update global best\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            # Adaptive adjustment of coefficients\n            self.cognitive_coef = np.random.uniform(1.4, 2.0)\n            self.social_coef = np.random.uniform(1.4, 2.0)\n\n            # Dynamic inertia weight adjustment based on convergence rate\n            if self.global_best_score < prev_best_score:  # New line\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.99)  # New line\n            prev_best_score = self.global_best_score\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Enhance AdaptiveSwarmOptimization by introducing dynamic inertia weight adjustment based on convergence rate.", "configspace": "", "generation": 60, "fitness": 0.2538650002973115, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.254 with standard deviation 0.008. And the mean value of best solutions found was 0.008 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "4559e42d-c3a7-4b96-a196-58112c37eb88", "metadata": {"aucs": [0.24739843343313028, 0.24975317023080768, 0.2644433972279966], "final_y": [0.01458155874761792, 0.0056907546853980345, 0.003213218770852156]}, "mutation_prompt": null}
{"id": "8894b982-5de6-4ab2-880e-66db0f7f11cc", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445  # Cognitive coefficient\n        self.social_coef = 1.49445  # Social coefficient\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for iter_count in range(self.budget):\n            # Evaluate current positions\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            # Update global best\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            # Adaptive adjustment of coefficients\n            self.cognitive_coef = np.random.uniform(1.4, 2.0)\n            self.social_coef = np.random.uniform(1.4, 2.0)\n\n            # Update inertia weight based on iteration\n            self.inertia_weight = 0.9 - 0.5 * (iter_count / self.budget)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Introduce diversity by dynamically adjusting inertia weight based on the iteration count to balance exploration and exploitation.", "configspace": "", "generation": 61, "fitness": 0.20845154062396576, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.208 with standard deviation 0.028. And the mean value of best solutions found was 0.150 (0. is the best) with standard deviation 0.073.", "error": "", "parent_id": "4559e42d-c3a7-4b96-a196-58112c37eb88", "metadata": {"aucs": [0.18388938016170597, 0.19440963345707096, 0.24705560825312034], "final_y": [0.24661745201074417, 0.13025799807664656, 0.07214556845177968]}, "mutation_prompt": null}
{"id": "63a124c1-8562-41a3-b429-5698c3fa3284", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445  # Cognitive coefficient\n        self.social_coef = 1.49445  # Social coefficient\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            # Evaluate current positions\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            # Update global best\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            # Adaptive adjustment of coefficients\n            self.cognitive_coef = np.random.uniform(1.4, 2.3)  # Change line for adaptive exploration\n            self.social_coef = np.random.uniform(1.4, 2.0)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Enhance exploration in high-dimensional search spaces by optimizing dynamic neighbor influence using adaptive swarm intelligence.", "configspace": "", "generation": 62, "fitness": 0.2570009743591327, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.257 with standard deviation 0.018. And the mean value of best solutions found was 0.011 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "4559e42d-c3a7-4b96-a196-58112c37eb88", "metadata": {"aucs": [0.25280942502199955, 0.2378677228206828, 0.2803257752347158], "final_y": [0.014386544015838021, 0.006819637634466472, 0.011323745137229349]}, "mutation_prompt": null}
{"id": "89440005-224d-4eb6-a979-b40e5131135e", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for step in range(self.budget):\n            # Evaluate current positions\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            # Update global best\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            # Adaptive adjustment of coefficients\n            self.cognitive_coef = np.random.uniform(1.4, 2.0)\n            self.social_coef = np.random.uniform(1.4, 2.0)\n\n            # Introduce chaotic search behavior\n            if step > self.budget // 2:\n                chaos_factor = 0.5 * np.sin(step)\n            else:\n                chaos_factor = 0.1\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i] + chaos_factor * np.random.randn(self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Enhance the swarm adaptation by incorporating a chaotic search mechanism for improved exploration and convergence.", "configspace": "", "generation": 63, "fitness": 0.2322561768746093, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.232 with standard deviation 0.016. And the mean value of best solutions found was 0.088 (0. is the best) with standard deviation 0.064.", "error": "", "parent_id": "4559e42d-c3a7-4b96-a196-58112c37eb88", "metadata": {"aucs": [0.2415803429188388, 0.20956262291354588, 0.24562556479144326], "final_y": [0.029642782194159528, 0.17616645854275206, 0.05715687533867416]}, "mutation_prompt": null}
{"id": "11d081e3-f067-4895-9b4e-422dd16983f2", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.9  # Dynamic inertia weight\n        self.cognitive_coef = 1.49445  # Cognitive coefficient\n        self.social_coef = 1.49445  # Social coefficient\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for t in range(self.budget):\n            # Evaluate current positions\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            # Update global best\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.9 - 0.5 * (t / self.budget)\n\n            # Update velocities and positions\n            elite_index = np.argmin(self.personal_best_scores)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                elite_influence = 0.1 * (self.personal_best_positions[elite_index] - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] + cognitive_velocity +\n                                      social_velocity + elite_influence)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Enhance swarm intelligence by introducing dynamic inertia adjustment and elite-guided search to improve exploration and exploitation balance.", "configspace": "", "generation": 64, "fitness": 0.21776568868734011, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.218 with standard deviation 0.017. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.045.", "error": "", "parent_id": "4559e42d-c3a7-4b96-a196-58112c37eb88", "metadata": {"aucs": [0.2057122428553334, 0.24159033709955358, 0.20599448610713333], "final_y": [0.18347758860776878, 0.11098723445861275, 0.0766661508110455]}, "mutation_prompt": null}
{"id": "85e1dcbe-f1d6-461b-81c6-fe66d20cdcc0", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445  # Cognitive coefficient\n        self.social_coef = 1.49445  # Social coefficient\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            # Evaluate current positions\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            # Update global best\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            # Adaptive adjustment of coefficients\n            self.cognitive_coef = np.random.uniform(1.4, 2.0)\n            self.social_coef = np.random.uniform(1.4, 2.0)\n            self.inertia_weight = 0.5 + 0.5 * (1 - _ / self.budget)  # Adapt inertia weight\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Enhance inertia weight adaptation for improved exploration-exploitation balance in swarm optimization.", "configspace": "", "generation": 65, "fitness": 0.21460681033443205, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.215 with standard deviation 0.014. And the mean value of best solutions found was 0.223 (0. is the best) with standard deviation 0.081.", "error": "", "parent_id": "4559e42d-c3a7-4b96-a196-58112c37eb88", "metadata": {"aucs": [0.19727885942121126, 0.2326150215622741, 0.21392655001981076], "final_y": [0.325947248215911, 0.12835817310204362, 0.21476842399838558]}, "mutation_prompt": null}
{"id": "6757c4ab-223b-4de8-9c0a-2a53d016249b", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = np.random.uniform(0.5, 0.9)  # Randomized inertia weight\n        self.cognitive_coef = 1.49445  # Cognitive coefficient\n        self.social_coef = 1.49445  # Social coefficient\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            # Evaluate current positions\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            # Update global best\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            # Adaptive adjustment of coefficients\n            self.cognitive_coef = np.random.uniform(1.4, 2.0)\n            self.social_coef = np.random.uniform(1.4, 2.0)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Introduce randomness in inertia weight for enhanced exploration and exploitation balance.", "configspace": "", "generation": 66, "fitness": 0.2405547109803744, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.241 with standard deviation 0.038. And the mean value of best solutions found was 0.065 (0. is the best) with standard deviation 0.073.", "error": "", "parent_id": "4559e42d-c3a7-4b96-a196-58112c37eb88", "metadata": {"aucs": [0.2757486781998112, 0.18714467274310786, 0.25877078199820414], "final_y": [0.0018395070374752189, 0.1673437824165559, 0.0253197326019223]}, "mutation_prompt": null}
{"id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Integrate diversity-enhancing perturbations and adaptive velocity scaling to improve convergence and exploration in high-dimensional search spaces.", "configspace": "", "generation": 67, "fitness": 0.3145167799200283, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.315 with standard deviation 0.024. And the mean value of best solutions found was 0.008 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "4559e42d-c3a7-4b96-a196-58112c37eb88", "metadata": {"aucs": [0.28059964404161475, 0.3276479082519955, 0.33530278746647457], "final_y": [0.017734382204794178, 0.0050166860908293625, 0.0026362706341973284]}, "mutation_prompt": null}
{"id": "53b3f9ee-a855-4d56-a410-ed44c6d303cd", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n                if np.any(self.positions[i] == lb) or np.any(self.positions[i] == ub):  # Adaptive boundary reflection\n                    self.velocities[i] *= -0.5\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Implement adaptive boundary reflection to prevent particles from getting stuck at the boundary.", "configspace": "", "generation": 68, "fitness": 0.2571968867925904, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.257 with standard deviation 0.026. And the mean value of best solutions found was 0.018 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "metadata": {"aucs": [0.2437814350816625, 0.2341048307447583, 0.29370439455135033], "final_y": [0.025306666912051405, 0.023950407553249693, 0.0036672286255513458]}, "mutation_prompt": null}
{"id": "8c1df16d-1b82-4448-a4b1-fe34e6ebc198", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for iter_num in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n            \n            self.inertia_weight *= 0.99  # Dynamic decay factor for inertia weight\n            \n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Introduce a modified inertia weight strategy by implementing a dynamic decay factor to enhance exploration-exploitation balance.", "configspace": "", "generation": 69, "fitness": 0.2883174301232897, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.288 with standard deviation 0.005. And the mean value of best solutions found was 0.006 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "metadata": {"aucs": [0.2944540668165513, 0.2875682729482334, 0.2829299506050844], "final_y": [0.006116578964671324, 0.008360366678973559, 0.0022635729961954306]}, "mutation_prompt": null}
{"id": "c68f71a2-2361-486a-b1ec-2f3932ee5d25", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            # Adjust inertia weight dynamically\n            self.inertia_weight = 0.4 + (0.5 * np.random.rand())  # Change made here\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Enhance exploration by dynamically adjusting the inertia weight based on convergence speed.", "configspace": "", "generation": 70, "fitness": 0.2611778699855779, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.261 with standard deviation 0.029. And the mean value of best solutions found was 0.010 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "metadata": {"aucs": [0.2578856823490939, 0.22753018422000382, 0.29811774338763597], "final_y": [0.005568833354072794, 0.014729981770599624, 0.008948736569261406]}, "mutation_prompt": null}
{"id": "7d9a2561-f541-4b56-96f5-61621bfacce7", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25\n        self.positions = self.chaotic_initialization()  # Chaotic initialization\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.9  # Start with higher inertia weight\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def chaotic_initialization(self):  # New chaotic initialization method\n        chaotic_sequence = np.sin(np.linspace(0, np.pi, self.population_size * self.dim))\n        return chaotic_sequence.reshape(self.population_size, self.dim)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.inertia_weight = 0.9 - _ / self.budget * 0.5  # Dynamic inertia adaptation\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Enhance exploration and convergence by incorporating chaotic maps for initial population and dynamic inertia adaptation.", "configspace": "", "generation": 71, "fitness": 0.2110835437028055, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.211 with standard deviation 0.015. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.028.", "error": "", "parent_id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "metadata": {"aucs": [0.2105254304752291, 0.22945708573597656, 0.19326811489721085], "final_y": [0.07985386653780942, 0.13103816284163267, 0.14459109088572503]}, "mutation_prompt": null}
{"id": "55e99294-9925-4e0f-8929-1dd193b66a39", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                # Stochastic inertia weight\n                self.inertia_weight = np.random.uniform(0.6, 0.8)\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Introduce stochastic inertia weight adjustments to enhance exploration and exploitation balance in high-dimensional spaces.", "configspace": "", "generation": 72, "fitness": 0.27678696995747376, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.277 with standard deviation 0.007. And the mean value of best solutions found was 0.010 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "metadata": {"aucs": [0.2719265593319279, 0.28618326801568195, 0.27225108252481145], "final_y": [0.00784135600249605, 0.0026738078955343943, 0.018298735483618236]}, "mutation_prompt": null}
{"id": "6f302b8e-b72b-4614-895a-2a69411b7541", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for step in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            self.inertia_weight = 0.9 - (0.5 * step / self.budget)  # Dynamic inertia weight\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Fine-tune inertia weight dynamically to balance exploration and exploitation for improving convergence and search efficiency.", "configspace": "", "generation": 73, "fitness": 0.2460477371705757, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.007. And the mean value of best solutions found was 0.084 (0. is the best) with standard deviation 0.051.", "error": "", "parent_id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "metadata": {"aucs": [0.23661085347703226, 0.25483577059733575, 0.24669658743735912], "final_y": [0.11393742240074164, 0.012000825025721914, 0.12568704376426118]}, "mutation_prompt": null}
{"id": "dbcd41f9-f396-47e2-b020-c0aad33400ae", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for iteration in range(self.budget):  # Changed line\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Enhance exploration by introducing a dynamic inertia weight that decreases linearly over iterations.", "configspace": "", "generation": 74, "fitness": 0.25676952863847113, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.257 with standard deviation 0.002. And the mean value of best solutions found was 0.027 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "metadata": {"aucs": [0.2593291706593157, 0.25342968823648315, 0.25754972701961454], "final_y": [0.013860291300855936, 0.029574881214769908, 0.03856242422781445]}, "mutation_prompt": null}
{"id": "2c4dfc2a-a86f-4809-b07f-98926e97cdc2", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for iteration in range(self.budget):\n            # Slight variation in inertia weight based on iteration\n            self.inertia_weight = 0.7 + 0.3 * (1 - iteration / self.budget)  # <--- Changed line\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Introduce slight inertia weight variation based on iteration to balance exploration and exploitation.", "configspace": "", "generation": 75, "fitness": 0.18473442539157495, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.185 with standard deviation 0.038. And the mean value of best solutions found was 0.617 (0. is the best) with standard deviation 0.409.", "error": "", "parent_id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "metadata": {"aucs": [0.23095857372237527, 0.13723929802710777, 0.18600540442524183], "final_y": [0.19028198447238076, 1.1688796445784313, 0.4907135964197428]}, "mutation_prompt": null}
{"id": "2519cb7e-9c9c-48ac-a31d-c6e1844c105e", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.inertia_weight = 0.5 + np.random.rand() * 0.4  # Dynamic adjustment\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n                # Local search refinement\n                if np.random.rand() < 0.1:\n                    self.positions[i] = np.clip(self.positions[i] + np.random.normal(0, 0.01, self.dim), lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Enhance convergence by incorporating dynamic inertia weight adjustment and local search refinement.", "configspace": "", "generation": 76, "fitness": 0.265932948084888, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.266 with standard deviation 0.022. And the mean value of best solutions found was 0.029 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "metadata": {"aucs": [0.23606015216760323, 0.27328241670577325, 0.2884562753812875], "final_y": [0.04225292680804692, 0.027940386239782688, 0.01567827885776759]}, "mutation_prompt": null}
{"id": "3fe6dcbc-8df9-417f-9965-e6875871ab50", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            \n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.9 - ((_ / self.budget) * 0.5)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Enhance convergence by refining velocity update with dynamic inertia weight adjustment.", "configspace": "", "generation": 77, "fitness": 0.26061062827066256, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.261 with standard deviation 0.018. And the mean value of best solutions found was 0.042 (0. is the best) with standard deviation 0.020.", "error": "", "parent_id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "metadata": {"aucs": [0.28590433001715754, 0.2474510581047178, 0.2484764966901123], "final_y": [0.01370798378519282, 0.055284072825597136, 0.05560747982175025]}, "mutation_prompt": null}
{"id": "ca5c157b-3431-48a8-9351-6e141c40bb77", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                scaling_factor = 0.9  # Scaling factor added for velocity components\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + scaling_factor * (cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Enhance the exploration by introducing a scaling factor to the cognitive and social components of the velocity update.", "configspace": "", "generation": 78, "fitness": 0.2585113120312778, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.259 with standard deviation 0.009. And the mean value of best solutions found was 0.020 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "metadata": {"aucs": [0.24608050610161902, 0.2606299910998344, 0.26882343889238003], "final_y": [0.01822501957668882, 0.033847009231802345, 0.007939565085687854]}, "mutation_prompt": null}
{"id": "de81e69a-2c6f-4b67-a7c6-5244281e5448", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            # Change: Dynamic adjustment of inertia_weight based on diversity\n            self.inertia_weight = 0.5 + 0.5 * np.std(self.positions, axis=0).mean()\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Enhance swarm exploration by dynamically adjusting inertia weight based on population diversity.", "configspace": "", "generation": 79, "fitness": 0.13215625671274803, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.132 with standard deviation 0.023. And the mean value of best solutions found was 2.399 (0. is the best) with standard deviation 1.100.", "error": "", "parent_id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "metadata": {"aucs": [0.1064592225178238, 0.12779104372088712, 0.16221850389953318], "final_y": [3.776052931699436, 2.335579938941498, 1.0844626539527937]}, "mutation_prompt": null}
{"id": "ecb8ebad-a2a8-425f-9608-42a6ba6c86f9", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.9  # Adaptive inertia weight to improve balance\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling with elite selection\n                if np.random.rand() < 0.15:\n                    self.velocities[i] *= np.random.uniform(0.5, 2.0)\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Enhance exploration by introducing adaptive inertia weight and integrating an elite selection mechanism for maintaining diversity.", "configspace": "", "generation": 80, "fitness": 0.22527536280831809, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.225 with standard deviation 0.032. And the mean value of best solutions found was 0.163 (0. is the best) with standard deviation 0.079.", "error": "", "parent_id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "metadata": {"aucs": [0.1984469860658522, 0.20648189164711706, 0.270897210711985], "final_y": [0.1855654115900545, 0.246416769119998, 0.0572608062143315]}, "mutation_prompt": null}
{"id": "0f32b5a3-9765-4704-b3cb-140267dce892", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n\n                # Adaptive velocity scaling\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n\n                self.velocities[i] = (self.inertia_weight * (0.9 - 0.5 * (_ / self.budget))) * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1 * (_ / self.budget), self.dim)\n\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Enhance exploration by introducing non-uniform mutation and dynamic inertia weight adjustment.", "configspace": "", "generation": 81, "fitness": 0.26722217992770064, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.267 with standard deviation 0.019. And the mean value of best solutions found was 0.008 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "metadata": {"aucs": [0.25889001931921085, 0.24977923380664013, 0.292997286657251], "final_y": [0.0075734846397753465, 0.009816987467842762, 0.006009058360946858]}, "mutation_prompt": null}
{"id": "86e469e4-12a4-4b71-b91e-fd315b9f7022", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            # Adaptive inertia weight\n            self.inertia_weight = np.random.uniform(0.6, 0.9)  # Updated line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Introduce adaptive inertia weight adjustment for improved convergence and exploration balance in high-dimensional search spaces.", "configspace": "", "generation": 82, "fitness": 0.23148488367314488, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.231 with standard deviation 0.019. And the mean value of best solutions found was 0.050 (0. is the best) with standard deviation 0.021.", "error": "", "parent_id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "metadata": {"aucs": [0.25665999212606583, 0.21104482317233153, 0.22674983572103724], "final_y": [0.021005243043523823, 0.06884575534578156, 0.05960397037228609]}, "mutation_prompt": null}
{"id": "53a1240d-321d-4a81-8f07-17598ff02e58", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for iteration in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            self.inertia_weight = 0.9 - (0.5 * (iteration / self.budget))  # Dynamic inertia adjustment\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Enhance AdaptiveSwarmOptimization by dynamically adjusting the inertia weight to improve exploration-exploitation balance.", "configspace": "", "generation": 83, "fitness": 0.2344102698128777, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.234 with standard deviation 0.009. And the mean value of best solutions found was 0.069 (0. is the best) with standard deviation 0.040.", "error": "", "parent_id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "metadata": {"aucs": [0.2458992102702986, 0.2341564326792156, 0.22317516648911884], "final_y": [0.034556794127342444, 0.12564333884930423, 0.04665470363945612]}, "mutation_prompt": null}
{"id": "ca817773-326b-4050-a79a-b56ead553882", "solution": "import numpy as np\nfrom scipy.stats.qmc import Sobol\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        sobol = Sobol(d=self.dim, scramble=True)\n        self.positions = sobol.random_base2(m=5)[:self.population_size]  # Improved initialization\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Introduce an improved initialization method using Sobol sequences for better space coverage and optimization performance.", "configspace": "", "generation": 84, "fitness": 0.24612020859658393, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.018. And the mean value of best solutions found was 0.041 (0. is the best) with standard deviation 0.021.", "error": "", "parent_id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "metadata": {"aucs": [0.22359285793168804, 0.2678285176987014, 0.24693925015936236], "final_y": [0.06838229129337635, 0.018149557566307893, 0.036874217305291786]}, "mutation_prompt": null}
{"id": "133291dd-e5d4-4db4-8841-09034b0b885c", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.9  # Dynamic inertia weight\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.1:  # Increased perturbation frequency\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Introduce a dynamic inertia weight and increased perturbation frequency to balance exploration and exploitation.", "configspace": "", "generation": 85, "fitness": 0.23171150523579512, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.232 with standard deviation 0.011. And the mean value of best solutions found was 0.099 (0. is the best) with standard deviation 0.020.", "error": "", "parent_id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "metadata": {"aucs": [0.24318487376870768, 0.2346742013954658, 0.2172754405432119], "final_y": [0.09216297336568802, 0.0779109167600334, 0.12654976409421376]}, "mutation_prompt": null}
{"id": "76704155-d0c4-4016-af48-3457176b5dc8", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                inertia_weight_dynamic = 0.5 + np.random.rand() * 0.5  # Dynamic inertia weight adjustment\n                self.velocities[i] = inertia_weight_dynamic * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Introduce a dynamic inertia weight adjustment to balance exploration and exploitation more effectively. ", "configspace": "", "generation": 86, "fitness": 0.23332718759056073, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.233 with standard deviation 0.018. And the mean value of best solutions found was 0.028 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "metadata": {"aucs": [0.2505982381427928, 0.2082567373428288, 0.24112658728606062], "final_y": [0.03189504109564484, 0.02828687515713341, 0.025116819956633115]}, "mutation_prompt": null}
{"id": "370854f3-8add-4590-a777-9e57552b59f8", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            self.inertia_weight = 0.9 - _ * (0.5 / self.budget)  # Adjusted inertia weight\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Enhance exploration and exploitation by introducing a dynamic inertia weight strategy.", "configspace": "", "generation": 87, "fitness": 0.2460477371705757, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.007. And the mean value of best solutions found was 0.084 (0. is the best) with standard deviation 0.051.", "error": "", "parent_id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "metadata": {"aucs": [0.23661085347703226, 0.25483577059733575, 0.24669658743735912], "final_y": [0.11393742240074164, 0.012000825025721914, 0.12568704376426118]}, "mutation_prompt": null}
{"id": "3ff8c826-25be-4e01-b7a3-ee79b1f7decd", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for iteration in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            # Time-varying coefficients for cognitive and social factors\n            self.cognitive_coef = 1.5 - (1.0 * iteration / self.budget)\n            self.social_coef = 1.5 + (1.0 * iteration / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Incorporate time-varying coefficients for enhanced convergence dynamics in AdaptiveSwarmOptimization.", "configspace": "", "generation": 88, "fitness": 0.2585767006766964, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.259 with standard deviation 0.034. And the mean value of best solutions found was 0.012 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "metadata": {"aucs": [0.21030218700191328, 0.2778056122647933, 0.28762230276338274], "final_y": [0.013410866091252607, 0.004104606649107139, 0.01901114157476668]}, "mutation_prompt": null}
{"id": "81f47f2b-b434-44ef-bbed-229594129286", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n        self.learning_rate = 0.9  # New learning rate parameter\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling with learning rate\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.learning_rate * (self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Introduce a learning rate parameter to improve velocity adjustments and enhance convergence precision in AdaptiveSwarmOptimization.", "configspace": "", "generation": 89, "fitness": 0.3372244174486256, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.337 with standard deviation 0.018. And the mean value of best solutions found was 0.003 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "252f2634-2155-40ed-aca2-6c57de2c1bb6", "metadata": {"aucs": [0.33482342592056513, 0.3603216765306867, 0.31652814989462486], "final_y": [0.0019135875131653345, 0.005958976698663491, 0.00020359936430018336]}, "mutation_prompt": null}
{"id": "a8190aaf-0ee5-468e-9a7f-c6c35ce66601", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n        self.learning_rate = 0.9  # New learning rate parameter\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for iteration in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            \n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.4 + (0.5 * (self.budget - iteration) / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling with learning rate\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.learning_rate * (self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Introduce a dynamic inertia weight adjustment based on iteration progress to enhance convergence precision in AdaptiveSwarmOptimization.", "configspace": "", "generation": 90, "fitness": 0.2342407619469495, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.234 with standard deviation 0.007. And the mean value of best solutions found was 0.048 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "81f47f2b-b434-44ef-bbed-229594129286", "metadata": {"aucs": [0.226038984116132, 0.2326814472738602, 0.24400185445085631], "final_y": [0.06810813578060644, 0.0350839266696041, 0.04059822625296432]}, "mutation_prompt": null}
{"id": "5e51bd25-ea4b-4f4b-af56-541d246c4a4a", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        # Diverse initialization for better exploration\n        self.positions = np.random.rand(self.population_size, self.dim) * np.linspace(0.1, 1.0, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n        self.learning_rate = 0.9  # New learning rate parameter\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling with learning rate\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.learning_rate * (self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Integrate a diverse initialization technique to boost exploration in AdaptiveSwarmOptimization.", "configspace": "", "generation": 91, "fitness": 0.23010905654090733, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.230 with standard deviation 0.005. And the mean value of best solutions found was 0.011 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "81f47f2b-b434-44ef-bbed-229594129286", "metadata": {"aucs": [0.2366068874438727, 0.22430063083238372, 0.22941965134646558], "final_y": [0.007894703166758055, 0.007910464690088992, 0.018253252107448485]}, "mutation_prompt": null}
{"id": "c076f0db-6335-4479-b914-454e5eac8819", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n        self.learning_rate = 0.9  # New learning rate parameter\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            # Adaptive inertia weight adjustment\n            self.inertia_weight = 0.9 - 0.5 * (_ / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling with learning rate\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.learning_rate * (self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Integrate an adaptive inertia weight adjustment mechanism into AdaptiveSwarmOptimization to enhance exploration-exploitation balance.", "configspace": "", "generation": 92, "fitness": 0.23424076194695306, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.234 with standard deviation 0.007. And the mean value of best solutions found was 0.048 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "81f47f2b-b434-44ef-bbed-229594129286", "metadata": {"aucs": [0.226038984116132, 0.23268144727386586, 0.2440018544508613], "final_y": [0.06810813578059811, 0.03508392666957337, 0.04059822625292309]}, "mutation_prompt": null}
{"id": "bd20608d-24b8-474f-87f2-3fd90ceb2e91", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n        self.learning_rate = 0.9  # New learning rate parameter\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling with learning rate\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.inertia_weight = 0.5 + np.random.rand() * 0.5  # Adaptive inertia weight\n                self.velocities[i] = self.learning_rate * (self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Introduce an adaptive inertia weight to balance exploration and exploitation dynamically in AdaptiveSwarmOptimization.", "configspace": "", "generation": 93, "fitness": 0.2710407171603528, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.271 with standard deviation 0.003. And the mean value of best solutions found was 0.013 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "81f47f2b-b434-44ef-bbed-229594129286", "metadata": {"aucs": [0.2755258595871428, 0.269291553344023, 0.26830473854989245], "final_y": [0.016190421682876568, 0.014851393268687162, 0.009017001809767401]}, "mutation_prompt": null}
{"id": "80a62038-04a5-4e57-ab08-4ec0baeb8576", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n        self.learning_rate = 0.9  # New learning rate parameter\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for iteration in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling with learning rate\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.learning_rate * (self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n            \n            # Introduce learning rate decay\n            self.learning_rate *= 0.995\n            \n            # Restart mechanism for diversity\n            if iteration % 10 == 0 and iteration > 0:\n                self.positions[np.argmax(self.personal_best_scores)] = np.random.uniform(lb, ub, self.dim)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Enhance convergence by introducing a decay factor for the learning rate and a restart mechanism for improved diversity.", "configspace": "", "generation": 94, "fitness": 0.34856658648891803, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.349 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "81f47f2b-b434-44ef-bbed-229594129286", "metadata": {"aucs": [0.3274347716948177, 0.3710547546292561, 0.3472102331426803], "final_y": [0.00026889644743678307, 0.00013291215433671878, 0.0005005702371642641]}, "mutation_prompt": null}
{"id": "9fbea523-0677-434e-92df-29cdea9e7172", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n        self.learning_rate = 0.9  # New learning rate parameter\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for iteration in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling with learning rate\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.learning_rate * (self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n            \n            # Introduce learning rate decay\n            self.learning_rate *= 0.995\n            \n            # Restart mechanism for diversity\n            if iteration % 10 == 0 and iteration > 0:\n                self.positions[np.argmax(self.personal_best_scores)] = np.random.uniform(lb, ub, self.dim)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Introduce a mutation step to enhance exploration in the AdaptiveSwarmOptimization algorithm.", "configspace": "", "generation": 95, "fitness": 0.350598190780163, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.351 with standard deviation 0.007. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80a62038-04a5-4e57-ab08-4ec0baeb8576", "metadata": {"aucs": [0.3607484218285053, 0.3471830627299808, 0.34386308778200303], "final_y": [2.458213477911805e-05, 0.00030582437495267774, 0.0002657116949506093]}, "mutation_prompt": null}
{"id": "bcfe06d1-4591-482d-a35d-9ac42aea85b3", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n        self.learning_rate = 0.9  # New learning rate parameter\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for iteration in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling with learning rate\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.learning_rate * (self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.1:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n            \n            # Introduce learning rate decay\n            self.learning_rate *= 0.995\n            \n            # Restart mechanism for diversity\n            if iteration % 10 == 0 and iteration > 0:\n                self.positions[np.argmax(self.personal_best_scores)] = np.random.uniform(lb, ub, self.dim)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Amplify diversity by increasing perturbation frequency in AdaptiveSwarmOptimization.", "configspace": "", "generation": 96, "fitness": 0.30144333542312113, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.301 with standard deviation 0.040. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "9fbea523-0677-434e-92df-29cdea9e7172", "metadata": {"aucs": [0.32316576741518455, 0.33548254607318395, 0.24568169278099494], "final_y": [0.0009100935991231271, 0.0009396640910169296, 0.002368743261191854]}, "mutation_prompt": null}
{"id": "a8e59ea5-f7ef-429d-8542-94f2e6ca2135", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n        self.learning_rate = 0.9  # New learning rate parameter\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for iteration in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.5, 2.0)  # Adjusted range for better balance\n            self.social_coef = np.random.uniform(1.5, 2.0)  # Adjusted range for better balance\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling with learning rate\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.learning_rate * (self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n            \n            # Introduce learning rate decay\n            self.learning_rate *= 0.995\n            \n            # Restart mechanism for diversity\n            if iteration % 10 == 0 and iteration > 0:\n                self.positions[np.argmax(self.personal_best_scores)] = np.random.uniform(lb, ub, self.dim)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Adjust cognitive and social coefficients for improved balance between exploration and exploitation.", "configspace": "", "generation": 97, "fitness": 0.27520880384703145, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.275 with standard deviation 0.022. And the mean value of best solutions found was 0.004 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "9fbea523-0677-434e-92df-29cdea9e7172", "metadata": {"aucs": [0.290297305659857, 0.24433196104147514, 0.29099714483976213], "final_y": [0.0025451606452671603, 0.008106984880028126, 0.00027221275118195754]}, "mutation_prompt": null}
{"id": "2068f32a-d1a9-4935-b435-9974c3cfc2d9", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n        self.learning_rate = 0.9  # New learning rate parameter\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for iteration in range(self.budget):\n            # Dynamic population size adjustment\n            self.population_size = max(5, int(self.budget / (iteration + 1)))\n\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling with learning rate\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.learning_rate * (self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                # Diversity-enhancing perturbation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.1, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n            \n            # Introduce learning rate decay\n            self.learning_rate *= 0.995\n            \n            # Restart mechanism for diversity\n            if iteration % 10 == 0 and iteration > 0:\n                self.positions[np.argmax(self.personal_best_scores)] = np.random.uniform(lb, ub, self.dim)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Introduce a dynamic population size adjustment mechanism to enhance convergence rate in AdaptiveSwarmOptimization.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 25 is out of bounds for axis 0 with size 25').", "error": "IndexError('index 25 is out of bounds for axis 0 with size 25')", "parent_id": "9fbea523-0677-434e-92df-29cdea9e7172", "metadata": {}, "mutation_prompt": null}
{"id": "a65c4ec9-4d22-4dfc-b5c4-c8321e821018", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.positions = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim) * 0.1\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.inertia_weight = 0.729  # Inertia weight to control exploration\n        self.cognitive_coef = 1.49445\n        self.social_coef = 1.49445\n        self.learning_rate = 0.9  # New learning rate parameter\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        for iteration in range(self.budget):\n            for i in range(self.population_size):\n                fitness = func(self.positions[i])\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n            min_personal_best_score = np.min(self.personal_best_scores)\n            if min_personal_best_score < self.global_best_score:\n                self.global_best_score = min_personal_best_score\n                self.global_best_position = self.personal_best_positions[np.argmin(self.personal_best_scores)].copy()\n\n            self.cognitive_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n            self.social_coef = np.random.uniform(1.3, 1.8)  # Adjusted range\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coef * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_coef * r2 * (self.global_best_position - self.positions[i])\n                \n                # Adaptive velocity scaling with learning rate\n                if np.random.rand() < 0.1:\n                    self.velocities[i] *= np.random.uniform(0.5, 1.5)\n                \n                self.velocities[i] = self.learning_rate * (self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                # Precise Gaussian mutation\n                if np.random.rand() < 0.05:\n                    self.positions[i] += np.random.normal(0, 0.05, self.dim)\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n            \n            # Introduce learning rate decay\n            self.learning_rate *= 0.995\n            \n            # Restart mechanism for diversity\n            if iteration % 10 == 0 and iteration > 0:\n                self.positions[np.argmax(self.personal_best_scores)] = np.random.uniform(lb, ub, self.dim)\n\n        return self.global_best_position", "name": "AdaptiveSwarmOptimization", "description": "Refining exploration by replacing diversity perturbation with a more precise Gaussian mutation.", "configspace": "", "generation": 99, "fitness": 0.33911796011240175, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.339 with standard deviation 0.004. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "9fbea523-0677-434e-92df-29cdea9e7172", "metadata": {"aucs": [0.33371894207626496, 0.33975450863406054, 0.3438804296268798], "final_y": [0.0003828497075391974, 0.0004970174306563506, 0.00027450478098862215]}, "mutation_prompt": null}
