{"id": "3770a2cc-b61b-407f-b1cf-8fd34df007e5", "solution": "import numpy as np\n\nclass AdaptiveSwarmDynamicsOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))  # scaling population size with dimension\n        self.c1 = 1.5  # cognitive coefficient\n        self.c2 = 1.5  # social coefficient\n        self.inertia = 0.9  # initial inertia weight\n        self.inertia_damp = 0.99  # damping factor for inertia weight\n        self.max_velocity = 0.2  # max velocity as a fraction of the search space\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            # Evaluate each particle's position\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.c1 * r1 * (personal_best_positions[i] - positions[i])\n                social_component = self.c2 * r2 * (global_best_position - positions[i])\n                velocities[i] = (self.inertia * velocities[i] + cognitive_component + social_component)\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n            # Adaptive adjustment of inertia weight\n            self.inertia *= self.inertia_damp\n\n        return global_best_position, global_best_score", "name": "AdaptiveSwarmDynamicsOptimization", "description": "\"Adaptive Swarm Dynamics Optimization\" - a novel metaheuristic combining swarm intelligence and adaptive parameter tuning to efficiently explore and exploit the search space for high-performing solutions.", "configspace": "", "generation": 0, "fitness": 0.23877230423826976, "feedback": "The algorithm AdaptiveSwarmDynamicsOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.239 with standard deviation 0.034. And the mean value of best solutions found was 0.014 (0. is the best) with standard deviation 0.019.", "error": "", "parent_id": null, "metadata": {"aucs": [0.2826111038700295, 0.23397454590084577, 0.19973126294393395], "final_y": [0.0011403192005255353, 0.00030196459808274343, 0.04032761866856883]}, "mutation_prompt": null}
{"id": "bd7f419b-a6f7-40d6-aaaf-23c6ac70b70b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmDynamics:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 + int(2 * np.sqrt(dim))\n        self.min_population_size = 5\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.inertia_initial = 0.9\n        self.inertia_damp = 0.99\n        self.max_velocity = 0.2\n        self.dynamic_shrinkage = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        positions = np.random.uniform(lb, ub, (population_size, self.dim))\n        velocities = np.zeros((population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.inertia = self.inertia_initial\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i].copy()\n\n            for i in range(population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.c1 * r1 * (personal_best_positions[i] - positions[i])\n                social_component = self.c2 * r2 * (global_best_position - positions[i])\n                velocities[i] = (self.inertia * velocities[i] + cognitive_component + social_component)\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n            # Dynamic adjustment of inertia, population size, and cognitive/social coefficients\n            self.inertia *= self.inertia_damp\n            self.c1 = max(0.5, self.c1_initial * (1 - evaluations / self.budget))\n            self.c2 = max(0.5, self.c2_initial * (evaluations / self.budget))\n            \n            # Reduce population size over time to intensify search\n            population_size = max(self.min_population_size, int(self.initial_population_size * (self.dynamic_shrinkage ** (evaluations / self.budget))))\n            positions = positions[:population_size]\n            velocities = velocities[:population_size]\n            personal_best_positions = personal_best_positions[:population_size]\n            personal_best_scores = personal_best_scores[:population_size]\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmDynamics", "description": "\"Enhanced Adaptive Swarm Dynamics\" - an improved algorithm that incorporates dynamic population sizing and adaptive parameter adjustment to enhance exploration and exploitation balance throughout the optimization process.", "configspace": "", "generation": 1, "fitness": 0.2971861742910767, "feedback": "The algorithm EnhancedAdaptiveSwarmDynamics got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.297 with standard deviation 0.102. And the mean value of best solutions found was 0.024 (0. is the best) with standard deviation 0.031.", "error": "", "parent_id": "3770a2cc-b61b-407f-b1cf-8fd34df007e5", "metadata": {"aucs": [0.2779218356661265, 0.4308085900248674, 0.18282809718223625], "final_y": [0.003795136657257938, 4.41676039708546e-05, 0.06835455637049605]}, "mutation_prompt": null}
{"id": "94701a14-fd06-4177-800a-6c4665dbe602", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveParticleDynamics:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 + int(2.5 * np.sqrt(dim))\n        self.min_population_size = 8\n        self.quantum_superposition_factor = 0.5\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.inertia_initial = 0.8\n        self.inertia_damp = 0.98\n        self.max_velocity = 0.3\n        self.dynamic_shrinkage = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        positions = np.random.uniform(lb, ub, (population_size, self.dim))\n        velocities = np.zeros((population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.inertia = self.inertia_initial\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i].copy()\n\n            # Quantum-inspired superposition and adaptive dynamics\n            for i in range(population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.c1 * r1 * (personal_best_positions[i] - positions[i])\n                social_component = self.c2 * r2 * (global_best_position - positions[i])\n                velocities[i] = (self.inertia * velocities[i] + cognitive_component + social_component)\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                # Quantum superposition factor to introduce stochastic perturbations\n                if np.random.rand() < self.quantum_superposition_factor:\n                    positions[i] = np.random.uniform(lb, ub, self.dim)\n\n            # Dynamic adjustment of inertia, population size, and cognitive/social coefficients\n            self.inertia *= self.inertia_damp\n            self.c1 = max(0.4, self.c1_initial * (1 - evaluations / self.budget))\n            self.c2 = max(0.4, self.c2_initial * (evaluations / self.budget))\n            \n            # Reduce population size over time to intensify search\n            population_size = max(self.min_population_size, int(self.initial_population_size * (self.dynamic_shrinkage ** (evaluations / self.budget))))\n            positions = positions[:population_size]\n            velocities = velocities[:population_size]\n            personal_best_positions = personal_best_positions[:population_size]\n            personal_best_scores = personal_best_scores[:population_size]\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredAdaptiveParticleDynamics", "description": "Quantum-Inspired Adaptive Particle Dynamics - an innovative algorithm blending quantum-inspired superposition principles with adaptive exploration-exploitation mechanics to optimize solutions efficiently.", "configspace": "", "generation": 2, "fitness": 0.15920000834778592, "feedback": "The algorithm QuantumInspiredAdaptiveParticleDynamics got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.159 with standard deviation 0.036. And the mean value of best solutions found was 0.622 (0. is the best) with standard deviation 0.327.", "error": "", "parent_id": "bd7f419b-a6f7-40d6-aaaf-23c6ac70b70b", "metadata": {"aucs": [0.1404453522841559, 0.20980235364695132, 0.12735231911225053], "final_y": [1.0424537916722847, 0.2457444606762349, 0.5773517320011485]}, "mutation_prompt": null}
{"id": "79852cfd-d2ff-4a94-a16e-1db16bcaa8d3", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 + int(2 * np.sqrt(dim))\n        self.min_population_size = 5\n        self.alpha = 0.5  # Amplitude damping factor\n        self.beta = 1.0   # Phase damping factor\n        self.dynamic_shrinkage = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        wave_functions = np.random.uniform(lb, ub, (population_size, self.dim, 2))\n        personal_best_positions = wave_functions[:, :, 0].copy()\n        personal_best_scores = np.full(population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            # Collapse wave functions to concrete positions\n            positions = wave_functions[:, :, 0] + self.beta * (wave_functions[:, :, 1] - wave_functions[:, :, 0])\n            for i in range(population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i].copy()\n\n            # Update wave functions based on best known positions\n            for i in range(population_size):\n                r = np.random.rand(self.dim)\n                wave_functions[i, :, 0] = self.alpha * wave_functions[i, :, 0] + r * (personal_best_positions[i] - wave_functions[i, :, 0])\n                wave_functions[i, :, 1] = self.alpha * wave_functions[i, :, 1] + r * (global_best_position - wave_functions[i, :, 1])\n                wave_functions[i] = np.clip(wave_functions[i], lb, ub)\n            \n            # Reduce population size over time to intensify search\n            population_size = max(self.min_population_size, int(self.initial_population_size * (self.dynamic_shrinkage ** (evaluations / self.budget))))\n            wave_functions = wave_functions[:population_size]\n            personal_best_positions = personal_best_positions[:population_size]\n            personal_best_scores = personal_best_scores[:population_size]\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredAdaptiveSearch", "description": "\"Quantum-Inspired Adaptive Search\" - a novel optimization algorithm leveraging quantum superposition principles to explore multiple potential solutions simultaneously, enhancing convergence speed and solution quality through adaptive wave function collapse mechanisms.", "configspace": "", "generation": 3, "fitness": 0.014786456745979485, "feedback": "The algorithm QuantumInspiredAdaptiveSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.015 with standard deviation 0.000. And the mean value of best solutions found was 29.449 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bd7f419b-a6f7-40d6-aaaf-23c6ac70b70b", "metadata": {"aucs": [0.014795175223715429, 0.014791647260971152, 0.014772547753251875], "final_y": [29.44857853895187, 29.44857853895187, 29.44857853895187]}, "mutation_prompt": null}
{"id": "c29fa3fe-d839-45a4-a83a-ca5f80010f01", "solution": "import numpy as np\n\nclass QuantumInspiredDynamicSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 + int(2 * np.sqrt(dim))\n        self.min_population_size = 5\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.inertia_initial = 0.9\n        self.inertia_damp = 0.99\n        self.max_velocity = 0.2\n        self.dynamic_shrinkage = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        positions = np.random.uniform(lb, ub, (population_size, self.dim))\n        velocities = np.zeros((population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.inertia = self.inertia_initial\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i].copy()\n\n            for i in range(population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.c1 * r1 * (personal_best_positions[i] - positions[i])\n                social_component = self.c2 * r2 * (global_best_position - positions[i])\n                velocities[i] = (self.inertia * velocities[i] + cognitive_component + social_component)\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n            # Quantum-inspired position update\n            quantum_positions = np.random.rand(population_size, self.dim) < 0.5\n            positions = np.where(quantum_positions, global_best_position + np.random.normal(0, 1, (population_size, self.dim)), positions)\n\n            # Dynamic adjustment of inertia, population size, and coefficients\n            self.inertia *= self.inertia_damp\n            self.c1 = max(0.5, self.c1_initial * (1 - evaluations / self.budget))\n            self.c2 = max(0.5, self.c2_initial * (evaluations / self.budget))\n            \n            # Reduce population size over time\n            population_size = max(self.min_population_size, int(self.initial_population_size * (self.dynamic_shrinkage ** (evaluations / self.budget))))\n            positions = positions[:population_size]\n            velocities = velocities[:population_size]\n            personal_best_positions = personal_best_positions[:population_size]\n            personal_best_scores = personal_best_scores[:population_size]\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDynamicSwarmOptimization", "description": "\"Quantum-Inspired Dynamic Swarm Optimization\" - a novel algorithm that leverages quantum superposition principles to enhance global exploration and dynamic parameter adjustments to adaptively balance exploration and exploitation.", "configspace": "", "generation": 4, "fitness": 0.20479615796221273, "feedback": "The algorithm QuantumInspiredDynamicSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.205 with standard deviation 0.063. And the mean value of best solutions found was 0.307 (0. is the best) with standard deviation 0.269.", "error": "", "parent_id": "bd7f419b-a6f7-40d6-aaaf-23c6ac70b70b", "metadata": {"aucs": [0.16957129796600467, 0.29310682734298377, 0.15171034857764976], "final_y": [0.21907748471196883, 0.03127817309020908, 0.671351778671224]}, "mutation_prompt": null}
{"id": "563a7dae-179a-4a3c-a3a5-911183c98be1", "solution": "import numpy as np\n\nclass QuantumInspiredWaveFunctionOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 + int(2 * np.sqrt(dim))\n        self.min_population_size = 5\n        self.max_velocity = 0.2\n        self.alpha = 0.9  # Damping factor for interference pattern\n        self.beta = 0.1   # Step size for wave interference\n        self.dynamic_shrinkage = 0.95\n\n    def wave_function(self, position, amplitude, frequency):\n        return amplitude * np.sin(frequency * position)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        positions = np.random.uniform(lb, ub, (population_size, self.dim))\n        velocities = np.zeros((population_size, self.dim))\n        best_positions = positions.copy()\n        best_scores = np.full(population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < best_scores[i]:\n                    best_scores[i] = score\n                    best_positions[i] = positions[i].copy()\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i].copy()\n\n            amplitude = np.sqrt(global_best_score + 1e-9)\n            frequency = self.beta * (evaluations / self.budget)\n\n            for i in range(population_size):\n                interference = self.wave_function(positions[i], amplitude, frequency)\n                velocities[i] = self.alpha * velocities[i] + interference\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n            # Reduce population size over time to enhance exploitation\n            population_size = max(self.min_population_size, int(self.initial_population_size * (self.dynamic_shrinkage ** (evaluations / self.budget))))\n            positions = positions[:population_size]\n            velocities = velocities[:population_size]\n            best_positions = best_positions[:population_size]\n            best_scores = best_scores[:population_size]\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredWaveFunctionOptimization", "description": "\"Quantum-Inspired Wave Function Optimization\" - a novel algorithm that draws inspiration from quantum mechanics, utilizing wave function probability density functions to explore and exploit the search space with dynamic interference patterns.", "configspace": "", "generation": 5, "fitness": 0.1542005339264386, "feedback": "The algorithm QuantumInspiredWaveFunctionOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.154 with standard deviation 0.021. And the mean value of best solutions found was 1.326 (0. is the best) with standard deviation 0.587.", "error": "", "parent_id": "bd7f419b-a6f7-40d6-aaaf-23c6ac70b70b", "metadata": {"aucs": [0.1814867296289434, 0.15183737595656832, 0.12927749619380402], "final_y": [0.6355866928446509, 1.2730797107934095, 2.0697357418467197]}, "mutation_prompt": null}
{"id": "cc17088c-4660-4751-b5a0-c3d138e682f9", "solution": "import numpy as np\n\nclass ImprovedAdaptiveSwarmDynamics:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 + int(2 * np.sqrt(dim))\n        self.min_population_size = 5\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.inertia_initial = 0.9\n        self.inertia_damp = 0.99\n        self.max_velocity = 0.2\n        self.dynamic_shrinkage = 0.95\n        self.neighborhood_radius = max(1, int(0.1 * dim))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        positions = np.random.uniform(lb, ub, (population_size, self.dim))\n        velocities = np.zeros((population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.inertia = self.inertia_initial\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i].copy()\n\n            # Determine neighborhood best position\n            neighborhood_best_positions = []\n            for i in range(population_size):\n                neighborhood = np.argsort(np.linalg.norm(positions - positions[i], axis=1))[:self.neighborhood_radius]\n                best_in_neighborhood = neighborhood[np.argmin(personal_best_scores[neighborhood])]\n                neighborhood_best_positions.append(personal_best_positions[best_in_neighborhood])\n\n            for i in range(population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_component = self.c1 * r1 * (personal_best_positions[i] - positions[i])\n                neighborhood_component = self.c2 * r2 * (neighborhood_best_positions[i] - positions[i])\n                velocities[i] = (self.inertia * velocities[i] + cognitive_component + neighborhood_component)\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n            self.inertia *= self.inertia_damp\n            self.c1 = max(0.5, self.c1_initial * (1 - evaluations / self.budget))\n            self.c2 = max(0.5, self.c2_initial * (evaluations / self.budget))\n\n            population_size = max(self.min_population_size, int(self.initial_population_size * (self.dynamic_shrinkage ** (evaluations / self.budget))))\n            positions = positions[:population_size]\n            velocities = velocities[:population_size]\n            personal_best_positions = personal_best_positions[:population_size]\n            personal_best_scores = personal_best_scores[:population_size]\n\n        return global_best_position, global_best_score", "name": "ImprovedAdaptiveSwarmDynamics", "description": "Improved Adaptive Swarm Dynamics with Dynamic Neighborhood for Enhanced Exploration and Convergence.", "configspace": "", "generation": 6, "fitness": 0.058566860437684665, "feedback": "The algorithm ImprovedAdaptiveSwarmDynamics got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.059 with standard deviation 0.028. And the mean value of best solutions found was 13.202 (0. is the best) with standard deviation 6.422.", "error": "", "parent_id": "bd7f419b-a6f7-40d6-aaaf-23c6ac70b70b", "metadata": {"aucs": [0.03184652232579854, 0.04600476283479027, 0.09784929615246518], "final_y": [20.178143039825787, 14.750048042802195, 4.676626635738728]}, "mutation_prompt": null}
{"id": "8c7ca176-011a-47aa-984e-1b4865e634b7", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.05  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "\"Quantum-Inspired Differential Evolution\" - a novel algorithm that leverages quantum superposition principles and differential evolution to enhance diversity and convergence in solving complex optimization problems.", "configspace": "", "generation": 7, "fitness": 0.5905371062696319, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.591 with standard deviation 0.051. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bd7f419b-a6f7-40d6-aaaf-23c6ac70b70b", "metadata": {"aucs": [0.6536459103886711, 0.5293299423556339, 0.5886354660645905], "final_y": [3.2206281867936257e-09, 8.999968021422506e-10, 1.9079178711401837e-09]}, "mutation_prompt": null}
{"id": "ef3aeb96-593c-4dbe-913a-0dfbd6ba760c", "solution": "import numpy as np\n\nclass AdaptiveQuantumParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 10 + int(2 * np.sqrt(dim))\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.q_prob = 0.1  # Probability to use quantum-inspired velocity update\n\n    def quantum_velocity_update(self, velocity, best_position, current_position, lb, ub):\n        factor = np.random.uniform(0.5, 1.5, self.dim)\n        new_velocity = factor * (best_position - current_position)\n        return np.clip(new_velocity, lb - current_position, ub - current_position)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        positions = np.random.uniform(lb, ub, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.swarm_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate current position\n                score = func(positions[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i].copy()\n\n                # Update velocity\n                inertia = self.w * velocities[i]\n                cognitive = self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - positions[i])\n                social = self.c2 * np.random.rand(self.dim) * (global_best_position - positions[i])\n                new_velocity = inertia + cognitive + social\n\n                # Quantum-inspired velocity update\n                if np.random.rand() < self.q_prob:\n                    new_velocity = self.quantum_velocity_update(new_velocity, global_best_position, positions[i], lb, ub)\n\n                velocities[i] = new_velocity\n\n                # Update position\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n        return global_best_position, global_best_score", "name": "AdaptiveQuantumParticleSwarmOptimization", "description": "Adaptive Particle Swarm Optimization with Quantum-Inspired Velocity Update - an innovative algorithm combining adaptive particle swarm optimization with quantum-inspired movements to enhance exploration and exploitation balance in complex optimization problems.", "configspace": "", "generation": 8, "fitness": 0.5694901762275212, "feedback": "The algorithm AdaptiveQuantumParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.569 with standard deviation 0.034. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8c7ca176-011a-47aa-984e-1b4865e634b7", "metadata": {"aucs": [0.5328938388914093, 0.6141603218163594, 0.5614163679747949], "final_y": [1.9154842554258657e-08, 3.450544306875999e-09, 4.974720601019352e-08]}, "mutation_prompt": null}
{"id": "42905354-535b-4050-b3d3-f38cd4078eb7", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.05  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with dynamically adjusted probability\n                dynamic_q_prob = self.q_prob * (1 - evaluations / self.budget)\n                if np.random.rand() < dynamic_q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "\"Enhanced Differential Evolution with Dynamic Quantum Move Probability\" - an improved metaheuristic that adaptively adjusts quantum-inspired move probability for enhanced exploration and convergence.", "configspace": "", "generation": 9, "fitness": 0.48736925864776265, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.487 with standard deviation 0.184. And the mean value of best solutions found was 0.040 (0. is the best) with standard deviation 0.056.", "error": "", "parent_id": "8c7ca176-011a-47aa-984e-1b4865e634b7", "metadata": {"aucs": [0.6278333839722621, 0.22789871668122397, 0.6063756752898017], "final_y": [4.2660937579096814e-10, 0.11893376160210717, 5.435174650607167e-10]}, "mutation_prompt": null}
{"id": "ad57a1aa-37b9-435d-a2c2-adc867a6696f", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.05  # Probability to use quantum-inspired move\n        self.adaptive_factor = 0.1  # Adaptive control factor\n    \n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n    \n    def adaptive_control(self, score, global_best_score, max_score):\n        return self.adaptive_factor * (1 - (score / max_score))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        max_score = 1e9  # Initialize with a large value\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                adjusted_F = self.F + self.adaptive_control(scores[i], global_best_score, max_score)\n                mutant = population[a] + adjusted_F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n                    max_score = max(max_score, trial_score)\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "\"Hybrid Quantum-Inspired Differential Evolution with Adaptive Parameters\" - an enhanced algorithm that combines adaptive parameter control with quantum-inspired differential evolution to improve exploration and exploitation balance for complex optimization tasks.", "configspace": "", "generation": 10, "fitness": 0.4281310788891406, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.428 with standard deviation 0.085. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "8c7ca176-011a-47aa-984e-1b4865e634b7", "metadata": {"aucs": [0.3438136162225971, 0.5452356240575902, 0.3953439963872346], "final_y": [0.004593583887211253, 3.948528582160452e-08, 3.4033205558764787e-07]}, "mutation_prompt": null}
{"id": "f48d3855-c189-4145-ad5e-74ad059e7bbb", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.05  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive differential weight\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                adaptive_F = 0.4 + 0.1 * (self.budget - evaluations) / self.budget\n                mutant = population[a] + adaptive_F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution with adaptive parameters to dynamically balance exploration and exploitation.", "configspace": "", "generation": 11, "fitness": 0.39082182344901134, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.391 with standard deviation 0.201. And the mean value of best solutions found was 1.011 (0. is the best) with standard deviation 1.429.", "error": "", "parent_id": "8c7ca176-011a-47aa-984e-1b4865e634b7", "metadata": {"aucs": [0.11347928166619226, 0.47571180360861376, 0.5832743850722282], "final_y": [3.0316393280158045, 3.578164963609277e-05, 3.7121263413834923e-10]}, "mutation_prompt": null}
{"id": "a1dadf4c-01e3-47a6-bf82-f8b257a96a95", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.05  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = 0.4 + (0.6 * (global_best_score / np.min(scores)))  # Adaptive F parameter\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution with adaptive F parameter for improved convergence and diversity.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\")", "parent_id": "8c7ca176-011a-47aa-984e-1b4865e634b7", "metadata": {}, "mutation_prompt": null}
{"id": "7fb554bb-8e1a-4723-b1d5-2bba16facab2", "solution": "import numpy as np\n\nclass QuantumAdaptiveParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 10 + int(2 * np.sqrt(dim))\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.q_prob = 0.05  # Probability to perform a quantum-inspired move\n        self.inertia_weight = 0.9  # Inertia weight\n\n    def quantum_jump(self, particle, global_best, lb, ub):\n        factor = np.random.uniform(-0.1, 0.1, self.dim)\n        new_position = global_best + factor * (particle - global_best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = swarm.copy()\n        personal_best_scores = np.full(self.swarm_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate current particle\n                score = func(swarm[i])\n                evaluations += 1\n                \n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = swarm[i].copy()\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = swarm[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.swarm_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_component = self.c1 * r1 * (personal_best_positions[i] - swarm[i])\n                social_component = self.c2 * r2 * (global_best_position - swarm[i])\n                \n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cognitive_component + social_component)\n                \n                swarm[i] += velocities[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Quantum-inspired jump with a small probability\n                if np.random.rand() < self.q_prob:\n                    swarm[i] = self.quantum_jump(swarm[i], global_best_position, lb, ub)\n\n        return global_best_position, global_best_score", "name": "QuantumAdaptiveParticleSwarmOptimization", "description": "Quantum Adaptive Particle Swarm Optimization (QAPSO) - A novel algorithm that combines principles of quantum mechanics with adaptive particle swarm strategies to dynamically balance exploration and exploitation for enhanced optimization performance.", "configspace": "", "generation": 13, "fitness": 0.23670672764937617, "feedback": "The algorithm QuantumAdaptiveParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.237 with standard deviation 0.075. And the mean value of best solutions found was 0.647 (0. is the best) with standard deviation 0.889.", "error": "", "parent_id": "8c7ca176-011a-47aa-984e-1b4865e634b7", "metadata": {"aucs": [0.31434923333500486, 0.2611139869070245, 0.13465696270609917], "final_y": [0.0015758140154399892, 0.03503805888199707, 1.9046258042075013]}, "mutation_prompt": null}
{"id": "01e767b8-e057-4425-972b-61f772441940", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.05  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive factor\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                adaptive_F = np.random.uniform(0.4, 0.9)\n                mutant = population[a] + adaptive_F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover with adaptive probability\n                adaptive_CR = np.random.uniform(0.5, 1.0)\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution with adaptive crossover and mutation strategies to improve exploration and exploitation balance.", "configspace": "", "generation": 14, "fitness": 0.42683455212928517, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.427 with standard deviation 0.013. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8c7ca176-011a-47aa-984e-1b4865e634b7", "metadata": {"aucs": [0.40804229817295545, 0.43336015635139813, 0.4391012018635021], "final_y": [7.557245824251339e-06, 3.932519418179841e-06, 3.068862431909958e-06]}, "mutation_prompt": null}
{"id": "e5c174c0-1a6a-4d05-955e-77d730643945", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.05  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Dynamic adjustment of the differential weight\n                self.F = 0.5 * (1 - evaluations / self.budget)\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhance exploration by dynamically adjusting the differential weight based on the evaluation progress.", "configspace": "", "generation": 15, "fitness": 0.39248304624817704, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.392 with standard deviation 0.263. And the mean value of best solutions found was 3.161 (0. is the best) with standard deviation 4.468.", "error": "", "parent_id": "8c7ca176-011a-47aa-984e-1b4865e634b7", "metadata": {"aucs": [0.708305590210134, 0.06481665616605359, 0.40432689236834374], "final_y": [1.1735946882851488e-08, 9.479638796386292, 0.0025541285805863747]}, "mutation_prompt": null}
{"id": "450f359c-49c6-4b6c-ba58-54d5972c92f4", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.05  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                adaptive_q_prob = self.q_prob * (1 - evaluations / self.budget)\n                if np.random.rand() < adaptive_q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "An improved Quantum-Inspired Differential Evolution algorithm that uses adaptive quantum probability and enhanced mutation scaling for better convergence.", "configspace": "", "generation": 16, "fitness": 0.42987552011488767, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.430 with standard deviation 0.221. And the mean value of best solutions found was 0.861 (0. is the best) with standard deviation 1.218.", "error": "", "parent_id": "8c7ca176-011a-47aa-984e-1b4865e634b7", "metadata": {"aucs": [0.11796746940714953, 0.5990331680710859, 0.5726259228664277], "final_y": [2.583608344565135, 2.587675185697155e-10, 7.867858841449944e-09]}, "mutation_prompt": null}
{"id": "3ae9152e-d89d-4216-b77f-a750a589c0ed", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob_initial = 0.05  # Initial probability to use quantum-inspired move\n        self.q_prob = self.q_prob_initial\n        self.adaptive_rate = 0.02  # Adaptive rate for altering F and CR\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adapt_parameters(self, iter_ratio):\n        self.F = 0.5 + 0.5 * np.sin(np.pi * iter_ratio)\n        self.CR = 0.9 - 0.4 * np.random.rand()\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            iter_ratio = evaluations / self.budget\n            self.adapt_parameters(iter_ratio)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with adaptive probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "\"Enhanced Quantum-Inspired Differential Evolution\" - integrates adaptive quantum-inspired moves and dynamic parameter adjustments to improve exploration and exploitation in solving complex optimization problems.", "configspace": "", "generation": 17, "fitness": 0.33686272140272205, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.337 with standard deviation 0.047. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "8c7ca176-011a-47aa-984e-1b4865e634b7", "metadata": {"aucs": [0.2744175031398376, 0.3487564060204654, 0.3874142550478632], "final_y": [0.001323321998452693, 0.00016855707666547738, 4.012330712922814e-05]}, "mutation_prompt": null}
{"id": "b98bad30-01b3-4db7-8431-13c0a61a209b", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.05  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Dynamic crossover probability based on diversity\n                self.CR = 0.5 + 0.4 * (1 - np.std(population, axis=0).mean() / (ub - lb).mean())\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "\"Quantum-Inspired Differential Evolution with Dynamic Crossover\" - an enhanced version of the algorithm that adapts its crossover probability dynamically based on the population's diversity to improve convergence rates in solving complex optimization problems.", "configspace": "", "generation": 18, "fitness": 0.17903161146461496, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.179 with standard deviation 0.003. And the mean value of best solutions found was 0.567 (0. is the best) with standard deviation 0.032.", "error": "", "parent_id": "8c7ca176-011a-47aa-984e-1b4865e634b7", "metadata": {"aucs": [0.1786457551445284, 0.17558848652611792, 0.18286059272319855], "final_y": [0.5516274361460575, 0.5374555261690188, 0.6118882391473396]}, "mutation_prompt": null}
{"id": "eabc2518-3a48-4c32-b3d8-bf27330d93d3", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.q_prob = 0.05  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update CR dynamically\n                self.CR = 0.5 + 0.5 * (global_best_score / (1 + np.std(scores)))\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhancing Quantum-Inspired Differential Evolution by adjusting the crossover probability dynamically to balance exploration and exploitation.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\")", "parent_id": "8c7ca176-011a-47aa-984e-1b4865e634b7", "metadata": {}, "mutation_prompt": null}
{"id": "ef6be291-a8bc-4e8d-8a3a-7cfd5dd5c1af", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.05  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            self.q_prob = 0.05 + 0.45 * evaluations / self.budget  # Adaptive quantum probability\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "\"Quantum-Inspired Differential Evolution with Adaptive Quantum Probability\" - an enhanced algorithm utilizing adaptive quantum-inspired moves to dynamically balance exploration and exploitation.", "configspace": "", "generation": 20, "fitness": 0.36226585088338376, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.362 with standard deviation 0.219. And the mean value of best solutions found was 0.547 (0. is the best) with standard deviation 0.747.", "error": "", "parent_id": "8c7ca176-011a-47aa-984e-1b4865e634b7", "metadata": {"aucs": [0.1420050426296975, 0.2835195155481173, 0.6612729944723363], "final_y": [1.6033011402499546, 0.0386904573181955, 2.1165534861032485e-10]}, "mutation_prompt": null}
{"id": "0a2b7e36-cc08-46e5-a70a-4f86b3d58435", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.05  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = 0.4 + 0.1 * np.random.rand()  # Adaptive differential weight\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution using adaptive differential weight to dynamically balance exploration and exploitation.", "configspace": "", "generation": 21, "fitness": 0.30398597509908026, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.304 with standard deviation 0.202. And the mean value of best solutions found was 0.897 (0. is the best) with standard deviation 1.071.", "error": "", "parent_id": "8c7ca176-011a-47aa-984e-1b4865e634b7", "metadata": {"aucs": [0.5853761570875808, 0.2029163866892557, 0.1236653815204043], "final_y": [2.363371119570315e-09, 0.28973174639558213, 2.402307565988951]}, "mutation_prompt": null}
{"id": "9ef94393-676f-490d-877e-5ae8237198f5", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.05  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Adaptive Mutation\n                self.F = 0.4 + 0.1 * np.random.rand()\n                \n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Adaptive Crossover\n                self.CR = 0.8 + 0.1 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "\"Enhanced Quantum-Inspired Differential Evolution\" - introduces adaptive differential weight and crossover probability to boost convergence and solution quality.", "configspace": "", "generation": 22, "fitness": 0.27047519722159646, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.270 with standard deviation 0.228. And the mean value of best solutions found was 3.758 (0. is the best) with standard deviation 4.877.", "error": "", "parent_id": "8c7ca176-011a-47aa-984e-1b4865e634b7", "metadata": {"aucs": [0.5875226683726729, 0.05928376366736354, 0.16461915962475304], "final_y": [4.855297998203357e-09, 10.646062757435441, 0.6275127263887152]}, "mutation_prompt": null}
{"id": "dd20bd31-b421-4b24-bcba-02a120887efc", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.initial_population_size = self.population_size\n        self.F = 0.5  # Initial differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.05  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_parameters(self, evaluations):\n        self.F = 0.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)\n        self.population_size = int(self.initial_population_size * (1 - evaluations / self.budget))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            self.adaptive_parameters(evaluations)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "EnhancedQuantumInspiredDifferentialEvolution", "description": "\"Enhanced Quantum-Inspired Differential Evolution\" integrates adaptive differential weights and dynamic population resizing to improve convergence and solution quality in complex optimization scenarios.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "8c7ca176-011a-47aa-984e-1b4865e634b7", "metadata": {}, "mutation_prompt": null}
{"id": "3e24879f-31b1-447f-8cbe-676d38a6a68d", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.05  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Adaptive mutation rate based on evaluations\n                self.F = 0.4 + 0.1 * (evaluations / self.budget)\n                \n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Adaptive crossover probability based on evaluations\n                self.CR = 0.8 + 0.2 * (global_best_score / (global_best_score + np.mean(scores)))\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution with adaptive mutation and crossover rates to improve exploration-exploitation balance.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\")", "parent_id": "8c7ca176-011a-47aa-984e-1b4865e634b7", "metadata": {}, "mutation_prompt": null}
{"id": "012a3f3a-fe26-4009-8c01-03542ca61cee", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Improved Quantum-Inspired Differential Evolution by increasing diversity through a higher quantum-inspired move probability.", "configspace": "", "generation": 25, "fitness": 0.6431016699627076, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.643 with standard deviation 0.023. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8c7ca176-011a-47aa-984e-1b4865e634b7", "metadata": {"aucs": [0.627170393376345, 0.6259369326297362, 0.6761976838820414], "final_y": [8.204117517331729e-11, 1.0925274317215365e-10, 2.0671356479468204e-11]}, "mutation_prompt": null}
{"id": "4a4e5223-8082-4a0d-9593-f923aae94fa5", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_parameters(self, eval_progress):\n        self.F = 0.4 + 0.1 * np.sin(eval_progress * np.pi)  # Adaptive F\n        self.CR = 0.8 + 0.1 * np.cos(eval_progress * np.pi)  # Adaptive CR\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            eval_progress = evaluations / self.budget\n            self.adaptive_parameters(eval_progress)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution with adaptive parameters for improved performance.", "configspace": "", "generation": 26, "fitness": 0.5108438275427761, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.511 with standard deviation 0.162. And the mean value of best solutions found was 0.019 (0. is the best) with standard deviation 0.027.", "error": "", "parent_id": "012a3f3a-fe26-4009-8c01-03542ca61cee", "metadata": {"aucs": [0.6202507086672707, 0.6306305708738218, 0.2816502030872359], "final_y": [1.1976487844151939e-08, 9.997726102133969e-10, 0.058250111152518866]}, "mutation_prompt": null}
{"id": "b875e00a-a2da-4659-a848-30262d31ccba", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.85  # Crossover probability (changed from 0.9 to 0.85)\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.4, 1.6)  # Changed range from (0.5, 1.5) to (0.4, 1.6)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution by adjusting quantum move factor range and crossover probability for improved exploration.", "configspace": "", "generation": 27, "fitness": 0.4467028472294768, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.447 with standard deviation 0.224. And the mean value of best solutions found was 0.641 (0. is the best) with standard deviation 0.906.", "error": "", "parent_id": "012a3f3a-fe26-4009-8c01-03542ca61cee", "metadata": {"aucs": [0.6393946026264844, 0.5684180364950954, 0.13229590256685053], "final_y": [3.413762100125996e-10, 6.502422342493303e-08, 1.9218444365341674]}, "mutation_prompt": null}
{"id": "595b5a56-16fd-4880-9db9-56e89d5e9ddc", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Adapt differential weight and crossover probability\n                self.F = 0.4 + 0.1 * np.random.rand()\n                self.CR = 0.8 + 0.1 * np.random.rand()\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution with adaptive differential weight and crossover probability for improved convergence.", "configspace": "", "generation": 28, "fitness": 0.2789562094303126, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.279 with standard deviation 0.204. And the mean value of best solutions found was 11.168 (0. is the best) with standard deviation 15.788.", "error": "", "parent_id": "012a3f3a-fe26-4009-8c01-03542ca61cee", "metadata": {"aucs": [0.008943543058586467, 0.5015463357937129, 0.3263787494386384], "final_y": [33.49519482863309, 0.00011146160632518977, 0.009227769477612634]}, "mutation_prompt": null}
{"id": "bbd395f6-4e19-4a5c-ac67-a8a35938ebb6", "solution": "import numpy as np\n\nclass EnhancedQuantumEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.15  # Increased quantum-inspired move probability\n        self.adaptive_factor = 0.95  # New adaptive factor for controlling diversity\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.6, 1.2)  # Adjusted factor range for better exploration\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive strategy\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.adaptive_factor * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a higher probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "EnhancedQuantumEvolution", "description": "Enhanced Quantum Evolution Strategy with adaptive parameters for increased convergence and diversity.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\")", "parent_id": "012a3f3a-fe26-4009-8c01-03542ca61cee", "metadata": {}, "mutation_prompt": null}
{"id": "d3cc19b1-27d0-4d2c-b470-a4c9e7429ff5", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover with adaptive probability\n                self.CR = 0.8 + 0.2 * (evaluations / self.budget)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Dynamic quantum-inspired move probability\n                self.q_prob = 0.05 + 0.15 * (1 - evaluations / self.budget)\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution by introducing adaptive crossover probability and dynamic quantum-inspired move probability for better exploration and exploitation.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\")", "parent_id": "012a3f3a-fe26-4009-8c01-03542ca61cee", "metadata": {}, "mutation_prompt": null}
{"id": "77b58471-b36a-4b6f-91b3-6c820f53cf94", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.initial_F = 0.5  # Initial Differential weight\n        self.initial_CR = 0.9  # Initial Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n        self.elite_size = max(1, self.population_size // 10)  # Elite pool size\n        self.F = self.initial_F\n        self.CR = self.initial_CR\n\n    def adapt_parameters(self, iter_num, max_iters):\n        self.F = self.initial_F * (1 - iter_num / max_iters)\n        self.CR = self.initial_CR * (iter_num / max_iters)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        max_iters = self.budget // self.population_size\n\n        for iter_num in range(max_iters):\n            self.adapt_parameters(iter_num, max_iters)\n\n            elite_indices = np.argsort(scores)[:self.elite_size]\n            elite_population = population[elite_indices]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], elite_population[np.random.randint(self.elite_size)], lb, ub)\n\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Incorporates adaptive parameter control and elitism to boost diversity and convergence in Quantum-Inspired Differential Evolution.", "configspace": "", "generation": 31, "fitness": 0.33785051098817426, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.338 with standard deviation 0.035. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "012a3f3a-fe26-4009-8c01-03542ca61cee", "metadata": {"aucs": [0.31494274647750553, 0.38747388335285915, 0.31113490313415826], "final_y": [0.0003951268520634295, 2.4275240664349445e-06, 0.0037578369377788056]}, "mutation_prompt": null}
{"id": "5a36fef3-2c13-4539-b7e4-18a7ae69eee6", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20 + int(2 * np.sqrt(dim))  # Increased population size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.3, 1.2)  # Adjusted factor range for quantum move\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution by increasing population size for better exploration and adjusting quantum-inspired move factor for improved convergence.", "configspace": "", "generation": 32, "fitness": 0.40921337246312994, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.409 with standard deviation 0.023. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "012a3f3a-fe26-4009-8c01-03542ca61cee", "metadata": {"aucs": [0.3833160935272142, 0.4388321177415443, 0.40549190612063146], "final_y": [1.7190358615138558e-05, 3.419377935257113e-07, 8.353885028546534e-06]}, "mutation_prompt": null}
{"id": "cefb1f6f-96a3-4559-a7fd-eef1706047b3", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = 0.5 + 0.3 * np.sin(2 * np.pi * evaluations / self.budget)  # Dynamic adjustment\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution by dynamically adjusting the differential weight (F) for better exploration-exploitation balance.", "configspace": "", "generation": 33, "fitness": 0.5029898884483229, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.503 with standard deviation 0.002. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "012a3f3a-fe26-4009-8c01-03542ca61cee", "metadata": {"aucs": [0.4998083535255391, 0.5046921438798881, 0.5044691679395417], "final_y": [3.223151736217987e-05, 1.6830792120874058e-05, 1.2021124724486128e-05]}, "mutation_prompt": null}
{"id": "b80cd8ca-e31d-4978-8fc4-f247791fd7bf", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = 0.4 + 0.1 * np.random.rand()  # Self-adaptive mutation scaling\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                self.CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution by introducing adaptive crossover probability and self-adaptive mutation scaling to improve convergence.", "configspace": "", "generation": 34, "fitness": 0.43434592903262786, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.434 with standard deviation 0.116. And the mean value of best solutions found was 0.004 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "012a3f3a-fe26-4009-8c01-03542ca61cee", "metadata": {"aucs": [0.5956786582120026, 0.3247626908603697, 0.38259643802551124], "final_y": [1.6791208339213525e-09, 0.010337769192023548, 0.0010929243604424124]}, "mutation_prompt": null}
{"id": "37ded885-2dcc-44e6-883f-6d24b0c66cda", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F_base = 0.5  # Base differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n\n    def adaptive_scaling_factor(self, score, best_score):\n        return self.F_base + 0.3 * (1 - score / (best_score + 1e-8))\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                F = self.adaptive_scaling_factor(scores[i], global_best_score)\n                mutant = population[a] + F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Enhanced Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.choice(range(self.dim))] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum Differential Evolution by optimizing crossover dynamics and introducing adaptive scaling factor.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\")", "parent_id": "012a3f3a-fe26-4009-8c01-03542ca61cee", "metadata": {}, "mutation_prompt": null}
{"id": "292eca95-a576-4f7f-82a5-3efc3ecf2ab6", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                self.CR = 0.8 + 0.2 * (global_best_score - scores[i]) / (global_best_score + 1e-10)  # adaptive CR\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n                self.q_prob = 0.1 + 0.15 * (global_best_score - np.mean(scores)) / (global_best_score + 1e-10)  # dynamic q_prob\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Further enhanced Quantum-Inspired Differential Evolution by adaptive crossover probability and dynamic quantum probability adjustment.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\")", "parent_id": "012a3f3a-fe26-4009-8c01-03542ca61cee", "metadata": {}, "mutation_prompt": null}
{"id": "62f5ed23-55ff-41f3-ac6b-d095810e5d71", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            self.F = 0.4 + 0.3 * (1 - evaluations / self.budget)  # Adaptive mutation factor\n            self.q_prob = 0.05 + 0.05 * (evaluations / self.budget)  # Dynamic quantum probability\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Introduced adaptive mutation factor and dynamic quantum probability to enhance convergence and diversity in the optimization process.", "configspace": "", "generation": 37, "fitness": 0.5720612576674772, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.572 with standard deviation 0.005. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "012a3f3a-fe26-4009-8c01-03542ca61cee", "metadata": {"aucs": [0.575822882671158, 0.5757535634755317, 0.5646073268557417], "final_y": [1.588996537552727e-09, 8.010562475792441e-10, 4.660961152431055e-09]}, "mutation_prompt": null}
{"id": "cbd7b798-0b20-4f0b-977d-eeace252d192", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.7  # Differential weight adjusted from 0.5 to 0.7\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.15  # Probability to use quantum-inspired move increased from 0.1 to 0.15\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Improved diversity in Quantum-Inspired Differential Evolution by adjusting mutation logic and quantum probability.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\")", "parent_id": "012a3f3a-fe26-4009-8c01-03542ca61cee", "metadata": {}, "mutation_prompt": null}
{"id": "6cdff230-f912-4c0d-9ae7-73163ac8a51d", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Initial probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        prev_global_best_score = global_best_score\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a dynamic probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n            # Adjust the quantum-inspired probability dynamically\n            if global_best_score < prev_global_best_score:\n                self.q_prob = min(0.3, self.q_prob + 0.05)  # Increase probability\n            else:\n                self.q_prob = max(0.05, self.q_prob - 0.05)  # Decrease probability\n            prev_global_best_score = global_best_score\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhance exploration by dynamically adjusting the quantum-inspired probability based on convergence rate.", "configspace": "", "generation": 39, "fitness": 0.5095338767124414, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.510 with standard deviation 0.158. And the mean value of best solutions found was 0.013 (0. is the best) with standard deviation 0.019.", "error": "", "parent_id": "012a3f3a-fe26-4009-8c01-03542ca61cee", "metadata": {"aucs": [0.28634037684001146, 0.6142907908886457, 0.6279704624086673], "final_y": [0.03937682249559001, 3.845841958195562e-11, 7.596948348301251e-12]}, "mutation_prompt": null}
{"id": "05af4ed8-70cb-4e25-939b-fa0b262bee8f", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob_initial = 0.1  # Initial probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Dynamic quantum-inspired move probability\n                q_prob = self.q_prob_initial * (1 - evaluations / self.budget)\n                if np.random.rand() < q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution with dynamic scaling of quantum move probability based on iteration count to improve exploration and exploitation balance.", "configspace": "", "generation": 40, "fitness": 0.624239072375271, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.624 with standard deviation 0.037. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "012a3f3a-fe26-4009-8c01-03542ca61cee", "metadata": {"aucs": [0.6754449144310346, 0.5869060302393971, 0.6103662724553811], "final_y": [1.7238713313920248e-11, 4.3421657853758127e-10, 6.00359241532267e-10]}, "mutation_prompt": null}
{"id": "5dc6ebf8-8120-450f-b572-789ac2744257", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (initial value)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Adaptive quantum-inspired move probability\n                self.q_prob = 0.1 + 0.4 * (1 - evaluations / self.budget)\n\n                # Quantum-inspired move with an adaptive probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best with elitism strategy\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution with adaptive quantum probability and elitism strategy to improve convergence.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\")", "parent_id": "012a3f3a-fe26-4009-8c01-03542ca61cee", "metadata": {}, "mutation_prompt": null}
{"id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Introduced adaptive mutation rate and quantum-inspired crossover to enhance search dynamics and convergence.", "configspace": "", "generation": 42, "fitness": 0.7131017870471436, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.713 with standard deviation 0.010. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "012a3f3a-fe26-4009-8c01-03542ca61cee", "metadata": {"aucs": [0.7004824716735394, 0.7138786502736023, 0.7249442391942891], "final_y": [6.529814986393326e-14, 1.229995425961701e-09, 5.381342359362802e-13]}, "mutation_prompt": null}
{"id": "e162cf9a-ff42-42f4-b3df-f9e8bcf427d3", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n        self.min_population_size = max(5, self.population_size // 2)  # Dynamic population size adjustment\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n            # Dynamic population adjustment based on convergence\n            if evaluations % (self.budget // 10) == 0:\n                self.population_size = max(self.min_population_size, int(0.9 * self.population_size))\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced exploration through dynamically adjusted population size based on convergence rate.", "configspace": "", "generation": 43, "fitness": 0.4473522425474392, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.447 with standard deviation 0.072. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.36359535143529775, 0.43989669514157914, 0.5385646810654408], "final_y": [0.0032163408658330652, 0.00020487694869192606, 1.876653063556727e-08]}, "mutation_prompt": null}
{"id": "93c59be2-5dd6-463c-8c59-74429f58e51a", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n\n    def levy_flight(self, individual, lb, ub):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v) ** (1 / beta)\n        new_position = individual + 0.01 * step * (individual - lb)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_crossover(self):\n        return 0.7 + np.random.rand() * 0.2  # Adaptive crossover probability\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.adaptive_crossover(), best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.levy_flight(population[i], lb, ub)\n\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced exploration by introducing levy flights and adaptive crossover to improve diversity and convergence.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'QuantumInspiredDifferentialEvolution' object has no attribute 'adaptive_mutation'\").", "error": "AttributeError(\"'QuantumInspiredDifferentialEvolution' object has no attribute 'adaptive_mutation'\")", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "0ebe487a-d119-427f-b729-d86d7f303ccf", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n        self.memory_size = 5  # Memory size for previous successful mutations\n        self.memory = []\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        if self.memory:\n            return np.mean(self.memory)  # Use memory to adapt mutation factor\n        return 0.5 + np.random.rand() * 0.3\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def update_population_size(self, evaluations):\n        if evaluations > 0.7 * self.budget:\n            return max(4, self.population_size // 2)\n        return self.population_size\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            self.population_size = self.update_population_size(evaluations)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n                    if len(self.memory) >= self.memory_size:\n                        self.memory.pop(0)\n                    self.memory.append(self.F)\n\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution with Dynamic Population and Memory-Based Adaptation for Improved Exploration and Exploitation.", "configspace": "", "generation": 45, "fitness": 0.5955691932073817, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.596 with standard deviation 0.023. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.5853298162462468, 0.6269319417004413, 0.5744458216754569], "final_y": [7.299618241023088e-07, 4.1082217041696295e-09, 5.190799628516417e-08]}, "mutation_prompt": null}
{"id": "0cad57d9-10ed-4247-95d4-5b1c8115369b", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim)) + budget // 1000  # Dynamic population size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Initial probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            self.q_prob = 0.1 + 0.1 * (evaluations / self.budget)  # Adaptive quantum probability\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced exploration by adding adaptive quantum probability and a dynamic population size strategy.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\")", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "fb8bbb10-998e-4cf5-8635-e003703804b3", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.95  # Crossover probability (increased from 0.9 to 0.95)\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced exploitation by increasing crossover probability to 0.95 for better convergence.", "configspace": "", "generation": 47, "fitness": 0.4613022585328506, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.461 with standard deviation 0.269. And the mean value of best solutions found was 2.088 (0. is the best) with standard deviation 2.952.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.08138517183218019, 0.638930967174165, 0.6635906365922067], "final_y": [6.2625642674076865, 7.236598944575595e-12, 1.1461307337093113e-10]}, "mutation_prompt": null}
{"id": "8eb533eb-5b26-435b-b3bf-546be1ad0676", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.05  # Probability to use quantum-inspired move (reduced from 0.1 to 0.05)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        chaotic_factor = 0.7 * np.abs(np.sin(np.random.rand()))\n        return 0.5 + chaotic_factor  # Adaptive mutation factor with chaotic map\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced exploration by introducing a chaotic map for adaptive mutation and reduced quantum move probability for better convergence.", "configspace": "", "generation": 48, "fitness": 0.5338338748225141, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.534 with standard deviation 0.012. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.5235207724364259, 0.5274894468037679, 0.5504914052273484], "final_y": [5.019720634706006e-09, 4.1027423196828255e-08, 2.2479968853015445e-08]}, "mutation_prompt": null}
{"id": "437d5441-eab3-4e06-934e-775b7ccd8f3d", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def adaptive_crossover(self, current_best_score, global_best_score):\n        return self.CR * (1 - current_best_score / (global_best_score + 1e-8))\n\n    def quantum_crossover(self, individual, best, current_best_score, global_best_score):\n        adaptive_CR = self.adaptive_crossover(current_best_score, global_best_score)\n        return np.where(np.random.rand(self.dim) < adaptive_CR, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position, scores[i], global_best_score)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Utilized dynamic crossover probability adjusted based on current best performance to fine-tune convergence behavior.", "configspace": "", "generation": 49, "fitness": 0.6185441849374288, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.619 with standard deviation 0.035. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.6368471660272522, 0.5698327197138793, 0.6489526690711549], "final_y": [7.876670847501928e-10, 4.172547512553129e-10, 1.4049404734733383e-10]}, "mutation_prompt": null}
{"id": "e21a88af-6a82-435d-8f18-92d2dcc29133", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def adaptive_scaling(self, scores):\n        return 0.5 + 0.3 * (np.std(scores) / np.mean(scores))  # Added line for adaptive scaling\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Introduced adaptive scaling factor based on fitness diversity to improve exploration-exploitation balance.", "configspace": "", "generation": 50, "fitness": 0.5947595081943774, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.595 with standard deviation 0.026. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.6272276988972719, 0.5633003120122999, 0.5937505136735604], "final_y": [1.1293520030972613e-10, 1.9872695465238885e-10, 1.6309238549489001e-10]}, "mutation_prompt": null}
{"id": "d1d93c11-921c-4baa-ae25-99af33bcdc41", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def local_search(self, position, func, bounds):\n        result = minimize(func, position, method='Nelder-Mead', bounds=bounds)\n        return result.x\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Local search to refine trial solutions\n                trial = self.local_search(trial, func, func.bounds)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Added local search with Nelder-Mead after mutation and crossover to refine solutions.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('zip() argument after * must be an iterable, not ioh.iohcpp.RealBounds').", "error": "TypeError('zip() argument after * must be an iterable, not ioh.iohcpp.RealBounds')", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "5e9d1e50-3e45-49be-bdf0-2c34eacecb8d", "solution": "# Description: Enhanced search efficiency by dynamically adjusting crossover probability based on convergence progress.\n# Code: \nimport numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.CR, best, individual)  # Changed from self.q_prob to self.CR\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced search efficiency by dynamically adjusting crossover probability based on convergence progress.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([None, None], dtype=object)').", "error": "TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([None, None], dtype=object)')", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "0708af9a-daf2-4674-ab90-cf1f08bc9b7a", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n                # Adjust quantum probability dynamically\n                self.q_prob = 0.1 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced exploration and exploitation balance by adjusting the quantum probability dynamically based on the performance progress.", "configspace": "", "generation": 53, "fitness": 0.5125329828989844, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.513 with standard deviation 0.240. And the mean value of best solutions found was 0.243 (0. is the best) with standard deviation 0.343.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.7311530665328397, 0.178220374215176, 0.6282255079489375], "final_y": [1.9550059825267708e-13, 0.7282854351331205, 1.8813924241914576e-09]}, "mutation_prompt": null}
{"id": "4c660230-ae23-4ca5-8e34-ed0e731c1e06", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5\n        self.CR = 0.9\n        self.q_prob = 0.05  # Probability to use quantum-inspired move (adjusted from 0.1 to 0.05)\n        self.scaling_layer = 2  # New scaling layer factor\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5) * self.scaling_layer\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return np.random.uniform(0.4, 0.9)  # Broadened mutation range for better diversity\n\n    def quantum_crossover(self, individual, best):\n        q_prob_adaptive = np.clip(self.q_prob + np.random.uniform(-0.02, 0.02), 0.05, 0.1)  # Adaptive quantum probability\n        return np.where(np.random.rand(self.dim) < q_prob_adaptive, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolutionV2", "description": "Introduced a multi-layer scaling factor and adaptive quantum probability to enhance exploration and exploitation balance.", "configspace": "", "generation": 54, "fitness": 0.5485789736656784, "feedback": "The algorithm QuantumInspiredDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.549 with standard deviation 0.023. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.5203678762188146, 0.5493920567870537, 0.5759769879911667], "final_y": [1.5891976699716405e-08, 3.805875954778704e-09, 2.890799603944901e-09]}, "mutation_prompt": null}
{"id": "07fa4424-e449-40a6-adf1-cbc5fbb3af82", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Dynamic quantum-inspired move with a small probability\n                self.q_prob = 0.05 + 0.05 * (1 - evaluations / self.budget)  # Dynamically adjust probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced quantum-inspired strategy with dynamic probability adjustment to improve search efficiency and balance exploration-exploitation.", "configspace": "", "generation": 55, "fitness": 0.6350272187476733, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.635 with standard deviation 0.027. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.6071118663558716, 0.6261215466889192, 0.6718482431982293], "final_y": [7.445562639036564e-10, 1.276650475241006e-10, 5.5648502200226484e-11]}, "mutation_prompt": null}
{"id": "ff7f7bb5-5070-4207-bc12-4960f09d7f54", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = np.random.rand()  # Stochastic scaling factor for mutation\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced mutation strategy with stochastic scaling factor to augment exploration capabilities.", "configspace": "", "generation": 56, "fitness": 0.4726986817921232, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.473 with standard deviation 0.246. And the mean value of best solutions found was 0.808 (0. is the best) with standard deviation 1.143.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.6486332236127923, 0.12529348650601635, 0.644169335257561], "final_y": [8.626574986221599e-11, 2.423849795533537, 1.0531293861388722e-08]}, "mutation_prompt": null}
{"id": "47e036f2-15ea-46eb-91ab-2bdb56286f2c", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.8, 2.0)  # Changed factor range for enhanced exploration\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced the quantum-inspired move to improve exploration capabilities.", "configspace": "", "generation": 57, "fitness": 0.42001248461349167, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.420 with standard deviation 0.201. And the mean value of best solutions found was 0.431 (0. is the best) with standard deviation 0.609.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.1441091367461328, 0.4965403479614705, 0.6193879691328716], "final_y": [1.2917845297916242, 1.044964979929304e-07, 8.781978773195256e-11]}, "mutation_prompt": null}
{"id": "5dc993a5-ccbf-4ea7-9790-838af7e49e7e", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 2.0)  # Changed upper bound from 1.5 to 2.0\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.4 + np.random.rand() * 0.4  # Changed base mutation factor from 0.5 to 0.4\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced the adaptive mutation and quantum move strategies with a self-adaptive learning mechanism to improve convergence.", "configspace": "", "generation": 58, "fitness": 0.6005518445683801, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.601 with standard deviation 0.075. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.5565731803726293, 0.7063782666090141, 0.5387040867234967], "final_y": [7.764089791813074e-09, 4.353143432471856e-12, 5.8395061972401246e-08]}, "mutation_prompt": null}
{"id": "74218682-1b85-411e-8820-e22888d7f7af", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.2  # Probability to use quantum-inspired move (increased from 0.1 to 0.2)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced quantum probability for more effective exploration and exploitation balance.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([1.9435840927412544, None], dtype=object)').", "error": "TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([1.9435840927412544, None], dtype=object)')", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "8a2ce1bf-0625-47ee-b63e-49e1ce19599d", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.15  # Probability to use quantum-inspired move (increased from 0.1 to 0.15)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.6 + np.random.rand() * 0.2  # Adaptive mutation factor (adjusted range)\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.CR, best, individual)  # Adjusted to use CR\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Improved exploration and exploitation by tuning quantum probabilities and mutation factors.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([None, None], dtype=object)').", "error": "TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([None, None], dtype=object)')", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "75043c42-ad70-4517-8f2d-b3de8654d243", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n        self.local_search_prob = 0.2  # Probability for local search move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def local_search_move(self, individual, lb, ub):\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        new_position = individual + perturbation\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        population = np.random.uniform(lb, ub, (population_size, self.dim))\n        scores = np.full(population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                if evaluations >= self.budget:\n                    break\n\n                candidates = list(range(population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                if np.random.rand() < self.local_search_prob:\n                    population[i] = self.local_search_move(population[i], lb, ub)\n\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n            population_size = max(4, int(self.initial_population_size * (1 - evaluations / self.budget)))\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Introduced adaptive population size and hybrid search strategy combining quantum moves with local search for improved exploration and exploitation balance.", "configspace": "", "generation": 61, "fitness": 0.28900982107123224, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.289 with standard deviation 0.009. And the mean value of best solutions found was 0.038 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.2950074120971804, 0.29601261928534184, 0.27600943183117443], "final_y": [0.03376942467634252, 0.029766333420697497, 0.0514030955519261]}, "mutation_prompt": null}
{"id": "3a61e5e1-a6b5-480f-8964-894639e0f33d", "solution": "import numpy as np\nimport scipy.stats as stats\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def levy_flight_mutation(self):\n        beta = 1.5\n        sigma = (stats.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (stats.gamma((1 + beta) / 2) * beta *\n                  2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / abs(v) ** (1 / beta)\n        return step  # Lévy flight step\n\n    def dynamic_quantum_crossover(self, individual, best, iter_ratio):\n        dynamic_prob = self.q_prob + iter_ratio * (1.0 - self.q_prob)\n        return np.where(np.random.rand(self.dim) < dynamic_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        max_evaluations = self.budget\n\n        while evaluations < self.budget:\n            iter_ratio = evaluations / max_evaluations  # Calculate iteration ratio\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Lévy flight mutation\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c]) + self.levy_flight_mutation()\n                mutant = np.clip(mutant, lb, ub)\n\n                # Dynamic quantum-inspired crossover\n                trial = self.dynamic_quantum_crossover(mutant, global_best_position, iter_ratio)\n                \n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced exploration by introducing Lévy flight-inspired mutation and dynamic quantum crossover probability for improved convergence.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'QuantumInspiredDifferentialEvolution' object has no attribute 'adaptive_mutation'\").", "error": "AttributeError(\"'QuantumInspiredDifferentialEvolution' object has no attribute 'adaptive_mutation'\")", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "2a53a744-e252-4911-ad2c-817ffd24fdf8", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.5  # Crossover probability (reduced from 0.9 to 0.5)\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best + np.random.uniform(0.1, 0.3) * (best - individual), individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced convergence by adjusting crossover probability dynamically and refining quantum-inspired moves.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "b03ad984-32f3-41f8-8c1b-351e39df64db", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n        self.elite_fraction = 0.2  # New: Fraction of elite individuals\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            # New: Adaptive population resizing strategy\n            if evaluations % (self.budget // 10) == 0:\n                elite_size = int(self.elite_fraction * self.population_size)\n                elite_indices = np.argsort(scores)[:elite_size]\n                population = population[elite_indices]\n                scores = scores[elite_indices]\n                self.population_size = len(population)\n            \n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Introduced adaptive population size and elite-based selection to enhance convergence and exploration.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "b89b2505-e4bf-4d31-a8f2-af2527027b0a", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.3, 1.7)  # Change made here\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced exploration by modifying the quantum move scaling factor range to improve convergence.", "configspace": "", "generation": 65, "fitness": 0.2928087434714907, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.293 with standard deviation 0.230. And the mean value of best solutions found was 1.481 (0. is the best) with standard deviation 1.386.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.6166494089071715, 0.10493645872739954, 0.1568403627799012], "final_y": [1.3656588074718868e-08, 3.3342517528780165, 1.1081865039016636]}, "mutation_prompt": null}
{"id": "ecba5c5f-c7e6-44f4-aa2b-d07f391fa239", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Initial probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def chaotic_map(self, x):\n        # Chaotic Logistic Map for parameter control\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with adapted probability\n                if np.random.rand() < self.chaotic_map(chaotic_factor):\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n                    chaotic_factor = self.chaotic_map(chaotic_factor)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced exploration by introducing chaotic maps for parameter tweaking and adaptive quantum probability.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\")", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "63e30a68-8994-4d83-a02f-568147d5da64", "solution": "import numpy as np\n\nclass EnhancedQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def levy_flight(self, individual, lb, ub):\n        step = np.random.normal(0, 0.1, self.dim) * (individual - lb)\n        new_position = individual + step\n        return np.clip(new_position, lb, ub)\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def rank_based_selection(self, scores, population, num_select):\n        ranked_indices = np.argsort(scores)\n        selected_indices = ranked_indices[:num_select]\n        return population[selected_indices]\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            num_select = max(1, int(self.population_size * 0.3))\n            selected_population = self.rank_based_selection(scores, population, num_select)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                a, b, c = np.random.choice(selected_population.shape[0], 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = selected_population[a] + self.F * (selected_population[b] - selected_population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Lévy flight exploration\n                if np.random.rand() < 0.2:\n                    trial = self.levy_flight(trial, lb, ub)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "EnhancedQuantumDifferentialEvolution", "description": "Enhanced selection strategy by introducing rank-based selection and integrating Lévy-flight-inspired exploration for improved search efficiency.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "e6bd65d2-c90e-45a0-ab6f-8ca673115d3e", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Dynamic population resizing\n                if evaluations % 10 == 0 and self.population_size > 5:\n                    self.population_size -= 1\n                    population = population[:self.population_size]\n                    scores = scores[:self.population_size]\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Local search around the global best\n                local_search_radius = 0.1 * (ub - lb)\n                local_candidate = global_best_position + np.random.uniform(-local_search_radius, local_search_radius, self.dim)\n                local_candidate = np.clip(local_candidate, lb, ub)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < global_best_score:\n                    global_best_score = local_score\n                    global_best_position = local_candidate\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced exploration and exploitation using dynamic population resizing and local search around the global best.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\")", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "6bbbbd62-0787-4a0f-acbd-5ee78c6e5742", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n\n    def levy_flight(self, individual, lb, ub):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v) ** (1 / beta)\n        new_position = individual + 0.01 * step * (individual - lb)\n        return np.clip(new_position, lb, ub)\n\n    def dynamic_crossover(self, iteration):\n        return self.CR * (1 - 0.5 * (iteration / self.budget))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        iteration = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with Lévy flight\n                self.F = self.adaptive_mutation()\n                mutant = self.levy_flight(population[i], lb, ub)\n\n                # Dynamic crossover\n                CR_dynamic = self.dynamic_crossover(evaluations)\n                trial = np.where(np.random.rand(self.dim) < CR_dynamic, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n            iteration += 1\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced exploration by introducing Lévy flights for mutation and dynamic crossover rate based on iteration count.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'QuantumInspiredDifferentialEvolution' object has no attribute 'adaptive_mutation'\").", "error": "AttributeError(\"'QuantumInspiredDifferentialEvolution' object has no attribute 'adaptive_mutation'\")", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "b73300d6-c0d6-4c96-88fe-73f86f616ef3", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5\n        self.CR = 0.9\n        self.q_prob = 0.1\n        self.dynamic_population = True\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def quantum_move(self, individual, best, lb, ub):\n        step = self.levy_flight(self.dim) if np.random.rand() < 0.5 else np.random.uniform(0.5, 1.5)\n        new_position = best + step * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            if self.dynamic_population:\n                self.population_size = 10 + int(2 * np.sqrt(self.dim)) - int(evaluations / self.budget * 5)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced solution exploration by introducing Lévy flight strategy and dynamic population resizing to improve diversity and convergence in Quantum-Inspired Differential Evolution.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "077e85c0-5a71-4c06-a596-b91db87e4660", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 + int(2 * np.sqrt(dim))  # Increased initial population size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.4  # Increased adaptive mutation range\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def stochastic_tunneling(self, score, global_best_score):\n        return np.exp(-np.abs(score - global_best_score) / (1 + np.abs(global_best_score)))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection with stochastic tunneling\n                trial_score = func(trial)\n                evaluations += 1\n                if self.stochastic_tunneling(trial_score, global_best_score) > np.random.rand():\n                    if trial_score < scores[i]:\n                        population[i] = trial\n                        scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced exploration using a stochastic tunneling mechanism and dynamic population size adjustment to adaptively balance exploration and exploitation.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([None, 117.65483032369343], dtype=object)').", "error": "TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([None, 117.65483032369343], dtype=object)')", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "f1c82422-2dd3-4583-bd9a-a2116d2d7a0b", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(3 * np.sqrt(dim))  # Increased population size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.15  # Increased probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced exploration by increasing population diversity and incorporating a probability-based quantum move.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\")", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "ff23c2c9-be23-4f11-b8ca-9ad65f26431f", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.15  # Probability to use quantum-inspired move (increased from 0.1 to 0.15)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced exploration by slightly increasing the quantum probability to balance between exploration and exploitation.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([1.9435840927412544, None], dtype=object)').", "error": "TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([1.9435840927412544, None], dtype=object)')", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "77447a44-b9c5-479d-9270-810d4e013660", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def adaptive_crossover(self, current_score, best_score):\n        # Adapt CR based on the progress towards the best score\n        return self.CR * (1 - current_score / (best_score + 1e-9))\n\n    def quantum_crossover(self, individual, best, current_score, best_score):\n        # Use adaptive crossover probability\n        adaptive_CR = self.adaptive_crossover(current_score, best_score)\n        return np.where(np.random.rand(self.dim) < adaptive_CR, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover with adaptive probability\n                trial = self.quantum_crossover(mutant, global_best_position, scores[i], global_best_score)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Incorporated adaptive crossover probability to balance exploration and exploitation for enhanced convergence.", "configspace": "", "generation": 74, "fitness": 0.6394888015980886, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.639 with standard deviation 0.038. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.6024383849349414, 0.6243928045613583, 0.6916352152979661], "final_y": [2.3668827164629604e-10, 9.633635327505897e-11, 6.876783622527738e-11]}, "mutation_prompt": null}
{"id": "bb658da5-2b97-40fb-9153-7452c67ef65d", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Tournament selection instead of direct comparison\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[np.random.randint(0, self.population_size)]:  # Modified line\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced selection strategy with tournament selection to improve diversity and convergence.", "configspace": "", "generation": 75, "fitness": 0.35106447091083015, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.351 with standard deviation 0.021. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.3667929149313791, 0.36455150824645266, 0.3218489895546587], "final_y": [9.955582234134797e-06, 1.9679034712814944e-05, 0.000569337703180095]}, "mutation_prompt": null}
{"id": "1fdfbdc0-a33e-4572-b2ea-a49717c7b069", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.15  # Probability to use quantum-inspired move (increased from 0.1 to 0.15)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced global exploration by increasing the quantum-inspired move probability to 0.15.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([1.9435840927412544, None], dtype=object)').", "error": "TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([1.9435840927412544, None], dtype=object)')", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "0a328f93-45a8-49ec-aa0d-4e19aca56c01", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.15  # Increased probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.3, 1.7)  # Expanded factor range\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.4 + np.random.rand() * 0.4  # Adjusted adaptive mutation factor range\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced adaptive mutation strategy and quantum-inspired move to improve convergence speed and solution quality.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([1.9796081251459743, None], dtype=object)').", "error": "TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([1.9796081251459743, None], dtype=object)')", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "11f99940-65e7-4a09-a0df-dd61a4713310", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.15  # Probability to use quantum-inspired move (changed from 0.1 to 0.15)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced convergence by modifying the probability of quantum-inspired moves to better balance exploration and exploitation.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([1.9435840927412544, None], dtype=object)').", "error": "TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([1.9435840927412544, None], dtype=object)')", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "fb9f2fac-7aef-40b7-a9d1-bc37c7fb05d3", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.init_population_size = 10 + int(2 * np.sqrt(dim))\n        self.population_size = self.init_population_size\n        self.F_min, self.F_max = 0.4, 0.9  # Dynamic differential weight boundaries\n        self.CR_min, self.CR_max = 0.5, 0.9  # Adaptive crossover probability range\n        self.q_prob = 0.1\n\n    def levy_flight(self, lam=1.5):\n        u = np.random.normal(0, 1, self.dim) * (np.random.gamma(1 + lam) * np.sin(np.pi * lam / 2) /\n            (np.cos(np.pi * lam / 2) * lam * np.exp(np.log(np.pi / 2))))\n        v = np.random.normal(0, 1, self.dim)\n        z = u / (np.abs(v) ** (1 / lam))\n        return z\n\n    def adaptive_mutation(self, score, best_score):\n        return self.F_min + (self.F_max - self.F_min) * (best_score - score) / best_score\n\n    def adaptive_crossover(self, score, best_score):\n        return self.CR_min + (self.CR_max - self.CR_min) * (best_score - score) / best_score\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation(scores[i], global_best_score)\n                mutant = population[a] + self.F * (population[b] - population[c]) + 0.1 * self.levy_flight()\n                mutant = np.clip(mutant, lb, ub)\n\n                self.CR = self.adaptive_crossover(scores[i], global_best_score)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n            if evaluations % (self.budget // 10) == 0:\n                self.population_size = max(5, int(self.init_population_size * (1 - evaluations / self.budget)))\n                population = population[:self.population_size]\n                scores = scores[:self.population_size]\n                \n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced convergence by introducing Lévy flight mutation, fitness-based adaptive crossover, and dynamic population resizing.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'QuantumInspiredDifferentialEvolution' object has no attribute 'quantum_move'\").", "error": "AttributeError(\"'QuantumInspiredDifferentialEvolution' object has no attribute 'quantum_move'\")", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "b85bb993-e074-4c95-8509-27a3d8ada75a", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with increased probability for elites\n                elite_q_prob = self.q_prob * 1.5 if scores[i] < global_best_score * 1.1 else self.q_prob\n                if np.random.rand() < elite_q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Introduced elite preservation by increasing the quantum-inspired move probability for top-performing individuals, enhancing convergence speed.", "configspace": "", "generation": 80, "fitness": 0.6833848996324013, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.683 with standard deviation 0.067. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.7381306244283017, 0.7232641205708248, 0.5887599538980776], "final_y": [4.34205213865776e-14, 1.5288744502789687e-10, 2.1811275015927654e-06]}, "mutation_prompt": null}
{"id": "d5a62957-f2d2-4f54-bc41-3f32b781def3", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def chaotic_crossover(self, individual, best):  # Line modified\n        chaotic_factor = np.sin(np.linspace(0, np.pi, self.dim))  # Line modified\n        return np.where(chaotic_factor < self.q_prob, best, individual)  # Line modified\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                chaotic_factor = np.sin(np.linspace(0, np.pi, self.dim))  # Line modified\n                mutant = population[a] + self.F * (population[b] - population[c] * chaotic_factor)  # Line modified\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.chaotic_crossover(mutant, global_best_position)  # Line modified\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhances exploration by incorporating chaotic maps in mutation and crossover operations.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([None, None], dtype=object)').", "error": "TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([None, None], dtype=object)')", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "92a4e1cc-5218-4c0d-bee0-58f78f2ffd17", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, 0.5 * (best + individual), individual)  # Enhanced crossover\n\n    def dynamic_population_size(self, evaluations):\n        self.population_size = max(int(5 + (self.budget - evaluations) / self.budget * 5), 5)  # Dynamic resizing\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            self.dynamic_population_size(evaluations)  # Adjust population size dynamically\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Introduced dynamic population resizing and enhanced quantum-inspired crossover for better exploration and exploitation balance.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\")", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "19be445b-995d-4172-ae52-ea8a5d72b616", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.15  # Probability to use quantum-inspired move (increased from 0.1 to 0.15)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced convergence by increasing the quantum-inspired probability for crossover operations.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([1.9435840927412544, None], dtype=object)').", "error": "TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([1.9435840927412544, None], dtype=object)')", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "c23a9380-0bcc-43e6-808c-42655a419e98", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 + int(2 * np.sqrt(dim))\n        self.population_size = self.initial_population_size\n        self.F = 0.5  \n        self.CR = 0.9  \n        self.q_prob = 0.15  # Increased quantum probability\n        self.resizing_rate = 0.1  # Introduced dynamic resizing\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def resize_population(self):\n        self.population_size = int(self.population_size * (1 + np.random.uniform(-self.resizing_rate, self.resizing_rate)))\n        self.population_size = max(3, self.population_size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            self.resize_population()  # Resize population dynamically\n            for i in range(len(population)):\n                if evaluations >= self.budget:\n                    break\n\n                candidates = list(range(len(population)))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced algorithm with dynamic population resizing and hybrid exploration strategies to improve convergence and solution quality.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([None, 129.85790482826866], dtype=object)').", "error": "TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([None, 129.85790482826866], dtype=object)')", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "9a5b859b-fa5a-4e52-aa14-991aab2f2adb", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.5  # Adaptive mutation factor with increased randomness\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced adaptive mutation strategy by introducing randomness to improve exploration and prevent premature convergence.", "configspace": "", "generation": 85, "fitness": 0.3887004260650877, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.389 with standard deviation 0.241. And the mean value of best solutions found was 3.246 (0. is the best) with standard deviation 4.590.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.06472478947078764, 0.4604052385060363, 0.640971250218439], "final_y": [9.7369446435621, 3.379035158064984e-05, 4.0068289835607403e-11]}, "mutation_prompt": null}
{"id": "15e89939-8cea-460a-b590-a546d6f50712", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.05  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.3, 1.7)  # Modified range for factor\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n                # Dynamic adjustment of q_prob\n                self.q_prob = 0.05 + 0.5 * (1 - evaluations / self.budget)  # Line adjusted to dynamically change q_prob\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced exploitation with dynamic quantum probability and refined quantum moves for better convergence.", "configspace": "", "generation": 86, "fitness": 0.104094553389586, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.104 with standard deviation 0.028. And the mean value of best solutions found was 4.821 (0. is the best) with standard deviation 2.505.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.07426181786825281, 0.09628057875999485, 0.1417412635405103], "final_y": [7.881321190246303, 4.837529944333594, 1.7446194310305032]}, "mutation_prompt": null}
{"id": "9765c725-ae46-4918-97a0-51cbb14ebc0d", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3\n\n    def levy_flight(self, position, lb, ub):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1/beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / (abs(v) ** (1/beta))\n        new_position = position + step\n        return np.clip(new_position, lb, ub)\n\n    def quantum_crossover(self, individual, best):\n        if np.random.rand() < self.q_prob:\n            return np.where(np.random.rand(self.dim) < self.CR, best, individual)\n        return individual\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Lévy flight for enhanced exploration\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.levy_flight(population[i], lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced exploration via Lévy flights and adjusted quantum crossover for improved convergence.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "1e4a1cbf-a674-46d2-8ce4-ead30ea54aeb", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            # Dynamically adjust population size\n            self.population_size = 10 + int(2 * np.log(self.dim + evaluations))\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Introduced dynamic population size adjustment to enhance exploration and exploitation balance.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 14 is out of bounds for axis 0 with size 12').", "error": "IndexError('index 14 is out of bounds for axis 0 with size 12')", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "8c86380a-3beb-4083-a292-c15d15b12a26", "solution": "import numpy as np\n\nclass ChaosEnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3\n\n    def chaotic_initialization(self, lb, ub):\n        population = np.zeros((self.population_size, self.dim))\n        x = np.random.rand()\n        for i in range(self.population_size):\n            x = 4 * x * (1 - x)  # Logistic map for chaos\n            population[i] = lb + (ub - lb) * x\n        return population\n\n    def dynamic_crossover(self, individual, best, iteration, max_iterations):\n        cr = self.CR * (1 - iteration / max_iterations)\n        return np.where(np.random.rand(self.dim) < cr, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.chaotic_initialization(lb, ub)\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                trial = self.dynamic_crossover(mutant, global_best_position, evaluations, self.budget)\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "ChaosEnhancedDifferentialEvolution", "description": "Enhanced with chaos theory-based initialization and dynamic adaptation of crossover and mutation probabilities for improved exploration-exploitation balance.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([None, None], dtype=object)').", "error": "TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([None, None], dtype=object)')", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "30aa6117-5645-4976-9ac9-b2ac0bb9ee51", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.6 + np.random.rand() * 0.4  # Enhanced adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def local_search(self, position, func, lb, ub):\n        perturbation = np.random.normal(0, 0.01, self.dim)\n        candidate = np.clip(position + perturbation, lb, ub)\n        if func(candidate) < func(position):\n            return candidate\n        return position\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Local search\n                population[i] = self.local_search(population[i], func, lb, ub)\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced adaptive mutation and quantum-inspired crossover with local search for better convergence.", "configspace": "", "generation": 90, "fitness": 0.26505103019650894, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.265 with standard deviation 0.026. And the mean value of best solutions found was 0.003 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.23023389484795787, 0.2911270917158608, 0.2737921040257082], "final_y": [0.0030547276278527886, 0.001209665184784041, 0.0034831065305223553]}, "mutation_prompt": null}
{"id": "20cc29c2-02a0-44db-85d3-6858acb803d7", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n        self.local_search_prob = 0.2  # Probability to perform local search\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def local_search(self, individual, lb, ub):\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        new_position = individual + perturbation\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        dynamic_population_factor = 1.1\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Local search with a probability\n                if np.random.rand() < self.local_search_prob:\n                    trial = self.local_search(trial, lb, ub)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n            # Dynamic population resizing\n            if evaluations % 100 == 0 and self.population_size < self.budget / 10:\n                self.population_size = int(self.population_size * dynamic_population_factor)\n                population = np.resize(population, (self.population_size, self.dim))\n                scores = np.resize(scores, self.population_size)\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Integrated local search and dynamic population resizing to enhance exploration-exploitation balance.", "configspace": "", "generation": 91, "fitness": 0.5191495612589021, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.519 with standard deviation 0.029. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.5055144961299096, 0.5593594289603909, 0.49257475868640566], "final_y": [2.4412180109531917e-07, 8.073453151558384e-08, 1.3373875731072996e-07]}, "mutation_prompt": null}
{"id": "7319e132-1cd5-4572-8baf-58bc9f42d4b6", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def stochastic_blend_crossover(self, parent1, parent2, lb, ub):\n        alpha = np.random.uniform(0, 1)\n        offspring = alpha * parent1 + (1 - alpha) * parent2\n        return np.clip(offspring, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Stochastic blend crossover\n                parent2 = population[np.random.choice(candidates)]\n                trial = self.stochastic_blend_crossover(mutant, parent2, lb, ub)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced population diversity and exploitation through stochastic blend crossover and dynamic self-adaptive parameter tuning.", "configspace": "", "generation": 92, "fitness": 0.11033365601737873, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.110 with standard deviation 0.047. And the mean value of best solutions found was 5.072 (0. is the best) with standard deviation 3.087.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.17613771912224085, 0.07376344716756011, 0.08109980176233522], "final_y": [0.7860420188749948, 7.9339938343312255, 6.497073598476645]}, "mutation_prompt": null}
{"id": "62215ecd-2f21-4a9b-a9e6-f2006da28a0a", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                self.q_prob = 0.1 + 0.4 * (1 - evaluations / self.budget)  # Adaptive quantum probability\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Introduced adaptive quantum probability to dynamically balance exploration and exploitation during search.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([None, None], dtype=object)').", "error": "TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([None, None], dtype=object)')", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "c4ef0302-f287-42ec-b715-cacf95234638", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.3, 1.7)  # Adjusted factor range for better exploration\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced quantum-inspired move by dynamically adjusting the factor to improve exploration.", "configspace": "", "generation": 94, "fitness": 0.4721109552732772, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.472 with standard deviation 0.149. And the mean value of best solutions found was 0.004 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.3764081522330822, 0.35678458088041265, 0.6831401327063367], "final_y": [0.004462686560441921, 0.007243101503688636, 4.0488178459709544e-11]}, "mutation_prompt": null}
{"id": "cc553793-e747-40e7-a76a-5953dc9eb9e3", "solution": "import numpy as np\nfrom scipy.stats import levy\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.15  # Increased probability for quantum move\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * levy().rvs(size=self.dim) * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def chaotic_initialization(self, lb, ub):\n        return lb + (ub - lb) * np.abs(np.sin(np.pi * np.random.rand(self.population_size, self.dim)))\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.chaotic_initialization(lb, ub)\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced diversity with chaotic initialization and Lévy flight exploration to improve solution quality and convergence.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([1.1, None], dtype=object)').", "error": "TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1121. ellipsometry (iid=1 dim=2)>, array([1.1, None], dtype=object)')", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "fdcaeb99-94af-4531-958b-7808a5d8b20f", "solution": "import numpy as np\n\nclass DynamicNeighborhoodTopology:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.neighborhood_size = max(3, int(self.population_size / 3))\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.initial_velocity = 0.5\n\n    def self_adaptive_local_search(self, individual, lb, ub):\n        perturbation = np.random.normal(scale=0.1, size=self.dim)\n        new_position = individual + perturbation\n        return np.clip(new_position, lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-self.initial_velocity, self.initial_velocity, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate current position\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i].copy()\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i].copy()\n\n            # Dynamic Neighborhood Topology\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select neighbors randomly\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best_index = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n\n                # Calculate new velocity\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i] +\n                    self.cognitive_constant * r1 * (personal_best_positions[i] - population[i]) +\n                    self.social_constant * r2 * (personal_best_positions[local_best_index] - population[i])\n                )\n\n                # Update position\n                population[i] = np.clip(population[i] + velocities[i], lb, ub)\n\n                # Self-adaptive local search\n                if np.random.rand() < 0.05:  # Small probability\n                    candidate = self.self_adaptive_local_search(population[i], lb, ub)\n                    candidate_score = func(candidate)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate.copy()\n\n        return global_best_position, global_best_score", "name": "DynamicNeighborhoodTopology", "description": "Leverage dynamic neighborhood topology and self-adaptive local search to enhance exploration-exploitation balance in black-box optimization.", "configspace": "", "generation": 96, "fitness": 0.3668225933225962, "feedback": "The algorithm DynamicNeighborhoodTopology got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.367 with standard deviation 0.029. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.3256869490499932, 0.38224907108521333, 0.39253175983258226], "final_y": [0.0011600290059457093, 0.00021490937848137116, 2.251893254868378e-05]}, "mutation_prompt": null}
{"id": "cc3880d5-c249-4168-bf9f-d53f0d0684dd", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Diverse initialization strategy\n        population = lb + (ub - lb) * np.random.beta(0.5, 0.5, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Introduce self-adaptive crossover probability\n                self.CR = 0.7 + 0.3 * (global_best_score / (np.abs(global_best_score) + 1e-10))\n\n                # Quantum-inspired crossover\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Introduced self-adaptive crossover probability and diverse initialization strategy to enhance diversity and convergence.", "configspace": "", "generation": 97, "fitness": 0.5592710319630484, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.559 with standard deviation 0.105. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {"aucs": [0.6690824830562979, 0.4184855435585524, 0.5902450692742948], "final_y": [4.211314413104431e-11, 0.00021434475948851035, 3.287654157892513e-10]}, "mutation_prompt": null}
{"id": "3187ba1b-8dfd-4e72-94dd-cc588148654b", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Adaptive quantum probability\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best)\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def adaptive_quantum_prob(self, evaluations, budget):\n        return 0.1 + 0.2 * (evaluations / budget)  # Increase with evaluations\n\n    def multi_parent_crossover(self, parents):\n        weights = np.random.dirichlet(np.ones(len(parents)))\n        return np.sum(weights[:, None] * np.array(parents), axis=0)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Multi-parent crossover\n                parents = [population[a], population[b], global_best_position]\n                trial = self.multi_parent_crossover(parents)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with adaptive probability\n                self.q_prob = self.adaptive_quantum_prob(evaluations, self.budget)\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced diversification and convergence through multi-parent crossover and adaptive quantum probability.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('setting an array element with a sequence. The requested array has an inhomogeneous shape after 1 dimensions. The detected shape was (3,) + inhomogeneous part.').", "error": "ValueError('setting an array element with a sequence. The requested array has an inhomogeneous shape after 1 dimensions. The detected shape was (3,) + inhomogeneous part.')", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
{"id": "7d6f8caf-58dd-4010-9f2a-0672cc483729", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.q_prob = 0.1  # Probability to use quantum-inspired move (increased from 0.05 to 0.1)\n\n    def levy_flight(self, scale=0.01):\n        # Implementing Levy flight for perturbation\n        return scale * np.random.normal(size=self.dim) / (np.abs(np.random.normal(size=self.dim)) ** (1/3))\n\n    def chaos_init(self, lb, ub):\n        # Chaos-based initialization\n        return lb + (ub - lb) * np.abs(np.sin(np.arange(self.population_size) * np.pi / self.population_size))\n\n    def quantum_move(self, individual, best, lb, ub):\n        factor = np.random.uniform(0.5, 1.5)\n        new_position = best + factor * (individual - best) + self.levy_flight()  # Added Levy flight\n        return np.clip(new_position, lb, ub)\n\n    def adaptive_mutation(self):\n        return 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n\n    def quantum_crossover(self, individual, best):\n        return np.where(np.random.rand(self.dim) < self.q_prob, best, individual)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = self.chaos_init(lb, ub)  # Changed initialization\n        scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation with adaptive rate\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                self.F = self.adaptive_mutation()\n                mutant = population[a] + self.F * (population[b] - population[c])\n                mutant = np.clip(mutant, lb, ub)\n\n                # Quantum-inspired crossover\n                trial = self.quantum_crossover(mutant, global_best_position)\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n                # Quantum-inspired move with a small probability\n                if np.random.rand() < self.q_prob:\n                    population[i] = self.quantum_move(population[i], global_best_position, lb, ub)\n\n                # Update global best\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = population[i].copy()\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredDifferentialEvolution", "description": "Enhanced exploration by implementing chaos-based initialization and integrating Levy flights for mutation.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (2,) (12,) ').", "error": "ValueError('operands could not be broadcast together with shapes (2,) (12,) ')", "parent_id": "f2d95b2a-b45f-4e0c-9904-91d0e49eb2d9", "metadata": {}, "mutation_prompt": null}
