{"id": "5f09828c-3d6e-413e-9706-69cbc37b4874", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particle positions and velocities\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n\n                # Update positions\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                # Evaluate new position\n                score = func(positions[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                # Apply simulated annealing acceptance criterion\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n            # Update global best\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "PSOSA", "description": "A hybrid metaheuristic algorithm combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) to balance exploration and exploitation for efficient black-box optimization.", "configspace": "", "generation": 0, "fitness": 0.23969978668723538, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.240 with standard deviation 0.001. And the mean value of best solutions found was 0.172 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": null, "metadata": {"aucs": [0.23850730365102313, 0.23966972296983924, 0.2409223334408438], "final_y": [0.17626196840398767, 0.16814190015653363, 0.17074175721860552]}, "mutation_prompt": null}
{"id": "b3dcc16a-8c8c-4cb5-a94d-9e40f7a5d2de", "solution": "import numpy as np\n\nclass QIGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.mutation_rate = 0.1\n        self.alpha = 0.5\n        self.quantum_amp = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize quantum individuals\n        quantum_population = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        real_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n        personal_best_positions = np.copy(real_population)\n        personal_best_scores = np.array([func(x) for x in real_population])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Quantum rotation gate\n                quantum_population[i] = self.alpha * quantum_population[i] + \\\n                                        (1 - self.alpha) * np.random.uniform(-1, 1, self.dim)\n\n                # Convert quantum individuals to real numbers\n                real_population[i] = lb + (ub - lb) * (0.5 + 0.5 * np.sin(np.pi * quantum_population[i] + self.quantum_amp))\n\n                # Evaluate new real position\n                score = func(real_population[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = real_population[i]\n                    personal_best_scores[i] = score\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_position = real_population[i]\n                    global_best_score = score\n\n            # Mutation step\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_vector = np.random.uniform(-1, 1, self.dim)\n                    quantum_population[i] = quantum_population[i] + mutation_vector\n                    quantum_population[i] = np.clip(quantum_population[i], -1, 1)\n\n        return global_best_position", "name": "QIGA", "description": "Quantum-Inspired Genetic Algorithm (QIGA) combining principles of quantum computing with evolutionary strategies to enhance diversity and convergence in black-box optimization.", "configspace": "", "generation": 1, "fitness": 0.2174253248585859, "feedback": "The algorithm QIGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.217 with standard deviation 0.004. And the mean value of best solutions found was 0.319 (0. is the best) with standard deviation 0.027.", "error": "", "parent_id": "5f09828c-3d6e-413e-9706-69cbc37b4874", "metadata": {"aucs": [0.2228958017820417, 0.2164963920422589, 0.21288378075145709], "final_y": [0.28269380153557966, 0.32645650716116137, 0.3474968405478418]}, "mutation_prompt": null}
{"id": "d9c151d6-4f87-4887-a0d6-66782b1c0ae9", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Start with higher inertia weight\n        self.min_inertia_weight = 0.4  # Allow adaptive reduction\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95  # Adjusted cooling rate for better convergence\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particle positions and velocities\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n\n                # Update positions\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                # Evaluate new position\n                score = func(positions[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                # Apply simulated annealing acceptance criterion\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            # Adaptive inertia weight reduction\n            self.inertia_weight = max(self.min_inertia_weight, self.inertia_weight - (0.5 / (self.budget / self.population_size)))\n\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n            # Update global best\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "PSOSA", "description": "A refined hybrid metaheuristic algorithm enhancing PSO with adaptive inertia weight and improved SA cooling schedule to intensify exploration-exploitation balance for black-box optimization.", "configspace": "", "generation": 2, "fitness": 0.24068670402877312, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.241 with standard deviation 0.001. And the mean value of best solutions found was 0.172 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "5f09828c-3d6e-413e-9706-69cbc37b4874", "metadata": {"aucs": [0.24119438127368853, 0.23896479115234848, 0.24190093966028237], "final_y": [0.16487431168565825, 0.18213314959571325, 0.1699224817423466]}, "mutation_prompt": null}
{"id": "2de073f4-261e-4a29-8867-1550e09e848e", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Start with higher inertia weight\n        self.min_inertia_weight = 0.4  # Allow adaptive reduction\n        self.cognitive_coeff = 1.6  # Increased cognitive coefficient\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95  # Adjusted cooling rate for better convergence\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particle positions and velocities\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n\n                # Update positions\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                # Evaluate new position\n                score = func(positions[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                # Apply simulated annealing acceptance criterion\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            # Adaptive inertia weight reduction\n            self.inertia_weight = max(self.min_inertia_weight, self.inertia_weight - (0.5 / (self.budget / self.population_size)))\n\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n            # Update global best\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "PSOSA", "description": "Enhanced PSOSA by slightly increasing the cognitive coefficient to boost individual exploration and achieve better solutions.", "configspace": "", "generation": 3, "fitness": 0.2425558178607393, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.243 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d9c151d6-4f87-4887-a0d6-66782b1c0ae9", "metadata": {"aucs": [0.24074124015640497, 0.24523393684495043, 0.24169227658086245], "final_y": [0.16493127745735736, 0.16569669082601923, 0.16540124360401576]}, "mutation_prompt": null}
{"id": "324d445e-e257-49cf-97d2-a39e16197f8d", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.92  # Adjusted cooling rate for balanced cooling\n        self.alpha = 0.98  # New parameter for adaptive cooling\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                acceptance_prob = np.exp((global_best_score - score) / self.temperature)\n                if score < global_best_score or np.random.rand() < acceptance_prob:\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = max(self.min_inertia_weight, self.inertia_weight - (0.5 / (self.budget / self.population_size)))\n\n            self.temperature *= self.cooling_rate * self.alpha  # Adaptive cooling\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "PSOSA", "description": "A hybrid PSO-Simulated Annealing algorithm with adaptive cooling for enhanced exploitation and exploration balance.", "configspace": "", "generation": 4, "fitness": 0.2378492701198176, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.238 with standard deviation 0.008. And the mean value of best solutions found was 0.197 (0. is the best) with standard deviation 0.043.", "error": "", "parent_id": "2de073f4-261e-4a29-8867-1550e09e848e", "metadata": {"aucs": [0.2261820215309015, 0.24442184178434168, 0.24294394704420963], "final_y": [0.25781661006740464, 0.16512499070597708, 0.1675902600008995]}, "mutation_prompt": null}
{"id": "30b48808-efd9-4cce-af2a-bc86d47b248d", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.92  # Start with higher inertia weight\n        self.min_inertia_weight = 0.4  # Allow adaptive reduction\n        self.cognitive_coeff = 1.6  # Increased cognitive coefficient\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93  # Adjusted cooling rate for better convergence\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particle positions and velocities\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n\n                # Update positions\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                # Evaluate new position\n                score = func(positions[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                # Apply simulated annealing acceptance criterion\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            # Adaptive inertia weight reduction\n            self.inertia_weight = max(self.min_inertia_weight, self.inertia_weight - (0.5 / (self.budget / self.population_size)))\n\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n            # Update global best\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "PSOSA", "description": "Improved PSOSA by slightly increasing the inertia weight and enhancing the cooling rate for better convergence.", "configspace": "", "generation": 5, "fitness": 0.23943263282211416, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.239 with standard deviation 0.006. And the mean value of best solutions found was 0.186 (0. is the best) with standard deviation 0.030.", "error": "", "parent_id": "2de073f4-261e-4a29-8867-1550e09e848e", "metadata": {"aucs": [0.23080075927855914, 0.24263188746661823, 0.24486525172116513], "final_y": [0.22804548114296508, 0.1650342803611764, 0.16487352389770404]}, "mutation_prompt": null}
{"id": "bdca4e6b-d379-4b82-b265-284d1b2c26f4", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 31  # Increased population size for more diversity\n        self.inertia_weight = 0.9  # Start with higher inertia weight\n        self.min_inertia_weight = 0.4  # Allow adaptive reduction\n        self.cognitive_coeff = 1.6  # Increased cognitive coefficient\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95  # Adjusted cooling rate for better convergence\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particle positions and velocities\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n\n                # Update positions\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                # Evaluate new position\n                score = func(positions[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                # Apply simulated annealing acceptance criterion\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            # Adaptive inertia weight reduction\n            self.inertia_weight = max(self.min_inertia_weight, self.inertia_weight - (0.5 / (self.budget / self.population_size)))\n\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n            # Update global best\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "PSOSA", "description": "Slightly increase the population size to enhance diversity and exploration capabilities.", "configspace": "", "generation": 6, "fitness": 0.23659704924961159, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.237 with standard deviation 0.001. And the mean value of best solutions found was 0.184 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "2de073f4-261e-4a29-8867-1550e09e848e", "metadata": {"aucs": [0.23490326538148354, 0.23777874512039976, 0.23710913724695148], "final_y": [0.18815704955947055, 0.182258025020696, 0.18197466484256053]}, "mutation_prompt": null}
{"id": "c3e63fb3-3a84-4f0f-ac27-65979b8cc9c3", "solution": "import numpy as np\n\nclass PSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Start with higher inertia weight\n        self.min_inertia_weight = 0.4  # Allow adaptive reduction\n        self.cognitive_coeff = 1.6  # Increased cognitive coefficient\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.97  # Adjusted cooling rate for faster convergence\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particle positions and velocities\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n\n                # Update positions\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                # Evaluate new position\n                score = func(positions[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                # Apply simulated annealing acceptance criterion\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            # Adaptive inertia weight reduction\n            self.inertia_weight = max(self.min_inertia_weight, self.inertia_weight - (0.5 / (self.budget / self.population_size)))\n\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n            # Update global best\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "PSOSA", "description": "Enhance PSOSA by increasing the cooling rate to improve convergence speed and solution quality.", "configspace": "", "generation": 7, "fitness": 0.2362743412059877, "feedback": "The algorithm PSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.236 with standard deviation 0.008. And the mean value of best solutions found was 0.198 (0. is the best) with standard deviation 0.042.", "error": "", "parent_id": "2de073f4-261e-4a29-8867-1550e09e848e", "metadata": {"aucs": [0.2244501778222624, 0.24353992709590355, 0.24083291869979717], "final_y": [0.2579009565585344, 0.16494367975525037, 0.17127050525469867]}, "mutation_prompt": null}
{"id": "e84243ad-a0f4-47e8-aa0f-ab6e1874282f", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.elite_rate = 0.1  # Proportion of the elite group\n        self.learning_rate_adapt = 0.1  # Adaptation rate for learning coefficients\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            elite_size = max(1, int(self.elite_rate * self.population_size))\n            elite_indices = np.argsort(personal_best_scores)[:elite_size]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                # Adaptive learning coefficients\n                self.cognitive_coeff += self.learning_rate_adapt * (np.random.rand() - 0.5)\n                self.social_coeff += self.learning_rate_adapt * (np.random.rand() - 0.5)\n                \n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            # Elite selection strategy for potential new global best\n            elite_best_idx = np.argmin(personal_best_scores[elite_indices])\n            if personal_best_scores[elite_indices[elite_best_idx]] < global_best_score:\n                global_best_position = personal_best_positions[elite_indices[elite_best_idx]]\n                global_best_score = personal_best_scores[elite_indices[elite_best_idx]]\n\n            self.inertia_weight = max(self.min_inertia_weight, self.inertia_weight - (0.5 / (self.budget / self.population_size)))\n            self.temperature *= self.cooling_rate\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introduce adaptive learning coefficients and elite selection strategy for improved exploration-exploitation balance and solution refinement.", "configspace": "", "generation": 8, "fitness": 0.24224272276182393, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.242 with standard deviation 0.003. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "2de073f4-261e-4a29-8867-1550e09e848e", "metadata": {"aucs": [0.24605207142466423, 0.24096702583831464, 0.23970907102249295], "final_y": [0.16572550338387215, 0.1655893924648355, 0.16824513343737169]}, "mutation_prompt": null}
{"id": "a96820d5-8724-47fe-b285-e17fdd5cb366", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5  # New parameter for neighborhood size\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n\n                # Dynamic neighborhood-based learning strategy\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (local_best_position - positions[i]))\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = max(self.min_inertia_weight, self.inertia_weight - (0.5 / (self.budget / self.population_size)))\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Improved PSOSA by incorporating a dynamic neighborhood-based learning strategy for enhanced social interaction and convergence.", "configspace": "", "generation": 9, "fitness": 0.24341127392956005, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.243 with standard deviation 0.003. And the mean value of best solutions found was 0.176 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "2de073f4-261e-4a29-8867-1550e09e848e", "metadata": {"aucs": [0.24019426209680328, 0.24266816742358732, 0.24737139226828952], "final_y": [0.18188074553804157, 0.18187876673840686, 0.16485579984043341]}, "mutation_prompt": null}
{"id": "bab7b845-ea2d-4ce9-8e22-9f51ce9ae5bc", "solution": "import numpy as np\n\nclass EnhancedImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.diversity_threshold = 0.1  # New parameter for diversity control\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (local_best_position - positions[i]))\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            # Adapt coefficients based on diversity\n            diversity = np.mean(np.std(positions, axis=0))\n            if diversity < self.diversity_threshold:\n                self.cognitive_coeff += 0.05\n                self.social_coeff -= 0.05\n            else:\n                self.cognitive_coeff -= 0.05\n                self.social_coeff += 0.05\n\n            self.inertia_weight = max(self.min_inertia_weight, self.inertia_weight - (0.5 / (self.budget / self.population_size)))\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "EnhancedImprovedPSOSA", "description": "Enhanced ImprovedPSOSA by introducing adaptive coefficients and diversity preservation for better exploration and exploitation balance.", "configspace": "", "generation": 10, "fitness": 0.23230441743829236, "feedback": "The algorithm EnhancedImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.232 with standard deviation 0.010. And the mean value of best solutions found was 0.239 (0. is the best) with standard deviation 0.057.", "error": "", "parent_id": "a96820d5-8724-47fe-b285-e17fdd5cb366", "metadata": {"aucs": [0.21791112485046737, 0.2390156566126156, 0.23998647085179414], "final_y": [0.32022156242058253, 0.20023239371493862, 0.19715969467146743]}, "mutation_prompt": null}
{"id": "8d141cb8-e414-423a-beed-7e91f1578b41", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2  # New: Adaptive inertia weight range\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5  # New: Historical influence factor\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n\n                # Dynamic neighborhood-based learning strategy\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                # New: Incorporate historical bests\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * (historical_best_position - positions[i]))  # New: historical influence\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)  # Updated: Adaptive inertia adjustment\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced ImprovedPSOSA with adaptive parameters and historical guidance for superior performance and convergence.", "configspace": "", "generation": 11, "fitness": 0.24573219446243563, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a96820d5-8724-47fe-b285-e17fdd5cb366", "metadata": {"aucs": [0.24535592640262882, 0.2456964733345849, 0.24614418365009316], "final_y": [0.164865053864647, 0.16485926738098022, 0.16485596446781237]}, "mutation_prompt": null}
{"id": "6bf8eea6-adf6-4b3b-a8ae-912f2b96f3ee", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93  # Updated: Enhanced cooling rate\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)  # Updated: Adjusted neighborhood size\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * (historical_best_position - positions[i]))\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "ImprovedPSOSA with dynamic neighborhood adjustment and enhanced cooling for better exploration-exploitation balance.", "configspace": "", "generation": 12, "fitness": 0.24625131492745903, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8d141cb8-e414-423a-beed-7e91f1578b41", "metadata": {"aucs": [0.2450112988279688, 0.2464818795880448, 0.24726076636636352], "final_y": [0.164856035350479, 0.1648558541599182, 0.16485578190966266]}, "mutation_prompt": null}
{"id": "2791a704-c29b-4c73-aaee-565f1e15c8a5", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93  # Updated: Enhanced cooling rate\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)  # Updated: Adjusted neighborhood size\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                # Adaptive cognitive and social coefficients\n                self.cognitive_coeff = 1.0 + 0.6 * (evaluations / self.budget)  # Changed line\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * (historical_best_position - positions[i]))\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "ImprovedPSOSA with adaptive cognitive and social coefficients for dynamic exploration-exploitation balance.", "configspace": "", "generation": 13, "fitness": 0.24579911345189923, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6bf8eea6-adf6-4b3b-a8ae-912f2b96f3ee", "metadata": {"aucs": [0.24315581725748847, 0.2470473564386969, 0.24719416665951233], "final_y": [0.16491937829813386, 0.1648606698290611, 0.16487418954614663]}, "mutation_prompt": null}
{"id": "0243ab00-0b91-46ad-8ce9-f9236ef21e8a", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * (0.5 + 0.5 * np.random.rand()) * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 self.social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * (historical_best_position - positions[i]))\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "ImprovedPSOSA with dynamic neighborhood adjustment, enhanced cooling, and adaptive cognitive coefficient for better convergence.", "configspace": "", "generation": 14, "fitness": 0.2467210323916631, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6bf8eea6-adf6-4b3b-a8ae-912f2b96f3ee", "metadata": {"aucs": [0.24705363582879558, 0.24675680482709916, 0.24635265651909455], "final_y": [0.16485678525688907, 0.16485667493083211, 0.16485605687453508]}, "mutation_prompt": null}
{"id": "09b63e67-6214-4df6-a8b8-2e319902e1cb", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * (0.6 + 0.4 * np.random.rand()) * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 self.social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * (historical_best_position - positions[i]))\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "ImprovedPSOSA with enhanced neighborhood influence by incorporating an additional inertia factor and refined cognitive component scaling.", "configspace": "", "generation": 15, "fitness": 0.24617302975735575, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0243ab00-0b91-46ad-8ce9-f9236ef21e8a", "metadata": {"aucs": [0.24588148313816072, 0.24598990435980828, 0.24664770177409823], "final_y": [0.16491202581256637, 0.1648675450091025, 0.16485577246312444]}, "mutation_prompt": null}
{"id": "9e74c507-c59b-4833-bc8a-1bcbec378f18", "solution": "import numpy as np\n\nclass EnhancedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n        self.inertia_oscillation = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * (0.5 + 0.5 * np.random.rand()) * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 (self.social_coeff + np.random.rand()) * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * np.sin(np.pi * evaluations / self.budget) * (historical_best_position - positions[i]))\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.min_inertia_weight + self.inertia_oscillation * np.sin(np.pi * evaluations / self.budget), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "EnhancedPSOSA", "description": "EnhancedPSOSA with inertia weight oscillation, diversified local search, and adaptive social coefficient for improved exploration and exploitation balance.", "configspace": "", "generation": 16, "fitness": 0.24550610080374458, "feedback": "The algorithm EnhancedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "0243ab00-0b91-46ad-8ce9-f9236ef21e8a", "metadata": {"aucs": [0.2475274124205158, 0.24324180948148688, 0.24574908050923105], "final_y": [0.16486507056742372, 0.18188357416722833, 0.16497686115526677]}, "mutation_prompt": null}
{"id": "6fa1c044-3a77-4c9a-98a2-4903cd437cf9", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n\n                # Adaptive neighborhood size adjustment\n                self.neighborhood_size = max(2, int(self.population_size * (1 - evaluations / self.budget)))\n\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * (0.5 + 0.5 * np.random.rand()) * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 self.social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * (historical_best_position - positions[i]))\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "ImprovedPSOSA with adaptive neighborhood size for enhanced local exploration and convergence.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "0243ab00-0b91-46ad-8ce9-f9236ef21e8a", "metadata": {}, "mutation_prompt": null}
{"id": "0d7784fa-49af-4580-b556-3eb7f518be18", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.8  # Recalibrated cognitive coefficient\n        self.social_coeff = 1.3    # Recalibrated social coefficient\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * (0.5 + 0.5 * np.random.rand()) * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 self.social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * (historical_best_position - positions[i]))\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced ImprovedPSOSA with recalibrated cognitive and social coefficients for refined balance between exploration and exploitation.", "configspace": "", "generation": 18, "fitness": 0.24504718809969694, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "0243ab00-0b91-46ad-8ce9-f9236ef21e8a", "metadata": {"aucs": [0.24665223198991626, 0.24223076180784386, 0.2462585705013307], "final_y": [0.16485639520987727, 0.18187813160444033, 0.16486215477129085]}, "mutation_prompt": null}
{"id": "ec414c42-3656-475c-a3a5-06d8de991cbf", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                # Adaptive social coefficient based on swarm diversity\n                diversity = np.mean(np.std(positions, axis=0))\n                adaptive_social_coeff = self.social_coeff * (1 + diversity)\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * (0.5 + 0.5 * np.random.rand()) * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * (historical_best_position - positions[i]))\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "ImprovedPSOSA now utilizes an adaptive social coefficient based on swarm diversity to enhance exploration and convergence.", "configspace": "", "generation": 19, "fitness": 0.2030698413367276, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.203 with standard deviation 0.003. And the mean value of best solutions found was 0.450 (0. is the best) with standard deviation 0.026.", "error": "", "parent_id": "0243ab00-0b91-46ad-8ce9-f9236ef21e8a", "metadata": {"aucs": [0.20083635867759175, 0.20680373557977605, 0.201569429752815], "final_y": [0.47239265783783124, 0.41379549904142665, 0.46469205749927356]}, "mutation_prompt": null}
{"id": "c5ef2369-4954-42f0-9bd0-5aa5ba33e4bf", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * (0.5 + 0.5 * np.random.rand()) * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 self.social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * (historical_best_position - positions[i]))\n\n                velocities[i] *= (1 + 0.1 * np.random.rand())  # Dynamic velocity scaling\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n            self.cognitive_coeff = 1.5 + 0.1 * np.random.rand()  # Adaptive personal coefficient\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced ImprovedPSOSA with dynamic velocity scaling and adaptive personal coefficient for improved exploration-exploitation balance.", "configspace": "", "generation": 20, "fitness": 0.2440350570140943, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "0243ab00-0b91-46ad-8ce9-f9236ef21e8a", "metadata": {"aucs": [0.24657423313326532, 0.24068537172696747, 0.2448455661820501], "final_y": [0.16485607384799006, 0.18187875401030795, 0.16486819934492636]}, "mutation_prompt": null}
{"id": "073ad15e-445f-4186-8703-500b5e62f653", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * (0.5 + 0.5 * np.random.rand()) * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 self.social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * (historical_best_position - positions[i]))\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = (global_best_position * 0.9 + personal_best_positions[global_best_idx] * 0.1)  # Change made here\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "ImprovedPSOSA with stochastic weight averaging for smoother convergence and enhanced robustness.", "configspace": "", "generation": 21, "fitness": 0.24621935210845072, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0243ab00-0b91-46ad-8ce9-f9236ef21e8a", "metadata": {"aucs": [0.24671577675436573, 0.24602321539221383, 0.24591906417877263], "final_y": [0.16485594830281702, 0.1648557760056678, 0.16485969448145465]}, "mutation_prompt": null}
{"id": "0779ec2d-777c-4848-b68a-be19de24b95d", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = np.mean([personal_best_positions[i], local_best_position], axis=0)\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * (0.5 + 0.5 * np.random.rand()) * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 self.social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * (historical_best_position - positions[i]))\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "ImprovedPSOSA with enhanced neighbor selection by using the best of both personal and local best positions for better exploration.", "configspace": "", "generation": 22, "fitness": 0.24580188739292894, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0243ab00-0b91-46ad-8ce9-f9236ef21e8a", "metadata": {"aucs": [0.24494378046129017, 0.24702308863132583, 0.24543879308617078], "final_y": [0.16494400494435502, 0.1649029339088377, 0.16485577686551212]}, "mutation_prompt": null}
{"id": "70a65f3c-0dee-4141-bb36-d54648374465", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 8  # Changed from 5 to 8 for improved local exploration\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * (0.5 + 0.5 * np.random.rand()) * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 self.social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * (historical_best_position - positions[i]))\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "ImprovedPSOSA with increased neighborhood size for better local exploration.", "configspace": "", "generation": 23, "fitness": 0.246500206126379, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0243ab00-0b91-46ad-8ce9-f9236ef21e8a", "metadata": {"aucs": [0.24710512191753464, 0.246314028782598, 0.2460814676790043], "final_y": [0.16485640139565905, 0.1651553553917292, 0.16486315304470578]}, "mutation_prompt": null}
{"id": "60d71771-897e-42fe-a876-9c377928eb63", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * (0.5 + 0.5 * np.random.rand()) * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 self.social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * (historical_best_position - positions[i]))\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.3 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced ImprovedPSOSA with adaptive inertia weight adjustment for more flexible exploration-exploitation balance.", "configspace": "", "generation": 24, "fitness": 0.24453402970666446, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.002. And the mean value of best solutions found was 0.173 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "0243ab00-0b91-46ad-8ce9-f9236ef21e8a", "metadata": {"aucs": [0.2466831279935945, 0.24121826426609128, 0.2457006968603076], "final_y": [0.16485791919048576, 0.18813064471393526, 0.16486233725585742]}, "mutation_prompt": null}
{"id": "c4bc5e38-4ed1-479e-ad1b-749c31ef2d0d", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                # Adaptive cognitive and social coefficients\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * (historical_best_position - positions[i]))\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introducing adaptive learning rates for cognitive and social coefficients to enhance the convergence behavior.", "configspace": "", "generation": 25, "fitness": 0.24687090906135958, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0243ab00-0b91-46ad-8ce9-f9236ef21e8a", "metadata": {"aucs": [0.2473759574719272, 0.24642270966475155, 0.24681406004740003], "final_y": [0.16485778009360652, 0.16486269139962262, 0.16485921527893277]}, "mutation_prompt": null}
{"id": "e4971168-8fe1-45dc-ad42-18e36cd2baca", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size_initial = 30\n        self.population_size = self.population_size_initial\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.population_size = max(5, int(self.population_size_initial * (1 - evaluations / self.budget)))\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                # Adaptive cognitive and social coefficients\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * (historical_best_position - positions[i]))\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size_initial)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Incorporating dynamic population size adjustment for enhanced exploration and exploitation balance.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "c4bc5e38-4ed1-479e-ad1b-749c31ef2d0d", "metadata": {}, "mutation_prompt": null}
{"id": "284aa8b2-1242-49e5-99fe-2582b01b5854", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)  # Changed to introduce correlation factor\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                # Adaptive cognitive and social coefficients\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i]))  # Introduced correlation factor here\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced selection of local best positions by introducing a correlation factor to improve performance.", "configspace": "", "generation": 27, "fitness": 0.2473957767873666, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c4bc5e38-4ed1-479e-ad1b-749c31ef2d0d", "metadata": {"aucs": [0.2478840847879522, 0.24686346737707054, 0.24743977819707708], "final_y": [0.16486538117788663, 0.16485578890776875, 0.16488057662539168]}, "mutation_prompt": null}
{"id": "dd3b95b3-be63-42c1-8392-d4d3348bb33b", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)  # Changed to introduce correlation factor\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                # Adaptive cognitive and social coefficients\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                # Introduce dynamic scaling factor for exploration-exploitation balance\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor  # Modified line\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced velocity update by incorporating a dynamic scaling factor for exploration-exploitation balance.", "configspace": "", "generation": 28, "fitness": 0.24768716702299876, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "284aa8b2-1242-49e5-99fe-2582b01b5854", "metadata": {"aucs": [0.24773442562927817, 0.24769012155899295, 0.24763695388072515], "final_y": [0.16511491861002858, 0.16485763649779117, 0.16536630267576147]}, "mutation_prompt": null}
{"id": "4b0c5d0a-9e38-47f6-b56a-6b2338237662", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)  # Changed to introduce correlation factor\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                # Adaptive cognitive and social coefficients\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                # Introduce dynamic scaling factor for exploration-exploitation balance\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                # Modified line: dynamic inertia weight based on evaluation progress\n                velocities[i] = (self.inertia_weight * (1.0 - scaling_factor) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced velocity update with dynamic inertia weight based on evaluation progress for improved balance.", "configspace": "", "generation": 29, "fitness": 0.2420333373703664, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.242 with standard deviation 0.003. And the mean value of best solutions found was 0.189 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "dd3b95b3-be63-42c1-8392-d4d3348bb33b", "metadata": {"aucs": [0.24630255868121897, 0.23815784874670543, 0.2416396046831748], "final_y": [0.17179964281416804, 0.2056726549791108, 0.19083312861098845]}, "mutation_prompt": null}
{"id": "7295eec4-c6eb-4180-85dd-ab5ab1356d8e", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n        historical_global_best = np.copy(global_best_position)\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)  # Changed to introduce correlation factor\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                # Adaptive cognitive and social coefficients\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                # Introduce dynamic scaling factor for exploration-exploitation balance\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i]) + \n                                 0.1 * (historical_global_best - positions[i])) * scaling_factor  # Modified line\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n                    historical_global_best = np.copy(global_best_position)  # Track historical global best\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced velocity update by introducing an adaptive learning strategy that leverages historical global best for improved convergence.", "configspace": "", "generation": 30, "fitness": 0.24557191572294182, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "dd3b95b3-be63-42c1-8392-d4d3348bb33b", "metadata": {"aucs": [0.24260343946460572, 0.24712418619558596, 0.2469881215086338], "final_y": [0.18200506609817713, 0.16523653901981916, 0.16687129792458755]}, "mutation_prompt": null}
{"id": "4f2a70da-ec6e-4e0f-89d6-82f8938d86ff", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)  # Changed to introduce correlation factor\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                # Adaptive cognitive and social coefficients\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand()) * np.sqrt(scaling_factor)  # Modified line\n\n                # Introduce dynamic scaling factor for exploration-exploitation balance\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced adaptive social coefficient with non-linear scaling for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'scaling_factor' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'scaling_factor' referenced before assignment\")", "parent_id": "dd3b95b3-be63-42c1-8392-d4d3348bb33b", "metadata": {}, "mutation_prompt": null}
{"id": "c0334865-628b-4881-a76c-2109b0b4d3bd", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)  # Changed to introduce correlation factor\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = np.mean(personal_best_positions[neighbors_indices], axis=0)  # Modified line\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                # Adaptive cognitive and social coefficients\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                # Introduce dynamic scaling factor for exploration-exploitation balance\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor  # Modified line\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced velocity update by incorporating a dynamic scaling factor for exploration-exploitation balance, with improved local best selection.", "configspace": "", "generation": 32, "fitness": 0.24715171965192695, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "dd3b95b3-be63-42c1-8392-d4d3348bb33b", "metadata": {"aucs": [0.247032011257168, 0.24761466975886892, 0.24680847793974392], "final_y": [0.16879627613775672, 0.16495750517564067, 0.16714855947995655]}, "mutation_prompt": null}
{"id": "6c95ec63-5a00-423d-a877-5e8ed0388dbe", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)  # Changed to introduce correlation factor\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                # Adaptive cognitive and social coefficients\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                # Introduce dynamic scaling factor for exploration-exploitation balance\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor  # Modified line\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            # Nonlinear inertia weight reduction for finer convergence control\n            self.inertia_weight = np.clip(self.min_inertia_weight + (self.max_inertia_weight - self.min_inertia_weight) * (1 - (evaluations / self.budget)**2), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introduced a nonlinear inertia weight reduction for enhanced convergence control.", "configspace": "", "generation": 33, "fitness": 0.245875834739308, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "dd3b95b3-be63-42c1-8392-d4d3348bb33b", "metadata": {"aucs": [0.24523007615834513, 0.24633500909504924, 0.24606241896452963], "final_y": [0.16520957937018887, 0.16489946283869428, 0.16514965973200668]}, "mutation_prompt": null}
{"id": "e29aa6f3-1ec3-4bb3-83a0-8898d1d90eb5", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)  # Changed to introduce correlation factor\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                # Adaptive cognitive and social coefficients\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                # Introduce enhanced dynamic scaling factor\n                scaling_factor = (self.budget - evaluations) / self.budget * (1.5 - r1)  \n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.3 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)  # Adjusted line\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced dynamic scaling factor and introduced inertia weight adaptation for improved exploration-exploitation balance.", "configspace": "", "generation": 34, "fitness": 0.2460423716698704, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "dd3b95b3-be63-42c1-8392-d4d3348bb33b", "metadata": {"aucs": [0.24290465168675712, 0.24763107673473117, 0.24759138658812285], "final_y": [0.1818785498889135, 0.16486298055540594, 0.16508196882231596]}, "mutation_prompt": null}
{"id": "65532696-7254-49a4-968a-4c92e3fe9038", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n        self.decay_factor = 0.99  # New parameter\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                # Introduce exponentially decaying velocity factor for exploration\n                velocities[i] *= self.decay_factor  # Modified line\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced random exploration by introducing an exponentially decaying velocity factor.", "configspace": "", "generation": 35, "fitness": 0.24754706157130477, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "dd3b95b3-be63-42c1-8392-d4d3348bb33b", "metadata": {"aucs": [0.24785949537717722, 0.24734422625211183, 0.24743746308462522], "final_y": [0.16487760589567568, 0.1650451163214156, 0.16497406577436402]}, "mutation_prompt": null}
{"id": "9af7cc73-63e8-4c0c-a370-70c4915a2f01", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                diversity_factor = np.std(personal_best_positions) / np.mean(personal_best_positions)  # New line\n                scaling_factor = ((self.budget - evaluations) / self.budget) * diversity_factor  # Modified line\n                \n                # Added historical velocity momentum\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i]) +\n                                 0.1 * velocities[i]) * scaling_factor  # Modified line\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced dynamic scaling by incorporating particle diversity and historical velocity momentum for better convergence.", "configspace": "", "generation": 36, "fitness": 0.24351334079792997, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.001. And the mean value of best solutions found was 0.183 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "dd3b95b3-be63-42c1-8392-d4d3348bb33b", "metadata": {"aucs": [0.2434395979441304, 0.24503818552683776, 0.24206223892282175], "final_y": [0.18297972083170377, 0.17607322654434165, 0.18867258843539947]}, "mutation_prompt": null}
{"id": "14c237f3-efa3-4f84-af39-d566f7206b09", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)  # Changed to introduce correlation factor\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 3, replace=False)  # Increased neighborhood influence\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                # Adaptive cognitive and social coefficients\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                # Introduce dynamic scaling factor for exploration-exploitation balance\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor  # Modified line\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced velocity update by incorporating a dynamic scaling factor for exploration-exploitation balance, with increased neighborhood influence.", "configspace": "", "generation": 37, "fitness": 0.24702944649225056, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "dd3b95b3-be63-42c1-8392-d4d3348bb33b", "metadata": {"aucs": [0.2473954009123891, 0.2474592001037479, 0.2462337384606147], "final_y": [0.16521510583191445, 0.16486185645268248, 0.16806520110251555]}, "mutation_prompt": null}
{"id": "62df68c4-3933-4a2f-8e42-f25669580269", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n        self.successful_updates = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)  # Changed to introduce correlation factor\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                # Adaptive cognitive and social coefficients\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                # Introduce dynamic scaling factor for exploration-exploitation balance\n                scaling_factor = (self.successful_updates + 1) / (i + 1)  # Modified line\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n                    self.successful_updates += 1\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced velocity update by introducing a self-adaptive scaling factor based on the success rate of finding better personal bests.", "configspace": "", "generation": 38, "fitness": 0.23258579379669694, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.233 with standard deviation 0.004. And the mean value of best solutions found was 0.205 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": "dd3b95b3-be63-42c1-8392-d4d3348bb33b", "metadata": {"aucs": [0.23487102172518548, 0.22732060754599037, 0.23556575211891495], "final_y": [0.19792186459000694, 0.229895077319497, 0.18705400277028272]}, "mutation_prompt": null}
{"id": "9d5c322e-7b14-49e4-b308-9d7ed467737a", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)  # Changed to introduce correlation factor\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                # Adaptive cognitive and social coefficients\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                # Introduce dynamic scaling factor for exploration-exploitation balance\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor  # Modified line\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / (self.temperature * scaling_factor)):  # Changed line\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Improved exploration-exploitation balance with adaptive temperature scaling.", "configspace": "", "generation": 39, "fitness": 0.24766925823885713, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "dd3b95b3-be63-42c1-8392-d4d3348bb33b", "metadata": {"aucs": [0.2476865902178773, 0.24769259623339634, 0.24762858826529777], "final_y": [0.16514474562067893, 0.16486073940919255, 0.16534977964196773]}, "mutation_prompt": null}
{"id": "beb39862-5c56-4b44-b721-ba258f8617ff", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)  # Changed to introduce correlation factor\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                # Adaptive cognitive and social coefficients\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                # Introduce dynamic scaling factor for exploration-exploitation balance\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +  # Modified line\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introduced random inertia weight adjustment for improved exploration-exploitation balance.", "configspace": "", "generation": 40, "fitness": 0.2477340338200137, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "dd3b95b3-be63-42c1-8392-d4d3348bb33b", "metadata": {"aucs": [0.24798047370107645, 0.2476537836699888, 0.2475678440889758], "final_y": [0.1648561450678051, 0.16525394435295415, 0.16515735929299302]}, "mutation_prompt": null}
{"id": "77fa0695-5ce3-4b5a-bdc2-0666d72a4368", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)  # Changed to introduce correlation factor\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                # Adaptive cognitive and social coefficients\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                # Introduce dynamic scaling factor for exploration-exploitation balance\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                # Enhanced dynamic inertia weight for better convergence\n                inertia_weight = self.min_inertia_weight + (self.max_inertia_weight - self.min_inertia_weight) * (self.budget - evaluations) / self.budget\n                velocities[i] = (inertia_weight * velocities[i] +  \n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced dynamic inertia weight and local search for better convergence.", "configspace": "", "generation": 41, "fitness": 0.24566597766155843, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "beb39862-5c56-4b44-b721-ba258f8617ff", "metadata": {"aucs": [0.2455304202253925, 0.24484894192498985, 0.24661857083429295], "final_y": [0.16487995898098107, 0.16485807595873014, 0.16495604295684763]}, "mutation_prompt": null}
{"id": "ec7f0026-a921-4db1-910f-b96161870acc", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)  # Changed to introduce correlation factor\n\n                # Dynamic neighborhood size adjustment\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                # Adaptive cognitive and social coefficients\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                # Introduce dynamic scaling factor for exploration-exploitation balance\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +  # Modified line\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            # Dynamic inertia weight adjustment based on evaluations ratio\n            self.inertia_weight = np.clip(self.max_inertia_weight - (self.max_inertia_weight - self.min_inertia_weight) * (evaluations / self.budget), self.min_inertia_weight, self.max_inertia_weight)\n            # Dynamic temperature adjustment\n            self.temperature = self.temperature * np.exp(-0.01 * evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introduced dynamic temperature and inertia weight to improve exploration-exploitation trade-off.", "configspace": "", "generation": 42, "fitness": 0.24772369719471513, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "beb39862-5c56-4b44-b721-ba258f8617ff", "metadata": {"aucs": [0.2479506961629261, 0.2475764171219509, 0.24764397829926843], "final_y": [0.1648577286889037, 0.16548308581294724, 0.16497334185568913]}, "mutation_prompt": null}
{"id": "e3c1a44d-1d00-4594-a590-126cc688abd7", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +  \n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor\n\n                positions[i] = positions[i] + velocities[i] + 0.1 * (np.random.rand(self.dim) - 0.5)  # Adaptive local search step\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introduced adaptive local search step to enhance local exploration capabilities.", "configspace": "", "generation": 43, "fitness": 0.24770191799674576, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "beb39862-5c56-4b44-b721-ba258f8617ff", "metadata": {"aucs": [0.24777668868237746, 0.2479698348590773, 0.2473592304487825], "final_y": [0.164855795418702, 0.16485580351919216, 0.16487055229950043]}, "mutation_prompt": null}
{"id": "3a9a6a7e-757f-4e7c-ac60-b8457dc4dcd6", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95  # Modified line\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced temperature cooling rate for better simulated annealing balance.", "configspace": "", "generation": 44, "fitness": 0.24775809207681057, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "beb39862-5c56-4b44-b721-ba258f8617ff", "metadata": {"aucs": [0.24788474312182174, 0.24770081192294047, 0.24768872118566954], "final_y": [0.16489081631095892, 0.1649524762822614, 0.16492406943360072]}, "mutation_prompt": null}
{"id": "17b8a2ef-fa9d-4e07-a34a-37721a42c6da", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (0.9 + 0.2 * (global_best_score / (np.min(personal_best_scores) + 1e-10)))  # Changed line\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introduce adaptive temperature cooling to enhance exploration and exploitation balance.", "configspace": "", "generation": 45, "fitness": 0.24762592121990032, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "3a9a6a7e-757f-4e7c-ac60-b8457dc4dcd6", "metadata": {"aucs": [0.2478112796345835, 0.24775738883968756, 0.24730909518542987], "final_y": [0.164871098776731, 0.16488820518073477, 0.16642089939516158]}, "mutation_prompt": null}
{"id": "26932ce3-414f-49fc-9e2e-8c5c2e100dc7", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95  # Modified line\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Modified line for neighborhood selection strategy\n                neighbors_indices = (np.argsort(personal_best_scores)[:self.neighborhood_size + 2])\n\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced neighborhood selection strategy for better local exploration.", "configspace": "", "generation": 46, "fitness": 0.23950764170565517, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.240 with standard deviation 0.009. And the mean value of best solutions found was 0.202 (0. is the best) with standard deviation 0.040.", "error": "", "parent_id": "3a9a6a7e-757f-4e7c-ac60-b8457dc4dcd6", "metadata": {"aucs": [0.24773226237475932, 0.24328055115572456, 0.2275101115864816], "final_y": [0.16489460145111912, 0.18193442400863158, 0.25781016380050337]}, "mutation_prompt": null}
{"id": "5e256d6a-bff3-4501-9e1b-cce7472e5c84", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.93  # Modified line\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n        self.diversity_factor = 0.1  # New line for diversity control\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                # Diversity preservation: slight random perturbation\n                velocities[i] += self.diversity_factor * np.random.uniform(-0.5, 0.5, self.dim) \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            # Adaptive inertia weight based on diversity\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), \n                                          self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Integrating diversity preservation and adaptive inertia to enhance solution exploration.", "configspace": "", "generation": 47, "fitness": 0.2477263902499609, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3a9a6a7e-757f-4e7c-ac60-b8457dc4dcd6", "metadata": {"aucs": [0.24774387024896416, 0.24795742489506267, 0.24747787560585588], "final_y": [0.16485580574379777, 0.16485581793645943, 0.16485582515230512]}, "mutation_prompt": null}
{"id": "6061b85b-45fd-44fe-bb5c-5340bcb480f9", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                self.neighborhood_size = max(2, int(self.population_size * (self.budget - evaluations) / self.budget)) # Adaptive neighborhood size\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Adaptive neighborhood and inertia modulation improve solution exploration.  ", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "3a9a6a7e-757f-4e7c-ac60-b8457dc4dcd6", "metadata": {}, "mutation_prompt": null}
{"id": "d071792b-8315-4448-b066-44634f041c4d", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = max(1, min(self.population_size - 1, int(self.population_size * 0.1)))  # Changed line\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introduced dynamic neighborhood size for enhanced local search adaptability.  ", "configspace": "", "generation": 49, "fitness": 0.2476081895122323, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "3a9a6a7e-757f-4e7c-ac60-b8457dc4dcd6", "metadata": {"aucs": [0.2475964658594616, 0.24782590063648646, 0.2474022020407488], "final_y": [0.16621607207984057, 0.16485635294734313, 0.1654362012417998]}, "mutation_prompt": null}
{"id": "6c643b49-9781-4707-b7de-e487f76f7d8c", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            # Changed line: Updated inertia weight decay\n            self.inertia_weight = np.clip(self.inertia_weight - (0.2 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            \n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced inertia weight decay factor for better exploration-exploitation balance.", "configspace": "", "generation": 50, "fitness": 0.24775809207681057, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3a9a6a7e-757f-4e7c-ac60-b8457dc4dcd6", "metadata": {"aucs": [0.24788474312182174, 0.24770081192294047, 0.24768872118566954], "final_y": [0.16489081631095892, 0.1649524762822614, 0.16492406943360072]}, "mutation_prompt": null}
{"id": "d5c715b1-2fca-49a7-adb1-5e23d1e73b21", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95  # Modified line\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.8 + 0.2 * np.random.rand())  # Modified line\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Improved control of cognitive coefficient dynamics for enhanced diversification.", "configspace": "", "generation": 51, "fitness": 0.24771034593147997, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3a9a6a7e-757f-4e7c-ac60-b8457dc4dcd6", "metadata": {"aucs": [0.24787505536041088, 0.2477555301088561, 0.24750045232517293], "final_y": [0.16485761498851648, 0.1651893753951007, 0.16561898175161915]}, "mutation_prompt": null}
{"id": "11f8bfc0-461f-4f52-bf5c-1dc66d6ce1c4", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95  # Modified line\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.6 + 0.4 * np.random.rand())  # Modified line\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Adjusted adaptive coefficients for enhanced exploitation in search velocity update.", "configspace": "", "generation": 52, "fitness": 0.24774221352669645, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3a9a6a7e-757f-4e7c-ac60-b8457dc4dcd6", "metadata": {"aucs": [0.24784232120401684, 0.2476532404493399, 0.24773107892673263], "final_y": [0.16490151067726166, 0.16494547377731406, 0.16493529550665142]}, "mutation_prompt": null}
{"id": "e3375d28-f239-4fd3-8c82-025c8b349470", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)  # Modified line\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introduced adaptive cooling rate based on evaluations to enhance solution exploration and exploitation.", "configspace": "", "generation": 53, "fitness": 0.2478595240246225, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3a9a6a7e-757f-4e7c-ac60-b8457dc4dcd6", "metadata": {"aucs": [0.24792349532739655, 0.24772547452313876, 0.24792960222333216], "final_y": [0.1648731138383719, 0.16492184701628088, 0.16502238535833413]}, "mutation_prompt": null}
{"id": "394c7e42-f6d5-46e5-8071-ae7e4f7a2f72", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight * (evaluations / float(self.budget)), self.min_inertia_weight, self.max_inertia_weight)  # Modified line\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Improved inertia weight cooling for better balance between exploration and exploitation.", "configspace": "", "generation": 54, "fitness": 0.2478595240246225, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e3375d28-f239-4fd3-8c82-025c8b349470", "metadata": {"aucs": [0.24792349532739655, 0.24772547452313876, 0.24792960222333216], "final_y": [0.1648731138383719, 0.16492184701628088, 0.16502238535833413]}, "mutation_prompt": null}
{"id": "b5e032aa-eeac-47d6-907d-71d4e00224f6", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                # Implement mutation for diversity\n                if np.random.rand() < 0.1:\n                    positions[i] = np.clip(positions[i] + np.random.normal(0, 0.1, self.dim), lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced adaptive strategy by incorporating mutation and diversity preservation for improved exploration and exploitation.", "configspace": "", "generation": 55, "fitness": 0.2478512571130884, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e3375d28-f239-4fd3-8c82-025c8b349470", "metadata": {"aucs": [0.24788163031417398, 0.24794049672919816, 0.247731644295893], "final_y": [0.16485577518547156, 0.16485577207936997, 0.16485577237586857]}, "mutation_prompt": null}
{"id": "b5e87863-7397-4070-8d55-508ce5b513a7", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                dynamic_neighborhood_size = max(2, int(self.neighborhood_size * (1 - evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                adaptive_velocity_scaling = 1 + 0.5 * np.random.rand() * (evaluations / self.budget)\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor * adaptive_velocity_scaling\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)  # Modified line\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introduced dynamic neighborhood size and adaptive velocity scaling to improve exploration and convergence.", "configspace": "", "generation": 56, "fitness": 0.24777978471380804, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e3375d28-f239-4fd3-8c82-025c8b349470", "metadata": {"aucs": [0.24773099693953604, 0.24779071388619667, 0.24781764331569145], "final_y": [0.1650155666841412, 0.16488100608991763, 0.16501904634860554]}, "mutation_prompt": null}
{"id": "fc3a54e9-466f-41a8-8ac8-27330488fec7", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                adaptive_neighborhood_size = self.neighborhood_size + int((1 - evaluations / self.budget) * 5)  # Modified line\n                neighbors_indices = np.random.choice(self.population_size, adaptive_neighborhood_size + 2, replace=False)  # Modified line\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                dynamic_random = scaling_factor * np.random.rand()  # Modified line\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i]) + dynamic_random) * scaling_factor  # Modified line\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introduced a dynamic neighborhood size and adaptive random factor to improve convergence and diversity.", "configspace": "", "generation": 57, "fitness": 0.24712661483387968, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.001. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "e3375d28-f239-4fd3-8c82-025c8b349470", "metadata": {"aucs": [0.2465873175222909, 0.24783953986616036, 0.2469529871131878], "final_y": [0.16897076007418355, 0.1651776386749233, 0.16613099201820714]}, "mutation_prompt": null}
{"id": "cc45ed6b-4a42-4a06-b939-e1db06e3243b", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n        self.pheromone_evaporation = 0.1  # New parameter\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n        pheromone_levels = np.ones(self.dim)  # New line\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i]) +\n                                 0.05 * pheromone_levels) * scaling_factor  # Updated line\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)  \n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n            pheromone_levels *= (1 - self.pheromone_evaporation)  # New line\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced PSO with adaptive velocities and pheromone-inspired guidance to improve convergence in dynamic environments.", "configspace": "", "generation": 58, "fitness": 0.24770614151040074, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e3375d28-f239-4fd3-8c82-025c8b349470", "metadata": {"aucs": [0.24775466786512246, 0.2477674460339654, 0.2475963106321144], "final_y": [0.16492219468119274, 0.16499789292509404, 0.16504408779930202]}, "mutation_prompt": null}
{"id": "fc2a94cc-6890-40fa-a443-820dabcdf561", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                neighbors_indices = np.random.choice(self.population_size, self.neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)) * (evaluations / self.budget), self.min_inertia_weight, self.max_inertia_weight)  # Modified line\n\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced inertia weight decay for improved convergence dynamics.", "configspace": "", "generation": 59, "fitness": 0.2478595240246225, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e3375d28-f239-4fd3-8c82-025c8b349470", "metadata": {"aucs": [0.24792349532739655, 0.24772547452313876, 0.24792960222333216], "final_y": [0.1648731138383719, 0.16492184701628088, 0.16502238535833413]}, "mutation_prompt": null}
{"id": "cda261d0-a898-4a4c-994a-d73c027e8f93", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)  # Modified line\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introduced dynamic neighborhood size adjustment to enhance local solution exploration.", "configspace": "", "generation": 60, "fitness": 0.24786144961853307, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e3375d28-f239-4fd3-8c82-025c8b349470", "metadata": {"aucs": [0.24792398630029133, 0.2477311028078577, 0.24792925974745017], "final_y": [0.1648707323756079, 0.16489465353836974, 0.16502374550505317]}, "mutation_prompt": null}
{"id": "ce07cff3-61aa-4fff-9fb0-bc25ebacacd6", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * (scaling_factor ** 2) \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)  # Modified line\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introduced dynamic velocity scaling based on evaluation proximity to the budget limit to enhance convergence.", "configspace": "", "generation": 61, "fitness": 0.24764261849423708, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cda261d0-a898-4a4c-994a-d73c027e8f93", "metadata": {"aucs": [0.24782339211179638, 0.24745933558518574, 0.2476451277857291], "final_y": [0.1652294578314959, 0.16612369362342982, 0.16553105132357826]}, "mutation_prompt": null}
{"id": "56989b61-af81-4861-ab59-cf32ab9b1d19", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                # Modified velocity update with chaotic influence\n                chaotic_factor = 4 * r3 * (1 - r3)\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * chaotic_factor * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)  # Modified line\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Improved convergence by enhancing velocity update with chaos-based influence and stochastic neighbor selection.", "configspace": "", "generation": 62, "fitness": 0.24783424743471058, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cda261d0-a898-4a4c-994a-d73c027e8f93", "metadata": {"aucs": [0.2479678345308216, 0.24797444339091934, 0.24756046438239077], "final_y": [0.16486609888843984, 0.16487323229822037, 0.16520615295527374]}, "mutation_prompt": null}
{"id": "5ad92f74-0ac3-428a-b722-703cafc9482e", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * max(0.5, (global_best_score / (np.min(personal_best_scores) + 1e-9)))  # Modified line\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introduced adaptive cooling based on current best score improvement to enhance convergence.", "configspace": "", "generation": 63, "fitness": 0.24761075093813922, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cda261d0-a898-4a4c-994a-d73c027e8f93", "metadata": {"aucs": [0.2477563996343619, 0.24742045177871264, 0.24765540140134312], "final_y": [0.1648899054883184, 0.1655615332959044, 0.16520849528522874]}, "mutation_prompt": null}
{"id": "4cb2d8f0-c067-4b35-8ece-5493592fbb01", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced exploration by introducing gradual increase in neighborhood size based on convergence rate.", "configspace": "", "generation": 64, "fitness": 0.24786144961853307, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cda261d0-a898-4a4c-994a-d73c027e8f93", "metadata": {"aucs": [0.24792398630029133, 0.2477311028078577, 0.24792925974745017], "final_y": [0.1648707323756079, 0.16489465353836974, 0.16502374550505317]}, "mutation_prompt": null}
{"id": "4060039e-dfad-46f0-bfbc-0f73b30c0c80", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.inertia_weight *= (1 + 0.1 * (1 - evaluations / self.budget))  # Modified line\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)  # Modified line\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced velocity update with a dynamic inertia weight based on historical performance.", "configspace": "", "generation": 65, "fitness": 0.24394941000188977, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cda261d0-a898-4a4c-994a-d73c027e8f93", "metadata": {"aucs": [0.24552559543134767, 0.24057610198328216, 0.2457465325910395], "final_y": [0.16498901688969514, 0.16592849549260114, 0.1649453991289065]}, "mutation_prompt": null}
{"id": "afb9b227-fbc7-4f03-97b0-79a358d67911", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n                \n                # Mutation strategy to introduce diversity\n                if np.random.rand() < 0.1:\n                    positions[i] += np.random.normal(0, 0.1, self.dim)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)  # Modified line\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introduced mutation strategy to diversify exploration and enhance convergence.", "configspace": "", "generation": 66, "fitness": 0.24785150568543626, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cda261d0-a898-4a4c-994a-d73c027e8f93", "metadata": {"aucs": [0.24788173846818684, 0.24794001986620617, 0.2477327587219158], "final_y": [0.16485577266019835, 0.16485577195796097, 0.1648557720128776]}, "mutation_prompt": null}
{"id": "bea7440c-edb2-4ec0-bb5e-c1cfd8f9c10f", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * (evaluations / self.budget))  # Changed line\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * (1 - evaluations / self.budget))  # Changed line\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced exploration and fine-tuning by dynamically adjusting social and cognitive coefficients based on iterations.", "configspace": "", "generation": 67, "fitness": 0.2474568904464848, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cda261d0-a898-4a4c-994a-d73c027e8f93", "metadata": {"aucs": [0.24726611228921114, 0.24745640554539727, 0.24764815350484604], "final_y": [0.16486630454115403, 0.16508452071117308, 0.16486542527163206]}, "mutation_prompt": null}
{"id": "7e892b44-f507-4f13-bd20-f75b8126f619", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 2.0  # Increased cognitive coefficient\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                # Introduced stochastic search direction\n                search_direction = np.random.choice([-1, 1], size=self.dim)\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i]) * search_direction) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)  \n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced particle exploration through adaptive velocity updates and stochastic search direction.", "configspace": "", "generation": 68, "fitness": 0.2460542280000055, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "cda261d0-a898-4a4c-994a-d73c027e8f93", "metadata": {"aucs": [0.24773763487604183, 0.24729464404063117, 0.2431304050833435], "final_y": [0.16485585286873383, 0.1648557728730664, 0.1818782058404309]}, "mutation_prompt": null}
{"id": "4949dcf3-244a-4878-b410-13f76d4ba53e", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight * (0.7 + 0.3 * np.sin(evaluations)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)  # Modified line\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introduced chaotic maps in inertia weight adjustment to improve exploration and exploitation balance.", "configspace": "", "generation": 69, "fitness": 0.24786144961853307, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cda261d0-a898-4a4c-994a-d73c027e8f93", "metadata": {"aucs": [0.24792398630029133, 0.2477311028078577, 0.24792925974745017], "final_y": [0.1648707323756079, 0.16489465353836974, 0.16502374550505317]}, "mutation_prompt": null}
{"id": "b368b3ab-17d0-439b-868f-0f5726968d6f", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / (self.budget**2)  # Modified line\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)  # Modified line\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced velocity update by incorporating a non-linear decay to improve exploration and exploitation.", "configspace": "", "generation": 70, "fitness": 0.2031343258710002, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.203 with standard deviation 0.003. And the mean value of best solutions found was 0.449 (0. is the best) with standard deviation 0.025.", "error": "", "parent_id": "cda261d0-a898-4a4c-994a-d73c027e8f93", "metadata": {"aucs": [0.20102486850518075, 0.2068086793550048, 0.201569429752815], "final_y": [0.4694425555687318, 0.4137496153613146, 0.46469205749927356]}, "mutation_prompt": null}
{"id": "b81c1897-783f-408b-acf1-2c99ee99b033", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                # Use neighborhood diversity for velocity adjustment\n                neighborhood_diversity = np.std(positions[neighbors_indices], axis=0).mean()\n                scaling_factor = (self.budget - evaluations) / self.budget * neighborhood_diversity\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Incorporate an adaptive velocity scaling mechanism based on neighborhood diversity to improve convergence.", "configspace": "", "generation": 71, "fitness": 0.2030698413367276, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.203 with standard deviation 0.003. And the mean value of best solutions found was 0.450 (0. is the best) with standard deviation 0.026.", "error": "", "parent_id": "cda261d0-a898-4a4c-994a-d73c027e8f93", "metadata": {"aucs": [0.20083635867759175, 0.20680373557977605, 0.201569429752815], "final_y": [0.47239265783783124, 0.41379549904142665, 0.46469205749927356]}, "mutation_prompt": null}
{"id": "ded5c911-fc1e-42ca-b797-d01d201d5a60", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                # Introduced adaptive velocity adjustment with mutation\n                mutation = np.random.normal(0, 0.1, self.dim) if np.random.rand() < 0.1 else 0\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i]) + mutation) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introduced adaptive velocity adjustment with mutation for enhanced exploration.", "configspace": "", "generation": 72, "fitness": 0.24785937928131727, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cda261d0-a898-4a4c-994a-d73c027e8f93", "metadata": {"aucs": [0.2477415238008256, 0.2478935980450051, 0.24794301599812107], "final_y": [0.16485577218490555, 0.16485577225279813, 0.1648557720044329]}, "mutation_prompt": null}
{"id": "28715705-2170-4529-a344-a1c6bda6a8b9", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n        self.scouting_rate = 0.1  # New parameter for scouting\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                # Introduce random scouting to explore new solutions\n                if np.random.rand() < self.scouting_rate:\n                    positions[i] = np.random.uniform(lb, ub, self.dim)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced solution diversity by introducing random scouting agents to explore new regions in the search space.", "configspace": "", "generation": 73, "fitness": 0.2472128593494082, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.247 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cda261d0-a898-4a4c-994a-d73c027e8f93", "metadata": {"aucs": [0.24685143265057286, 0.24732810877500566, 0.24745903662264612], "final_y": [0.16495910028854277, 0.16489336881168648, 0.16497057212672717]}, "mutation_prompt": null}
{"id": "4c2c3e59-c6c5-4464-8331-9f5e1b84ec15", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * np.random.rand()  # Modified line\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)  # Modified line\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Improved on adaptive cognitive and social coefficients for better convergence.", "configspace": "", "generation": 74, "fitness": 0.24770593504219462, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "cda261d0-a898-4a4c-994a-d73c027e8f93", "metadata": {"aucs": [0.24794579278778672, 0.247439473200588, 0.24773253913820914], "final_y": [0.16487799194382424, 0.16609176228602152, 0.16515586983166441]}, "mutation_prompt": null}
{"id": "9906c016-9c26-45fd-b81b-231562ccdc03", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                # Perturb velocities to enhance exploration\n                velocities[i] += np.random.uniform(-0.1, 0.1, self.dim) * scaling_factor\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)  # Modified line\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhance solution diversification by introducing velocity perturbation during exploration.", "configspace": "", "generation": 75, "fitness": 0.24767319946630628, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cda261d0-a898-4a4c-994a-d73c027e8f93", "metadata": {"aucs": [0.24782284182499204, 0.2479102210071713, 0.2472865355667555], "final_y": [0.16485577657126294, 0.16485577598791168, 0.16485577591744383]}, "mutation_prompt": null}
{"id": "a59f32dc-3c50-4513-bf90-548de0426a9a", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand()) * (1 - evaluations / self.budget)  # Modified line\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced adaptive social coefficient to boost convergence rate near optimum.", "configspace": "", "generation": 76, "fitness": 0.24782423794718056, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cda261d0-a898-4a4c-994a-d73c027e8f93", "metadata": {"aucs": [0.24788785048357875, 0.2478201198243134, 0.24776474353364952], "final_y": [0.16507986820337406, 0.16503902522513003, 0.16488009661889713]}, "mutation_prompt": null}
{"id": "34369d8a-e364-4141-92b7-fb50a794f045", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)  # Modified line\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n            if np.random.rand() < 0.1:  # Stochastic escape mechanism\n                global_best_position += np.random.normal(0, 0.1, self.dim)\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introduced a stochastic escape mechanism to avoid premature convergence by occasionally perturbing the global best with a small random displacement.", "configspace": "", "generation": 77, "fitness": 0.2477653505220603, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cda261d0-a898-4a4c-994a-d73c027e8f93", "metadata": {"aucs": [0.24779652902413696, 0.24778893036779415, 0.24771059217424984], "final_y": [0.16491161903330342, 0.16485791671992045, 0.16487909762055508]}, "mutation_prompt": null}
{"id": "8a24d35b-2c17-49d2-87d3-91c88c2d7c1f", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                stochastic_perturbation = np.random.normal(0, 1, self.dim) * (self.budget - evaluations) / self.budget  # Added line\n                positions[i] = positions[i] + velocities[i] + stochastic_perturbation  # Modified line\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)  # Modified line\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced the solution update mechanism by introducing a decaying stochastic perturbation for improved exploration.", "configspace": "", "generation": 78, "fitness": 0.24785516909159036, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cda261d0-a898-4a4c-994a-d73c027e8f93", "metadata": {"aucs": [0.24752818040392344, 0.24807432759541648, 0.2479629992754312], "final_y": [0.16485669243066348, 0.1648565408146947, 0.16485667652259517]}, "mutation_prompt": null}
{"id": "996e3807-65df-432e-af5b-0790cdedb19d", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand())\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            # Adaptive inertia weight\n            self.inertia_weight = np.clip(self.inertia_weight * (1.0 + 0.1 * (global_best_score < np.mean(personal_best_scores))), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Integrated adaptive inertia weight based on performance progress for enhanced exploration and exploitation balance.", "configspace": "", "generation": 79, "fitness": 0.24786144961853307, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cda261d0-a898-4a4c-994a-d73c027e8f93", "metadata": {"aucs": [0.24792398630029133, 0.2477311028078577, 0.24792925974745017], "final_y": [0.1648707323756079, 0.16489465353836974, 0.16502374550505317]}, "mutation_prompt": null}
{"id": "5bfeb08f-0096-4e24-9855-1b382f3554bc", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                # Line to be slightly modified\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand() * (1 - global_best_score / max(personal_best_scores)))\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)  # Modified line\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced velocity update by introducing dynamic social coefficient variability based on global score improvement.", "configspace": "", "generation": 80, "fitness": 0.24786747909521858, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cda261d0-a898-4a4c-994a-d73c027e8f93", "metadata": {"aucs": [0.2480085619877761, 0.24769395182045995, 0.24789992347741974], "final_y": [0.16485670578113165, 0.1655930061874199, 0.16512979889785684]}, "mutation_prompt": null}
{"id": "f10448e1-8bf6-4947-8fec-d37906a2c617", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand() * (1 - global_best_score / max(personal_best_scores)))\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - ((0.5 / (self.budget / self.population_size)) * evaluations / self.budget), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)  # Modified line\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introduce adaptive inertia weight scaling based on the current evaluation ratio and improved balance between exploration and exploitation.", "configspace": "", "generation": 81, "fitness": 0.24786747909521858, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5bfeb08f-0096-4e24-9855-1b382f3554bc", "metadata": {"aucs": [0.2480085619877761, 0.24769395182045995, 0.24789992347741974], "final_y": [0.16485670578113165, 0.1655930061874199, 0.16512979889785684]}, "mutation_prompt": null}
{"id": "2bc7e75d-80e4-4732-9827-400ca464e019", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand() * (1 - global_best_score / max(personal_best_scores)))\n\n                scaling_factor = 1.0 - (evaluations / self.budget)  # Modified line for fitness-scaling\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / (self.temperature * scaling_factor)):  # Modified line\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced adaptive mechanisms by introducing a fitness-scaling factor and a velocity damping approach for fine-tuned convergence.", "configspace": "", "generation": 82, "fitness": 0.24786747909521858, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5bfeb08f-0096-4e24-9855-1b382f3554bc", "metadata": {"aucs": [0.2480085619877761, 0.24769395182045995, 0.24789992347741974], "final_y": [0.16485670578113187, 0.1655930061874199, 0.16512979889785684]}, "mutation_prompt": null}
{"id": "8b862b07-f8a4-4d2a-aa25-1dba45474d31", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                \n                # Modified Line: Use relative difference for social coefficient\n                avg_personal_best_score = np.mean(personal_best_scores)\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand() * (1 - (global_best_score / avg_personal_best_score)))\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Implement a dynamic adjustment to the social coefficient based on the relative difference between the global best score and the average personal best score.", "configspace": "", "generation": 83, "fitness": 0.24774459779811409, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5bfeb08f-0096-4e24-9855-1b382f3554bc", "metadata": {"aucs": [0.24789821967976267, 0.2477697417993604, 0.2475658319152192], "final_y": [0.16527915165311668, 0.1649618515736223, 0.16544907122582464]}, "mutation_prompt": null}
{"id": "0c4c5fdc-ea90-459e-8210-38a922ecc184", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand() * (1 - global_best_score / max(personal_best_scores)))\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                # Modified line to introduce dynamic inertia weight\n                inertia = self.min_inertia_weight + (self.max_inertia_weight - self.min_inertia_weight) * (1 - evaluations / self.budget)\n                velocities[i] = (inertia * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Refine ImprovedPSOSA by introducing a dynamic inertia weight based on the ratio of current evaluations to budget.", "configspace": "", "generation": 84, "fitness": 0.24579501318138597, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.000. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "5bfeb08f-0096-4e24-9855-1b382f3554bc", "metadata": {"aucs": [0.24621876369522744, 0.24530264945869684, 0.24586362639023362], "final_y": [0.16520505361673588, 0.16661937557851403, 0.16851978610891682]}, "mutation_prompt": null}
{"id": "ec2e6d6c-29b1-4768-ac8e-e7ee6d0a5873", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand() * (1 - global_best_score / max(personal_best_scores)))\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / np.sqrt(self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)  # Modified line\n            self.temperature *= self.cooling_rate * (1.5 * evaluations / self.budget)  # Modified line\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Refined inertia adaptation and enhanced temperature scaling for dynamic exploration-exploitation balance.", "configspace": "", "generation": 85, "fitness": 0.24786747909521858, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5bfeb08f-0096-4e24-9855-1b382f3554bc", "metadata": {"aucs": [0.2480085619877761, 0.24769395182045995, 0.24789992347741974], "final_y": [0.16485670578113165, 0.1655930061874199, 0.16512979889785684]}, "mutation_prompt": null}
{"id": "48fc10aa-ec86-4b02-adb0-37ac6bac7b3f", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n        success_count = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand() * (1 - global_best_score / max(personal_best_scores)))\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n                    success_count += 1\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            success_rate = success_count / self.population_size\n            self.inertia_weight = np.clip(self.inertia_weight * (1 - 0.5 * success_rate), self.min_inertia_weight, self.max_inertia_weight)  # Modified line\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Adaptive inertia weight based on success rate to balance exploration and exploitation.", "configspace": "", "generation": 86, "fitness": 0.24786747909521858, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5bfeb08f-0096-4e24-9855-1b382f3554bc", "metadata": {"aucs": [0.2480085619877761, 0.24769395182045995, 0.24789992347741974], "final_y": [0.16485670578113165, 0.1655930061874199, 0.16512979889785684]}, "mutation_prompt": null}
{"id": "5d085383-576a-4ce1-a983-29cdb389c31a", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                # Slight modification in adaptive_social_coeff calculation\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand() * np.exp(-evaluations/self.budget))\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced velocity update with a refined scaling factor for better convergence.", "configspace": "", "generation": 87, "fitness": 0.24786027496441387, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5bfeb08f-0096-4e24-9855-1b382f3554bc", "metadata": {"aucs": [0.2479326787540732, 0.24778047873460252, 0.2478676674045659], "final_y": [0.16494779074019406, 0.16501643517438713, 0.16512294955340534]}, "mutation_prompt": null}
{"id": "76cf611d-c757-4176-937d-18d226ebb3ec", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand() * (1 - global_best_score / max(personal_best_scores)))\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                # Introduced temperature-modulated random factor\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i]) * self.temperature) * scaling_factor\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)  # Modified line\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced historical position influence by introducing temperature-modulated random factor to velocity update.", "configspace": "", "generation": 88, "fitness": 0.2478273460084066, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5bfeb08f-0096-4e24-9855-1b382f3554bc", "metadata": {"aucs": [0.24793527926125147, 0.24801822191252954, 0.24752853685143883], "final_y": [0.16524208618463831, 0.1650508814097974, 0.1657902146358673]}, "mutation_prompt": null}
{"id": "c182839e-c564-45a3-a0cb-70a5f96d97b4", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Enhanced neighborhood size adaptability\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget * 0.5)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand() * (1 - global_best_score / max(personal_best_scores)))\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            # Modified inertia weight adaptation\n            self.inertia_weight = np.clip(self.inertia_weight - (0.3 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Adaptive neighborhood enhancement and inertia weight variability integration for improved convergence.", "configspace": "", "generation": 89, "fitness": 0.2478662961748066, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5bfeb08f-0096-4e24-9855-1b382f3554bc", "metadata": {"aucs": [0.24800854550792228, 0.24769040112824758, 0.24789994188824993], "final_y": [0.16485678711857255, 0.16561079944483836, 0.1651296541305154]}, "mutation_prompt": null}
{"id": "380f57d9-8aad-4b39-ac53-43df628c5f41", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand()) * (1 - global_best_score / max(personal_best_scores)) * (1 - evaluations / self.budget)\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(self.inertia_weight - (0.5 / (self.budget / self.population_size)), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced velocity update by incorporating a decay factor for dynamic social coefficient to ensure better convergence.", "configspace": "", "generation": 90, "fitness": 0.24758730306275256, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "5bfeb08f-0096-4e24-9855-1b382f3554bc", "metadata": {"aucs": [0.24773622615279356, 0.24729535217336063, 0.2477303308621035], "final_y": [0.16569667698196688, 0.16754137367981026, 0.1659760860921271]}, "mutation_prompt": null}
{"id": "2699496e-8aa8-482b-b180-1a0ee2f1abc5", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand() * (1 - global_best_score / max(personal_best_scores)))\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (self.inertia_weight * velocities[i] +  # Reduced randomness in inertia\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = max(self.min_inertia_weight, self.inertia_weight * 0.99)  # Modified inertia update\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Adaptive neighborhood-based PSO with momentum-driven velocity update and temperature-scaled acceptance.", "configspace": "", "generation": 91, "fitness": 0.24775873809558124, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5bfeb08f-0096-4e24-9855-1b382f3554bc", "metadata": {"aucs": [0.2477479896361816, 0.24771018746762807, 0.24781803718293405], "final_y": [0.16561015666537693, 0.1659348403144617, 0.16545623301359902]}, "mutation_prompt": null}
{"id": "45f93a3c-2b68-4eb3-a089-1b84688ce1ca", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand() * (1 - global_best_score / max(personal_best_scores)))\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(np.random.uniform(self.min_inertia_weight, self.max_inertia_weight), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introduced randomness in inertia weight for greater exploration.", "configspace": "", "generation": 92, "fitness": 0.24794535751509805, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5bfeb08f-0096-4e24-9855-1b382f3554bc", "metadata": {"aucs": [0.24806572974420282, 0.24786825528434941, 0.24790208751674192], "final_y": [0.16490527173236935, 0.16487960439456473, 0.16521335718218]}, "mutation_prompt": null}
{"id": "ab280026-7419-45ef-8e68-c1e6ec89564d", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idxs = np.argsort(personal_best_scores[neighbors_indices])[:2]\n                local_best_position = np.mean([personal_best_positions[neighbors_indices[idx]] for idx in local_best_idxs], axis=0)\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand() * (1 - global_best_score / max(personal_best_scores)))\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(np.random.uniform(self.min_inertia_weight, self.max_inertia_weight), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced selection of the local best solution by considering the top two neighborhood solutions.", "configspace": "", "generation": 93, "fitness": 0.247889903406563, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "45f93a3c-2b68-4eb3-a089-1b84688ce1ca", "metadata": {"aucs": [0.24791606849733017, 0.24787455739461162, 0.2478790843277472], "final_y": [0.16501164290796244, 0.16520714928488645, 0.1650847592675937]}, "mutation_prompt": null}
{"id": "6207f8e8-1743-4032-9020-08b1d75bc903", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand() * (1 - global_best_score / max(personal_best_scores)))\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                # Line 1: Introduce inertia weight decay\n                inertia_weight = self.inertia_weight * scaling_factor\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                # Line 2: Introduce mutation step\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i] + np.random.normal(0, 0.1, self.dim)\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(np.random.uniform(self.min_inertia_weight, self.max_inertia_weight), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced exploration by introducing inertia weight decay and a mutation step.", "configspace": "", "generation": 94, "fitness": 0.2478669242245576, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "45f93a3c-2b68-4eb3-a089-1b84688ce1ca", "metadata": {"aucs": [0.24804793305854023, 0.24775670098347136, 0.24779613863166128], "final_y": [0.16485891889999538, 0.1652705062609795, 0.16500099555517178]}, "mutation_prompt": null}
{"id": "be483e9d-205c-495e-b958-089db27a0429", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                # Adjusted neighborhood size dynamically\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand() * (1 - global_best_score / max(personal_best_scores)))\n\n                scaling_factor = (self.budget - evaluations) / self.budget\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(np.random.uniform(self.min_inertia_weight, self.max_inertia_weight), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)**0.5  # Changed line for adaptive temperature scaling\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introduced adaptive temperature scaling to enhance exploration near the budget limits.", "configspace": "", "generation": 95, "fitness": 0.24781171726442086, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "45f93a3c-2b68-4eb3-a089-1b84688ce1ca", "metadata": {"aucs": [0.24802834107846328, 0.248010638602419, 0.2473961721123803], "final_y": [0.1648923153854892, 0.16485691688456583, 0.16582831928782227]}, "mutation_prompt": null}
{"id": "5866d1dc-4466-448a-91db-a668fb44a412", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand() * (1 - global_best_score / max(personal_best_scores)))\n\n                scaling_factor = np.sin(np.pi * (self.budget - evaluations) / (2 * self.budget))  # changed line\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(np.random.uniform(self.min_inertia_weight, self.max_inertia_weight), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Enhanced exploration by adjusting velocity scaling with a non-linear function.", "configspace": "", "generation": 96, "fitness": 0.24797577617657438, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "45f93a3c-2b68-4eb3-a089-1b84688ce1ca", "metadata": {"aucs": [0.24802390216870462, 0.24793306277111704, 0.24797036358990143], "final_y": [0.16485674048128474, 0.1649380565034817, 0.164980940985601]}, "mutation_prompt": null}
{"id": "d4784260-cd92-493b-845d-fb6fc0947218", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand() * (1 - global_best_score / max(personal_best_scores)))\n\n                scaling_factor = np.sin(np.pi * (self.budget - evaluations) / (2 * self.budget))\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(np.random.uniform(self.min_inertia_weight, self.max_inertia_weight), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introducing a dynamic inertia weight adjustment based on the evaluation ratio to enhance convergence speed and solution quality.", "configspace": "", "generation": 97, "fitness": 0.24797577617657438, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.248 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5866d1dc-4466-448a-91db-a668fb44a412", "metadata": {"aucs": [0.24802390216870462, 0.24793306277111704, 0.24797036358990143], "final_y": [0.16485674048128474, 0.1649380565034817, 0.164980940985601]}, "mutation_prompt": null}
{"id": "90022b5f-4181-4158-abb2-4355f1daf37e", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                dynamic_neighborhood_size = min(self.population_size, int(self.neighborhood_size * (1 + evaluations / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (0.5 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (0.5 + 0.5 * np.random.rand() * (1 - global_best_score / max(personal_best_scores)))\n\n                scaling_factor = np.sin(np.pi * (self.budget - evaluations) / (2 * self.budget))\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * np.std(positions, axis=0).mean() * velocities[i] +  # changed line\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  \n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor \n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(np.random.uniform(self.min_inertia_weight, self.max_inertia_weight), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Improved global convergence by scaling inertia weight with position diversity.", "configspace": "", "generation": 98, "fitness": 0.20834707846025113, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.208 with standard deviation 0.002. And the mean value of best solutions found was 0.400 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "5866d1dc-4466-448a-91db-a668fb44a412", "metadata": {"aucs": [0.2109313800251561, 0.20680373557977605, 0.20730611977582125], "final_y": [0.3775421926934007, 0.41379549904142665, 0.40904983441970155]}, "mutation_prompt": null}
{"id": "cdd2e73d-eaf5-4372-96b8-7d3143cd4380", "solution": "import numpy as np\n\nclass ImprovedPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.min_inertia_weight = 0.4\n        self.max_inertia_weight = 1.2\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.neighborhood_size = 5\n        self.alpha = 0.5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(x) for x in positions])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n\n                dynamic_neighborhood_size = max(3, int(self.neighborhood_size * (1 + (self.budget - evaluations) / self.budget)))\n                neighbors_indices = np.random.choice(self.population_size, dynamic_neighborhood_size + 2, replace=False)\n                local_best_idx = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_idx]\n\n                historical_best_position = self.alpha * personal_best_positions[i] + (1 - self.alpha) * global_best_position\n\n                adaptive_cognitive_coeff = self.cognitive_coeff * (1 + 0.5 * np.random.rand())\n                adaptive_social_coeff = self.social_coeff * (1 + 0.5 * np.random.rand() * (1 - global_best_score / max(personal_best_scores)))\n\n                scaling_factor = np.cos(np.pi * (self.budget - evaluations) / (2 * self.budget)) \n\n                velocity_reliability = np.mean(personal_best_scores) / (personal_best_scores[i] + 1e-9)\n\n                velocities[i] = (np.random.uniform(self.min_inertia_weight, self.max_inertia_weight) * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) * velocity_reliability +\n                                 adaptive_social_coeff * r2 * (local_best_position - positions[i]) +\n                                 self.alpha * r3 * (historical_best_position - positions[i])) * scaling_factor\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], lb, ub)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_scores[i] = score\n\n                if score < global_best_score or np.random.rand() < np.exp((global_best_score - score) / self.temperature):\n                    global_best_position = positions[i]\n                    global_best_score = score\n\n            self.inertia_weight = np.clip(np.random.uniform(self.min_inertia_weight, self.max_inertia_weight), self.min_inertia_weight, self.max_inertia_weight)\n            self.temperature *= self.cooling_rate * (evaluations / self.budget)\n\n            if evaluations < self.budget:\n                global_best_idx = np.argmin(personal_best_scores)\n                if personal_best_scores[global_best_idx] < global_best_score:\n                    global_best_position = personal_best_positions[global_best_idx]\n                    global_best_score = personal_best_scores[global_best_idx]\n\n        return global_best_position", "name": "ImprovedPSOSA", "description": "Introduce a dynamic neighborhood size and adaptive velocity update based on collective information reliability.", "configspace": "", "generation": 99, "fitness": 0.2429465324005695, "feedback": "The algorithm ImprovedPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.243 with standard deviation 0.002. And the mean value of best solutions found was 0.177 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "5866d1dc-4466-448a-91db-a668fb44a412", "metadata": {"aucs": [0.24284281064806512, 0.2451259321769126, 0.24087085437673073], "final_y": [0.17702594489976653, 0.1692009779098762, 0.185283161876303]}, "mutation_prompt": null}
