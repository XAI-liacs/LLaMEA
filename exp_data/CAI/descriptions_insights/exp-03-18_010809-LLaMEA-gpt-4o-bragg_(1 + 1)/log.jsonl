{"id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm combines adaptive explorative-exploitative search using dynamic particle swarm concepts with random local perturbations to balance global and local search capabilities.", "configspace": "", "generation": 0, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": null, "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "ceb172af-a70f-497c-87c4-977dddd072f5", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim) * 2.0  # adjusted exploration factor\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances the exploration by adjusting the cognitive component, boosting global convergence.", "configspace": "", "generation": 1, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "df67c9cc-e7b6-48de-923d-5a760443823f", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            dynamic_perturbation = 0.1 * np.random.normal(loc=0, scale=iterations/self.budget, size=(self.budget, self.dim))\n            particles += velocities + dynamic_perturbation\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "This refined algorithm introduces a dynamic random perturbation factor to improve exploration capabilities without compromising convergence.", "configspace": "", "generation": 2, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "2bf3174c-8416-470f-8b8a-48ee0037f88d", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities * 0.9 + 0.1 * np.random.normal(size=(self.budget, self.dim))  # Improved\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "An enhanced dynamic particle swarm optimization algorithm utilizing adaptive inertia with improved velocity update for efficient exploration and exploitation.", "configspace": "", "generation": 3, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "06fab0e9-f089-4670-9253-c9cf6c88ea2e", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.3 / (1 + iterations))  # refined adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "A refined adaptive inertia weight strategy is employed to enhance convergence and exploration balance in dynamic particle swarm optimization.", "configspace": "", "generation": 4, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "bb895c13-1c1e-4671-9022-7e50dbb4e3c2", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with dynamically adjusted local random perturbations\n            perturbation_factor = 0.1 - 0.05 * (iterations / self.budget)\n            particles += velocities + perturbation_factor * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances diversity by adjusting the local random perturbation factor dynamically based on iteration progress.", "configspace": "", "generation": 5, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "57e2500e-c851-45c6-be25-2d03af70730e", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.7 - 0.5 * (iterations / self.budget)  # refined adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm refines the adaptive inertia weight to enhance convergence in the explorative-exploitative balance.", "configspace": "", "generation": 6, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "ed1ff42f-a8c8-4175-928a-9ffba698101b", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim)) * (0.95 ** iterations)\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm adapts dynamic particle swarm concepts enhanced by a non-static random local perturbation for improved exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "84d06134-b357-4b8c-b525-efb2265f1d6a", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with dynamically adjusted local random perturbations\n            particles += velocities + 0.1 * np.random.normal(scale=(1 - iterations/self.budget), size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm dynamically adjusts the local random perturbations to improve balance between exploration and exploitation.", "configspace": "", "generation": 8, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "e7b09b6f-ea93-4149-81ef-d59dfa50a289", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n            \n            # Apply small mutation for enhanced exploration\n            particles += 0.01 * np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances diversity by introducing a small mutation factor to positions after updating, improving exploration capability.", "configspace": "", "generation": 9, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "b0eb8a64-5895-47e0-b103-d0d1ba9b83de", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.9 - 0.4 * (iterations / self.budget)  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                2.05 * cognitive_component * (personal_best_positions - particles) + \n                2.05 * social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Enhanced inertia weight adaptation and velocity update mechanism in the particle swarm to improve convergence.", "configspace": "", "generation": 10, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "12e4458a-aa5f-4832-9381-05e64ca3ea2a", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.9 * (0.5 ** (iterations / self.budget))  # nonlinear decay for inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Improved inertia weight adaptation by introducing a nonlinear decay for enhanced balance between exploration and exploitation.", "configspace": "", "generation": 11, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "11a1b616-f89a-4314-9509-0e3b8491f64c", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n            \n            learning_rate = 0.5 * (1 - iterations / self.budget)  # New dynamic learning rate\n\n            velocities = (\n                inertia_weight * velocities +\n                learning_rate * cognitive_component * (personal_best_positions - particles) + \n                learning_rate * social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Enhances convergence by introducing a dynamic learning rate that decreases over time to fine-tune the balance between exploration and exploitation.", "configspace": "", "generation": 12, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "82df1123-618e-42b3-b37b-a72415b367f1", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim) * (1 - iterations/self.budget)  # Changed line\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Enhancing the exploration of global optima by adapting cognitive and social component randomization based on iteration count.", "configspace": "", "generation": 13, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "b17eb879-7ed4-496a-a30f-b8cf4bd176bb", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with adaptive local random perturbations\n            adaptive_perturbation = 0.1 * (1 - iterations / self.budget) \n            particles += velocities + adaptive_perturbation * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm now uses an adaptive local perturbation factor to enhance convergence towards the best solutions.", "configspace": "", "generation": 14, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "0345e327-9630-4a38-9bc8-97b12827d1e1", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with increased local random perturbations\n            particles += velocities + 0.15 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances global search by increasing the random perturbation factor to improve exploration.", "configspace": "", "generation": 15, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "a08915f2-da6c-4a39-b25a-69fc0f4f4fd8", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with chaotic local perturbations\n            particles += velocities + 0.1 * np.sin(iterations) * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm employs a balanced mix of adaptive explorative-exploitative search through dynamic particle swarm mechanics, incorporating chaotic perturbations for enhanced local search capabilities.", "configspace": "", "generation": 16, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "c830ac28-62a7-465c-a027-f0cbc8809a99", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n            learning_factor = 1.5 - (1.0 / (1 + iterations))  # adaptive learning factor\n\n            velocities = (\n                inertia_weight * velocities +\n                learning_factor * (cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles))\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm introduces an adaptive learning factor to dynamically adjust the influence of personal and global best positions, enhancing the balance between exploration and exploitation.", "configspace": "", "generation": 17, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "967b1ad0-7690-4163-8690-d25bd9fab812", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with adaptively scaled local random perturbations\n            scale = 0.1 * (1 - iterations / self.budget)\n            particles += velocities + scale * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances global exploration and local exploitation by adaptively scaling random perturbations based on convergence progress.", "configspace": "", "generation": 18, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "37169c59-854d-404c-900c-f9890295d05f", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = 0.5 + 0.5 * np.random.rand(self.budget, self.dim)  # dynamic social component\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm introduces a dynamic adjustment of the social component factor in the velocity update to improve convergence speed and solution quality.", "configspace": "", "generation": 19, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "17248231-832f-4f0e-b334-6b907d4e6c4a", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            decay_factor = 1 - (iterations / self.budget)  # decay factor for components\n            cognitive_component = decay_factor * np.random.rand(self.budget, self.dim)\n            social_component = decay_factor * np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm introduces a decay factor to the cognitive and social components to dynamically balance exploration and exploitation as iterations progress.", "configspace": "", "generation": 20, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "27c51402-6cad-491a-800b-d1d0654df95f", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.3 / (1 + iterations))  # refined adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm refines adaptive inertia weight and local random perturbations for enhanced exploration-exploitation balance.", "configspace": "", "generation": 21, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "70d3716e-8bca-499d-88cb-41fc33b4ad0d", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with adaptive local random perturbations\n            perturbation_scale = 0.1 * (1 - (iterations / self.budget))\n            particles += velocities + perturbation_scale * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Introduce adaptive local perturbation scaling to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 22, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "5c3445df-717c-4557-9dfc-5da260730fd1", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.05 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm leverages adaptive inertia and global best strategies combined with position updates using limited local perturbations for efficient convergence.", "configspace": "", "generation": 23, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "e7b715b0-c66c-47a9-b361-f0dc22043417", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n            \n            # Introduce a convergence acceleration factor\n            convergence_factor = 1.05\n\n            velocities = (\n                convergence_factor * (inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles))\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm introduces a convergence acceleration factor in the velocity update to enhance search efficiency.", "configspace": "", "generation": 24, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "24101057-6a2f-4f11-8e4e-82449f06fe17", "solution": "# Description: The algorithm enhances the exploitation phase by dynamically adjusting velocity update equations to improve convergence speed and precision.\n# Code:\nimport numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) * 0.9 +  # Adjusted cognitive scaling factor\n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances the exploitation phase by dynamically adjusting velocity update equations to improve convergence speed and precision.", "configspace": "", "generation": 25, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "d74d30f7-91e3-491e-97e4-4d261c2f6268", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim) * (0.5 + 0.5 / (iterations + 1))\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm refines by adjusting the weights of the cognitive and social components dynamically based on iterations to improve convergence speed.", "configspace": "", "generation": 26, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "fe0730c5-a256-499b-b135-a43ccd46293e", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            perturbation = 0.1 * (1 - iterations / self.budget)  # progressive reduction\n            particles += velocities + perturbation * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm introduces a progressive reduction in local perturbation size to enhance convergence towards the optimum as iterations progress.", "configspace": "", "generation": 27, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "57a540af-88e4-42b8-8360-bc693e90c79d", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n            \n            # Introduce small probability for random jumps\n            random_jump = np.random.rand(self.budget) < 0.01  # 1% chance\n            particles[random_jump] = np.random.uniform(low=lb, high=ub, size=(np.sum(random_jump), self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances global exploration by introducing a small probability for particles to jump to random positions within bounds, aiming to escape local optima.", "configspace": "", "generation": 28, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "4fa84b74-a9cf-42f5-b501-a2bd6861f348", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n\n            # Dynamic cognitive and social components\n            cognitive_component = np.random.rand(self.budget, self.dim) * (1 - iterations / self.budget)\n            social_component = np.random.rand(self.budget, self.dim) * (iterations / self.budget)\n\n            velocities = (\n                inertia_weight * velocities + \n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Enhance exploration by incorporating dynamic adjustment of cognitive and social coefficients based on iteration progress.", "configspace": "", "generation": 29, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "6b1d3c6a-d160-42cc-8afc-69de0072709a", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            perturbation_scale = 0.1 * (1 - iterations / self.budget)  # dynamic perturbation scale\n            particles += velocities + perturbation_scale * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances its particle update strategy by implementing a dynamic local perturbation scale based on the iteration count to improve convergence rates.", "configspace": "", "generation": 30, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "0d4bf87b-4de3-41e2-bba0-4f2459820276", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with dampened local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim)) * (1 - iterations / self.budget)\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm uses a dampening local random perturbation factor to refine balance between exploration and exploitation over iterations.", "configspace": "", "generation": 31, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "672ba3b6-3012-44b4-9863-25f1c6db4df7", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.9 - (0.7 * iterations / self.budget)  # refined adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances adaptive inertia weights to improve exploration-exploitation balance while maintaining random local perturbations.", "configspace": "", "generation": 32, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "92568fa6-c129-470c-a98f-7171582de575", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.9 / (1 + 0.01 * iterations)  # adjusted adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Enhanced the adaptive inertia weight calculation for improved convergence speed.", "configspace": "", "generation": 33, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "79da6c17-ab6e-425c-a896-9d4986d8f1d6", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.05 * np.random.normal(size=(self.budget, self.dim))  # Adjusted perturbation\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm augments adaptive particle swarm optimization with an improved local search mechanism for nuanced exploration.", "configspace": "", "generation": 34, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "cc507d40-2feb-441e-a06d-3ef42a73217f", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + (0.1 - 0.05 * (iterations / self.budget)) * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Enhanced the exploration capability by adjusting the random perturbation for position updates based on iteration count.", "configspace": "", "generation": 35, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "dc04ac7c-0a1d-48b7-abfc-979ff9cd8dae", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.05 * np.random.normal(size=(self.budget, self.dim))  # Changed 0.1 to 0.05\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm integrates adaptive exploration-exploitation via dynamic particle swarm concepts with selective random local perturbations, enhancing balance and search efficiency.", "configspace": "", "generation": 36, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "f1df5d70-f249-407c-bed4-181d5b4d20d8", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with iteration-adaptive local random perturbations\n            perturbation_magnitude = 0.1 * (1 - iterations / self.budget)\n            particles += velocities + perturbation_magnitude * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances local search capabilities by adjusting the magnitude of random perturbations based on the iteration count.", "configspace": "", "generation": 37, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "de1c0e78-4d4e-4f12-819b-b97e09043136", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            # Changed line: Introducing sine-cosine mechanism for velocity update\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * np.sin(personal_best_positions - particles) + \n                social_component * np.cos(global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm introduces an adaptive velocity update mechanism based on a sine-cosine function to enhance exploration and exploitation balance.", "configspace": "", "generation": 38, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "aeba20ca-4ea7-4551-9c48-65457db5fbfe", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n                + 0.05 * np.sin(iterations * np.pi / self.budget) * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm integrates an adaptive non-linear velocity component to enhance convergence speed and diversity.", "configspace": "", "generation": 39, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "23db5810-d7c4-4ade-b67a-abce7971c54f", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * (1 - iterations / self.budget) * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances exploitation by introducing a dynamic reduction in random perturbations as iterations progress.", "configspace": "", "generation": 40, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "6645aab6-80a1-4c6b-b6c2-f097d64d15af", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with adaptive local random perturbations\n            perturbation_magnitude = 0.1 * (1 - iterations / self.budget)  # Dynamic adjustment\n            particles += velocities + perturbation_magnitude * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Enhance the explorative-exploitative balance by introducing dynamic adjustment of random perturbation magnitude based on the iteration progress.", "configspace": "", "generation": 41, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "c1cb8bc3-ccf9-4663-a864-3cd3195ed284", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + np.var(velocities)))  # enhanced adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Enhanced adaptive inertia weight to accelerate convergence by incorporating velocity variance.", "configspace": "", "generation": 42, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "8a87ed1c-1e4a-4469-b830-a5f8a324b987", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + inertia_weight * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances the exploration by introducing Gaussian noise scaled by the inertia weight, improving the balance between exploration and exploitation.", "configspace": "", "generation": 43, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "2a27c040-b9c7-42b0-87f6-b1b9c26e17b6", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with dynamic local random perturbations\n            perturbation_factor = 0.1 * (1 - iterations / self.budget)\n            particles += velocities + perturbation_factor * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm introduces a dynamic local perturbation factor based on iteration progression for enhanced local search control.", "configspace": "", "generation": 44, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "cf813111-d38b-4187-b3fc-d3bc40a2eb03", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n            \n            # Time-varying acceleration coefficients\n            acceleration_coefficient = 2.0 - ((2.0 - 0.5) * (iterations / self.budget))\n\n            velocities = (\n                inertia_weight * velocities +\n                acceleration_coefficient * cognitive_component * (personal_best_positions - particles) + \n                acceleration_coefficient * social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm leverages adaptive explorative-exploitative search using dynamic particle swarm concepts with enhanced velocity update based on a time-varying acceleration coefficient to improve convergence.", "configspace": "", "generation": 45, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "999d7986-3807-44cf-b0d1-6c8edc78959a", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n        last_global_best_score = np.inf  # track last global best score\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            improvement_rate = (last_global_best_score - global_best_score) / last_global_best_score if last_global_best_score > global_best_score else 0\n            perturbation_factor = 0.1 + 0.1 * improvement_rate  # dynamic perturbation factor\n            particles += velocities + perturbation_factor * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            last_global_best_score = global_best_score  # update last global best score\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm refines exploration by introducing a variable perturbation factor, which dynamically adjusts based on the improvement rate of the global best score.", "configspace": "", "generation": 46, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "6554c9ac-57cf-4cc7-a597-05ed1fdf9423", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations and dynamic boundary adaptation\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n            # Ensure particles are within dynamic bounds\n            particles = np.clip(particles, lb + 0.1*(ub-lb), ub - 0.1*(ub-lb))\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The refined algorithm introduces dynamic boundary adaptation to enhance exploration and exploitation in the search space while maintaining balance.", "configspace": "", "generation": 47, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "d31fefa9-8572-4c58-8a21-407fc6a65ef1", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n            \n            decay_factor = 0.99  # New decay factor for velocity to enhance convergence\n            velocities = (\n                decay_factor * (inertia_weight * velocities) +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Improved velocity update by introducing a decay factor to enhance convergence.", "configspace": "", "generation": 48, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "f044efa9-3451-464b-b57f-16c368a6a2de", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            # Dynamic adaptive mutation rate\n            mutation_rate = 0.1 - (0.1 * iterations / self.budget)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + mutation_rate * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances convergence by adding a dynamic adaptive mutation rate to the velocity update process, improving both exploration and exploitation.", "configspace": "", "generation": 49, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "ac9213a2-1c36-4e40-92f1-3cd75a3876a7", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.9 - (0.9 / self.budget) * iterations  # nonlinear decreasing inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm incorporates a nonlinear decreasing inertia weight, enhancing convergence speed by dynamically adjusting exploration and exploitation balance.", "configspace": "", "generation": 50, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "b376de31-1708-4097-8288-f604ec472dc5", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim)) * np.random.uniform(-1, 1, size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm introduces an adaptive stochastic perturbation in the particle update process to enhance global exploration while maintaining local search capabilities.", "configspace": "", "generation": 51, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "1c33a5fb-1c38-4860-943f-1ca3f19da954", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with Levy flight\n            levy_flight = 0.1 * np.random.standard_cauchy(size=(self.budget, self.dim))\n            particles += velocities + levy_flight\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances local search by implementing a Levy flight mechanism, providing diverse particle movements and improved exploitation of promising regions.", "configspace": "", "generation": 52, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "0b743181-23e2-46da-b92a-8aef7987f37c", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.9 - (0.5 * iterations / self.budget)  # time-varying inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Improve inertia weight adaptability using a time-varying approach for enhanced convergence.", "configspace": "", "generation": 53, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "c253cdec-7870-4da4-be94-63394a29dcdd", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations)) * 0.99  # adaptive inertia weight with decay\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm refines the adaptive inertia weight by introducing a small decay factor to enhance convergence speed.", "configspace": "", "generation": 54, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "0bcfbde3-e286-42c6-98f2-4fbd04ba0116", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.9 - (0.5 * iterations / self.budget)  # refined adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances the inertia weight adaptation to improve convergence stability, refining exploration to exploitation transition.", "configspace": "", "generation": 55, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "1a165526-1d71-465e-915d-4e76399f8007", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Introduce periodic velocity reset\n            if iterations % 10 == 0:\n                velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Enhance exploration by introducing periodic velocity resetting to prevent premature convergence.", "configspace": "", "generation": 56, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "4fe4757b-f601-459c-a4a2-75e2e59ddc28", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                np.power(cognitive_component, 2) * (personal_best_positions - particles) + \n                np.power(social_component, 2) * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * (1 / inertia_weight) * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances balance between exploration and exploitation by introducing a non-linear velocity update and adaptive perturbation scaling.", "configspace": "", "generation": 57, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "bddb7515-eecc-4f22-910d-9b3fdb294682", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.9 - (0.8 * iterations / self.budget)  # refined adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm uses a refined adaptive inertia weight to enhance the balance between exploration and exploitation in the dynamic particle swarm process.", "configspace": "", "generation": 58, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "f4505d0e-8f39-45a4-9d87-c06f4652d419", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles) +\n                np.tan(np.random.rand(self.budget, self.dim)) * 0.01  # Added chaotic factor\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Enhance global exploration by introducing a chaotic factor in velocity updates to improve convergence speed.", "configspace": "", "generation": 59, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "afcf7949-464b-48b9-a68d-5c0cd9d2ac12", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                1.5 * cognitive_component * (personal_best_positions - particles) + \n                1.5 * social_component * (global_best_position - particles)\n            )\n\n            # Position update with refined local random perturbations\n            particles += velocities + 0.05 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm refines the perturbation mechanism and velocity update strategy to enhance convergence efficiency.", "configspace": "", "generation": 60, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "e3635bfd-6902-4e71-8409-58f082afdefd", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim) * (1.0 - iterations / self.budget)  # dynamic cognitive component\n            social_component = np.random.rand(self.budget, self.dim) * (iterations / self.budget)  # dynamic social component\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Introduce dynamic learning rates for cognitive and social components in the velocity update to enhance the balance between exploration and exploitation.", "configspace": "", "generation": 61, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "1a9ba87a-1b98-47c2-97be-b8ee1f037db8", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.uniform(0.5, 1.5, (self.budget, self.dim))  # slight change here\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm integrates dynamic particle swarm optimization with adaptive inertia and cognitive factors, along with random local perturbations, to enhance black box optimization performance.", "configspace": "", "generation": 62, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "9feeae0a-e14a-4bce-bd9c-e055e64e7e24", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + 0.1 * iterations**0.5))  # modified adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Enhances the convergence rate by introducing a non-linear decay factor to the inertia weight, improving balance between exploration and exploitation.", "configspace": "", "generation": 63, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "61828d55-e142-4305-b7a2-4c644e00c4db", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with iteration-adjusted local random perturbations\n            perturbation_amplitude = 0.1 * (1 - iterations / self.budget)  # Adjusted perturbation\n            particles += velocities + perturbation_amplitude * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances local exploitation by adjusting the amplitude of local perturbations based on the iteration progress to improve the balance between exploration and exploitation.", "configspace": "", "generation": 64, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "58d6d968-3531-49c1-91bc-29f13e9214e1", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n            learning_factor = 2.0 - ((2.0 / self.budget) * iterations)  # dynamic learning factor\n\n            velocities = (\n                inertia_weight * velocities +\n                learning_factor * (cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles))\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances convergence by introducing a dynamic learning factor in the velocity update to adaptively balance exploration and exploitation.", "configspace": "", "generation": 65, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "32ed2d38-37ef-448d-af7c-c20c33d6cb24", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim) / (1 + iterations)  # adaptive cognitive component\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances the balance between exploration and exploitation by introducing an adaptive cognitive component scaling with inverse iterations.", "configspace": "", "generation": 66, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "70aab946-19d6-431a-bc13-3ac4e4fc36f6", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            # Modified velocity update formula for enhanced exploration/exploitation\n            velocities = (\n                inertia_weight * velocities +\n                2 * cognitive_component * (personal_best_positions - particles) + \n                2 * social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Enhance the algorithm by adjusting the velocity update formula to better exploit personal and global best positions, potentially improving convergence speed and solution quality.", "configspace": "", "generation": 67, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "4d69b44b-65ca-41a7-83c3-1581cdb2738f", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n            \n            # Dynamic learning factor based on iteration progress\n            learning_factor = (1 + np.cos(np.pi * iterations / self.budget)) / 2\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) * learning_factor + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Enhancing exploration and exploitation by introducing a dynamic learning factor in velocity update based on iteration progress.", "configspace": "", "generation": 68, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "4aa1aa07-4aab-4479-8a1a-046cababb002", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with iteration-based local random perturbations\n            perturbation_magnitude = 0.1 * (1 - iterations / self.budget)\n            particles += velocities + perturbation_magnitude * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Enhanced particle exploration by varying the local perturbation's magnitude based on iteration, improving convergence.", "configspace": "", "generation": 69, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "6b180e7f-b3a0-44e1-bfb9-01628b89d4ed", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            # Calculate dynamic learning rate\n            learning_rate = 0.5 * (1 + np.tanh((global_best_score - personal_best_scores) / self.budget))\n\n            velocities = (\n                inertia_weight * velocities +\n                learning_rate[:, None] * (cognitive_component * (personal_best_positions - particles)) + \n                learning_rate[:, None] * (social_component * (global_best_position - particles))\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm introduces a dynamic learning rate into the velocity update equation to enhance convergence speed and accuracy by adjusting the influence of personal and global best positions based on their relative scores.", "configspace": "", "generation": 70, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "cc338887-9750-461d-aa72-3f6114df36d9", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with decreasing local random perturbations\n            particles += velocities + (0.1 / (1 + iterations)) * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm refines adaptive search by adjusting velocity updates using a dynamically decreasing random local perturbation to enhance solution stability.", "configspace": "", "generation": 71, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "105b4873-f7d1-4965-a1b1-a5ccbae0454e", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.9 - (iterations / (2 * self.budget))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm uses an adaptive inertia weight to enhance the balance between exploration and exploitation in the particle swarm optimization process.", "configspace": "", "generation": 72, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "d290d9a4-5e74-4707-b8ae-8ccece9c3237", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            convergence_factor = 0.9 * (iterations / self.budget)  # convergence factor\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) * convergence_factor + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances the explorative-exploitative balance by introducing a convergence factor to modulate the influence of personal best positions.", "configspace": "", "generation": 73, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "f4314a6d-5a57-412e-aba8-2ca4aabf27ad", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with iteration-dependent local random perturbations\n            particles += velocities + (0.1 - 0.09 * (iterations / self.budget)) * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances dynamic particle swarm optimization by adjusting the random local perturbations based on iteration progress to improve balance between exploration and exploitation.", "configspace": "", "generation": 74, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "5f4395b4-e6b6-4e4a-8383-c44e57f783f2", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim) * (1 - iterations / self.budget)  # dynamic adjustment\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm improves convergence speed by dynamically adjusting the cognitive component based on the iteration count.", "configspace": "", "generation": 75, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "239f35d9-44d6-42c1-ae41-6bc0f06bfa40", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with dynamic local random perturbations\n            particles += velocities + (0.1 * (1 - iterations / self.budget)) * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Introduced a dynamic local perturbation scale that decreases over iterations to enhance convergence precision while ensuring global exploration.", "configspace": "", "generation": 76, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "eb4107c9-2aea-4748-9ac9-bdd6817e62cf", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            perturbation_factor = 0.1 * (1 - iterations / self.budget)  # Decaying perturbation\n            particles += velocities + perturbation_factor * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Introduce a decaying random perturbation factor to enhance exploration in early stages and encourage convergence later.", "configspace": "", "generation": 77, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "e68fc4e0-db9b-4cba-97a2-7fcd0313460f", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with adaptive local random perturbations\n            adaptive_perturbation = 0.1 * np.exp(-0.01 * iterations)\n            particles += velocities + adaptive_perturbation * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Enhance global exploration by introducing adaptive perturbation scaling based on iteration count.", "configspace": "", "generation": 78, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "c855df0b-9ac8-42c8-80f1-61cf32357294", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.9 - (0.4 * (iterations / self.budget))  # adaptive inertia weight decay\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm incorporates adaptive inertia weight decay to enhance convergence precision in the dynamic particle swarm optimization approach.", "configspace": "", "generation": 79, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "8249ee61-53d1-4d29-8cad-3a85905697f2", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n            \n            velocities *= 1 - np.exp(-0.01 * iterations)  # Nonlinear dynamic scaling\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm refines exploration by including nonlinear dynamic scaling for velocities, enhancing the balance of exploration and exploitation phases.", "configspace": "", "generation": 80, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "29b3afab-0b16-4dc3-98e9-ef7d69462de5", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with reduced local random perturbations\n            particles += velocities + 0.05 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Enhance exploitation by reducing random perturbations to improve convergence precision.", "configspace": "", "generation": 81, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "73b8c407-6b60-45f7-9f26-faf49fae5b72", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles) +\n                0.05 * np.random.normal(size=(self.budget, self.dim))  # Added Gaussian perturbation\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances dynamic particle swarm optimization by integrating random Gaussian perturbations in velocity updates for improved exploration.", "configspace": "", "generation": 82, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "7aa4fdfd-0dd2-4917-9a0a-2c92973df8de", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim) * (1 - iterations / self.budget)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances convergence by introducing a dynamic cognitive component scaling based on iteration count to balance exploration and exploitation.", "configspace": "", "generation": 83, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "bf2784ca-2908-4d38-8a69-45966cd58242", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.15 * np.random.normal(size=(self.budget, self.dim))  # increased from 0.1 to 0.15\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Enhance exploration by slightly increasing the randomness in position updates.", "configspace": "", "generation": 84, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "b9c357c7-3fae-4ae5-92f0-321b23c9df0f", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim) * (1 - (iterations / self.budget))  # time-varying cognitive component\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm introduces a time-varying mechanism for the cognitive component to enhance the adaptability of the search process.", "configspace": "", "generation": 85, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "f036bf87-8d33-4c05-8e4e-176296cca29b", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            # Adaptive learning rates\n            cognitive_rate = 1.5 / (1 + iterations * 0.01)  \n            social_rate = 1.5 / (1 + iterations * 0.01)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_rate * cognitive_component * (personal_best_positions - particles) + \n                social_rate * social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Incorporate adaptive learning rates to enhance exploration-exploitation balance in particle updates.", "configspace": "", "generation": 86, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "288cfb0a-ba9e-440e-bcc6-cb28868042db", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            # Include dynamic learning factor enhancement\n            velocities = (\n                inertia_weight * velocities +\n                0.1 * np.random.rand() * cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm improves the existing design by incorporating a dynamic learning factor to enhance convergence efficiency in the adaptive particle swarm approach.", "configspace": "", "generation": 87, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "939cda46-a913-4dfc-a84e-9cda320782b4", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Elite selection: focus updates on top-performing particles\n            elite_indices = np.argsort(personal_best_scores)[:int(self.budget * 0.1)]\n            elite_positions = personal_best_positions[elite_indices]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (elite_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm now incorporates elite selection mechanisms to enhance convergence by focusing on the top-performing particles during updates.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (500,10) (5000,10) ').", "error": "ValueError('operands could not be broadcast together with shapes (500,10) (5000,10) ')", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {}, "mutation_prompt": null}
{"id": "728067c8-97d4-491c-928f-bcf9eb694665", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with dynamic local random perturbations\n            decay_factor = (self.budget - iterations) / self.budget\n            particles += velocities + 0.1 * decay_factor * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Introduce a decay factor to dynamically adjust the local random perturbations as iterations progress for refined convergence.", "configspace": "", "generation": 89, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "8bda75c6-0d76-4e87-988b-46ead908d180", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = (1.1 * np.random.rand(self.budget, self.dim))  # increased social influence\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances global exploration by utilizing a slightly increased social component influence during velocity updates.", "configspace": "", "generation": 90, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "a393bba9-2c43-49bf-a1a3-c863d05ef87b", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n            \n            # Change 1: Added adaptive scaling factor to social component\n            social_scaling_factor = 1.2 - (iterations / (self.budget * 1.2))\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_scaling_factor * social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances global search by incorporating an adaptive social component scaling factor, allowing more effective exploration of global best directions.", "configspace": "", "generation": 91, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "0a99d704-63ca-40be-9643-42917f385187", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            # Introduce sinusoidal perturbation\n            sinusoidal_component = 0.1 * np.sin(iterations * np.pi / self.budget) \n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles) +\n                sinusoidal_component\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances exploration by introducing a sinusoidal component to velocity updates.", "configspace": "", "generation": 92, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "c6c0191e-fc95-4664-867f-3049f29484c8", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 * (iterations/self.budget))  # dynamic inertia weight increasing with iterations\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances global search capability by introducing a dynamic inertia weight that increases over iterations rather than decreases, slightly altering the exploration-exploitation balance.", "configspace": "", "generation": 93, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "a03a6bdc-c66e-438e-bbf9-94925b2971fe", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim) * (1 - iterations / self.budget)  # linearly decreasing cognitive component\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances the velocity update mechanism by introducing a linearly decreasing cognitive component, further balancing exploration and exploitation.", "configspace": "", "generation": 94, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "74a7daf2-b6db-4983-976c-3e8b6f0f58ff", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + 0.4 / (1 + np.exp(-0.1 * (iterations - self.budget / 2)))  # dynamic adaptation\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm introduces a dynamic adaptation in inertia weight calculation based on convergence speed to enhance exploration and exploitation balance.", "configspace": "", "generation": 95, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "70cbe490-706b-408d-a7ea-3b02e817098f", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim) * (1 + iterations/self.budget) # dynamic social factor\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances global search by introducing a dynamic social component factor in the velocity update to improve convergence speed and solution quality.", "configspace": "", "generation": 96, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "2eebd856-20c5-45bd-baed-8fea1ad91e13", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim) * (1.2 - 0.5 / (1 + iterations))  # modified line\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "Modified the velocity update formula to enhance exploration and exploitation balance by introducing a dynamic adaptation of the cognitive and social components.", "configspace": "", "generation": 97, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "2f611bf2-bae0-4ece-8264-84cf98ab9daa", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with local random perturbations\n            particles += velocities + 0.1 * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds with adaptive boundary handling\n            particles = np.clip(particles, lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm enhances dynamic particle swarm optimization with adaptive boundary handling to maintain diversity and prevent premature convergence.", "configspace": "", "generation": 98, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
{"id": "3773f2c3-1938-4085-9e57-b56b448d8ba4", "solution": "import numpy as np\n\nclass NovelMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(low=lb, high=ub, size=(self.budget, self.dim))\n        velocities = np.random.uniform(low=-1, high=1, size=(self.budget, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.budget, np.inf)\n\n        # Initialize global best\n        global_best_score = np.inf\n        global_best_position = None\n\n        # Iteration counter\n        iterations = 0\n\n        while iterations < self.budget:\n            for i in range(self.budget):\n                # Evaluate the current position\n                score = func(particles[i])\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            inertia_weight = 0.5 + (0.5 / (1 + iterations))  # adaptive inertia weight\n            cognitive_component = np.random.rand(self.budget, self.dim)\n            social_component = np.random.rand(self.budget, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_component * (personal_best_positions - particles) + \n                social_component * (global_best_position - particles)\n            )\n\n            # Position update with time-varying random perturbations\n            particles += velocities + (0.1 / (1 + iterations)) * np.random.normal(size=(self.budget, self.dim))\n\n            # Ensure particles are within bounds\n            particles = np.clip(particles, lb, ub)\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "NovelMetaheuristicOptimizer", "description": "The algorithm builds upon adaptive explorative-exploitative search by using time-varying random local perturbations to enhance convergence towards optimal solutions.", "configspace": "", "generation": 99, "fitness": 0.6636344506722321, "feedback": "The algorithm NovelMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.062. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "f8fe64e4-84d7-44ea-9e25-d05b6bb31032", "metadata": {"aucs": [0.5850438449659985, 0.7369088559257345, 0.6689506511249634], "final_y": [0.304017421389266, 0.24804256082676257, 0.2670307094097698]}, "mutation_prompt": null}
