{"id": "12e8047f-ec33-4a9d-964e-c85555543102", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_samples = np.random.uniform(bounds[:, 0], bounds[:, 1], (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Adaptive Boundary Refinement with Local Search (ABR-LS) combines initial uniform sampling with adaptive boundary refinement and local search using BFGS to optimize smooth and low-dimensional black box functions efficiently.", "configspace": "", "generation": 0, "fitness": 0.8432268167047452, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.843 with standard deviation 0.037. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7919540005724399, 0.8575354788705214, 0.8801909706712745], "final_y": [8.348725856425736e-08, 2.7483824602686643e-08, 2.557050102683057e-09]}, "mutation_prompt": null}
{"id": "f3ace812-85fa-489a-ab6a-b8943fd060ca", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_samples = np.random.uniform(bounds[:, 0], bounds[:, 1], (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) optimizes smooth and low-dimensional functions by integrating momentum-based boundary refinement for improved convergence speed.", "configspace": "", "generation": 1, "fitness": 0.8576252797806928, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.858 with standard deviation 0.026. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "12e8047f-ec33-4a9d-964e-c85555543102", "metadata": {"aucs": [0.8356469335443953, 0.8430892534768955, 0.8941396523207877], "final_y": [3.146417414264372e-08, 3.420906104051306e-08, 3.884638114961498e-09]}, "mutation_prompt": null}
{"id": "db84935b-dc82-490f-8b5e-5f8e4e87f7f2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_samples = np.random.uniform(bounds[:, 0], bounds[:, 1], (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.85  # Adjusted shrink factor\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) optimizes smooth and low-dimensional functions by integrating momentum-based boundary refinement and dynamic sampling adjustment for improved convergence speed.", "configspace": "", "generation": 2, "fitness": 0.8548382235641155, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.855 with standard deviation 0.029. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f3ace812-85fa-489a-ab6a-b8943fd060ca", "metadata": {"aucs": [0.8272857648946632, 0.8430892534768955, 0.8941396523207877], "final_y": [4.2784808927948186e-08, 3.420906104051306e-08, 3.884638114961498e-09]}, "mutation_prompt": null}
{"id": "dce769ec-f86c-4f23-9d2c-0fd61f854def", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_samples = np.random.uniform(bounds[:, 0], bounds[:, 1], (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='trust-constr', bounds=refined_bounds)  # Change here\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced Local Exploration with Curvature-Aware Refinement (ELE-CAR) incorporates curvature sensitivity for improved exploration in smooth landscapes.", "configspace": "", "generation": 3, "fitness": 0.5530156835290789, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.553 with standard deviation 0.314. And the mean value of best solutions found was 1.153 (0. is the best) with standard deviation 1.630.", "error": "", "parent_id": "f3ace812-85fa-489a-ab6a-b8943fd060ca", "metadata": {"aucs": [0.7339111697327656, 0.11151995448224883, 0.8136159263722225], "final_y": [1.818563055280448e-07, 3.457594396618161, 5.655078527670846e-08]}, "mutation_prompt": null}
{"id": "96599001-4c25-4231-9dcd-7767dd81ea54", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_samples = np.random.uniform(bounds[:, 0], bounds[:, 1], (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.85  # Changed shrink factor for better refinement\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.85 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.15  # Adjusted momentum influence\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Modified Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) by improving initial sample coverage and momentum influence for enhanced convergence.", "configspace": "", "generation": 4, "fitness": 0.8548382235641155, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.855 with standard deviation 0.029. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f3ace812-85fa-489a-ab6a-b8943fd060ca", "metadata": {"aucs": [0.8272857648946632, 0.8430892534768955, 0.8941396523207877], "final_y": [4.2784808927948186e-08, 3.420906104051306e-08, 3.884638114961498e-09]}, "mutation_prompt": null}
{"id": "407c2674-cab5-493a-9597-1eefcf4d91f9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_samples = np.random.uniform(bounds[:, 0], bounds[:, 1], (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.85  # Reduced shrink factor for finer adjustments\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Refinement of the Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) algorithm by adjusting the shrink factor for improved convergence.", "configspace": "", "generation": 5, "fitness": 0.8548382235641155, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.855 with standard deviation 0.029. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f3ace812-85fa-489a-ab6a-b8943fd060ca", "metadata": {"aucs": [0.8272857648946632, 0.8430892534768955, 0.8941396523207877], "final_y": [4.2784808927948186e-08, 3.420906104051306e-08, 3.884638114961498e-09]}, "mutation_prompt": null}
{"id": "3924b428-5e21-4b41-b000-b5fe85af15bd", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_samples = np.random.uniform(bounds[:, 0], bounds[:, 1], (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.95 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.05  # Updated momentum\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced Momentum and Boundary Scaling (EMBS) refines local optima convergence by dynamically adjusting momentum scaling.", "configspace": "", "generation": 6, "fitness": 0.8576252797806928, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.858 with standard deviation 0.026. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f3ace812-85fa-489a-ab6a-b8943fd060ca", "metadata": {"aucs": [0.8356469335443953, 0.8430892534768955, 0.8941396523207877], "final_y": [3.146417414264372e-08, 3.420906104051306e-08, 3.884638114961498e-09]}, "mutation_prompt": null}
{"id": "f2df9f9f-a81f-4795-8b2f-c295a65f7f6e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_samples = np.random.uniform(bounds[:, 0], bounds[:, 1], (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8 * (1 + 0.1 * (self.budget - function_evals) / self.budget)\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Incorporating a dynamic shrink factor for boundary refinement in Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) to improve convergence speed.", "configspace": "", "generation": 7, "fitness": 0.8548382235641155, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.855 with standard deviation 0.029. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f3ace812-85fa-489a-ab6a-b8943fd060ca", "metadata": {"aucs": [0.8272857648946632, 0.8430892534768955, 0.8941396523207877], "final_y": [4.2784808927948186e-08, 3.420906104051306e-08, 3.884638114961498e-09]}, "mutation_prompt": null}
{"id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) with improved initial sampling by incorporating variance-based scaling for better starting conditions.", "configspace": "", "generation": 8, "fitness": 0.8605235728673838, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.861 with standard deviation 0.010. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "f3ace812-85fa-489a-ab6a-b8943fd060ca", "metadata": {"aucs": [0.8603283571569454, 0.8725322639254003, 0.8487100975198054], "final_y": [1.6262696571239394e-08, 1.6745554089326937e-09, 2.4584055362991597e-08]}, "mutation_prompt": null}
{"id": "cc84d706-4838-4b40-bc87-7b712c3058cf", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.85  # Changed from 0.8 to 0.85\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Improved Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) by adjusting the shrink factor to increase exploration in the final stages.", "configspace": "", "generation": 9, "fitness": 0.8470930080306456, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.847 with standard deviation 0.022. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.82695990373906, 0.8359839825235369, 0.8783351378293396], "final_y": [2.5889135192498767e-08, 3.5990160606368895e-08, 7.268854793919243e-09]}, "mutation_prompt": null}
{"id": "415b09c4-5b70-410f-9bc2-df575dec4aff", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        decay_rate = 0.01  # New decay factor for shrink_factor\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = max(0.4, 0.8 * (1 - decay_rate * function_evals))  # Modified shrink_factor with decay\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced a decay factor to the shrink_factor, adapting boundary refinement to gradually narrow the search space more efficiently.", "configspace": "", "generation": 10, "fitness": 0.8415520244089457, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.006. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8387658514990112, 0.8359839825235369, 0.849906239204289], "final_y": [4.363490347582046e-09, 3.5990160606368895e-08, 5.8230389074446605e-09]}, "mutation_prompt": null}
{"id": "04ed5446-57c7-4455-8bb1-f7902b22acc7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = min(0.8, 1 - best_value / 10)  # Dynamic adjustment based on progress\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced a dynamic shrink factor adjustment to improve the convergence speed by adapting the search space based on progress.", "configspace": "", "generation": 11, "fitness": 0.8241897827563176, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8173908060198045, 0.8359839825235369, 0.8191945597256113], "final_y": [3.713084414894703e-08, 3.5990160606368895e-08, 6.886861625175895e-08]}, "mutation_prompt": null}
{"id": "3042978f-0f8b-4cc8-a885-8041c8b3ace3", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.05 * np.linalg.norm(x0 - best_point)  # Momentum update with adaptive scaling\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introducing adaptive velocity scaling in momentum update to enhance convergence speed and solution quality.", "configspace": "", "generation": 12, "fitness": 0.8241897827563176, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8173908060198045, 0.8359839825235369, 0.8191945597256113], "final_y": [3.713084414894703e-08, 3.5990160606368895e-08, 6.886861625175895e-08]}, "mutation_prompt": null}
{"id": "0b70a0cb-41b8-4372-bcfc-d64e74f587aa", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.7 + 0.2 * (res.success)  # Dynamically adjust shrink factor based on success\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) now incorporates a dynamic shrink factor adjustment based on the current success rate of optimization steps.", "configspace": "", "generation": 13, "fitness": 0.8422443666277006, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.012. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8583892571067692, 0.8359839825235369, 0.8323598602527958], "final_y": [9.15739950124202e-09, 3.5990160606368895e-08, 4.604746818710519e-08]}, "mutation_prompt": null}
{"id": "b4adbd9f-f34c-4821-91ee-ff3750820b06", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.95 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Improved Adaptive Boundary Refinement with Local Search and Momentum (IABR-LSM) enhances convergence by adjusting the momentum update factor for more dynamic exploration.", "configspace": "", "generation": 14, "fitness": 0.8241897827563176, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8173908060198045, 0.8359839825235369, 0.8191945597256113], "final_y": [3.713084414894703e-08, 3.5990160606368895e-08, 6.886861625175895e-08]}, "mutation_prompt": null}
{"id": "2e95d3de-90cd-4d7a-83f0-acc6c87e3ab2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.95 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.05  # Momentum update with acceleration\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Improved convergence speed by adjusting the velocity update with a momentum-based acceleration term.", "configspace": "", "generation": 15, "fitness": 0.8241897827563176, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8173908060198045, 0.8359839825235369, 0.8191945597256113], "final_y": [3.713084414894703e-08, 3.5990160606368895e-08, 6.886861625175895e-08]}, "mutation_prompt": null}
{"id": "77fae17e-04c0-41d3-936c-6c1675af61a6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            improvement_rate = (best_value - res.fun) / best_value if best_value != 0 else 0\n            shrink_factor = 0.8 + 0.2 * improvement_rate  # Dynamic adjustment of shrink factor\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced dynamic shrink factor adjustment based on improvement rate to enhance boundary refinement.", "configspace": "", "generation": 16, "fitness": 0.8241897827563176, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8173908060198045, 0.8359839825235369, 0.8191945597256113], "final_y": [3.713084414894703e-08, 3.5990160606368895e-08, 6.886861625175895e-08]}, "mutation_prompt": null}
{"id": "686ff544-30e1-4651-a701-b0e83d388ab4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.05  # Adaptive momentum scaling\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced EABR-LS with adaptive momentum scaling for improved convergence.", "configspace": "", "generation": 17, "fitness": 0.8241897827563176, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8173908060198045, 0.8359839825235369, 0.8191945597256113], "final_y": [3.713084414894703e-08, 3.5990160606368895e-08, 6.886861625175895e-08]}, "mutation_prompt": null}
{"id": "aee7634c-aeb1-425c-9485-2c71f6cd39ff", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.85  # Slightly increased shrink factor for optimized exploration\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced Adaptive Boundary Refinement with Local Search using variance-based scaling and momentum for improved exploration-exploitation balance.", "configspace": "", "generation": 18, "fitness": 0.8470930080306456, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.847 with standard deviation 0.022. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.82695990373906, 0.8359839825235369, 0.8783351378293396], "final_y": [2.5889135192498767e-08, 3.5990160606368895e-08, 7.268854793919243e-09]}, "mutation_prompt": null}
{"id": "ecd5f48e-a2a8-42fc-ad54-b0eef4374f58", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.5 + 0.3 * (function_evals / self.budget)  # Adjust shrink factor dynamically\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced a dynamic update of the shrink factor to refine boundaries more effectively based on the progress.", "configspace": "", "generation": 19, "fitness": 0.8341171657557664, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.834 with standard deviation 0.005. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8278114712304586, 0.8359839825235369, 0.8385560435133037], "final_y": [2.2763641814722507e-08, 3.5990160606368895e-08, 3.1420001698721266e-08]}, "mutation_prompt": null}
{"id": "8c3e02d3-7d28-465e-b9eb-ec572ab67d48", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.random.normal(0, (refined_bounds[:, 1] - refined_bounds[:, 0]) / 4, self.dim)  # Variance-based scaling for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced variance-based scaling for momentum initialization to enhance exploration in the adaptive boundary refinement process.", "configspace": "", "generation": 20, "fitness": 0.8241897827563176, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8173908060198045, 0.8359839825235369, 0.8191945597256113], "final_y": [3.713084414894703e-08, 3.5990160606368895e-08, 6.886861625175895e-08]}, "mutation_prompt": null}
{"id": "f0ff2a95-72f8-44a3-84c6-c7d7fea6b50c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8 + 0.2 * (function_evals / self.budget)  # Dynamic shrink factor\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduce dynamic shrink factor in adaptive boundary refinement to better adapt the search space as optimization progresses.", "configspace": "", "generation": 21, "fitness": 0.7908230713796099, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.791 with standard deviation 0.027. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8267297197235857, 0.7621324720058478, 0.7836070224093967], "final_y": [6.060505766457727e-08, 3.206318220329824e-07, 2.94966164950806e-07]}, "mutation_prompt": null}
{"id": "2c39625f-d1ce-457a-93f9-c1fd1398a2d9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.05  # Dynamic momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced ABRLSOptimizer with dynamic momentum adjustment for improved convergence speed.", "configspace": "", "generation": 22, "fitness": 0.8241897827563176, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8173908060198045, 0.8359839825235369, 0.8191945597256113], "final_y": [3.713084414894703e-08, 3.5990160606368895e-08, 6.886861625175895e-08]}, "mutation_prompt": null}
{"id": "05153b43-24de-481a-aacf-d61dc441cc29", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8 * (1 + 0.1 * np.random.rand())  # Adaptive step size\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduce an adaptive step size strategy to refine the boundary refinement process for improved convergence.", "configspace": "", "generation": 23, "fitness": 0.8464133889235489, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.846 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8536932166253884, 0.8359839825235369, 0.8495629676217209], "final_y": [8.090762361576266e-09, 3.5990160606368895e-08, 2.348582093244298e-08]}, "mutation_prompt": null}
{"id": "42e0f78f-b9b7-4c12-bec1-91bda4faca80", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1 * np.random.rand(self.dim)  # Dynamic velocity scaling\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced dynamic velocity scaling to enhance momentum adaptation for faster convergence.", "configspace": "", "generation": 24, "fitness": 0.7942627569398174, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.794 with standard deviation 0.009. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8060913213633591, 0.7921835400282203, 0.7845134094278728], "final_y": [9.68061562099931e-08, 1.3284928185593583e-07, 1.597347489659989e-07]}, "mutation_prompt": null}
{"id": "fcf42ff4-3b02-4fbd-b1c7-5b8e9587a79d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1 * 0.95  # Momentum update with decay\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduce a decay factor in the momentum update to improve convergence speed and accuracy.", "configspace": "", "generation": 25, "fitness": 0.8315798593137164, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.832 with standard deviation 0.026. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.808258404514679, 0.8182894810967862, 0.8681916923296842], "final_y": [5.757383534995724e-08, 6.808176873742946e-08, 1.1312886091919658e-08]}, "mutation_prompt": null}
{"id": "028aae03-8d90-4e51-aa6b-fa1d5005b1d4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.95 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.05  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) incorporating adaptive momentum for improved convergence.", "configspace": "", "generation": 26, "fitness": 0.8241897827563176, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8173908060198045, 0.8359839825235369, 0.8191945597256113], "final_y": [3.713084414894703e-08, 3.5990160606368895e-08, 6.886861625175895e-08]}, "mutation_prompt": null}
{"id": "6174127b-7b3e-46fc-a783-940f8b2dcfbe", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = max(0.5, 0.8 * (self.budget - function_evals) / self.budget)  # Dynamic shrink factor\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced dynamic shrink factor adjustment for refined bounds to enhance convergence rate.", "configspace": "", "generation": 27, "fitness": 0.8370250652286195, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.837 with standard deviation 0.010. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8258712975567652, 0.8359839825235369, 0.8492199156055565], "final_y": [2.3863981380594996e-08, 3.5990160606368895e-08, 2.0098303895439434e-08]}, "mutation_prompt": null}
{"id": "4c215c4e-5ef8-4649-9b99-2be41648b734", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.9 - (function_evals / self.budget) * 0.2  # Dynamically adjust shrink factor\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced Adaptive Boundary Refinement with Local Search using a dynamic shrink factor for improved convergence.", "configspace": "", "generation": 28, "fitness": 0.8350961168469028, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.835 with standard deviation 0.019. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8119336003182593, 0.8359839825235369, 0.8573707676989121], "final_y": [4.4192431999027184e-08, 3.5990160606368895e-08, 2.0298395898886552e-08]}, "mutation_prompt": null}
{"id": "5b2cc334-60ee-4035-aeb2-cb9026d56544", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.75  # Changed from 0.8 to 0.75\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) featuring dynamic shrink factor adjustment for improved convergence.", "configspace": "", "generation": 29, "fitness": 0.8347098271904622, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.835 with standard deviation 0.002. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8322468456177975, 0.8359839825235369, 0.8358986534300522], "final_y": [2.401448795041806e-08, 3.5990160606368895e-08, 3.803239336345585e-08]}, "mutation_prompt": null}
{"id": "b28a8ad1-5427-418f-928c-81fc1f2f4177", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Apply Gaussian perturbation to the best initial sample\n        best_point += np.random.normal(0, 0.01, self.dim)  # Small perturbation\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced Gaussian perturbation to the initial best sample for enhanced diversity and improved exploration.", "configspace": "", "generation": 30, "fitness": 0.83251159867452, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.833 with standard deviation 0.005. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8272573727514095, 0.839588341926303, 0.8306890813458474], "final_y": [4.18063811681156e-08, 3.5055973734498646e-08, 4.800594106795175e-08]}, "mutation_prompt": null}
{"id": "dd1a7c27-02ee-4c04-a2c4-e3c158a1c342", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.7  # Changed from 0.8 to 0.7 for tighter convergence\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Adjusted shrink factor for tighter convergence in boundary refinement stage.", "configspace": "", "generation": 31, "fitness": 0.7932343760399553, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.793 with standard deviation 0.025. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8267297197235857, 0.7680062806119922, 0.7849671277842878], "final_y": [6.060505766457727e-08, 2.533824494726373e-07, 2.8383874180939696e-07]}, "mutation_prompt": null}
{"id": "3ddd5f30-a861-40a0-a650-8d02ddf521ee", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.9 if res.success else 0.8  # Adjust shrink factor based on convergence speed\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "EABR-LS with an exploration-exploitation balance by adjusting the shrink factor based on convergence speed.", "configspace": "", "generation": 32, "fitness": 0.8432144555846964, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.843 with standard deviation 0.011. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8583892571067692, 0.8359839825235369, 0.8352701271237837], "final_y": [9.15739950124202e-09, 3.5990160606368895e-08, 4.208452792195452e-08]}, "mutation_prompt": null}
{"id": "484367b6-fc12-49ca-b91c-28f74ccf55f9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.85  # Slight increase in shrink factor for finer refinement\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) incorporating momentum-like adjustments to refine search space.", "configspace": "", "generation": 33, "fitness": 0.8470930080306456, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.847 with standard deviation 0.022. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.82695990373906, 0.8359839825235369, 0.8783351378293396], "final_y": [2.5889135192498767e-08, 3.5990160606368895e-08, 7.268854793919243e-09]}, "mutation_prompt": null}
{"id": "5ffba2e8-5e5f-47a8-a4e2-504516e1e9a8", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.85  # Changed from 0.8 to 0.85 to enhance boundary refinement\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced a small adjustment by increasing the shrink factor to 0.85 for better boundary refinement, enhancing convergence speed.", "configspace": "", "generation": 34, "fitness": 0.8470930080306456, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.847 with standard deviation 0.022. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.82695990373906, 0.8359839825235369, 0.8783351378293396], "final_y": [2.5889135192498767e-08, 3.5990160606368895e-08, 7.268854793919243e-09]}, "mutation_prompt": null}
{"id": "988e2f86-1ee1-43fc-8dcd-ef30bd66ef45", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            progress_ratio = 1 - (res.fun / best_value) if best_value != 0 else 0\n            shrink_factor = 0.8 + 0.2 * progress_ratio  # Dynamic shrink factor\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced a dynamic shrink factor to adaptively fine-tune convergence speed based on recent progress in optimization.", "configspace": "", "generation": 35, "fitness": 0.8241897827563176, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8173908060198045, 0.8359839825235369, 0.8191945597256113], "final_y": [3.713084414894703e-08, 3.5990160606368895e-08, 6.886861625175895e-08]}, "mutation_prompt": null}
{"id": "0dc66201-8cf9-4ad2-903c-4a4a15586244", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8 + 0.1 * (function_evals / self.budget)  # Dynamic shrink factor\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced a dynamic adjustment of the shrink factor based on optimization progress to enhance local search performance.", "configspace": "", "generation": 36, "fitness": 0.8280524720391885, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.828 with standard deviation 0.021. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.7997146730886511, 0.8359839825235369, 0.8484587605053775], "final_y": [6.875020331180258e-08, 3.5990160606368895e-08, 2.4921047397286673e-08]}, "mutation_prompt": null}
{"id": "7782f4f1-882d-403f-94ea-66878e661356", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            dynamic_shrink_factor = 0.8 + 0.1 * (function_evals / self.budget)  # Dynamic shrink factor\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - dynamic_shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - dynamic_shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Improved Adaptive Boundary Refinement with Local Search (IABR-LS) by introducing a dynamic shrink factor that adapts based on the optimization progress for more efficient convergence.", "configspace": "", "generation": 37, "fitness": 0.8280524720391885, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.828 with standard deviation 0.021. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.7997146730886511, 0.8359839825235369, 0.8484587605053775], "final_y": [6.875020331180258e-08, 3.5990160606368895e-08, 2.4921047397286673e-08]}, "mutation_prompt": null}
{"id": "31a5c051-9ff6-4915-90d4-df96ee3a6bd9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds using Sobol sequences\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        sampler = Sobol(d=self.dim, scramble=True)\n        initial_samples = sampler.random_base2(m=int(np.log2(n_initial_samples)))\n        initial_samples = bounds[:, 0] + initial_samples * (bounds[:, 1] - bounds[:, 0])\n        \n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced sampling using quasi-random Sobol sequences to improve initial coverage of the search space.", "configspace": "", "generation": 38, "fitness": 0.8536373986709442, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.854 with standard deviation 0.020. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8353206937390528, 0.8822128241934566, 0.8433786780803233], "final_y": [6.858476926970605e-08, 1.2224209537915886e-08, 3.314173702623651e-08]}, "mutation_prompt": null}
{"id": "81a4e7db-6afe-4c7f-9b93-914971e10896", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.5 + 0.3 * (function_evals / self.budget)  # Dynamic shrink factor\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "The Enhanced ABR-LS algorithm now leverages a dynamic shrink factor for adaptive boundary refinement, improving convergence by tuning the search space more responsively.", "configspace": "", "generation": 39, "fitness": 0.8188248896660694, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.819 with standard deviation 0.011. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8300732849046738, 0.82321502291095, 0.8031863611825844], "final_y": [2.6025378656692773e-08, 3.005352062303759e-08, 7.161765189609812e-08]}, "mutation_prompt": null}
{"id": "7d873da8-16c8-40a7-944b-8ae561f2a928", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8 + 0.1 * (best_value < res.fun)  # Dynamic shrink factor\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced dynamic adjustment of the shrink factor based on the optimization progress to enhance convergence speed.", "configspace": "", "generation": 40, "fitness": 0.8241897827563176, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8173908060198045, 0.8359839825235369, 0.8191945597256113], "final_y": [3.713084414894703e-08, 3.5990160606368895e-08, 6.886861625175895e-08]}, "mutation_prompt": null}
{"id": "f3bb68b4-6f62-48cf-9eac-e7aacd8fefdc", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.85  # Adjusted shrink factor for improved convergence\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Improved convergence by refining the shrink factor to balance exploration and exploitation.", "configspace": "", "generation": 41, "fitness": 0.8470930080306456, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.847 with standard deviation 0.022. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.82695990373906, 0.8359839825235369, 0.8783351378293396], "final_y": [2.5889135192498767e-08, 3.5990160606368895e-08, 7.268854793919243e-09]}, "mutation_prompt": null}
{"id": "ae21b353-04b8-4818-a2e7-1236a4a6debc", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.95 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Improved Adaptive Boundary Refinement with Local Search (EABR-LS) featuring velocity-based convergence speedup for enhanced performance.", "configspace": "", "generation": 42, "fitness": 0.8241897827563176, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8173908060198045, 0.8359839825235369, 0.8191945597256113], "final_y": [3.713084414894703e-08, 3.5990160606368895e-08, 6.886861625175895e-08]}, "mutation_prompt": null}
{"id": "fc1bb2e8-e340-49e7-857c-9654a1006ac4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.85  # Changed from 0.8 to 0.85 for dynamic adaptation\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "EABR-LS with advanced momentum for refined boundary adaptation using dynamic shrink factor.", "configspace": "", "generation": 43, "fitness": 0.8470930080306456, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.847 with standard deviation 0.022. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.82695990373906, 0.8359839825235369, 0.8783351378293396], "final_y": [2.5889135192498767e-08, 3.5990160606368895e-08, 7.268854793919243e-09]}, "mutation_prompt": null}
{"id": "e461431a-4046-41e0-ba2d-00e132271cac", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.85  # Adjusted shrink factor for dynamic refinement\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced ABR-LS with dynamic shrink factor adjustment for improved convergence precision.", "configspace": "", "generation": 44, "fitness": 0.8470930080306456, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.847 with standard deviation 0.022. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.82695990373906, 0.8359839825235369, 0.8783351378293396], "final_y": [2.5889135192498767e-08, 3.5990160606368895e-08, 7.268854793919243e-09]}, "mutation_prompt": null}
{"id": "6c3c977f-9059-420d-aa77-dd96b5bc32af", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.95 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) with improved velocity scaling for better convergence momentum.", "configspace": "", "generation": 45, "fitness": 0.8241897827563176, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8173908060198045, 0.8359839825235369, 0.8191945597256113], "final_y": [3.713084414894703e-08, 3.5990160606368895e-08, 6.886861625175895e-08]}, "mutation_prompt": null}
{"id": "bf96dd67-0fba-4df5-9b79-af29bea656c8", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.9  # Adjusted shrink factor for better convergence\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced Adaptive Boundary Refinement with Local Search and improved boundary refinement strategy for better convergence.", "configspace": "", "generation": 46, "fitness": 0.8502955919634182, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.850 with standard deviation 0.010. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8583892571067692, 0.8359839825235369, 0.8565135362599487], "final_y": [9.15739950124202e-09, 3.5990160606368895e-08, 1.7561448938762302e-08]}, "mutation_prompt": null}
{"id": "8e876054-9dc4-485c-b9ca-7c4c694b88f0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3.5,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Improved the initial sampling variance scaling to enhance exploration in the parameter space.", "configspace": "", "generation": 47, "fitness": 0.8237649940424743, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.012. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8076617379080309, 0.836647720150421, 0.826985524068971], "final_y": [7.106877663174978e-08, 2.8248601885172282e-08, 4.923202889387695e-08]}, "mutation_prompt": null}
{"id": "f4b0527c-f84d-491c-8c4f-fc480e0617b4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = max(0.5, 0.1 + 0.7 * (1 - function_evals / self.budget))\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced dynamic adjustment of the shrink factor for refined bounds based on convergence rate to enhance exploration capabilities.", "configspace": "", "generation": 48, "fitness": 0.8423005867544083, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.842 with standard deviation 0.005. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8439864054656293, 0.8359839825235369, 0.8469313722740587], "final_y": [9.577075615550896e-09, 3.5990160606368895e-08, 2.2382878355107916e-08]}, "mutation_prompt": null}
{"id": "de4733b0-0bc8-4e6d-80f0-923d61c0f0c9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1 * ((best_value - res.fun) / best_value)  # Momentum update with adaptive learning rate\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "ABRLSOptimizer with enhanced momentum update using adaptive learning rate based on recent improvements in function values for faster convergence.", "configspace": "", "generation": 49, "fitness": 0.8241897827563176, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8173908060198045, 0.8359839825235369, 0.8191945597256113], "final_y": [3.713084414894703e-08, 3.5990160606368895e-08, 6.886861625175895e-08]}, "mutation_prompt": null}
{"id": "a098acbe-fc17-4156-be4b-8ac747ca618a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        # Use Sobol sequence for initial sampling\n        sobol = Sobol(d=self.dim, scramble=True)\n        initial_samples = sobol.random(n_initial_samples) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced Sobol sequence for better initial sample distribution to improve exploration.", "configspace": "", "generation": 50, "fitness": 0.8542974849441333, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.854 with standard deviation 0.009. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.84611114337163, 0.8664933382674452, 0.8502879731933249], "final_y": [2.6488996607119297e-08, 1.7712533703227023e-08, 3.189749859829708e-08]}, "mutation_prompt": null}
{"id": "85b45ea5-6cf4-4396-ad89-463aa7a66a95", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8 + 0.1 * (function_evals / self.budget)  # Dynamic shrink factor adjustment\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introducing a dynamic shrink factor adjustment based on convergence rate to enhance boundary refinement.", "configspace": "", "generation": 51, "fitness": 0.8193536646364925, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.819 with standard deviation 0.009. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8300732849046738, 0.8085623539605186, 0.8194253550442853], "final_y": [2.6025378656692773e-08, 6.07944216833143e-08, 4.533723038916216e-08]}, "mutation_prompt": null}
{"id": "b2ed1f02-2894-4d0d-b453-3399293f8d61", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.85  # Modified to enhance convergence speed\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced Adaptive Boundary Refinement with Local Search (EABR-LS) incorporating momentum-based boundary adjustment for improved convergence speed.", "configspace": "", "generation": 52, "fitness": 0.8470930080306456, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.847 with standard deviation 0.022. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.82695990373906, 0.8359839825235369, 0.8783351378293396], "final_y": [2.5889135192498767e-08, 3.5990160606368895e-08, 7.268854793919243e-09]}, "mutation_prompt": null}
{"id": "bbe2ddb3-b250-443d-a109-30bf536b4ff2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 6,  # Adjusted from 4 to 6\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced sampling initialization through a sophisticated variance-based distribution ensures more robust starting points.", "configspace": "", "generation": 53, "fitness": 0.8228024341662227, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.823 with standard deviation 0.013. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8058832894762454, 0.8364614345396181, 0.8260625784828042], "final_y": [6.153877753621777e-08, 2.6658058947937982e-08, 4.358099894235436e-08]}, "mutation_prompt": null}
{"id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced sampling diversity by adjusting variance scaling to improve exploration capabilities.", "configspace": "", "generation": 54, "fitness": 0.8748932001536948, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.875 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b8849cb-6af3-479d-84ac-2de6247797dd", "metadata": {"aucs": [0.8905830644951324, 0.8493470188077118, 0.8847495171582401], "final_y": [1.0003551889631946e-09, 3.401620765472227e-08, 4.838059450246168e-09]}, "mutation_prompt": null}
{"id": "298b5784-2e75-45c5-b4ec-d250078510be", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (0.1 + 0.02 * np.random.rand(self.dim))  # Dynamic momentum scaling\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced dynamic momentum scaling to improve convergence in smooth landscapes.", "configspace": "", "generation": 55, "fitness": 0.8748932001536948, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.875 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8493470188077118, 0.8847495171582401], "final_y": [1.0003551889631946e-09, 3.401620765472227e-08, 4.838059450246168e-09]}, "mutation_prompt": null}
{"id": "3c0912e6-8550-45e5-a9cc-cf85a7eba2a4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.95 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.05  # Adaptive momentum scaling\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced adaptive momentum scaling to enhance convergence speed and solution quality.", "configspace": "", "generation": 56, "fitness": 0.8303194028234223, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.830 with standard deviation 0.030. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8714681550192187, 0.8184480390237866, 0.8010420144272612], "final_y": [1.3843241057518562e-08, 6.872947387835842e-08, 1.0828693802124861e-07]}, "mutation_prompt": null}
{"id": "aaf4a352-57e3-4f12-b4ea-a74d6b01c658", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n            shrink_factor *= 0.95  # Adapt learning rate\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduce a learning rate adaptation mechanism to enhance convergence speed.", "configspace": "", "generation": 57, "fitness": 0.8748932001536948, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.875 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8493470188077118, 0.8847495171582401], "final_y": [1.0003551889631946e-09, 3.401620765472227e-08, 4.838059450246168e-09]}, "mutation_prompt": null}
{"id": "9f0848e2-1505-4ce1-8d3e-56a1223dae17", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.9 if function_evals < self.budget * 0.5 else 0.8  # Dynamically adjust shrink factor\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Improved exploration by dynamically adjusting the shrink factor for refined bounds based on function evaluation feedback.", "configspace": "", "generation": 58, "fitness": 0.866103854099618, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.866 with standard deviation 0.019. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8441034911458258, 0.8636250066578958], "final_y": [1.0000719276490122e-09, 4.106017002041405e-08, 1.706120110819951e-08]}, "mutation_prompt": null}
{"id": "55a47aa5-b554-49d8-9273-1779cd5e029e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8 + 0.2 * (function_evals / self.budget)  # Dynamic shrink factor based on progress\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduce a dynamic shrink factor based on progress towards the function evaluation budget to adaptively refine the search space.", "configspace": "", "generation": 59, "fitness": 0.8549813466297804, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.855 with standard deviation 0.026. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8441034911458258, 0.830257484248383], "final_y": [1.0003110663373713e-09, 4.106017002041405e-08, 5.431023701560484e-08]}, "mutation_prompt": null}
{"id": "1bad1e04-fbc4-443d-97eb-5e4bd17584f7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.85  # Changed from 0.8 to improve exploration\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced exploration by adjusting the shrink factor for boundary refinement.", "configspace": "", "generation": 60, "fitness": 0.8741118102023181, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.874 with standard deviation 0.012. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8699861145272412, 0.8617662515845808], "final_y": [1.000302654153149e-09, 1.4832104186806943e-08, 1.641860006098734e-08]}, "mutation_prompt": null}
{"id": "b5ad5e75-60ae-4f1e-a648-434624f4ceab", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n            else:\n                # Random restart mechanism\n                x0 = np.random.uniform(refined_bounds[:, 0], refined_bounds[:, 1])  # Change: introduce random restart\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduce a random restart mechanism to escape local minima and enhance exploration.", "configspace": "", "generation": 61, "fitness": 0.8748932001536948, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.875 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8493470188077118, 0.8847495171582401], "final_y": [1.0003551889631946e-09, 3.401620765472227e-08, 4.838059450246168e-09]}, "mutation_prompt": null}
{"id": "d1ead0ac-ff9f-4da4-b5cc-00b9fd59707f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim) \n\n        # Adaptive boundary refinement\n        learning_rate = 0.1  # Initial learning rate\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n                learning_rate *= 1.05  # Increase learning rate on success\n            else:\n                learning_rate *= 0.7  # Decrease learning rate on failure\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * learning_rate  # Apply learning rate\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced learning rate adaptation by dynamically adjusting the step size based on previous iterations to enhance convergence speed.", "configspace": "", "generation": 62, "fitness": 0.7881358651712175, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.788 with standard deviation 0.011. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.7760734262353189, 0.7855507118624092, 0.8027834574159245], "final_y": [2.1269272605390478e-07, 1.5175149486326502e-07, 9.117246733839873e-08]}, "mutation_prompt": null}
{"id": "35713fd6-b77f-4169-8015-25088a507f7b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8 if res.fun < best_value else 0.9  # Dynamic shrink factor adjustment\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Improved the convergence rate by adopting a dynamic shrink factor strategy based on optimization progress.", "configspace": "", "generation": 63, "fitness": 0.866103854099618, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.866 with standard deviation 0.019. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8441034911458258, 0.8636250066578958], "final_y": [1.0002051756286743e-09, 4.106017002041405e-08, 1.706120110819951e-08]}, "mutation_prompt": null}
{"id": "56160211-b521-4423-8b18-0272607b57f2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Adaptive variance scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Utilize adaptive variance scaling in sampling to enhance initial exploration and convergence rate.", "configspace": "", "generation": 64, "fitness": 0.8241897827563176, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8173908060198045, 0.8359839825235369, 0.8191945597256113], "final_y": [3.713084414894703e-08, 3.5990160606368895e-08, 6.886861625175895e-08]}, "mutation_prompt": null}
{"id": "d0383e4c-fdc9-4f42-9acd-89fd9186e925", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8 + 0.1 * (function_evals / self.budget)  # Dynamic shrink factor\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced convergence by refining boundary adaptation with dynamic shrink factor adjustment.", "configspace": "", "generation": 65, "fitness": 0.8727996823177184, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.873 with standard deviation 0.014. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8556693491904618, 0.872146633267561], "final_y": [1.0004091492407036e-09, 2.4202335271454457e-08, 1.3394315844953386e-08]}, "mutation_prompt": null}
{"id": "ca2455a9-9bdb-4c2c-8589-91e65a763152", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8 - (0.3 * (function_evals / self.budget))  # Dynamic shrink factor adjustment\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced dynamic shrink factor adjustment based on the convergence rate to enhance boundary refinement.", "configspace": "", "generation": 66, "fitness": 0.8675709525514795, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.868 with standard deviation 0.016. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8581324001003181, 0.8539973930589881], "final_y": [1.0001663655787434e-09, 5.47726771664771e-09, 2.1259895021855134e-08]}, "mutation_prompt": null}
{"id": "5aef275e-fbf2-40ec-a1d6-8da19f2c8cd6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.5 + 0.3 * (function_evals / self.budget)  # Dynamic shrink factor\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced dynamic shrink factor to enhance adaptability and precision in boundary refinement.", "configspace": "", "generation": 67, "fitness": 0.8580383809031797, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.858 with standard deviation 0.023. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8451711869402591, 0.8383608912741479], "final_y": [1.0004024382891424e-09, 3.9353353997840267e-08, 3.8839399945817436e-08]}, "mutation_prompt": null}
{"id": "c45553b9-9d48-4c9d-8f24-4bb9f80aba4f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1 * np.random.rand(self.dim)  # Momentum update with adaptive learning rate\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced velocity update by incorporating adaptive learning rates for faster convergence.", "configspace": "", "generation": 68, "fitness": 0.8748932001536948, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.875 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8493470188077118, 0.8847495171582401], "final_y": [1.0003551889631946e-09, 3.401620765472227e-08, 4.838059450246168e-09]}, "mutation_prompt": null}
{"id": "1c343c4f-881e-4b46-92f4-b638102f7e9e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8 - 0.1 * (function_evals / self.budget)  # Adjust shrink factor dynamically\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced dynamic boundary refinement and convergence by incrementally adjusting the shrink factor based on function evaluation feedback.", "configspace": "", "generation": 69, "fitness": 0.8381916624388035, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.838 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8714681550192187, 0.8184480390237866, 0.824658793273405], "final_y": [1.3843241057518562e-08, 6.872947387835842e-08, 4.55642457017406e-08]}, "mutation_prompt": null}
{"id": "cc4bf782-74e8-43b0-95a8-003a61999562", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.95 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.05  # Adaptive momentum scaling\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Refine boundary update rule to expedite convergence via adaptive momentum scaling.", "configspace": "", "generation": 70, "fitness": 0.8748932001536948, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.875 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8493470188077118, 0.8847495171582401], "final_y": [1.0003551889631946e-09, 3.401620765472227e-08, 4.838059450246168e-09]}, "mutation_prompt": null}
{"id": "fa3722e6-e2c2-4026-b125-063568ddb18b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n        learning_rate = 0.1  # Introduce learning rate for momentum update\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * learning_rate  # Momentum update with learning rate\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduce a learning rate to dynamically adjust the momentum update for improved convergence.", "configspace": "", "generation": 71, "fitness": 0.8748932001536948, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.875 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8493470188077118, 0.8847495171582401], "final_y": [1.0003551889631946e-09, 3.401620765472227e-08, 4.838059450246168e-09]}, "mutation_prompt": null}
{"id": "08e8bf8d-bc00-485e-9a59-4bd130e9b51a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats.qmc import Sobol\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Sobol sequence for variance-based scaling in initial samples\n        sobol = Sobol(d=self.dim)\n        initial_samples = sobol.random_base2(m=int(np.log2(n_initial_samples)))\n        initial_samples = bounds[:, 0] + (bounds[:, 1] - bounds[:, 0]) * initial_samples\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhance initial sampling exploration by incorporating Sobol sequence for better coverage.", "configspace": "", "generation": 72, "fitness": 0.8434217680480587, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.843 with standard deviation 0.016. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.861445998536061, 0.822009122969884, 0.8468101826382309], "final_y": [2.4527528075686088e-08, 8.021911952331658e-08, 4.2108458344815303e-08]}, "mutation_prompt": null}
{"id": "eb495309-310f-4170-8990-71cd3ab7860e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.95 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced exploitation phase by increasing the momentum update coefficient for faster local convergence.", "configspace": "", "generation": 73, "fitness": 0.846196495095992, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.846 with standard deviation 0.014. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8644025688521786, 0.8304931793877284, 0.843693737048069], "final_y": [1.1652836975988941e-08, 2.169763477368407e-08, 2.4396423041610485e-08]}, "mutation_prompt": null}
{"id": "c322c1cc-f70c-46a5-a011-b335ccaa088a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8 + 0.1 * np.random.rand()  # Variable shrink factor\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced a variable shrink factor to dynamically adjust search space refinement, enhancing convergence.", "configspace": "", "generation": 74, "fitness": 0.8709854809099337, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.871 with standard deviation 0.016. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8507571714697415, 0.8716162067649267], "final_y": [1.000343115328825e-09, 3.160379104625809e-08, 1.344860848848422e-08]}, "mutation_prompt": null}
{"id": "55f113d7-2521-49c7-bf9a-2553afcb9f36", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.7 + 0.1 * (best_value / (best_value + 1))  # Dynamic shrink factor\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.8 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.2  # Adaptive velocity update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introducing a dynamic shrink factor and adaptive velocity scaling for improved convergence.", "configspace": "", "generation": 75, "fitness": 0.8169441563438206, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.817 with standard deviation 0.043. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8333312019922142, 0.7579527517473843, 0.8595485152918633], "final_y": [3.257271235703313e-08, 3.442148409222498e-07, 2.5917753210657823e-09]}, "mutation_prompt": null}
{"id": "1ccf76b4-9d1e-468c-9a29-bb53ddf046a2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.85  # Adjusted shrink factor\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Improves optimization by slightly expanding boundary shrink factor to enhance exploration.", "configspace": "", "generation": 76, "fitness": 0.8741118102023181, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.874 with standard deviation 0.012. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8699861145272412, 0.8617662515845808], "final_y": [1.000302654153149e-09, 1.4832104186806943e-08, 1.641860006098734e-08]}, "mutation_prompt": null}
{"id": "f6803abc-c11f-42be-ae5e-5e1ee57297fc", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n            else:\n                # Introduce random restart when stuck\n                x0 = initial_samples[np.random.randint(n_initial_samples)]\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Utilized random restart mechanism to enhance exploration by reintroducing new initial samples when stuck in local optima.", "configspace": "", "generation": 77, "fitness": 0.8748932001536948, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.875 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8493470188077118, 0.8847495171582401], "final_y": [1.0003551889631946e-09, 3.401620765472227e-08, 4.838059450246168e-09]}, "mutation_prompt": null}
{"id": "eba351f4-8a20-41c1-9b44-48ad695ec250", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Enhanced variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n\n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.75  # More aggressive shrinking\n            # Dynamic adjustment of refined_bounds\n            interval_adjust = 0.15 * (refined_bounds[:, 1] - refined_bounds[:, 0])\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - interval_adjust / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + interval_adjust / 2)\n            velocity = 0.85 * velocity + interval_adjust * 0.15  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Incorporates a dual strategy of exploration and exploitation with adaptive variance and dynamic boundary adjustments to improve convergence speed.", "configspace": "", "generation": 78, "fitness": 0.8198287926652945, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.820 with standard deviation 0.029. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8288272478551445, 0.7801936459986099, 0.8504654841421291], "final_y": [7.747354587138791e-08, 1.8893474915785293e-07, 2.7628932662839304e-08]}, "mutation_prompt": null}
{"id": "d09e70ab-87ef-413c-a3e9-adc26e478901", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8 * (1 - (function_evals / self.budget))  # Dynamic shrink factor\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Adaptive boundary refinement now considers a dynamic shrink factor based on convergence rate.", "configspace": "", "generation": 79, "fitness": 0.8623563983564194, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.862 with standard deviation 0.020. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8459876709845348, 0.8504984595895912], "final_y": [1.0007720129176431e-09, 3.7752430878297057e-08, 2.3631324735561293e-08]}, "mutation_prompt": null}
{"id": "d8d93782-cd93-453b-8609-c89b641e6db5", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / np.sqrt(self.budget),  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Improved exploration by adjusting initial sampling variance to scale with budget, enhancing solution diversity.", "configspace": "", "generation": 80, "fitness": 0.8323407371383581, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.832 with standard deviation 0.019. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8143304342075659, 0.824851774050653, 0.8578400031568554], "final_y": [4.971963873457809e-08, 4.556006270239437e-08, 1.4950249901500545e-08]}, "mutation_prompt": null}
{"id": "04735050-243f-4baa-b436-e9209e6912b7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.95 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Increased momentum influence\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Improved local search efficiency by increasing momentum influence during boundary refinement.", "configspace": "", "generation": 81, "fitness": 0.8748932001536948, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.875 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8493470188077118, 0.8847495171582401], "final_y": [1.0003551889631946e-09, 3.401620765472227e-08, 4.838059450246168e-09]}, "mutation_prompt": null}
{"id": "c68a23e6-2024-44a3-ad8a-272d644d9563", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n            x0 = x0 + velocity  # Apply momentum to the starting point\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Integrate momentum-based velocity updates to accelerate convergence and refine parameter exploration.", "configspace": "", "generation": 82, "fitness": 0.8527989401962467, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.853 with standard deviation 0.028. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8441034911458258, 0.8237102649477823], "final_y": [1.0007720129176431e-09, 4.106017002041405e-08, 5.4274703569414606e-08]}, "mutation_prompt": null}
{"id": "1a75885f-66b4-4d37-bd77-c69514872a00", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds, options={'maxiter': 5})  # Added maxiter for gradient refinement\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduce gradient-based refinement to enhance precision in the final optimization stage.", "configspace": "", "generation": 83, "fitness": 0.5763638689988636, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.576 with standard deviation 0.277. And the mean value of best solutions found was 0.220 (0. is the best) with standard deviation 0.312.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.7934675274860268, 0.7507294881735788, 0.18489459133698505], "final_y": [8.420889703907164e-08, 4.2865629954837834e-07, 0.6610766870950446]}, "mutation_prompt": null}
{"id": "fc8ab8be-91ab-4caf-93ca-944ea4152c20", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8 - 0.2 * (function_evals / self.budget)  # Dynamic shrink factor\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduce a dynamic shrink factor for adaptive boundary refinement to enhance exploitation while respecting the budget limit.", "configspace": "", "generation": 84, "fitness": 0.8544839653059602, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.854 with standard deviation 0.027. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8455097591649938, 0.8273590722577545], "final_y": [1.0001073272126378e-09, 3.7644598632730536e-08, 5.942508288637881e-08]}, "mutation_prompt": null}
{"id": "5c2234b4-6e2d-4a5b-9da7-908fc82a73bf", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * np.random.uniform(0.05, 0.15)  # Dynamic velocity update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Incorporate a more dynamic velocity update inspired by adaptive learning rate techniques to enhance optimization efficiency.", "configspace": "", "generation": 85, "fitness": 0.8748932001536948, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.875 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8493470188077118, 0.8847495171582401], "final_y": [1.0003551889631946e-09, 3.401620765472227e-08, 4.838059450246168e-09]}, "mutation_prompt": null}
{"id": "b30c07ad-5ed7-43ea-9ad1-c80956f150f6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0 + velocity, method='L-BFGS-B', bounds=refined_bounds)  # Added velocity\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Improved convergence by integrating a momentum term into the optimization loop for enhanced speed.", "configspace": "", "generation": 86, "fitness": 0.8195084435490414, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.820 with standard deviation 0.005. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8247217562868996, 0.8205417278078881, 0.8132618465523365], "final_y": [4.79693216816171e-08, 4.852341839583641e-08, 4.820509025533688e-08]}, "mutation_prompt": null}
{"id": "43e31713-e064-40dd-9e8e-42693df14c0f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Adaptive variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / np.random.uniform(2.5, 3.5),  # Adaptive variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduce adaptive variance scaling to enhance exploration and exploitation balance in sampling.", "configspace": "", "generation": 87, "fitness": 0.8390378979498948, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.839 with standard deviation 0.012. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8555623914445438, 0.8279721807734437, 0.8335791216316971], "final_y": [2.6522668301562535e-08, 5.6692795447794444e-08, 3.305152621643226e-08]}, "mutation_prompt": null}
{"id": "a1d4fac6-3043-40c8-b5df-a4c69187f10e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1 * np.random.rand(self.dim)  # Dynamic velocity scaling\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Incorporate dynamic velocity scaling for enhanced adaptive exploration-exploitation balancing.", "configspace": "", "generation": 88, "fitness": 0.8665693655496044, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.867 with standard deviation 0.025. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8976909134407567, 0.86540322360046, 0.8366139596075961], "final_y": [3.2810179441489244e-09, 2.1117826931407396e-08, 5.154915104600411e-08]}, "mutation_prompt": null}
{"id": "5849d20d-acae-4dd5-8ad7-5bacd57f7b83", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8 - 0.3 * (function_evals / self.budget)  # Dynamically adjust shrink factor\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced a dynamic shrink factor to enhance boundary refinement adaptively.", "configspace": "", "generation": 89, "fitness": 0.8576062781681015, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.858 with standard deviation 0.007. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8506841169342422, 0.8554671398914935, 0.8666675776785693], "final_y": [1.2348320926579567e-08, 4.4898896531662534e-08, 2.5514176817744946e-08]}, "mutation_prompt": null}
{"id": "f4e149d3-c73d-45ee-a958-25915fee817a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples with dynamic adjustment\n        variance_scaling = np.random.uniform(0.3, 0.5)  # Dynamic variance\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) * variance_scaling,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduce dynamic sampling variance for enhanced adaptation to the problem landscape.", "configspace": "", "generation": 90, "fitness": 0.8448384483260586, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.845 with standard deviation 0.013. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8351414098702757, 0.8631300434537732, 0.8362438916541267], "final_y": [4.3228412860749766e-08, 1.7596718919396346e-08, 4.503535549408328e-08]}, "mutation_prompt": null}
{"id": "c9356569-a47b-46a3-9d94-388579f76c11", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 4,  # Slightly adjusted variance scaling for exploration\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced initial sampling by fine-tuning variance to improve exploration and convergence efficiency.", "configspace": "", "generation": 91, "fitness": 0.823519868833778, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.824 with standard deviation 0.015. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8033881780621966, 0.840928369833375, 0.8262430586057624], "final_y": [9.47975104924173e-08, 3.602793680824738e-08, 5.295215530550017e-08]}, "mutation_prompt": null}
{"id": "facd450d-8f6b-49c8-b1fc-be34173e9e6b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 2.5,  # Adjusted variance scaling factor\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhanced exploration capability by modifying the initial sampling variance scaling factor to improve convergence speed.", "configspace": "", "generation": 92, "fitness": 0.8570759060421782, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.857 with standard deviation 0.027. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8195795617462209, 0.8767280955600095, 0.874920060820304], "final_y": [8.96452431080025e-08, 1.2748434809078112e-10, 2.1192624381373023e-08]}, "mutation_prompt": null}
{"id": "a0b7845f-3bed-4c8e-9558-7b2dfe86e505", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point + np.random.uniform(-0.01, 0.01, self.dim)  # Slight perturbation added here\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced a slight perturbation to the best point to escape potential local minima during optimization.", "configspace": "", "generation": 93, "fitness": 0.8517459553994545, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.852 with standard deviation 0.028. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.812532525899681, 0.8669207749827621, 0.8757845653159207], "final_y": [6.242628985234871e-08, 1.4036324357641791e-08, 1.5854737838724653e-08]}, "mutation_prompt": null}
{"id": "46350ee1-076f-44b8-b637-919c3428f02c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + np.random.uniform(0.05, 0.15) * (refined_bounds[:, 1] - refined_bounds[:, 0])  # Adaptive momentum scaling\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Integrate adaptive momentum scaling to improve exploration-exploitation balance.", "configspace": "", "generation": 94, "fitness": 0.8135339040029024, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.814 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.79567700149459, 0.8066255670192808, 0.8382991434948364], "final_y": [2.197670237045667e-07, 1.0012229236581221e-07, 3.2350948588762754e-08]}, "mutation_prompt": null}
{"id": "00fafe1d-18b7-43c5-ac3a-18eba0eb776f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Adaptive variance scaling for initial samples\n        scaling_factor = (bounds[:, 1] - bounds[:, 0]) / (4 if n_initial_samples > 10 else 3)\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           scaling_factor,\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced adaptive variance scaling during initial sampling to better balance exploration and exploitation.", "configspace": "", "generation": 95, "fitness": 0.8181917457671686, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.818 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8408102383915363, 0.7961421779056217, 0.8176228210043477], "final_y": [3.0812224214458515e-08, 1.4886215388648433e-07, 6.476407743092544e-08]}, "mutation_prompt": null}
{"id": "d575bf26-8be2-4793-8414-bde4a4f8bac0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = (0.9 + 0.1 * function_evals / self.budget) * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Improved convergence by dynamically adjusting momentum factor based on function evaluations.", "configspace": "", "generation": 96, "fitness": 0.8748932001536948, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.875 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8493470188077118, 0.8847495171582401], "final_y": [1.0003551889631946e-09, 3.401620765472227e-08, 4.838059450246168e-09]}, "mutation_prompt": null}
{"id": "a9df73bd-ab82-4cb2-b7f0-6501174ab7f4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3, \n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)\n\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            x0 = res.x\n            shrink_factor = 0.8 * (1 - (function_evals / self.budget))  # Dynamic shrink factor adjustment\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Enhance exploitation by dynamically adjusting the shrink factor based on convergence progress.", "configspace": "", "generation": 97, "fitness": 0.8623563983564194, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.862 with standard deviation 0.020. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8459876709845348, 0.8504984595895912], "final_y": [1.0007720129176431e-09, 3.7752430878297057e-08, 2.3631324735561293e-08]}, "mutation_prompt": null}
{"id": "761c4fb7-b571-4e5d-b079-9865de8ba036", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 2,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Improved exploration by adjusting initial sample variance for better balance between exploration and exploitation.", "configspace": "", "generation": 98, "fitness": 0.8430097058068521, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.843 with standard deviation 0.014. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8607052203895662, 0.843011561451244, 0.8253123355797461], "final_y": [1.553510846543045e-08, 2.5810018251985615e-08, 5.4211131431249666e-08]}, "mutation_prompt": null}
{"id": "e10c1615-b10f-44f2-af49-dc2954d946ba", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ABRLSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        # Uniformly sample initial points within bounds\n        n_initial_samples = min(5 * self.dim, self.budget // 2)\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Variance-based scaling for initial samples\n        initial_samples = np.random.normal((bounds[:, 0] + bounds[:, 1]) / 2, \n                                           (bounds[:, 1] - bounds[:, 0]) / 3,  # Adjusted variance scaling\n                                           (n_initial_samples, self.dim))\n        function_evals = 0\n        \n        # Evaluate initial samples\n        best_value = float('inf')\n        best_point = None\n        for sample in initial_samples:\n            value = func(sample)\n            function_evals += 1\n            if value < best_value:\n                best_value = value\n                best_point = sample\n\n        # Start optimization from the best initial sample found\n        x0 = best_point\n        refined_bounds = bounds.copy()\n        velocity = np.zeros(self.dim)  # Initialize velocity for momentum\n\n        # Adaptive boundary refinement\n        while function_evals < self.budget:\n            def bounded_func(x):\n                nonlocal function_evals\n                if np.any(x < refined_bounds[:, 0]) or np.any(x > refined_bounds[:, 1]):\n                    return float('inf')  # Penalty for out of bounds\n                function_evals += 1\n                return func(x)\n\n            res = minimize(bounded_func, x0, method='L-BFGS-B', bounds=refined_bounds)\n            if res.fun < best_value:\n                best_value = res.fun\n                best_point = res.x\n\n            # Update the starting point and refine bounds\n            x0 = res.x\n            shrink_factor = 0.8\n            refined_bounds[:, 0] = np.maximum(refined_bounds[:, 0], x0 - (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            refined_bounds[:, 1] = np.minimum(refined_bounds[:, 1], x0 + (refined_bounds[:, 1] - refined_bounds[:, 0]) * (1 - shrink_factor) / 2)\n            velocity = 0.9 * velocity + (refined_bounds[:, 1] - refined_bounds[:, 0]) * 0.1  # Momentum update\n            velocity *= 1.1  # Adaptive momentum scaling to expedite convergence\n\n            if function_evals >= self.budget:\n                break\n\n        return best_point", "name": "ABRLSOptimizer", "description": "Introduced adaptive momentum scaling to expedite convergence by enhancing step size control.", "configspace": "", "generation": 99, "fitness": 0.8748932001536948, "feedback": "The algorithm ABRLSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.875 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "adb4cce5-13cc-44ba-b014-88b3949d5e9d", "metadata": {"aucs": [0.8905830644951324, 0.8493470188077118, 0.8847495171582401], "final_y": [1.0003551889631946e-09, 3.401620765472227e-08, 4.838059450246168e-09]}, "mutation_prompt": null}
