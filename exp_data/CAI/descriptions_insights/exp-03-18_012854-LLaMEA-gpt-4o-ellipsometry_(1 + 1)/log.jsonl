{"id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm combines a swarm intelligence-inspired exploration with evolutionary strategy-based exploitation to efficiently optimize black box functions within limited evaluations.", "configspace": "", "generation": 0, "fitness": 0.21093567412485878, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.211 with standard deviation 0.007. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.098.", "error": "", "parent_id": null, "metadata": {"aucs": [0.2182818336655339, 0.21316994644633191, 0.2013552422627105], "final_y": [0.03292747543013843, 0.10376723989411833, 0.26675779846634856]}, "mutation_prompt": null}
{"id": "f9366f75-e9d8-4cef-a410-a485869c387c", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.5 + (0.4 * (self.budget - eval_count) / self.budget)  # Dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm incorporates a dynamic inertia weight to balance exploration and exploitation, enhancing solution convergence within limited evaluations.", "configspace": "", "generation": 1, "fitness": 0.14669691690994432, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.147 with standard deviation 0.015. And the mean value of best solutions found was 0.706 (0. is the best) with standard deviation 0.427.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.12765819799141942, 0.16512482711132404, 0.1473077256270895], "final_y": [1.2645416649989785, 0.2271969124304403, 0.6253058473264748]}, "mutation_prompt": null}
{"id": "c6930a67-1416-48de-9895-93ae88908ce4", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                # Adjust the influence of pbest and gbest based on the progress\n                weight = 1 - (eval_count / self.budget) \n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * weight * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances exploitation by dynamically adjusting the influence of personal and global best positions based on the evaluation progress.", "configspace": "", "generation": 2, "fitness": 0.18145211601254171, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.181 with standard deviation 0.016. And the mean value of best solutions found was 0.273 (0. is the best) with standard deviation 0.063.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.16704439835458085, 0.173415879766605, 0.20389606991643927], "final_y": [0.351707187070705, 0.1985393502503193, 0.26887927869625067]}, "mutation_prompt": null}
{"id": "e4c6b08e-12c7-448a-afcc-e1bf053fd47a", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < 0.05:  # Random jump strategy\n                    population[i] = np.random.uniform(bounds[0], bounds[1], self.dim)\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm integrates a random jump strategy to enhance exploration, allowing jumps to random points within bounds to escape local optima.", "configspace": "", "generation": 3, "fitness": 0.15971275607235944, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.160 with standard deviation 0.016. And the mean value of best solutions found was 0.343 (0. is the best) with standard deviation 0.252.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13708148501276374, 0.17262715044114163, 0.1694296327631729], "final_y": [0.6730345774806049, 0.2943895424833227, 0.061136008907898616]}, "mutation_prompt": null}
{"id": "4c6edcb1-27c8-40dd-8e1f-a28661592f80", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Adaptive inertia weight\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhance convergence by introducing adaptive inertia weight in velocity calculation for improved exploration-exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.17510467990163794, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.175 with standard deviation 0.005. And the mean value of best solutions found was 0.400 (0. is the best) with standard deviation 0.053.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.17411189075905475, 0.18161516010842693, 0.16958698883743217], "final_y": [0.3650756635222657, 0.35900112755114905, 0.47494474629923544]}, "mutation_prompt": null}
{"id": "b6fe8fba-f203-4283-a997-0985abed96d7", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = 0.9 - ((0.9 - 0.4) * (eval_count / self.budget))  # Dynamically adjust inertia weight\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances its exploration capability by introducing a dynamic inertia weight adjustment to balance exploration and exploitation phases.", "configspace": "", "generation": 5, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "67514f68-e86b-464e-b79f-a3eb54446da3", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.7 + 0.3 * (1 - eval_count / self.budget)  # Dynamic inertia weight\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances convergence by dynamically adjusting the inertia weight in the velocity update of particles, fostering balance between exploration and exploitation.", "configspace": "", "generation": 6, "fitness": 0.12782333398013757, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.128 with standard deviation 0.029. And the mean value of best solutions found was 2.113 (0. is the best) with standard deviation 1.055.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.10877539392189206, 0.1054614880512511, 0.16923311996726953], "final_y": [2.438746879166507, 3.211315034979523, 0.6883055634447593]}, "mutation_prompt": null}
{"id": "7255cf79-758a-463d-b6c9-dd6203a235c5", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = 0.9 - (0.5 * eval_count / self.budget)  # adaptive inertia\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm introduces adaptive velocity scaling to balance exploration and exploitation phases, optimizing black box functions more effectively within limited evaluations.", "configspace": "", "generation": 7, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "d34310c9-4f1b-4248-88f9-fde36b52bc79", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            w = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = w * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm combines swarm intelligence-inspired exploration with evolutionary strategy-based exploitation, introducing adaptive inertia weight for improved convergence within limited evaluations.", "configspace": "", "generation": 8, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "ea5cd3ed-acca-4da8-8de3-97c5bb5cf6f1", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = 0.5 + np.random.rand() * 0.5  # Dynamically adjust inertia\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances local search efficiency by adjusting velocity coefficients dynamically based on performance.", "configspace": "", "generation": 9, "fitness": 0.1464833230309077, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.146 with standard deviation 0.004. And the mean value of best solutions found was 0.936 (0. is the best) with standard deviation 0.296.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.1439270834719435, 0.15219841952204372, 0.14332446609873584], "final_y": [0.8258868307756344, 0.6412558195322617, 1.341369706391506]}, "mutation_prompt": null}
{"id": "b240a674-12d3-40c8-8107-da6fb0c49cb2", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        inertia_weight = 0.9  # Initial inertia weight\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm utilizes an adaptive inertia weight approach for velocity update to enhance convergence speed and solution quality.", "configspace": "", "generation": 10, "fitness": 0.15751063707011417, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.158 with standard deviation 0.013. And the mean value of best solutions found was 0.692 (0. is the best) with standard deviation 0.180.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.14580870702416782, 0.17608880531299687, 0.15063439887317787], "final_y": [0.9263159782829933, 0.48776339772534155, 0.663292441379794]}, "mutation_prompt": null}
{"id": "7f4de30d-2b41-4498-90f2-c5087df8ab03", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.5 + (0.5 - 0.1) * (self.budget - eval_count) / self.budget  # Dynamic adjustment\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances exploration by dynamically adjusting the velocity coefficient to improve optimization efficiency within limited evaluations.", "configspace": "", "generation": 11, "fitness": 0.14816208848247672, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.148 with standard deviation 0.019. And the mean value of best solutions found was 0.784 (0. is the best) with standard deviation 0.508.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.12464856871193408, 0.1703483054055699, 0.14948939132992622], "final_y": [1.4796787355636214, 0.2784572363790426, 0.5941786603606671]}, "mutation_prompt": null}
{"id": "79090b3d-1de2-4345-b065-59dbc76a211f", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i]) + np.random.normal(0, 0.1, self.dim)  # Added mutation-based strategy\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm combines a swarm intelligence-inspired exploration with a mutation-based strategy to enhance convergence speed and diversify search directions for efficient optimization under a limited budget.", "configspace": "", "generation": 12, "fitness": 0.18596058919035982, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.186 with standard deviation 0.017. And the mean value of best solutions found was 0.290 (0. is the best) with standard deviation 0.244.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.16355348643900958, 0.18932208898843028, 0.20500619214363958], "final_y": [0.6330980662980192, 0.0887976902275785, 0.1474720341146653]}, "mutation_prompt": null}
{"id": "18d91e26-02f4-4cc4-aff1-d34cf71db31b", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.7 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The enhanced algorithm utilizes adaptive velocity scaling for improved convergence in black box optimization.", "configspace": "", "generation": 13, "fitness": 0.17281441860634764, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.173 with standard deviation 0.001. And the mean value of best solutions found was 0.377 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.17105393920069611, 0.17319444642124449, 0.17419487019710234], "final_y": [0.3765464677950064, 0.3774684378961005, 0.3779795274555056]}, "mutation_prompt": null}
{"id": "f5536ddb-2131-4257-afe9-b630609fc834", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = 0.9 - (0.5 * eval_count / self.budget)  # Updated line\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Introduce adaptive inertia in velocity update to enhance the convergence rate and exploration-exploitation balance.", "configspace": "", "generation": 14, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "e3a6fd24-bcbe-4e9f-89e6-a7f1091ccfe3", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - 0.7 * (eval_count / self.budget)  # Line modified to add adaptive inertia weight\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhanced HybridSwarmEvolution algorithm with adaptive inertia weight for better balance between exploration and exploitation.", "configspace": "", "generation": 15, "fitness": 0.13561015223579675, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.136 with standard deviation 0.010. And the mean value of best solutions found was 0.983 (0. is the best) with standard deviation 0.278.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.14352170819108323, 0.12127047877746133, 0.1420382697388457], "final_y": [0.8975755905274523, 0.6938884164428618, 1.3588773874518885]}, "mutation_prompt": null}
{"id": "24ee6a4f-7f39-46ac-9429-ee12a7b7cefb", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = np.linalg.norm(self.gbest - population[i]) / np.linalg.norm(bounds[1] - bounds[0])\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances particle diversity by adjusting inertia dynamically based on the distance to the global best, improving exploration and exploitation balance.", "configspace": "", "generation": 16, "fitness": 0.18988317805841673, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.190 with standard deviation 0.050. And the mean value of best solutions found was 0.485 (0. is the best) with standard deviation 0.507.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.17684936245347505, 0.13644825865512933, 0.25635191306664584], "final_y": [0.24059862663653214, 1.1910231958735524, 0.02266088147117256]}, "mutation_prompt": null}
{"id": "234b17fd-1c7e-4d27-a41e-b7c2a788a97d", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i]) + 0.1 * r3\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhanced the velocity update equation by incorporating a stochastic term to improve exploration.", "configspace": "", "generation": 17, "fitness": 0.19348682709931644, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.193 with standard deviation 0.012. And the mean value of best solutions found was 0.106 (0. is the best) with standard deviation 0.044.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.18867022971378278, 0.2097058290973407, 0.18208442248682588], "final_y": [0.07004787756414049, 0.07887447838908879, 0.16803456272022418]}, "mutation_prompt": null}
{"id": "6d3da10b-d38e-4333-9a2a-e929896da09d", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        inertia_weight = 0.7\n        c1, c2 = 1.5, 1.5  # Adaptive learning rates\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.7 - 0.5 * (eval_count / self.budget)  # Adaptive inertia\n                self.velocity[i] = inertia_weight * self.velocity[i] + c1 * r1 * (self.pbest[i] - population[i]) + c2 * r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhances exploration-exploitation balance by incorporating adaptive learning rates and dynamic neighborhood interactions.", "configspace": "", "generation": 18, "fitness": 0.20807788443095965, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.208 with standard deviation 0.030. And the mean value of best solutions found was 0.332 (0. is the best) with standard deviation 0.210.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.17387111397475252, 0.24674399932493551, 0.2036185399931909], "final_y": [0.574162730518925, 0.062054186585437494, 0.3584078621462598]}, "mutation_prompt": null}
{"id": "dfa8ce7f-0b39-4aed-9378-0e90593f446f", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Added dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhancing exploration by adjusting velocity update with a dynamic inertia weight.", "configspace": "", "generation": 19, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "1cc4d0b4-ccf7-49ea-b0af-984098aedbaa", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                self.velocity[i] *= 0.9  # Adaptive velocity scaling for improved convergence\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm integrates adaptive velocity scaling to improve convergence speed and solution quality in black box optimization.", "configspace": "", "generation": 20, "fitness": 0.19437348050866898, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.194 with standard deviation 0.008. And the mean value of best solutions found was 0.099 (0. is the best) with standard deviation 0.071.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.1836322493276642, 0.19570969083708967, 0.20377850136125308], "final_y": [0.062252993426559, 0.03656485690677117, 0.1976918677263152]}, "mutation_prompt": null}
{"id": "e7771e5c-c400-41ae-8018-360c4af301a7", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.7 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])  # Adjusted line\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances swarm exploration by adjusting the velocity update factor for improved convergence.", "configspace": "", "generation": 21, "fitness": 0.16947741141915115, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.169 with standard deviation 0.024. And the mean value of best solutions found was 0.385 (0. is the best) with standard deviation 0.107.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.14885127981181734, 0.20253208915511978, 0.15704886529051632], "final_y": [0.3445220418225152, 0.2793227885019512, 0.5314024783303278]}, "mutation_prompt": null}
{"id": "f8669233-427d-4792-a3a3-6555f52d124c", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                improvement = func(self.pbest[i]) - func(population[i])\n                adaptive_factor = max(0.1, improvement)\n                self.velocity[i] = adaptive_factor * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm uses adaptive velocity scaling based on current improvement to balance exploration and exploitation effectively within the given budget. ", "configspace": "", "generation": 22, "fitness": 0.12484111492200696, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.125 with standard deviation 0.035. And the mean value of best solutions found was 2.213 (0. is the best) with standard deviation 1.448.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.09440880833310439, 0.10689974845380723, 0.17321478797910927], "final_y": [3.6157627950521953, 2.80343777658231, 0.21958079260704205]}, "mutation_prompt": null}
{"id": "89a6fec1-421c-421d-9955-ba030da8b01d", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                # Increase the influence of random components by using a factor of 0.6\n                self.velocity[i] = 0.6 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "This refined algorithm enhances global exploration by slightly increasing random influence in velocity updates for improved convergence on black box optimization tasks.", "configspace": "", "generation": 23, "fitness": 0.20645327972820127, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.206 with standard deviation 0.008. And the mean value of best solutions found was 0.190 (0. is the best) with standard deviation 0.098.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.20778322289307805, 0.1964398935240128, 0.21513672276751294], "final_y": [0.12234499976336675, 0.32921290749446686, 0.11890109032734045]}, "mutation_prompt": null}
{"id": "1fc1dcb8-d3e8-4e46-9f07-771540cecc96", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - (0.5 * (eval_count / self.budget)) # Dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The improved algorithm uses dynamic inertia weight adjustment in swarm intelligence to balance exploration and exploitation.", "configspace": "", "generation": 24, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "04b84aee-9bfa-403e-b259-8611988d9f44", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        inertia_weight = 0.7\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + \n                                    r2 * (self.gbest - population[i]))\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "This refined algorithm tweaks the velocity update equation to incorporate an additional inertia weight factor, enhancing the balance between exploration and exploitation.  ", "configspace": "", "generation": 25, "fitness": 0.16947741141915115, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.169 with standard deviation 0.024. And the mean value of best solutions found was 0.385 (0. is the best) with standard deviation 0.107.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.14885127981181734, 0.20253208915511978, 0.15704886529051632], "final_y": [0.3445220418225152, 0.2793227885019512, 0.5314024783303278]}, "mutation_prompt": null}
{"id": "54955c11-f3c9-4b71-bf04-6a6530a6a170", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.7 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhancing exploitation by adjusting velocity scaling factor for improved convergence.", "configspace": "", "generation": 26, "fitness": 0.16947741141915115, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.169 with standard deviation 0.024. And the mean value of best solutions found was 0.385 (0. is the best) with standard deviation 0.107.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.14885127981181734, 0.20253208915511978, 0.15704886529051632], "final_y": [0.3445220418225152, 0.2793227885019512, 0.5314024783303278]}, "mutation_prompt": null}
{"id": "4adffc16-0abe-4830-9760-1c678eca7b80", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm refines HybridSwarmEvolution by adjusting inertia weight dynamically based on evaluations to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "2b0fdc76-420b-4737-8c4b-de8a995fc28c", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        inertia_weight = 0.9  # Initializing inertia weight\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                # Adjusting the inertia weight dynamically\n                inertia_weight -= 0.4 / self.budget  \n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "This refined algorithm introduces a subtle improvement by adjusting the inertia weight dynamically to enhance the balance between exploration and exploitation, potentially improving convergence.", "configspace": "", "generation": 28, "fitness": 0.13531534892166477, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.135 with standard deviation 0.009. And the mean value of best solutions found was 0.906 (0. is the best) with standard deviation 0.412.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.12353251698374856, 0.1359579940571164, 0.1464555357241294], "final_y": [1.419023900294808, 0.4100028274014208, 0.8874928941642656]}, "mutation_prompt": null}
{"id": "5bffdf80-a881-4e0e-a76b-71b86b964d26", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.9 - (0.5 * (eval_count / self.budget))\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm integrates adaptive inertia weight to dynamically balance exploration and exploitation in optimizing black box functions.", "configspace": "", "generation": 29, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "fb655410-5cfa-46bd-bf55-ec16e92190de", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                # Modified velocity update with a dynamic inertia weight for improved convergence\n                inertia_weight = 0.5 + 0.5 * (self.budget - eval_count) / self.budget\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhancing the velocity update mechanism in HybridSwarmEvolution for improved convergence rate in black box optimization.", "configspace": "", "generation": 30, "fitness": 0.13444848816297947, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.134 with standard deviation 0.036. And the mean value of best solutions found was 1.769 (0. is the best) with standard deviation 1.515.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.12028467593090397, 0.09934757542875594, 0.18371321312927846], "final_y": [1.0105667403685505, 3.883234514966444, 0.41197564546607846]}, "mutation_prompt": null}
{"id": "91c7a6ae-fa7e-4042-bfd3-50c19208793a", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Changed line\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances its convergence by introducing a dynamic inertia weight to balance exploration and exploitation phases effectively.", "configspace": "", "generation": 31, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "165e3069-f902-4d1a-9a52-2e8da236aee9", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                distance_factor = np.linalg.norm(self.gbest - population[i])\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i]) / (1 + distance_factor)\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances swarm exploration with adaptive velocity scaling based on solution distance from the global best.", "configspace": "", "generation": 32, "fitness": 0.130006873425616, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.130 with standard deviation 0.014. And the mean value of best solutions found was 0.979 (0. is the best) with standard deviation 0.746.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.11103480853084136, 0.14524663850341168, 0.133739173242595], "final_y": [0.7007448386644813, 0.2370271713664541, 2.0003842291259266]}, "mutation_prompt": null}
{"id": "18b64fad-ee71-494d-b37f-803e33ff5193", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Adaptive inertia weight\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm employs adaptive inertia weight for velocity updates to enhance convergence efficiency.", "configspace": "", "generation": 33, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "0c5426ea-b278-4e56-9da3-0c59284a0d42", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances the velocity update mechanism by integrating a dynamic inertia factor to balance exploration and exploitation more effectively.", "configspace": "", "generation": 34, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "9565812f-86cc-414a-a3a5-ab8791ec05a5", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm now utilizes a dynamic inertia weight in its velocity update to balance exploration and exploitation more effectively.", "configspace": "", "generation": 35, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "07361895-d23c-4fd8-8e43-27e2b7729760", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - 0.4 * (eval_count / self.budget)  # Dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances convergence by adjusting the inertia weight dynamically based on the iteration count for improved balance between exploration and exploitation.", "configspace": "", "generation": 36, "fitness": 0.14669691690994432, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.147 with standard deviation 0.015. And the mean value of best solutions found was 0.706 (0. is the best) with standard deviation 0.427.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.12765819799141942, 0.16512482711132404, 0.1473077256270895], "final_y": [1.2645416649989785, 0.22719691243040221, 0.6253058473264956]}, "mutation_prompt": null}
{"id": "8fe98c79-2c61-40e4-b586-495f2d16a5bd", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - ((0.9 - 0.4) * eval_count / self.budget)  # Dynamically adjust inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances convergence by dynamically adjusting the inertia weight in the swarm's velocity update to balance exploration and exploitation.", "configspace": "", "generation": 37, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "61abb2c8-8009-4d24-8d4b-1104cb0edc3c", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.9 - (0.5 * (eval_count / self.budget))  # Adaptive inertia weight\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances swarm exploration by introducing adaptive inertia weight to balance exploration and exploitation dynamically.", "configspace": "", "generation": 38, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "fcd1d47c-2fce-408c-a736-17d1d54cd9a5", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        inertia_weight = 0.9\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "By introducing adaptive inertia weights to the velocity update in the HybridSwarmEvolution algorithm, the exploration-exploitation balance is enhanced to optimize performance.", "configspace": "", "generation": 39, "fitness": 0.12663379045466072, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.127 with standard deviation 0.010. And the mean value of best solutions found was 1.562 (0. is the best) with standard deviation 0.714.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.11583241955873202, 0.12431372837072141, 0.13975522343452873], "final_y": [2.317881232485276, 1.7640660467751483, 0.6038035421681122]}, "mutation_prompt": null}
{"id": "bd4ff1e9-c3b7-4c9d-858d-5b6a69008af6", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - (0.5 * (eval_count / self.budget))  # Dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm integrates a dynamic adjustment of the inertia weight in its velocity update to enhance convergence and exploration capabilities.", "configspace": "", "generation": 40, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "5152047f-e0ed-46bb-9040-2f663146613d", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm improves exploitation by adjusting the inertia weight dynamically based on the evaluations performed, which helps balance exploration and exploitation more effectively within the limited budget.", "configspace": "", "generation": 41, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "81265ed6-87b3-4ef9-8d11-9ce02b704c75", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - (0.5 * (eval_count / self.budget))\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhancing the HybridSwarmEvolution by introducing a dynamic inertia factor to improve convergence speed and accuracy.", "configspace": "", "generation": 42, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "380e5eec-f505-4121-a657-85f48e488a04", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        momentum = 0.9  # Introducing a momentum term\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = momentum * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances the velocity update mechanism by introducing a momentum term to balance exploration and exploitation for efficient optimization.", "configspace": "", "generation": 43, "fitness": 0.12663379045466072, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.127 with standard deviation 0.010. And the mean value of best solutions found was 1.562 (0. is the best) with standard deviation 0.714.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.11583241955873202, 0.12431372837072141, 0.13975522343452873], "final_y": [2.317881232485276, 1.7640660467751483, 0.6038035421681122]}, "mutation_prompt": null}
{"id": "901c8880-3263-45e8-90d1-3a55c76d9598", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                # Changed line: dynamically adjust cognitive component\n                cognitive_weight = 0.5 / (1.0 + np.linalg.norm(self.gbest - population[i]))\n                self.velocity[i] = cognitive_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances swarm exploration by dynamically adjusting the cognitive component's weight based on the distance from the global best position, to improve convergence speed and solution quality.", "configspace": "", "generation": 44, "fitness": 0.137449098896167, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.030. And the mean value of best solutions found was 0.852 (0. is the best) with standard deviation 0.562.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.11415516864465747, 0.1182682822068204, 0.17992384583702314], "final_y": [1.168696181775194, 1.325432975487799, 0.06281308546141133]}, "mutation_prompt": null}
{"id": "8aa015f2-a0e4-42a4-8e0a-c77d7476e316", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - (0.5 * (eval_count / self.budget))  # Adaptive inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm augments swarm intelligence exploration with an adaptive inertia weight for enhanced convergence in black box optimization.", "configspace": "", "generation": 45, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "51ba5253-92df-4878-a4cd-f8035e4506f1", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n\n        inertia_weight = 0.9  # Adding line for adaptive inertia weight\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm refines particle velocity updates with an adaptive inertia weight for improved exploration-exploitation balance.", "configspace": "", "generation": 46, "fitness": 0.12663379045466072, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.127 with standard deviation 0.010. And the mean value of best solutions found was 1.562 (0. is the best) with standard deviation 0.714.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.11583241955873202, 0.12431372837072141, 0.13975522343452873], "final_y": [2.317881232485276, 1.7640660467751483, 0.6038035421681122]}, "mutation_prompt": null}
{"id": "4ac13ade-6681-4ae1-a8cb-27eb73a56d9f", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.4 + 0.1 * (self.budget - eval_count) / self.budget  # Dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances its exploration phase by adjusting the inertia weight dynamically based on the remaining budget to balance exploration and exploitation more effectively.", "configspace": "", "generation": 47, "fitness": 0.1818830890621177, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.182 with standard deviation 0.023. And the mean value of best solutions found was 0.251 (0. is the best) with standard deviation 0.189.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.15710592745681684, 0.17617746720650318, 0.21236587252303307], "final_y": [0.5174336036082551, 0.11790773844745256, 0.1165134776077531]}, "mutation_prompt": null}
{"id": "de74991e-9adc-490a-8137-0f0126df3f8e", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm refines the balance between exploration and exploitation by dynamically adjusting velocity scaling in response to search progress.", "configspace": "", "generation": 48, "fitness": 0.18481935982679698, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.185 with standard deviation 0.038. And the mean value of best solutions found was 0.269 (0. is the best) with standard deviation 0.182.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13871185095467986, 0.1839109308319944, 0.2318352976937167], "final_y": [0.511628395943185, 0.22210963362150343, 0.0725668509094268]}, "mutation_prompt": null}
{"id": "b1846d72-e30e-4657-bd89-6c649e0d0290", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i]) + 0.1 * r3 * (np.mean(population, axis=0) - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances velocity updates by incorporating an additional social learning factor to boost convergence speed.", "configspace": "", "generation": 49, "fitness": 0.18880151336259374, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.189 with standard deviation 0.012. And the mean value of best solutions found was 0.255 (0. is the best) with standard deviation 0.062.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.18466046888467313, 0.17645251825728703, 0.20529155294582102], "final_y": [0.16785720123311704, 0.2864008557471362, 0.3104788283620232]}, "mutation_prompt": null}
{"id": "7302ab64-0067-4ef3-8a62-ded1efca41ab", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n        self.elite_fraction = 0.2  # New parameter for elite retention, change 1/17\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            adaptive_scale = 1 - (eval_count / self.budget)  # Adaptive velocity scaling, change 2/17\n            elite_count = int(self.population_size * self.elite_fraction)  # Number of elites, change 3/17\n            elite_indices = np.argsort([func(ind) for ind in population])[:elite_count]  # Select elites, change 4/17\n            for i in range(self.population_size):\n                if i not in elite_indices:\n                    r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                    self.velocity[i] = adaptive_scale * (0.5 * self.velocity[i] + \n                                                        r1 * (self.pbest[i] - population[i]) + \n                                                        r2 * (self.gbest - population[i]))  # Apply scaling, change 5/17\n                    population[i] += self.velocity[i]\n                    population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                    if func(population[i]) < func(self.pbest[i]):\n                        self.pbest[i] = population[i]\n                \n                    if func(population[i]) < func(self.gbest):\n                        self.gbest = population[i]\n                    \n                    eval_count += 1\n                    if eval_count >= self.budget:\n                        break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhances HybridSwarmEvolution by introducing adaptive velocity scaling and elite retention for improved convergence efficiency.", "configspace": "", "generation": 50, "fitness": 0.1907686021071342, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.191 with standard deviation 0.022. And the mean value of best solutions found was 0.291 (0. is the best) with standard deviation 0.146.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.2209921403113485, 0.1803416997438967, 0.1709719662661574], "final_y": [0.11589072677141962, 0.47415419498298483, 0.282937477809167]}, "mutation_prompt": null}
{"id": "2b00df16-798a-40a8-9419-2661e28bd792", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - (0.5 * (eval_count / self.budget))  # Line changed\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The refined algorithm adds an inertia weight reduction mechanism to balance exploration and exploitation better, potentially improving convergence performance within the budget constraints.", "configspace": "", "generation": 51, "fitness": 0.16834184373258076, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.168 with standard deviation 0.031. And the mean value of best solutions found was 0.754 (0. is the best) with standard deviation 0.370.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.21186770174501557, 0.1538455347451504, 0.13931229470757633], "final_y": [0.230487447732704, 1.0246593878453591, 1.0068881871150652]}, "mutation_prompt": null}
{"id": "cbee2b82-d8ed-440f-8d7b-e600d8e2c4f6", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                # Modified line for adaptive velocity scaling\n                inertia_weight = 0.5 + 0.5 * (self.budget - eval_count) / self.budget\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "A hybrid algorithm enhancing swarm intelligence with evolutionary strategies, now augmented by adaptive velocity scaling to balance exploration and exploitation.", "configspace": "", "generation": 52, "fitness": 0.13444848816297947, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.134 with standard deviation 0.036. And the mean value of best solutions found was 1.769 (0. is the best) with standard deviation 1.515.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.12028467593090397, 0.09934757542875594, 0.18371321312927846], "final_y": [1.0105667403685505, 3.883234514966444, 0.41197564546607846]}, "mutation_prompt": null}
{"id": "929ab136-d6bb-4372-91ed-55a8dfef4e2e", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        inertia_weight = 0.7  # Added line: Introduce inertia weight\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Introduce inertia weight to balance exploration and exploitation in velocity update for improved convergence.", "configspace": "", "generation": 53, "fitness": 0.16947741141915115, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.169 with standard deviation 0.024. And the mean value of best solutions found was 0.385 (0. is the best) with standard deviation 0.107.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.14885127981181734, 0.20253208915511978, 0.15704886529051632], "final_y": [0.3445220418225152, 0.2793227885019512, 0.5314024783303278]}, "mutation_prompt": null}
{"id": "4ae1326d-2dce-432b-9256-da706547307d", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        inertia_weight = 0.9\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "A hybrid algorithm that enhances the balance of exploration and exploitation by dynamically adjusting inertia weight in the particle swarm strategy to optimize black box functions efficiently.", "configspace": "", "generation": 54, "fitness": 0.12663379045466072, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.127 with standard deviation 0.010. And the mean value of best solutions found was 1.562 (0. is the best) with standard deviation 0.714.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.11583241955873202, 0.12431372837072141, 0.13975522343452873], "final_y": [2.317881232485276, 1.7640660467751483, 0.6038035421681122]}, "mutation_prompt": null}
{"id": "ee2a8fe6-f83c-4ecc-aba6-8718616503da", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.9 - 0.7 * (eval_count / self.budget)  # Time-varying inertia weight\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm employs a time-varying inertia weight in the velocity update equation to enhance balance between exploration and exploitation.", "configspace": "", "generation": 55, "fitness": 0.15108589986626975, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.151 with standard deviation 0.007. And the mean value of best solutions found was 0.432 (0. is the best) with standard deviation 0.168.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.15397243861174503, 0.14174429599510896, 0.15754096499195525], "final_y": [0.19817950673020113, 0.516785732487249, 0.5817269768046979]}, "mutation_prompt": null}
{"id": "2e56e119-636d-4cfd-99f3-ca67e16aa490", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - 0.4 * (eval_count / self.budget)  # Dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm utilizes a dynamic inertia weight based on the evaluation budget to enhance the balance between exploration and exploitation phases.", "configspace": "", "generation": 56, "fitness": 0.14669691690994432, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.147 with standard deviation 0.015. And the mean value of best solutions found was 0.706 (0. is the best) with standard deviation 0.427.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.12765819799141942, 0.16512482711132404, 0.1473077256270895], "final_y": [1.2645416649989785, 0.22719691243040221, 0.6253058473264956]}, "mutation_prompt": null}
{"id": "4cb43c9a-df50-4ee2-9da5-a0ec4779c0c1", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - (0.5 * (eval_count / self.budget))\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "By introducing a dynamic inertia weight in the velocity update equation, the algorithm enhances convergence by balancing exploration and exploitation adaptively.", "configspace": "", "generation": 57, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "b80b3b7d-3750-4dac-8cfc-af91b0553bfb", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - 0.7 * (eval_count / self.budget)  # Dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm refines velocity update by incorporating an inertia weight that dynamically decreases, enhancing exploration in early stages of optimization and exploitation in later stages.", "configspace": "", "generation": 58, "fitness": 0.13561015223579675, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.136 with standard deviation 0.010. And the mean value of best solutions found was 0.983 (0. is the best) with standard deviation 0.278.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.14352170819108323, 0.12127047877746133, 0.1420382697388457], "final_y": [0.8975755905274523, 0.6938884164428618, 1.3588773874518885]}, "mutation_prompt": null}
{"id": "71a0d32d-e320-498d-89c0-8c9e48d2e33a", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.7 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances exploration by adjusting velocity scaling to improve convergence towards the global best solution.", "configspace": "", "generation": 59, "fitness": 0.16947741141915115, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.169 with standard deviation 0.024. And the mean value of best solutions found was 0.385 (0. is the best) with standard deviation 0.107.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.14885127981181734, 0.20253208915511978, 0.15704886529051632], "final_y": [0.3445220418225152, 0.2793227885019512, 0.5314024783303278]}, "mutation_prompt": null}
{"id": "b5e2b4ba-17f5-4a7c-8f02-78298a27afd3", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - (0.5 * (eval_count / self.budget))  # Adaptive inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm incorporates adaptive inertia weight to balance exploration and exploitation dynamically during the optimization process.", "configspace": "", "generation": 60, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "fe9cc475-5900-48bd-833f-de7bc1d07fd2", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        inertia_weight = 0.9  # New addition for dynamic inertia weight\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight update\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm employs a dynamic inertia weight to enhance exploration and exploitation balance, refining the velocity update strategy within the swarm intelligence-based optimization process.", "configspace": "", "generation": 61, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "19176190-24eb-4e19-a006-4015204bf33d", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += 0.7 * self.velocity[i]  # Changed line: Adaptive velocity scaling factor\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm employs adaptive velocity scaling in swarm evolution to enhance convergence speed and precision in black box optimization.", "configspace": "", "generation": 62, "fitness": 0.17048223350123828, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.170 with standard deviation 0.008. And the mean value of best solutions found was 0.227 (0. is the best) with standard deviation 0.049.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.1598479430725257, 0.1759024710148127, 0.17569628641637647], "final_y": [0.2847406619517261, 0.16452876450254397, 0.2322323997552266]}, "mutation_prompt": null}
{"id": "6ddc5307-f7d5-4cc4-8f72-b2b81b132b5b", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        w_max, w_min = 0.9, 0.4  # Adaptive inertia weight\n        \n        while eval_count < self.budget:\n            inertia_weight = w_max - ((w_max - w_min) * eval_count / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = (inertia_weight * self.velocity[i] + \n                                    r1 * (self.pbest[i] - population[i]) + \n                                    r2 * (self.gbest - population[i]))\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances the swarm dynamics by incorporating adaptive inertia weights to balance exploration and exploitation, aiming to improve convergence within the evaluation budget.", "configspace": "", "generation": 63, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "2bafffe6-9e16-440b-920d-b040d528fe02", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "By dynamically adapting the inertia weight based on the evaluation count, the HybridSwarmEvolution algorithm enhances exploration and exploitation balance, leading to improved optimization performance.", "configspace": "", "generation": 64, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "f2652533-bf7e-42e4-a9fc-15a2c3278e03", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        constriction_coefficient = 0.729  # Added line for convergence stability\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = constriction_coefficient * (0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i]))\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm integrates a constriction coefficient to enhance convergence stability and control particle velocities during optimization.", "configspace": "", "generation": 65, "fitness": 0.18719229823650096, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.187 with standard deviation 0.005. And the mean value of best solutions found was 0.104 (0. is the best) with standard deviation 0.038.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.17957051338243402, 0.19013703499695156, 0.19186934633011732], "final_y": [0.13267381146527205, 0.04970810871627413, 0.1298331679559396]}, "mutation_prompt": null}
{"id": "f86cc4d6-cddf-40a1-887d-52ef2f1f9056", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.9 - 0.5 * eval_count / self.budget  # Modified line\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Modified inertia weight strategy to enhance balance between exploration and exploitation in HybridSwarmEvolution.", "configspace": "", "generation": 66, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "dc69f7db-660e-4455-8081-5033a869f198", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        inertia_weight = 0.7  # New line: Adding an inertia weight factor\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])  # Modified line\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "By incorporating an inertia weight factor in the velocity update equation, the algorithm achieves better balance between exploration and exploitation, potentially leading to improved convergence.", "configspace": "", "generation": 67, "fitness": 0.16947741141915115, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.169 with standard deviation 0.024. And the mean value of best solutions found was 0.385 (0. is the best) with standard deviation 0.107.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.14885127981181734, 0.20253208915511978, 0.15704886529051632], "final_y": [0.3445220418225152, 0.2793227885019512, 0.5314024783303278]}, "mutation_prompt": null}
{"id": "481cd900-9b0d-48a2-8048-e96d5270e565", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        momentum = 0.9  # Added adaptive momentum factor\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = momentum * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm integrates adaptive momentum in velocity updates to enhance convergence efficiency within the given evaluation budget. ", "configspace": "", "generation": 68, "fitness": 0.12663379045466072, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.127 with standard deviation 0.010. And the mean value of best solutions found was 1.562 (0. is the best) with standard deviation 0.714.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.11583241955873202, 0.12431372837072141, 0.13975522343452873], "final_y": [2.317881232485276, 1.7640660467751483, 0.6038035421681122]}, "mutation_prompt": null}
{"id": "a19f52dc-e6b5-4a64-b2e0-0ec803db3eeb", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamically adjust inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances convergence by adjusting the inertia weight dynamically based on the evaluation budget.", "configspace": "", "generation": 69, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "4be9f81f-c32f-4e79-a449-552c47d8d078", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_factor = 0.7  # Modified line: introducing an inertia factor\n                self.velocity[i] = inertia_factor * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm leverages a refined inertia factor in the velocity update to balance exploration and exploitation, optimizing convergence within the given budget.", "configspace": "", "generation": 70, "fitness": 0.16947741141915115, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.169 with standard deviation 0.024. And the mean value of best solutions found was 0.385 (0. is the best) with standard deviation 0.107.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.14885127981181734, 0.20253208915511978, 0.15704886529051632], "final_y": [0.3445220418225152, 0.2793227885019512, 0.5314024783303278]}, "mutation_prompt": null}
{"id": "ffcd7772-4f70-482e-9410-2afc510c4af6", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Adaptive inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm introduces adaptive inertia weight to the swarm-based component, enhancing convergence precision and solution quality within limited evaluations.", "configspace": "", "generation": 71, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "4961d74e-ce1d-486a-8efd-c0b42bfec7e0", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.9 - (eval_count / self.budget) * 0.5  # Dynamically adjust inertia weight\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm integrates a dynamic inertia weight in the velocity update to balance exploration and exploitation for improved optimization performance.", "configspace": "", "generation": 72, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "551fb93f-9b39-4d4f-8e78-5118c4823efe", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - (0.5 * (eval_count / self.budget))  # Dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm is enhanced by adding a dynamic inertia weight to the velocity update to balance exploration and exploitation more effectively.", "configspace": "", "generation": 73, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "496c5299-dd52-457b-aff5-ae68135b295e", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm refines velocity update by introducing adaptive inertia to better balance exploration and exploitation in the search space.", "configspace": "", "generation": 74, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "6aef8708-e6f6-4426-9f23-0b91401f696c", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.5 + 0.5 * (self.budget - eval_count) / self.budget  # Dynamically adjust inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm improves exploitation by adjusting inertia weight dynamically in the velocity update equation to enhance convergence speed in black box optimization.", "configspace": "", "generation": 75, "fitness": 0.13897185437279735, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.139 with standard deviation 0.041. And the mean value of best solutions found was 1.737 (0. is the best) with standard deviation 1.230.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.11564312573484958, 0.10512660505607097, 0.19614583232747151], "final_y": [1.7237786758433977, 3.2500502602337344, 0.23835373059985449]}, "mutation_prompt": null}
{"id": "52686795-54a4-4f32-b53e-6a58e0b79420", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.5 + 0.5 * np.random.rand()  # Adjusted line\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances swarm intelligence by dynamically adjusting individual learning rates, maintaining efficient exploration and exploitation for black box optimization.", "configspace": "", "generation": 76, "fitness": 0.1464833230309077, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.146 with standard deviation 0.004. And the mean value of best solutions found was 0.936 (0. is the best) with standard deviation 0.296.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.1439270834719435, 0.15219841952204372, 0.14332446609873584], "final_y": [0.8258868307756344, 0.6412558195322617, 1.341369706391506]}, "mutation_prompt": null}
{"id": "6a7933d6-9997-4d22-9273-429eed53f89c", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        w_max = 0.9\n        w_min = 0.4\n        \n        while eval_count < self.budget:\n            w = w_max - (w_max - w_min) * (eval_count / self.budget)  # Adaptive inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = w * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances exploration by introducing an adaptive inertia weight, balancing exploration and exploitation dynamically throughout the optimization process.", "configspace": "", "generation": 77, "fitness": 0.17597529742794746, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.176 with standard deviation 0.036. And the mean value of best solutions found was 0.793 (0. is the best) with standard deviation 0.556.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.2249607768033981, 0.16171692994092524, 0.141248185539519], "final_y": [0.060442989092804406, 0.9117483878285988, 1.4079239906283576]}, "mutation_prompt": null}
{"id": "c7632487-4d87-4a37-bbc6-1464283f8178", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                # Introduce a chaotic term to enhance exploration\n                chaotic_term = np.sin(eval_count)\n                self.velocity[i] = 0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i]) + chaotic_term\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm improves global exploration by introducing a chaotic term to the velocity update, enhancing the diversity of the search process.", "configspace": "", "generation": 78, "fitness": 0.14072063840054594, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.141 with standard deviation 0.007. And the mean value of best solutions found was 0.864 (0. is the best) with standard deviation 0.167.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.1490553420849008, 0.13241294977033002, 0.140693623346407], "final_y": [0.813541602167767, 1.089235191045555, 0.6906561570433879]}, "mutation_prompt": null}
{"id": "07d28085-6e80-453f-9d8e-e5b25c85b6bf", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.7 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])  # Adjusted inertia weight\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhanced exploration by adjusting the velocity update formula to improve convergence rate in black box optimization.", "configspace": "", "generation": 79, "fitness": 0.16947741141915115, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.169 with standard deviation 0.024. And the mean value of best solutions found was 0.385 (0. is the best) with standard deviation 0.107.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.14885127981181734, 0.20253208915511978, 0.15704886529051632], "final_y": [0.3445220418225152, 0.2793227885019512, 0.5314024783303278]}, "mutation_prompt": null}
{"id": "d11bcf54-f184-4990-a483-3ce2ae319102", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - (0.5 * (eval_count / self.budget))  # Dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm integrates dynamic inertia weight adjustment for velocity updates in swarm intelligence, enhancing convergence efficiency under limited evaluations.", "configspace": "", "generation": 80, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "581ba48c-ad1f-445c-b56a-ac42efb1f9af", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.7 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances convergence by increasing the randomness factor in velocity, boosting exploration capabilities.", "configspace": "", "generation": 81, "fitness": 0.16947741141915115, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.169 with standard deviation 0.024. And the mean value of best solutions found was 0.385 (0. is the best) with standard deviation 0.107.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.14885127981181734, 0.20253208915511978, 0.15704886529051632], "final_y": [0.3445220418225152, 0.2793227885019512, 0.5314024783303278]}, "mutation_prompt": null}
{"id": "2d92ff52-1c5f-44bb-804d-65b67d91f709", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The refined algorithm incorporates an adaptive inertia weight to enhance the exploration-exploitation balance in HybridSwarmEvolution.", "configspace": "", "generation": 82, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "c0419c02-a97a-440f-940d-c91dcc612188", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Non-linear inertia weight\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Introduced a non-linear inertia weight to improve convergence behavior by balancing exploration and exploitation dynamically.", "configspace": "", "generation": 83, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "c2f44b1b-8175-4761-8e28-7fcd5bc5c05e", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = 0.7 - 0.5 * (eval_count / self.budget)  # Adaptive inertia\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm refines the swarm velocity update by introducing adaptive inertia to balance exploration and exploitation more effectively.", "configspace": "", "generation": 84, "fitness": 0.17152409351340983, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.172 with standard deviation 0.012. And the mean value of best solutions found was 0.276 (0. is the best) with standard deviation 0.107.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.1584197229627594, 0.1679581534061656, 0.1881944041713045], "final_y": [0.21552696756434228, 0.4261829627003022, 0.18496120371498023]}, "mutation_prompt": null}
{"id": "dc9f6f27-4c39-4418-a42f-ac274fa1ebb5", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Change: dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances exploration by adjusting the inertia weight dynamically based on the remaining budget, improving convergence speed and solution quality.", "configspace": "", "generation": 85, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "4f662f83-a0fd-4626-bfd7-bfa031c90325", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = 0.5 * (1 - eval_count / self.budget)  # Adjusting inertia dynamically\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm refines its exploration by dynamically adjusting velocity weights based on iteration progress, combining swarm and evolutionary strategies within limited evaluations.", "configspace": "", "generation": 86, "fitness": 0.19126848724158232, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.191 with standard deviation 0.017. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.060.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.17024628681593734, 0.1905985599421567, 0.21296061496665297], "final_y": [0.07278516091652369, 0.210462234728616, 0.09657300610589566]}, "mutation_prompt": null}
{"id": "b84750a4-ce92-4cf3-802a-7ffb14201885", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                # Adjusted line: Dynamically scale velocity\n                inertia_weight = 0.5 + 0.5 * (1 - eval_count / self.budget) \n\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhance exploration by dynamically adjusting the velocity scaling factor to balance exploration and exploitation.", "configspace": "", "generation": 87, "fitness": 0.13444848816297947, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.134 with standard deviation 0.036. And the mean value of best solutions found was 1.769 (0. is the best) with standard deviation 1.515.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.12028467593090397, 0.09934757542875594, 0.18371321312927846], "final_y": [1.0105667403685505, 3.883234514966444, 0.41197564546607846]}, "mutation_prompt": null}
{"id": "0238295e-c9f2-47f9-828b-113aaad8bfb5", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        inertia_weight = 0.7  # Inertia weight for velocity update\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhanced inertia weight adjustment in velocity update improves convergence by balancing exploration and exploitation.", "configspace": "", "generation": 88, "fitness": 0.16947741141915115, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.169 with standard deviation 0.024. And the mean value of best solutions found was 0.385 (0. is the best) with standard deviation 0.107.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.14885127981181734, 0.20253208915511978, 0.15704886529051632], "final_y": [0.3445220418225152, 0.2793227885019512, 0.5314024783303278]}, "mutation_prompt": null}
{"id": "a9ae9366-fd22-4802-a41f-ab5e5ea963c6", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.7 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm leverages swarm intelligence and evolutionary strategies to optimize functions, with an improved velocity update factor for enhanced convergence.", "configspace": "", "generation": 89, "fitness": 0.16947741141915115, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.169 with standard deviation 0.024. And the mean value of best solutions found was 0.385 (0. is the best) with standard deviation 0.107.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.14885127981181734, 0.20253208915511978, 0.15704886529051632], "final_y": [0.3445220418225152, 0.2793227885019512, 0.5314024783303278]}, "mutation_prompt": null}
{"id": "809da902-649c-44d7-8601-c6f9f5ddc78f", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm uses a dynamic inertia weight to balance exploration and exploitation in hybrid swarm and evolutionary optimization.", "configspace": "", "generation": 90, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "d90a3d98-c418-4258-8507-28b4ef571728", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.9 - eval_count / (2 * self.budget)  # Adaptive inertia weight\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm leverages an adaptive inertia weight in the velocity update to balance exploration and exploitation dynamically.", "configspace": "", "generation": 91, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "9e233a8d-380a-4c3c-bb03-477d39534b6d", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Changed line: adaptive inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = w * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Introduce adaptive inertia weight to enhance exploration-exploitation balance in HybridSwarmEvolution.", "configspace": "", "generation": 92, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "ca197ddc-c043-4db7-ba70-0c5a99a6574c", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Adaptive inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Integrate adaptive inertia weight in velocity update to enhance the balance between exploration and exploitation.", "configspace": "", "generation": 93, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "5d12d8e7-26ae-415f-b00e-0d66fe80de20", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Introducing a dynamic inertia weight in the velocity update to balance exploration and exploitation more effectively.", "configspace": "", "generation": 94, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "9cf29dff-c9d0-48c5-a8a8-7466561ef570", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Enhance exploration by replacing a fixed inertia weight with a dynamic one that decreases over iterations.", "configspace": "", "generation": 95, "fitness": 0.14362572834597753, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.003. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.156.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13970060806295692, 0.14708134171018084, 0.14409523526479484], "final_y": [0.49203535960107786, 0.6713755307527013, 0.874976605362164]}, "mutation_prompt": null}
{"id": "994ed235-7a47-4f2a-bae7-1de1c43321fb", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocity[i] = 0.4 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm optimizes using swarm intelligence and evolutionary strategies, with improved global influence by adjusting the velocity update rule.", "configspace": "", "generation": 96, "fitness": 0.18509196292477167, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.185 with standard deviation 0.018. And the mean value of best solutions found was 0.111 (0. is the best) with standard deviation 0.045.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.16293680288065382, 0.18549702613118013, 0.20684205976248105], "final_y": [0.11781535069336639, 0.16141180645526623, 0.05247877832693912]}, "mutation_prompt": null}
{"id": "bd5f840b-4b2a-4c02-bd0c-5d6aada2e26b", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity_damping = 0.98  # Added velocity damping factor\n                self.velocity[i] = velocity_damping * (0.5 * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i]))\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "Integrate velocity damping to enhance convergence stability in HybridSwarmEvolution.", "configspace": "", "generation": 97, "fitness": 0.17306471986527874, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.173 with standard deviation 0.030. And the mean value of best solutions found was 0.430 (0. is the best) with standard deviation 0.208.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.1603085863857131, 0.14419984981600986, 0.2146857233941133], "final_y": [0.30280884310863276, 0.723359256538193, 0.26246809893942347]}, "mutation_prompt": null}
{"id": "59be7b61-bc81-4a5f-a5fe-eb6e6412e922", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Dynamic inertia weight\n                self.velocity[i] = inertia_weight * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm enhances the swarm intelligence-inspired exploration by introducing a dynamic inertia weight strategy to balance exploration and exploitation efficiently.", "configspace": "", "generation": 98, "fitness": 0.13725642888070647, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.137 with standard deviation 0.009. And the mean value of best solutions found was 0.931 (0. is the best) with standard deviation 0.133.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.13070601552087868, 0.13117842824857873, 0.14988484287266202], "final_y": [0.7791754555217912, 1.103380846616059, 0.9099300112338795]}, "mutation_prompt": null}
{"id": "c172394e-7e0a-42e6-aa03-983e7903a852", "solution": "import numpy as np\n\nclass HybridSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.sqrt(self.budget))\n        self.pbest = None\n        self.gbest = None\n        self.velocity = None\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.uniform(bounds[0], bounds[1], (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.pbest = population.copy()\n        self.gbest = population[np.argmin([func(ind) for ind in population])]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = 0.5 - (0.3 * (eval_count / self.budget))  # Adaptive inertia\n                self.velocity[i] = inertia * self.velocity[i] + r1 * (self.pbest[i] - population[i]) + r2 * (self.gbest - population[i])\n                population[i] += self.velocity[i]\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n                \n                if func(population[i]) < func(self.pbest[i]):\n                    self.pbest[i] = population[i]\n                \n                if func(population[i]) < func(self.gbest):\n                    self.gbest = population[i]\n                    \n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest", "name": "HybridSwarmEvolution", "description": "The algorithm introduces adaptive velocity scaling in the hybrid swarm evolution strategy to enhance the convergence rate and improve solution quality.", "configspace": "", "generation": 99, "fitness": 0.18368508090791305, "feedback": "The algorithm HybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.184 with standard deviation 0.017. And the mean value of best solutions found was 0.135 (0. is the best) with standard deviation 0.070.", "error": "", "parent_id": "dbd6cae4-933a-4593-a200-8c4061abc3b5", "metadata": {"aucs": [0.1624253361255542, 0.1845026619052056, 0.20412724469297938], "final_y": [0.16077501405075875, 0.03894830780670653, 0.2039456557010559]}, "mutation_prompt": null}
