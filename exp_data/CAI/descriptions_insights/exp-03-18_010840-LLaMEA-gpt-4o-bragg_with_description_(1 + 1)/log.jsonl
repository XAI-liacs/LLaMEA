{"id": "405aad56-0e9b-49c4-9271-cfb8803d222e", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Dynamic F and CR based on diversity\n            F = 0.5 if diversity > 0.1 else 0.9\n            CR = 0.9 if diversity > 0.1 else 0.5\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n        \n        return self.best", "name": "AQDE", "description": "Adaptive Quantum-inspired Differential Evolution (AQDE) integrates quantum mechanics principles with differential evolution to dynamically adjust mutation strategies based on population diversity.", "configspace": "", "generation": 0, "fitness": 0.047419075414678526, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": null, "metadata": {"aucs": [0.047419572297754176, 0.04741921888535239, 0.04741843506092902], "final_y": [0.9183673469387755, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "aeaf01e6-02a8-4079-b97c-6c4a7408bf17", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Dynamic F and CR based on diversity\n            F = 0.5 if diversity > 0.1 else 0.9\n            CR = 0.9 if diversity > 0.1 else 0.5\n            \n            # Adjust population size based on diversity\n            self.population_size = max(int(self.population_size * (1 + 0.1 * (0.1 - diversity))), 1)\n            self.pop = np.resize(self.pop, (self.population_size, self.dim))  # Maintain array size\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n        \n        return self.best", "name": "AQDE", "description": "Enhanced Adaptive Quantum-inspired Differential Evolution (EAQDE) introduces dynamic population size adjustments and a novel parameter tuning strategy to improve optimization performance.", "configspace": "", "generation": 1, "fitness": 0.047417254956345155, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "405aad56-0e9b-49c4-9271-cfb8803d222e", "metadata": {"aucs": [0.0474189619876233, 0.04741585669005621, 0.047416946191355946], "final_y": [0.9183673469387755, 0.9183731989402419, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "40e66219-a333-4a48-ae26-a34a81060433", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Dynamic F and CR based on diversity\n            F = 0.5 if diversity > 0.1 else 0.9\n            CR = 0.9 if diversity > 0.1 else 0.5\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size + 1, 3, replace=False)  # Change here\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n        \n        return self.best", "name": "AQDE", "description": "Improved AQDE with dynamic population size adjustment based on performance.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 100 is out of bounds for axis 0 with size 100').", "error": "IndexError('index 100 is out of bounds for axis 0 with size 100')", "parent_id": "405aad56-0e9b-49c4-9271-cfb8803d222e", "metadata": {}, "mutation_prompt": null}
{"id": "25df0e8c-2cf8-477e-a909-ac4e3349ada4", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Dynamic F and CR based on diversity\n            F = 0.5 if diversity > 0.1 else 0.9\n            CR = 0.9 if diversity > 0.1 else 0.5\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n\n            # Adaptive population resizing\n            self.population_size = min(100, int(self.population_size * (1 + (self.best_score - np.mean(scores)))))\n\n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n        \n        return self.best", "name": "AQDE", "description": "Enhanced AQDE with adaptive population size dynamically adjusting based on convergence rate to explore more efficiently.", "configspace": "", "generation": 3, "fitness": 0.047419075414678526, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "405aad56-0e9b-49c4-9271-cfb8803d222e", "metadata": {"aucs": [0.047419572297754176, 0.04741921888535239, 0.04741843506092902], "final_y": [0.9183673469387755, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "7f738cb3-ad91-462b-9717-76e90a1c33e3", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Dynamic F and CR based on diversity\n            F = 0.5 if diversity > 0.1 else 0.9\n            CR = 0.9 if diversity > 0.1 else 0.5\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n\n            # Adjust population size periodically\n            if evaluations % (5 * self.population_size) == 0:\n                if self.population_size > 2 * self.dim:\n                    self.population_size = int(self.population_size * 0.9)\n\n        return self.best", "name": "AQDE", "description": "Enhanced Adaptive Quantum-inspired Differential Evolution (EAQDE) introduces a periodic adaptation of the population size to balance exploration and exploitation.", "configspace": "", "generation": 4, "fitness": 0.047419075414678526, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "405aad56-0e9b-49c4-9271-cfb8803d222e", "metadata": {"aucs": [0.047419572297754176, 0.04741921888535239, 0.04741843506092902], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "30b3575e-6e71-46ef-a057-27edc71ae513", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Improved dynamic F and CR based on diversity\n            F = 0.5 + 0.4 * (diversity < 0.1)\n            CR = 0.9 - 0.4 * (diversity < 0.1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + F * (x1 - x2)\n                quantum_step = np.random.normal(0, 0.5, self.dim)  # Adjusted step size\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n        \n        return self.best", "name": "AQDE", "description": "Improved Adaptive Quantum-inspired Differential Evolution (AQDE) with enhanced mutation and diversity-based population control for better convergence.", "configspace": "", "generation": 5, "fitness": 0.04740081930435003, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "405aad56-0e9b-49c4-9271-cfb8803d222e", "metadata": {"aucs": [0.04741761751187501, 0.04739991886341777, 0.04738492153775731], "final_y": [0.918370944969, 0.9184003248679531, 0.9184263147733429]}, "mutation_prompt": null}
{"id": "7f28848d-11f3-42db-9763-d1999671c827", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Dynamic F and CR based on diversity\n            F = 0.5 if diversity > 0.1 else 0.9\n            CR = 0.9 if diversity > 0.1 else 0.5\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced Adaptive Quantum-inspired Differential Evolution (EAQDE) with adaptive population size scaling based on progress.", "configspace": "", "generation": 6, "fitness": 0.04741918312253753, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "405aad56-0e9b-49c4-9271-cfb8803d222e", "metadata": {"aucs": [0.047419572297754176, 0.04741909452364668, 0.04741888254621174], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "cf895f43-46f7-420f-80a6-da9f82b2b647", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            F = 0.5 if diversity > 0.1 else 0.9\n            CR = 0.5 + 0.4 * np.tanh(diversity)\n\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            if np.max(new_scores) > self.best_score * 0.98:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced Adaptive Quantum-inspired Differential Evolution (EAQDE) with variance-controlled dynamic crossover and convergence criteria.", "configspace": "", "generation": 7, "fitness": 0.04741889320427591, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "7f28848d-11f3-42db-9763-d1999671c827", "metadata": {"aucs": [0.047419286400386396, 0.04741872395378355, 0.047418669258657786], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "5e462752-4399-4086-98ac-ce1b429c2018", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Dynamic F and CR based on diversity\n            F = 0.4 if diversity > 0.2 else 0.8  # Adjusted F value\n            CR = 0.8 if diversity > 0.2 else 0.4  # Adjusted CR value\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process with elitism\n            combined_pop = np.vstack((self.pop, new_pop))\n            combined_scores = np.hstack((scores, new_scores))\n            elite_indices = np.argsort(combined_scores)[-self.population_size:]\n            self.pop = combined_pop[elite_indices]\n            \n            # Adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE with diversity-based mutation adjustments and elitism to improve convergence.", "configspace": "", "generation": 8, "fitness": 0.047418945351844134, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "7f28848d-11f3-42db-9763-d1999671c827", "metadata": {"aucs": [0.04741952212726319, 0.047418715132661604, 0.047418598795607614], "final_y": [0.9183673469387754, 0.9183673469387755, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "c517b3f6-e891-4796-9e4e-daa7ede0dd94", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Dynamic F and CR based on diversity and performance\n            F = 0.5 + 0.4 * (np.max(scores) - self.best_score) if diversity > 0.1 else 0.9\n            CR = 0.9 if diversity > 0.1 else 0.5\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Improved Quantum-inspired DE (IQDE) with dynamic mutation scaling based on performance.", "configspace": "", "generation": 9, "fitness": 0.04741918312253753, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "7f28848d-11f3-42db-9763-d1999671c827", "metadata": {"aucs": [0.047419572297754176, 0.04741909452364668, 0.04741888254621174], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "65b3071e-0010-4264-ae71-16aee382827d", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Dynamic F and CR based on diversity\n            F = 0.7 if diversity > 0.1 else 1.0  # Adjusted F for stronger mutation\n            CR = 0.8 if diversity > 0.1 else 0.6  # Adjusted CR for more exploration\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + F * (x1 - x2)\n                quantum_step = np.random.normal(0, 0.5, self.dim)  # Reduced step size for finer search\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n            else:\n                self.population_size = min(20 * self.dim, self.population_size * 2)  # Expand when progress stalls\n\n        return self.best", "name": "AQDE", "description": "Enhanced Adaptive Quantum-inspired Differential Evolution (EAQDE) with dynamic population size and mutation intensification based on convergence speed.", "configspace": "", "generation": 10, "fitness": 0.04741874054748252, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "7f28848d-11f3-42db-9763-d1999671c827", "metadata": {"aucs": [0.047419732640175405, 0.04741838094128559, 0.047418108060986564], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "9bbca8bd-4198-4f55-914b-12069473c9c2", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            F = 0.5 if diversity > 0.1 else 0.9\n            CR = 0.9 if diversity > 0.1 else 0.5\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                \n                if scores[i] < self.best_score * 0.9:\n                    trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                else:\n                    trial_vector = np.clip(mutation_vector - quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE with adaptive crossover and mutation strategies based on population performance.", "configspace": "", "generation": 11, "fitness": 0.04741909883810769, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "7f28848d-11f3-42db-9763-d1999671c827", "metadata": {"aucs": [0.04741920411818501, 0.04741878921595821, 0.04741930318017984], "final_y": [0.9183673469387754, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "80165667-7262-4923-a542-7c6accb7c6ff", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Self-adaptive F and CR\n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE using adaptive differential evolution with self-adaptive crossover and mutation rates for improved exploration-exploitation balance.", "configspace": "", "generation": 12, "fitness": 0.04741929128668906, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "7f28848d-11f3-42db-9763-d1999671c827", "metadata": {"aucs": [0.047419582837722185, 0.047419122252135404, 0.047419168770209574], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "6d2239ac-94e1-4a85-b81c-8d808e64b507", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                local_search = 0.1 * np.random.randn(self.dim)\n                trial_vector = np.clip(mutation_vector + local_search, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced Quantum Adaptive QDE with dynamic local search and adaptive boundary constraints for improved convergence.", "configspace": "", "generation": 13, "fitness": 0.04741849097740595, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {"aucs": [0.04741830494315524, 0.04741833792666583, 0.04741883006239678], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "0b0245fd-090d-4245-aff9-af42df6cdd3b", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Self-adaptive F and CR\n            self.F = np.random.normal(0.5, 0.2 + 0.1 * (1 - diversity)) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.05 + 0.05 * diversity) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                # Dynamic boundary handling\n                trial_vector = np.clip(mutation_vector + quantum_step, func.bounds.lb, func.bounds.ub)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process with adaptive pressure\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Improved AQDE with adaptive selection pressure and dynamic boundary constraints for enhanced convergence.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {}, "mutation_prompt": null}
{"id": "e6d045b3-0923-4ee2-9184-c29db3071419", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Self-adaptive F and CR\n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)  # Adjusted from 0.5 to 0.6\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Slightly adjusted the self-adaptive strategy for determining the mutation factor `F` to enhance exploration-exploitation balance throughout the optimization process.", "configspace": "", "generation": 15, "fitness": 0.047419234167450974, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {"aucs": [0.047419547778014604, 0.047419155626968856, 0.04741899909736946], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "c98a94e9-6669-4be3-a654-1d7e73c2493c", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                levy_step = self.levy_flight(self.dim)\n                trial_vector = np.clip(mutation_vector + levy_step, 0, 1)\n\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best\n\n    def levy_flight(self, dim):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, dim)\n        v = np.random.normal(0, 1, dim)\n        step = u / np.abs(v) ** (1 / beta)\n        return step", "name": "AQDE", "description": "Hybrid AQDE algorithm with adaptive Lévy-flight mutation and population diversity-based adaption for enhanced global search capability and convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {}, "mutation_prompt": null}
{"id": "379280a3-588d-47d7-8850-0f89c3562971", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        success_count = 0  # Track successful mutations\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Self-adaptive F and CR\n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n                    success_count += 1\n            \n            # Adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "AQDE with adaptive mutation strategy based on the success of previous generations to improve convergence.", "configspace": "", "generation": 17, "fitness": 0.04741929128668906, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {"aucs": [0.047419582837722185, 0.047419122252135404, 0.047419168770209574], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "ac6e0484-a91d-4c74-a824-1d5e0edb612a", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Self-adaptive F and CR\n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                chaotic_factor = np.sin(np.pi * quantum_step)  # Added chaotic map\n                trial_vector = np.clip(mutation_vector + chaotic_factor, 0, 1)  # Applied chaotic factor\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Improved AQDE with adaptive learning rate and chaotic map for enhanced exploration and exploitation.", "configspace": "", "generation": 18, "fitness": 0.04741912595200071, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {"aucs": [0.047418972116095914, 0.04741848471130017, 0.04741992102860604], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "cd35dc2f-5aa0-4f39-a5da-5c7c9a9d857a", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F_min, self.F_max = 0.3, 0.9\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Dynamic F range adjustment\n            self.F_min, self.F_max = (0.1, 0.6) if diversity > 0.2 else (0.4, 0.9)\n            self.F = np.random.uniform(self.F_min, self.F_max)\n            self.CR = np.random.uniform(0.8, 1.0) if diversity > 0.2 else np.random.uniform(0.5, 0.7)\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover with adaptive probability\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Improved AQDE with dynamic mutation scaling and enhanced crossover mechanism to better balance exploration and exploitation.  ", "configspace": "", "generation": 19, "fitness": 0.04741915534055378, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {"aucs": [0.04741952212726319, 0.047419042391541044, 0.0474189015028571], "final_y": [0.9183673469387754, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "69744e19-41fa-4a0b-bbd0-52343d991c2f", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Self-adaptive F and CR\n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            # Quantum-inspired mutation with exploration boost\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = np.random.normal(0, 0.5 + diversity, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Improved adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(3 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Improved AQDE with dynamic population size adaptation and enhanced quantum-inspired mutation for better exploration.", "configspace": "", "generation": 20, "fitness": 0.047419074520462644, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {"aucs": [0.047419604688564876, 0.047418886015879624, 0.047418732856943424], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "d77d62ad-5045-4870-b0d4-d9c03d1ad4b1", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Self-adaptive F and CR\n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.7, 0.2)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Modified AQDE by incorporating dynamic scaling in mutation for improved adaptation and robustness.", "configspace": "", "generation": 21, "fitness": 0.04741929128668906, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {"aucs": [0.047419582837722185, 0.047419122252135404, 0.047419168770209574], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "0875c18a-a16f-40a0-8df8-3d23ba7f1d34", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = np.random.normal(0, 0.1, self.dim)  # Adjusted quantum step\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            if np.max(new_scores) > self.best_score * 0.9:  # Adjusted threshold for population size\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE with adaptive quantum mutation and dynamic population size adjustment for improved convergence and solution quality. ", "configspace": "", "generation": 22, "fitness": 0.04741849097740595, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {"aucs": [0.04741830494315524, 0.04741833792666583, 0.04741883006239678], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "ded423a4-cd45-450b-8b59-83fbd13ed312", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.8, 1.0)\n            self.CR = np.random.uniform(0.8, 1.0) if diversity > 0.1 else np.random.uniform(0.4, 0.7)\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                tunneling_step = np.random.normal(0, 0.5, self.dim) * (1.0 - np.exp(-abs(scores[i] - self.best_score)))\n                trial_vector = np.clip(mutation_vector + tunneling_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "TQDE combines stochastic tunneling with adaptive mutation rates for deeper exploration of complex optimization landscapes.", "configspace": "", "generation": 23, "fitness": 0.047418226224728945, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {"aucs": [0.04741810674438929, 0.04741846386881099, 0.047418108060986564], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "04091339-4511-4793-a272-91d1128b91f5", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n\n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n\n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n\n            # Self-adaptive F and CR\n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n\n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n\n            # Selection process with tournament selection\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i] or np.random.rand() < 0.1:\n                    self.pop[i] = new_pop[i]\n\n            # Dynamic population size adjustment\n            if evaluations % (self.budget // 4) == 0:\n                self.population_size = max(5 * self.dim, int(self.population_size * 0.9))\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE with dynamic population size adjustment and tournament selection for improved optimization performance.", "configspace": "", "generation": 24, "fitness": 0.0474174869931423, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {"aucs": [0.047419582837722185, 0.047414912584771485, 0.04741796555693323], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "07c81be8-6a88-42b5-9372-c4663173d519", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n            \n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Self-adaptive F and CR\n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                elite = self.best if np.random.rand() < 0.2 else x0\n                mutation_vector = elite + self.F * (x1 - x2)  # Changed line\n                quantum_step = np.random.normal(0, 1, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step * diversity, 0, 1)  # Changed line\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Improved AQDE with adaptive mutation vectors based on diversity and elite learning for enhanced convergence.", "configspace": "", "generation": 25, "fitness": 0.047418697017618215, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {"aucs": [0.04741786464247111, 0.04741858621568973, 0.0474196401946938], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "af9dbaab-0371-4532-9eff-8b1e339ec2ca", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Self-adaptive F and CR\n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Adaptive population size based on diversity\n            if diversity < 0.05:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE with dynamic adaptation of population size based on diversity to balance exploration and exploitation.", "configspace": "", "generation": 26, "fitness": 0.047418680269540846, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {"aucs": [0.047419582837722185, 0.04741795146831396, 0.04741850650258639], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "0ade1f31-4e7e-4ca4-9546-92af0b6b9960", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Self-adaptive F and CR\n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                levy_step = np.random.standard_cauchy(self.dim)\n                trial_vector = np.clip(mutation_vector + levy_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Introducing adaptive levy flight and dynamic scaling to enhance global exploration in AQDE.", "configspace": "", "generation": 27, "fitness": 0.04741892044343099, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {"aucs": [0.047418390505546415, 0.04741877313175591, 0.047419597692990645], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "be6c2fbe-9156-4c85-97e7-1fa00384cf56", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Self-adaptive F and CR\n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = np.random.normal(0, diversity, self.dim)  # Adjusted quantum step size\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Improved AQDE with adaptive quantum step size based on diversity for better exploration.", "configspace": "", "generation": 28, "fitness": 0.04741855938578906, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {"aucs": [0.047418738117069315, 0.047418084745844635, 0.04741885529445322], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "22f59cb3-5ca4-4faa-b307-4f43bfd78b73", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Self-adaptive F and CR\n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Novel crossover strategy\n                crossover_prob = np.random.rand()\n                if crossover_prob < 0.5:\n                    crossover_mask = np.random.rand(self.dim) < self.CR\n                else:\n                    crossover_mask = np.full(self.dim, True)\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE with adaptive population reduction and novel crossover strategy for improved convergence speed.", "configspace": "", "generation": 29, "fitness": 0.04741917497227799, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {"aucs": [0.0474189079167292, 0.04741925590182072, 0.04741936109828404], "final_y": [0.9183673469387754, 0.9183673469387755, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "79aa5245-3f15-42c2-8ce7-bf0d26106b0f", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1)\n            self.F = np.clip(self.F, 0.1, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim) * (1 - (evaluations / self.budget))\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n            else:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n\n        return self.best", "name": "AQDE", "description": "Refined AQDE using enhanced quantum-inspired mutation with variable neighborhood search for improved convergence and robustness.", "configspace": "", "generation": 30, "fitness": 0.04741926555839382, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {"aucs": [0.047419585426991984, 0.04741910011758077, 0.047419111130608704], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "37b73885-18dc-4724-983d-9ea664599fda", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        learning_rate = 0.01\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n            \n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else self.F + learning_rate\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else self.CR - learning_rate\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            elitism_threshold = self.best_score * 0.99\n            if np.max(new_scores) > elitism_threshold:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE with adaptive learning rates and elitism to improve convergence and solution quality.", "configspace": "", "generation": 31, "fitness": 0.04741929128668906, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {"aucs": [0.047419582837722185, 0.047419122252135404, 0.047419168770209574], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "a2b59fcf-5be8-42ad-98d2-240e97b62e55", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                dynamic_step_size = (self.best - x0) * np.random.rand(self.dim)\n                trial_vector = np.clip(mutation_vector + dynamic_step_size, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE with dynamic mutation scaling and adaptive search space constraint for improved solution accuracy.", "configspace": "", "generation": 32, "fitness": 0.04741781012078768, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {"aucs": [0.04741782960725216, 0.04741749269412432, 0.047418108060986564], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "5c7378a3-1fa6-40b8-8f04-093f62c9d526", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Self-adaptive F and CR\n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = np.random.normal(0, 0.5, self.dim)  # Adjusted quantum step size\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE using adaptive differential evolution with self-adaptive crossover and mutation rates, now with adjusted quantum step size for improved exploration-exploitation balance.", "configspace": "", "generation": 33, "fitness": 0.04741883643079107, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {"aucs": [0.047419601636459086, 0.04741857887978018, 0.047418328776133944], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "38da33d0-d371-4130-8ed3-6161ebfea520", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Self-adaptive F and CR\n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) * diversity if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim) * diversity\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE with diversity-driven crossover control and variable quantum steps for optimized exploration-exploitation dynamics.", "configspace": "", "generation": 34, "fitness": 0.047418411498431734, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {"aucs": [0.04741890854174147, 0.04741821789256717, 0.047418108060986564], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "18597eca-e1ce-4cfb-bebc-aa8c94b873d3", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased initial population size\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Self-adaptive F and CR\n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.2 else np.random.normal(0.9, 0.1)  # Adjusted diversity threshold\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.2 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F, 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            # Enhanced Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = np.random.normal(0, 0.5, self.dim)  # Reduced quantum step scale\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(3 * self.dim, self.population_size // 2)  # Further reduced min population size\n\n        return self.best", "name": "AQDE", "description": "Improved AQDE using adaptive population dynamics and enhanced quantum-inspired mutation for better exploration.", "configspace": "", "generation": 35, "fitness": 0.047418435840766916, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {"aucs": [0.04741822003409302, 0.04741868932910165, 0.04741839815910609], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "8375f06c-2928-4734-be10-f0483647f185", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Self-adaptive F and CR\n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget), 0, 1)  # Modified to include exponential decay\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE with dynamic scaling factor using exponential decay for improved exploration-exploitation balance.", "configspace": "", "generation": 36, "fitness": 0.04741929989134852, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "80165667-7262-4923-a542-7c6accb7c6ff", "metadata": {"aucs": [0.047419586022075744, 0.04741912120389913, 0.04741919244807069], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "34307f73-67fc-4581-ab60-f9ee8341faf2", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n        self.chaotic_seq = np.random.rand(self.population_size)\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Self-adaptive F and CR\n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n\n            # Introduce chaotic sequence for F adaptation\n            self.F = self.chaotic_seq.mean()  # Use chaotic sequence mean\n            self.CR = np.clip(self.CR * (scores.mean()/self.best_score), 0, 1)  # Adjust CR with feedback\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget), 0, 1)\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "AQDE with chaotic map for enhanced diversity and adaptive crossover using function feedback.", "configspace": "", "generation": 37, "fitness": 0.047419005099225586, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8375f06c-2928-4734-be10-f0483647f185", "metadata": {"aucs": [0.04741937540956265, 0.04741873125698404, 0.047418908631130074], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "b9a39c73-33a9-4a28-8565-3b0ec5713b50", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Self-adaptive F and CR\n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.15 else np.random.normal(0.9, 0.1)  # Adjusted threshold\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.15 else np.random.normal(0.5, 0.1)  # Adjusted threshold\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget), 0, 1)  # Modified to include exponential decay\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = np.random.normal(0, 1, self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Improved AQDE by adjusting population diversity impact on mutation and crossover control parameters.", "configspace": "", "generation": 38, "fitness": 0.04741929989134852, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8375f06c-2928-4734-be10-f0483647f185", "metadata": {"aucs": [0.047419586022075744, 0.04741912120389913, 0.04741919244807069], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "85ea6bcf-7dff-4e5f-9758-9d22dd2893c5", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate current population\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            # Update the best solution\n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            # Calculate diversity measure\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Self-adaptive F and CR\n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget), 0, 1)  # Modified to include exponential decay\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            # Adaptive crossover based on diversity\n            self.CR = 1 - self.CR if diversity < 0.05 else self.CR\n            \n            # Quantum-inspired mutation: Generate new population\n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = np.random.normal(0, 0.5, self.dim)  # Adjusted quantum step\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            # Selection process\n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Adaptive population size based on progress\n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Improved AQDE with enhanced mutation strategy and adaptive crossover leveraging diversity for robust exploration and exploitation.", "configspace": "", "generation": 39, "fitness": 0.04741881816995638, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8375f06c-2928-4734-be10-f0483647f185", "metadata": {"aucs": [0.047419578676998975, 0.04741856336307082, 0.04741831246979933], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "621d982a-5e69-46d8-8800-e7f0c3b88fb7", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget), 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Incorporating Lévy flights and adaptive mutation steps to improve exploration in AQDE.", "configspace": "", "generation": 40, "fitness": 0.04741973721512097, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8375f06c-2928-4734-be10-f0483647f185", "metadata": {"aucs": [0.04741979476248692, 0.04741954895345535, 0.047419867929420656], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "7809b34b-427c-4eeb-8afa-8570c362580f", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.5, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget), 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n\n            if np.max(new_scores) > self.best_score * 0.99:  # Adjusted from 0.95 for better adaptation\n                self.population_size = max(5 * self.dim, self.population_size // 1.5)  # Adjusted population reduction\n\n        return self.best", "name": "AQDE", "description": "Introducing adaptive population size and mutation rate based on current best score improvement to enhance AQDE's exploration and exploitation balance.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object cannot be interpreted as an integer\").", "error": "TypeError(\"'float' object cannot be interpreted as an integer\")", "parent_id": "621d982a-5e69-46d8-8800-e7f0c3b88fb7", "metadata": {}, "mutation_prompt": null}
{"id": "1f95f21f-11bf-4959-9ffd-ae44c2e5eac5", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget), 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by adjusting mutation strategy to dynamically evolve F and CR using diversity feedback.", "configspace": "", "generation": 42, "fitness": 0.04741979627873871, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "621d982a-5e69-46d8-8800-e7f0c3b88fb7", "metadata": {"aucs": [0.04741979445088784, 0.04741973195757632, 0.04741986242775198], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "be197de8-22dd-4a35-9063-b7a25c6c7861", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        convergence_speed = 0.05\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget), 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            if np.max(new_scores) > self.best_score * (1 - convergence_speed):\n                self.population_size = min(20 * self.dim, self.population_size + self.dim)\n\n        return self.best", "name": "AQDE", "description": "Improved AQDE by adding adaptive population size adjustment based on convergence speed.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 104 is out of bounds for axis 0 with size 100').", "error": "IndexError('index 104 is out of bounds for axis 0 with size 100')", "parent_id": "1f95f21f-11bf-4959-9ffd-ae44c2e5eac5", "metadata": {}, "mutation_prompt": null}
{"id": "3213843e-949e-44db-9ede-a2b868b479fd", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by dynamically adjusting mutation vector scaling based on current best score relative to initial best score.", "configspace": "", "generation": 44, "fitness": 0.047419805562704566, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1f95f21f-11bf-4959-9ffd-ae44c2e5eac5", "metadata": {"aucs": [0.04741979445088784, 0.04741975476831772, 0.04741986746890814], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "7e90345a-4ac1-46eb-863b-a4b8c599761f", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim) * (diversity + 0.1)  # Incorporating dynamic Lévy flight step size\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Introduced dynamic diversity-based scaling for the mutation factor and adapted Lévy flight step size to enhance exploration.", "configspace": "", "generation": 45, "fitness": 0.04741933699723525, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3213843e-949e-44db-9ede-a2b868b479fd", "metadata": {"aucs": [0.04741959115178873, 0.04741911197101967, 0.047419307868897365], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "68991b63-84bb-42bd-9e4a-0e413160eea8", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            # Adjust population size based on convergence\n            if np.max(new_scores) > self.best_score * 0.9:\n                self.population_size = max(5 * self.dim, self.population_size // 1.5)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE with adaptive population size based on convergence speed and exploration-exploitation balance.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object cannot be interpreted as an integer\").", "error": "TypeError(\"'float' object cannot be interpreted as an integer\")", "parent_id": "3213843e-949e-44db-9ede-a2b868b479fd", "metadata": {}, "mutation_prompt": null}
{"id": "d773f585-72a6-42fd-b822-cdb34bd9c98c", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            if np.max(new_scores) > self.best_score * 0.95:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n            else:\n                self.population_size = min(20 * self.dim, self.population_size * 2)  # Increase population if not improving\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE with adaptive population size adjustment based on recent improvements to exploit promising areas more effectively.", "configspace": "", "generation": 47, "fitness": 0.047419805562704566, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3213843e-949e-44db-9ede-a2b868b479fd", "metadata": {"aucs": [0.04741979445088784, 0.04741975476831772, 0.04741986746890814], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Improved AQDE by introducing adaptive population size based on dynamic score improvement rates.", "configspace": "", "generation": 48, "fitness": 0.04741981309110196, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "3213843e-949e-44db-9ede-a2b868b479fd", "metadata": {"aucs": [0.04741979445088784, 0.04741975476831772, 0.0474198900541003], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "ea5b4fdb-72a1-4fc6-b92a-9492d3b78a21", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if np.std(trial_vector) < 0.01:  # New line: Enhance diversity\n                    trial_vector += np.random.normal(0, 0.1, self.dim)  # New line: Perturbation step\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by integrating adaptive mutation strategies and improved diversity handling.", "configspace": "", "generation": 49, "fitness": 0.04741981309110196, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741975476831772, 0.0474198900541003], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "eb3278df-02f6-41bb-b272-0b544157b45f", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0.1, 0.9)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim) * np.random.normal(0, 0.01, self.dim)  # Enhanced Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Improved AQDE by integrating adaptive mutation scaling factor and enhanced Lévy flight for promoting exploration.", "configspace": "", "generation": 50, "fitness": 0.04739145746994341, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.047385907500383295, 0.04737708517901684, 0.04741137973043008], "final_y": [0.9184247890886907, 0.9184396758603671, 0.9183819554963389]}, "mutation_prompt": null}
{"id": "bb654e8c-ea51-4b3c-b9a1-e2ab7310d5eb", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.uniform(0.4, 0.7) if diversity > 0.1 else np.random.uniform(0.8, 1.0)\n            self.CR = np.random.uniform(0.85, 0.95) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.F = np.clip(self.F * (1 - evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(30 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE algorithm by refining population size dynamics and incorporating a mutation strategy adaptive to performance improvements.", "configspace": "", "generation": 51, "fitness": 0.04741979161700449, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741974394173043, 0.047419836458395204], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "e914aa53-e023-44cd-a6a9-e6c4bfe092e5", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n        self.recent_scores = []\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n            self.recent_scores.append(np.max(scores))\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            score_gradient = (self.recent_scores[-1] - self.recent_scores[-min(5, len(self.recent_scores))]) / (min(5, len(self.recent_scores)) + 1e-9)\n            if score_gradient > 0.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif score_gradient < -0.01:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by refining population control using a gradient of recent score improvements to maintain exploration/exploitation balance.", "configspace": "", "generation": 52, "fitness": 0.04741981309110196, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741975476831772, 0.0474198900541003], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "16a19893-096b-4128-a2de-15a93de9f073", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n            \n            self.F *= (1 + np.log1p(diversity))  # Adjust mutation scale factor based on population variance\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by introducing adaptive mutation scale factor based on population variance for improved exploration-exploitation balance.", "configspace": "", "generation": 53, "fitness": 0.04741981309110196, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741975476831772, 0.0474198900541003], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "b0ab831f-9934-4bd0-809b-f756c0063dce", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L, scale=1.0):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return scale * (u / np.power(abs(v), 1/3))  # Lévy distribution with scale\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim, scale=diversity)  # Dynamic Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE using a dynamic Lévy flight scaling factor and adaptive crossover probability.", "configspace": "", "generation": 54, "fitness": 0.04741017022362818, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741208165228328, 0.047407332138339586, 0.04741109688026168], "final_y": [0.9183804758803872, 0.9183881801610665, 0.9183817638578833]}, "mutation_prompt": null}
{"id": "536ac038-620a-494f-857a-8b53e77e8aea", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)\n            self.CR = np.clip(self.CR * (1 + 0.1 * np.random.randn()), 0, 1)  # Dynamically adjust CR\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n            \n            elite_idx = np.argsort(new_scores)[-int(0.1 * self.population_size):]  # Elite selection\n            self.pop[elite_idx] = new_pop[elite_idx]\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by dynamically adjusting crossover rate and incorporating elite selection to improve convergence.", "configspace": "", "generation": 55, "fitness": 0.04741808258725718, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.0474175869827661, 0.04741731857026321, 0.04741934220874222], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "b2b0d3b6-b845-4589-898d-8d6667eed339", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim) * (diversity + 0.1)  # Incorporate adaptive perturbation\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE algorithm by integrating adaptive perturbation based on population diversity to improve convergence.", "configspace": "", "generation": 56, "fitness": 0.04741214930760788, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.047415278741083644, 0.04740894511576099, 0.047412224065979], "final_y": [0.9183750267404872, 0.9183854527921389, 0.9183799622371226]}, "mutation_prompt": null}
{"id": "2cdec6f1-6fa3-480d-b70d-71e37caa0c2c", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.15 else np.random.normal(0.95, 0.1)  # Increased threshold\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.15 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim) + np.random.normal(0, 0.1, self.dim)  # Added Gaussian perturbation\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhance AQDE by introducing Gaussian perturbations for better exploration control and altering diversity threshold.", "configspace": "", "generation": 57, "fitness": 0.04741855661640652, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.047419834156205654, 0.04741796575307522, 0.047417869939938684], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "f91a749a-4b63-4821-ae63-bfdc14e9a677", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        elite_size = max(1, self.population_size // 10)  # Ensure elite conservation\n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            elite_indices = np.argsort(scores)[-elite_size:]\n            new_pop[elite_indices] = self.pop[elite_indices]  # Keep elites unchanged\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE with dynamic mutation and adaptive crossover using elite conservation to maintain diversity and accelerate convergence.", "configspace": "", "generation": 58, "fitness": 0.04741981309110196, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741975476831772, 0.0474198900541003], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "33dff79e-5a12-4b68-a40c-7c2605c198bd", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1) \n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim) * diversity  # Enhanced quantum step\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Introduced dynamic scaling of mutation factor based on the population's diversity and enhanced quantum step adjustment.", "configspace": "", "generation": 59, "fitness": 0.04741017022362818, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741208165228328, 0.047407332138339586, 0.04741109688026168], "final_y": [0.9183804758803872, 0.9183881801610665, 0.9183817638578833]}, "mutation_prompt": null}
{"id": "8bed333c-1c86-41a6-b2d3-81d90007545b", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                weights = np.random.rand(self.dim)  # Dynamic dimensional weights\n                mutation_vector = x0 + self.F * (x1 - x2) * weights  # Apply weights\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by integrating dynamic dimensional weights within the mutation process to improve convergence.", "configspace": "", "generation": 60, "fitness": 0.047419267712965306, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741940434261083, 0.04741852271319058, 0.0474198760830945], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "53a14151-09cb-4c1b-82ce-0d1592e6882a", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        elite_fraction = 0.1  # New parameter for elite selection\n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            elite_indices = scores.argsort()[-int(elite_fraction * self.population_size):]  # Elite selection\n            elite_pop = self.pop[elite_indices]  # New elite population\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                if np.random.rand() < elite_fraction:  # Choose from elite with some probability\n                    base = elite_pop[np.random.randint(len(elite_pop))]\n                else:\n                    base = self.pop[np.random.randint(self.population_size)]\n                indices = np.random.choice(self.population_size, 2, replace=False)\n                x1, x2 = self.pop[indices]\n                mutation_vector = base + self.F * (x1 - x2)  # Adjusted base\n                quantum_step = self.levy_flight(self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by integrating elite selection and adaptive mutation scaling for improved convergence.", "configspace": "", "generation": 61, "fitness": 0.04741896637236461, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.0474196595913563, 0.04741848326683451, 0.047418756258903016], "final_y": [0.9183673469387755, 0.9183673469387755, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "b6f91c1a-a75c-4c21-b196-c1799ea5f0c8", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.02:  # Refined threshold\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced adaptive control of population size by refining the improvement rate threshold.", "configspace": "", "generation": 62, "fitness": 0.04741981309110196, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741975476831772, 0.0474198900541003], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "a1e5044f-94b8-47d8-aedf-4b531f8f6559", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim) * np.exp(-evaluations/self.budget)  # Dynamic quantum step scaling\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Improved AQDE by introducing dynamic mutation strategies based on evaluation stages to enhance exploration and exploitation balance.", "configspace": "", "generation": 63, "fitness": 0.04741980766205348, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741973887029849, 0.047419889664974124], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "0b6551ea-eaa1-45e8-92f7-c0fc6a66d631", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement_history = []  # Track historical improvement rates\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            improvement_history.append(improvement_rate)  # Store improvement rate\n            \n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n                if len(improvement_history) > 3 and all(r > 1.05 for r in improvement_history[-3:]):  # Adjust based on history\n                    self.F *= 1.1\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n                if len(improvement_history) > 3 and all(r < 0.95 for r in improvement_history[-3:]):  # Adjust based on history\n                    self.F *= 0.9\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by integrating dynamic mutation scaling based on historical improvement rates.", "configspace": "", "generation": 64, "fitness": 0.04741981309110196, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741975476831772, 0.0474198900541003], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "ac2e742d-94cf-41f4-95d7-e4b219406f75", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L, scale=0.1):  # Changed: Added scale parameter\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return scale * (u / np.power(abs(v), 1/3))  # Changed: Scaled Lévy flight\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                scale = 0.1 + 0.9 * (scores[i] / (self.best_score + 1e-9))  # Changed: Adaptive scale\n                quantum_step = self.levy_flight(self.dim, scale)  # Changed: Pass adaptive scale\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Introduced adaptive Lévy flight scale and rank-based selection to enhance exploration and exploitation balance.", "configspace": "", "generation": 65, "fitness": 0.047419813010770064, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741975450269709, 0.04741989007872527], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "da01d600-cdfa-4c77-8132-2b96c6acbbc3", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L, scale=0.1):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return scale * (u / np.power(abs(v), 1/3))  # Scaled Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim, scale=diversity)  # Adaptive scale for Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by integrating adaptive mutability and scaled Lévy flights for improved exploration.", "configspace": "", "generation": 66, "fitness": 0.04741017022362818, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741208165228328, 0.047407332138339586, 0.04741109688026168], "final_y": [0.9183804758803872, 0.9183881801610665, 0.9183817638578833]}, "mutation_prompt": null}
{"id": "e034773d-05b6-4e62-a5eb-5b61c281449e", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.7, 0.3) if diversity > 0.15 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.15 else np.random.normal(0.7, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by integrating dynamic mutation scaling and adaptive crossover based on performance variations, improving exploration and exploitation balance.", "configspace": "", "generation": 67, "fitness": 0.04741946421030615, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741871028138067, 0.047419887898649926], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "f47adc6c-3ecb-4ee2-a66c-ca74777c60d2", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.7, 0.2) if diversity > 0.1 else np.random.normal(0.95, 0.1)  # Adjusted F\n            self.CR = np.random.normal(0.9, 0.2) if diversity > 0.1 else np.random.normal(0.6, 0.1)  # Adjusted CR\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by introducing dynamic mutation scaling and adaptive crossover based on improvement rate and diversity metrics.", "configspace": "", "generation": 68, "fitness": 0.04741962326743735, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741918517698318, 0.04741989017444104], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "055e40a6-d0f7-4e29-a2c5-a815424fba41", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n        self.velocity = np.zeros((self.population_size, dim))  # Momentum\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial_vector = np.where(crossover_mask, trial_vector, self.pop[i])\n                self.velocity[i] = 0.9 * self.velocity[i] + trial_vector  # Momentum update\n                new_pop[i] = self.velocity[i]\n\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by integrating a momentum-based update mechanism for better convergence.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 122 is out of bounds for axis 0 with size 100').", "error": "IndexError('index 122 is out of bounds for axis 0 with size 100')", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {}, "mutation_prompt": null}
{"id": "3cebc114-0436-4f2a-a778-afd8ac155fe9", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) + 0.1 * diversity  # Adjust F based on diversity\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by integrating dynamic mutation scaling using population variance and F adaptation.", "configspace": "", "generation": 70, "fitness": 0.04741981068226775, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741974804982951, 0.04741988954608589], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "7044514a-e036-4cc3-b130-aff4d6d46d11", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim)) * (func.bounds.ub - func.bounds.lb) + func.bounds.lb  # Improved initialization\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, func.bounds.lb, func.bounds.ub)  # Boundary condition handling\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by introducing periodic boundary condition handling and improved initialization for better convergence.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {}, "mutation_prompt": null}
{"id": "7a6ad757-e36b-4dff-acfb-09c6ddcd871c", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n                    \n            mutation_success_rate = np.mean(new_scores > scores)\n            self.population_size = min(20 * self.dim, max(5 * self.dim, int(self.population_size * (1 + mutation_success_rate))))\n\n        return self.best", "name": "AQDE", "description": "Improved AQDE by enhancing adaptive population size using feedback from mutation vector performance.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 143 is out of bounds for axis 0 with size 100').", "error": "IndexError('index 143 is out of bounds for axis 0 with size 100')", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {}, "mutation_prompt": null}
{"id": "a15ab0cd-06da-49e4-a845-be881356a6ea", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)  # Increased number of indices\n                x0, x1, x2, x3 = self.pop[indices]  # Added x3\n                mutation_vector = x0 + self.F * (x1 - x2) + self.F * (x3 - x0)  # Enhanced mutation strategy\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced the exploration capability of AQDE by refining mutation strategy.", "configspace": "", "generation": 73, "fitness": 0.047419213759656444, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741977729290159, 0.04741840716887491, 0.04741945681719284], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "40a5adfd-d280-436c-b6d3-2fb586005628", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)\n            self.CR = np.clip(self.CR * (1 - evaluations / self.budget), 0, 1)  # Time-varying CR\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99 and np.random.rand() < 0.5:  # Probabilistic size adjustment\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by incorporating a time-varying crossover probability and a probabilistic population size adjustment.", "configspace": "", "generation": 74, "fitness": 0.04741981309110196, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741975476831772, 0.0474198900541003], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "505c0df9-f717-4a34-87f5-f3f612b8cfc2", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n        self.chaotic_map = lambda x: 4 * x * (1 - x)  # Logistic map for chaos\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            chaotic_val = np.random.rand()\n            self.F = self.chaotic_map(chaotic_val) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by integrating chaotic maps for dynamic parameter tuning, boosting exploration and exploitation balance.", "configspace": "", "generation": 75, "fitness": 0.04741819301497278, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741764099548729, 0.047417435584955814, 0.04741950246447524], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "00fd8526-6383-40a4-af74-1395de669571", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L, current_best_score):  # Updated to include current_best_score\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        scale = max(0.1, min(1.0, current_best_score))  # Line added to scale Lévy flight\n        return scale * (u / np.power(abs(v), 1/3))  # Line modified to incorporate scale\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim, self.best_score)  # Pass best_score\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by integrating a dynamic Lévy flight scaling based on the current best score.", "configspace": "", "generation": 76, "fitness": 0.047419789961575885, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741968778202299, 0.04741988765181682], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "896224a7-6b65-4b8b-90a3-7afb4fe26b48", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L, scale=0.01):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return scale * (u / np.power(abs(v), 1/3))  # Fitness-scaled Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim, scale=self.best_score)  # Incorporating fitness-based Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size + 1)  # More gradual adaptation\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size - 1)  # More gradual adaptation\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by incorporating fitness-based scaling of Lévy flight and refined population size adaptation.", "configspace": "", "generation": 77, "fitness": 0.047419789961575885, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741968778202299, 0.04741988765181682], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "3b0c173a-d003-482b-bf52-713dc9827ee0", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return 0.01 * (u / np.power(abs(v), 1/3))  # Scaled Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]  # Enhancing mutation scaling for fitness improvement\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by incorporating adaptive mutation scaling based on individual fitness and using a more robust Lévy flight step size adaptation.", "configspace": "", "generation": 78, "fitness": 0.047397252046108784, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04738294558164602, 0.047396901348700005, 0.04741190920798033], "final_y": [0.9184299609267439, 0.9184059778691827, 0.9183809756262834]}, "mutation_prompt": null}
{"id": "be2791c0-a113-4de3-8e38-58c015b18509", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n\n            self.F = np.random.normal(0.65, 0.2) if diversity > 0.1 else np.random.normal(0.9, 0.1)\n            self.CR = np.random.normal(0.9, 0.1) if diversity > 0.1 else np.random.normal(0.65, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by introducing adaptive differential evolution parameters based on improving best solutions.", "configspace": "", "generation": 79, "fitness": 0.04741948051653844, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741875625869818, 0.04741989084002929], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "9adbda90-161e-4a6a-9e7e-609176573714", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.linalg.norm(self.pop - self.pop.mean(axis=0), axis=1).mean()  # Updated diversity measure\n            \n            self.F = np.random.uniform(0.4, 1.2) if diversity > 0.1 else np.random.uniform(0.7, 1.0)  # Modified scaling factor\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.3)  # Modified crossover rate\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Introduced adaptive scaling factor and crossover rate adjustments based on a novel diversity metric to enhance convergence speed and robustness.", "configspace": "", "generation": 80, "fitness": 0.04741802602627961, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741769097410675, 0.04741688598755334, 0.04741950111717874], "final_y": [0.9183673469387754, 0.918367509959741, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "68372527-9407-4618-9b91-8130fee27abc", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + 0.5 * quantum_step, 0, 1)  # Adjusted mutation strategy\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by introducing a variable mutation strategy inspired by optimization history, improving convergence reliability.", "configspace": "", "generation": 81, "fitness": 0.04741520500438334, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741837912285596, 0.04741090621151722, 0.04741632967877685], "final_y": [0.9183697497804701, 0.9183821268170214, 0.9183720632978639]}, "mutation_prompt": null}
{"id": "ae2313dc-138e-42df-8d5d-5014d0ee4013", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = 0.5 + 0.3 * np.random.rand() if diversity > 0.1 else 0.9 * np.random.rand()\n            self.CR = 0.9 * np.random.rand() if diversity > 0.1 else 0.6 * np.random.rand()\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.02:\n                self.population_size = min(20 * self.dim, self.population_size * 2)  # Slightly more aggressive scaling\n            elif improvement_rate < 0.98:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by incorporating adaptive mutation strategy and dynamic population scaling.", "configspace": "", "generation": 82, "fitness": 0.04741254123177404, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741042532533446, 0.047418649847921546, 0.04740854852206611], "final_y": [0.9183768020320984, 0.9183673469387754, 0.9183836823360184]}, "mutation_prompt": null}
{"id": "79a91865-ba38-4d0b-811c-fdf7e69ec435", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L, scale):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3) * scale  # Lévy distribution with scale\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                scale_factor = (1 - evaluations / self.budget)  # Adaptive scale factor\n                quantum_step = self.levy_flight(self.dim, scale_factor)  # Incorporating adaptive Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by integrating an adaptive Lévy flight scale factor to balance exploration and exploitation.", "configspace": "", "generation": 83, "fitness": 0.04741980760644245, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741973870802174, 0.04741988966041777], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "ebf8cf7d-d522-4bb3-8a60-c5a8c57794e8", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.uniform(0.4, 1.0) * (1 - diversity)  # Adaptive F based on diversity\n            self.CR = np.random.uniform(0.6, 1.0) * diversity  # Adaptive CR based on diversity\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Integrate adaptive crossover and mutation scaling based on population diversity for enhanced exploration-exploitation balance.", "configspace": "", "generation": 84, "fitness": 0.04739406165154673, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04740085212276024, 0.04739263625411383, 0.04738869657776612], "final_y": [0.9183985368110237, 0.918413271142367, 0.9184203789384591]}, "mutation_prompt": null}
{"id": "7612006e-e856-4021-ae86-788aab5e34f0", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n\n            # Elite Opposition-Based Learning\n            elite_opposition = np.clip(1 - self.best, 0, 1)\n            new_pop[np.random.randint(self.population_size)] = elite_opposition\n\n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by incorporating elite opposition-based learning to boost population diversity and exploration.", "configspace": "", "generation": 85, "fitness": 0.04741981309110196, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741975476831772, 0.0474198900541003], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "26d2a28c-b1b3-4664-bf8a-345b71af97ee", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.8, 0.1) if diversity > 0.1 else np.random.normal(0.5, 0.1)  # Adjusted CR \n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2) + diversity * 0.1  # Adaptive mutation scaling\n                quantum_step = self.levy_flight(self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by fine-tuning the crossover probability and adding adaptive mutation scaling based on population diversity.", "configspace": "", "generation": 86, "fitness": 0.047419261805644854, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741812686660274, 0.04741986409944399], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "17d4dadd-a950-4be3-a36f-520229d57531", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.8, 0.2) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.05) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (1 - self.best_score), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE with adaptive dynamic F and CR based on diversity and best-score proximity for improved convergence.", "configspace": "", "generation": 87, "fitness": 0.04741956153954526, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.047419851644174726, 0.04741968179314304, 0.04741915118131801], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387755]}, "mutation_prompt": null}
{"id": "0229a017-a125-40ab-bbbd-268a03cfa6d4", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.65, 0.25) if diversity > 0.1 else np.random.normal(0.85, 0.15)  # Adjusted F and CR\n            self.CR = np.random.normal(0.9, 0.15) if diversity > 0.1 else np.random.normal(0.65, 0.15)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1) \n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  \n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by refining adaptive strategies and integrating a focus on promising regions of the search space.", "configspace": "", "generation": 88, "fitness": 0.04741954709101163, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.047418956707185544, 0.047419890114961505], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "f72ca6ff-a281-4588-a7d0-6f0582b2cd7b", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + 0.5 * quantum_step, 0, 1)  # Adjusted quantum step\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by fine-tuning the mutation strategy for improved exploration and exploitation balance.", "configspace": "", "generation": 89, "fitness": 0.04741520500438334, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741837912285596, 0.04741090621151722, 0.04741632967877685], "final_y": [0.9183697497804701, 0.9183821268170214, 0.9183720632978639]}, "mutation_prompt": null}
{"id": "86e688cb-3a43-472c-8d34-ac2eb52630c8", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR + 0.05 * np.random.rand(), 0, 1)  # Dynamic CR adjustment\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE with adaptive mutation strength and dynamic crossover strategy to improve convergence.", "configspace": "", "generation": 90, "fitness": 0.04741981309110196, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741975476831772, 0.0474198900541003], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "c9a93eca-7da1-4681-accf-49a0c8a1dd89", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.7, 0.2) if diversity > 0.15 else np.random.normal(0.9, 0.05)  # Adjusted diversity threshold\n            self.CR = np.random.normal(0.92, 0.08) if diversity > 0.15 else np.random.normal(0.65, 0.05)  # Refined CR adjustment\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by refining the adaptive control parameters and improving solution diversity management.", "configspace": "", "generation": 91, "fitness": 0.047419811000496304, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741974837616003, 0.04741989017444104], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "28c0b67a-cd23-403a-a740-4cf6e3490a45", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        historical_scores = []\n\n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            # Modifications here for adaptive behavior\n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            historical_scores.append(self.best_score)\n            if len(historical_scores) > 5:  # New adaptive strategy\n                trend = np.polyfit(range(5), historical_scores[-5:], 1)[0]\n                self.F = np.clip(self.F + 0.1 * trend, 0, 1)\n                self.CR = np.clip(self.CR - 0.1 * trend, 0, 1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Introduce adaptive mutation and crossover rates based on historical performance trends to enhance exploration and exploitation balance.", "configspace": "", "generation": 92, "fitness": 0.04741981309110196, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741975476831772, 0.0474198900541003], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "59ba2751-5b33-45bc-8a8e-190235d82105", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L, scale=1):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return scale * (u / np.power(abs(v), 1/3))  # Adjusted Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                scale = 1.5 if diversity < 0.1 else 0.5  # Dynamic scaling of Lévy flight\n                quantum_step = self.levy_flight(self.dim, scale)  # Updated Lévy flight with scaling\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE with adaptive Lévy flight scaling and dynamic population diversity for improved exploration and exploitation balance.", "configspace": "", "generation": 93, "fitness": 0.04741520500438334, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741837912285596, 0.04741090621151722, 0.04741632967877685], "final_y": [0.9183697497804701, 0.9183821268170214, 0.9183720632978639]}, "mutation_prompt": null}
{"id": "40323a46-5c49-450b-ab81-017558b4a731", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n            # Apply Gaussian mutation when convergence\n            if np.std(new_scores) < 0.01:\n                self.pop += np.random.normal(0, 0.01, self.pop.shape)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by introducing Gaussian mutation and adjusting population size based on convergence status.", "configspace": "", "generation": 94, "fitness": 0.04741908830629934, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741975476831772, 0.04741771569969244], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183708905157881]}, "mutation_prompt": null}
{"id": "eca1df4b-c224-4c28-8a55-e1aa5f00d582", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)) * (0.9 + 0.2 * np.random.rand()), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)  # Incorporating Lévy flight\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by dynamically adjusting mutation factor F based on score improvement.", "configspace": "", "generation": 95, "fitness": 0.04741981048465316, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741974609352784, 0.047419890909543794], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "ecf33f43-4588-49e7-bc8d-f8404046fe2f", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = 0.5 * self.levy_flight(self.dim)  # Improved Lévy flight scaling\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "AQDE with adaptive mutation based on population diversity and improved Lévy flights for enhanced exploration.", "configspace": "", "generation": 96, "fitness": 0.04741520500438334, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741837912285596, 0.04741090621151722, 0.04741632967877685], "final_y": [0.9183697497804701, 0.9183821268170214, 0.9183720632978639]}, "mutation_prompt": null}
{"id": "1a72f6f0-928a-4450-aba1-386778f002b9", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L, scale=1.0):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return scale * (u / np.power(abs(v), 1/3))  # Lévy distribution with scaling\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim, scale=np.random.uniform(0.5, 1.5))  # Adaptive scaling\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n                self.CR = np.clip(self.CR + 0.1, 0, 1)  # Modulated CR based on improvement\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by incorporating adaptive Lévy flight scaling and modulation of crossover rate based on recent improvement trends.", "configspace": "", "generation": 97, "fitness": 0.047418299470569636, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741977445483625, 0.047419037698421374, 0.047416086258451284], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "be1f26f4-7804-40c0-a887-00c98d6217de", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return u / np.power(abs(v), 1/3)  # Lévy distribution\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.1 else np.random.normal(0.95, 0.1)\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)  # Adjusted F based on score\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim) * np.exp(-evaluations/self.budget)  # Refined quantum step\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by refining the quantum step component to improve exploration/exploitation balance.", "configspace": "", "generation": 98, "fitness": 0.04741980766205348, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04741979445088784, 0.04741973887029849, 0.047419889664974124], "final_y": [0.9183673469387754, 0.9183673469387754, 0.9183673469387754]}, "mutation_prompt": null}
{"id": "d361816c-01ad-4289-9262-48f8d8e7d064", "solution": "import numpy as np\n\nclass AQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(0, 1, (self.population_size, dim))\n        self.best = None\n        self.best_score = float('-inf')\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, L)\n        v = np.random.normal(0, 1, L)\n        return 0.1 * (u / np.power(abs(v), 1/3))  # Adjusted Lévy step size\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            scores = np.array([func(ind) for ind in self.pop])\n            evaluations += self.population_size\n            \n            if np.max(scores) > self.best_score:\n                self.best_score = np.max(scores)\n                self.best = self.pop[np.argmax(scores)]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            \n            self.F = np.random.normal(0.6, 0.3) if diversity > 0.2 else np.random.normal(0.95, 0.1)  # Adjusted diversity threshold\n            self.CR = np.random.normal(0.95, 0.1) if diversity > 0.1 else np.random.normal(0.6, 0.1)\n            self.F = np.clip(self.F * np.exp(-evaluations/self.budget) * (self.best_score / (self.best_score + 0.1)), 0, 1)\n            self.CR = np.clip(self.CR, 0, 1)\n            \n            new_pop = np.zeros_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[indices]\n                mutation_vector = x0 + self.F * (x1 - x2)\n                quantum_step = self.levy_flight(self.dim)\n                trial_vector = np.clip(mutation_vector + quantum_step, 0, 1)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                new_pop[i] = np.where(crossover_mask, trial_vector, self.pop[i])\n            \n            new_scores = np.array([func(ind) for ind in new_pop])\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if new_scores[i] > scores[i]:\n                    self.pop[i] = new_pop[i]\n            \n            improvement_rate = np.max(new_scores) / (self.best_score + 1e-9)\n            if improvement_rate > 1.01:\n                self.population_size = min(20 * self.dim, self.population_size * 2)\n            elif improvement_rate < 0.99:\n                self.population_size = max(5 * self.dim, self.population_size // 2)\n\n        return self.best", "name": "AQDE", "description": "Enhanced AQDE by implementing population diversity control and adaptive Lévy flight scaling for better exploration-exploitation balance.", "configspace": "", "generation": 99, "fitness": 0.047396294728087006, "feedback": "The algorithm AQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.047 with standard deviation 0.000. And the mean value of best solutions found was 0.918 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "658f84e8-4cba-43bb-8246-ac8c702ae06a", "metadata": {"aucs": [0.04739311440157579, 0.047390712733178963, 0.04740505704950626], "final_y": [0.9184124390035481, 0.9184165518330255, 0.9183925543039562]}, "mutation_prompt": null}
