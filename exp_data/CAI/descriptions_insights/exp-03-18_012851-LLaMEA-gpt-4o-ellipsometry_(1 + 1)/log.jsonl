{"id": "6adf6269-3590-40aa-a0e1-bb1ab8948b3d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9)\n            self.cr = np.random.uniform(0.8, 1.0)\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with a dynamic population size and self-adaptive control parameters for efficient exploration and exploitation in black box optimization.", "configspace": "", "generation": 0, "fitness": 0.3527530543742902, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.353 with standard deviation 0.030. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": null, "metadata": {"aucs": [0.3806146168952741, 0.3669503680478776, 0.3106941781797189], "final_y": [4.70013625454655e-05, 9.554337524336317e-05, 0.0009981177690130498]}, "mutation_prompt": null}
{"id": "fc624c83-3959-4787-9a92-3193db215bf7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Opposition-based learning\n                opposite = lower_bound + upper_bound - trial\n                trial_fitness = func(trial)\n                opposite_fitness = func(opposite)\n                budget_used += 2\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                elif opposite_fitness < fitness[i]:\n                    new_population[i] = opposite\n                    fitness[i] = opposite_fitness\n\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9)\n            self.cr = np.random.uniform(0.8, 1.0)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with opposition-based learning for enhanced global exploration and exploitation balance.", "configspace": "", "generation": 1, "fitness": 0.2078921107475786, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.208 with standard deviation 0.012. And the mean value of best solutions found was 0.027 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "6adf6269-3590-40aa-a0e1-bb1ab8948b3d", "metadata": {"aucs": [0.20064619963622987, 0.19844370708789505, 0.22458642551861085], "final_y": [0.025913589337605233, 0.015390260514256151, 0.03821447491118889]}, "mutation_prompt": null}
{"id": "09984399-f4e0-47d3-9c02-91683f3e1f4d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9)\n            self.cr = np.random.uniform(0.8, 1.0)\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Adaptive Differential Evolution algorithm with a modified dynamic population size calculation for improved exploration and exploitation in black box optimization.", "configspace": "", "generation": 2, "fitness": 0.44315382605698367, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.443 with standard deviation 0.028. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6adf6269-3590-40aa-a0e1-bb1ab8948b3d", "metadata": {"aucs": [0.43776708657435326, 0.4117814624240419, 0.479912929172556], "final_y": [1.0618204943030353e-05, 2.4738314956875467e-06, 2.793910027327928e-07]}, "mutation_prompt": null}
{"id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9)\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Optimizes the crossover probability range and uses elitism to retain best solutions in Adaptive Differential Evolution.", "configspace": "", "generation": 3, "fitness": 0.4898239716412065, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.490 with standard deviation 0.057. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "09984399-f4e0-47d3-9c02-91683f3e1f4d", "metadata": {"aucs": [0.4758762715121474, 0.5659009579722163, 0.4276946854392557], "final_y": [4.867076887275987e-06, 4.5087353057338647e-08, 3.534112544483435e-05]}, "mutation_prompt": null}
{"id": "e2a247e8-d0a0-44f8-85ca-c11e802aece9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9) * (1 - budget_used / self.budget)  # Adjusted differential weight\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic adaptation of the differential weight to improve exploration and exploitation balance in Adaptive Differential Evolution.", "configspace": "", "generation": 4, "fitness": 0.4597138229276691, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.460 with standard deviation 0.035. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.4943925471612425, 0.4124880416022717, 0.47226088001949296], "final_y": [3.7976495248939712e-06, 0.00021562432189659372, 5.922364449999288e-06]}, "mutation_prompt": null}
{"id": "20960695-b987-46be-a456-be35958d7ccd", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9) * (1 - budget_used / self.budget)  # Dynamic mutation scale\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with dynamic mutation scaling and enhanced elitism.", "configspace": "", "generation": 5, "fitness": 0.4597138229276691, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.460 with standard deviation 0.035. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.4943925471612425, 0.4124880416022717, 0.47226088001949296], "final_y": [3.7976495248939712e-06, 0.00021562432189659372, 5.922364449999288e-06]}, "mutation_prompt": null}
{"id": "657dd9ca-8d21-484b-8ea0-9d39bf609d0d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                f_dynamic = self.f * (1 - budget_used / self.budget)  # Time-varying scaling factor\n                mutant = np.clip(x1 + f_dynamic * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9)\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduces time-varying scaling factor and adaptive mutation strategy in Adaptive Differential Evolution.", "configspace": "", "generation": 6, "fitness": 0.43361587462193757, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.434 with standard deviation 0.044. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.4063356745738991, 0.4955681602650055, 0.3989437890269081], "final_y": [0.00024090930243552867, 2.215669675324738e-06, 0.00013512662376298325]}, "mutation_prompt": null}
{"id": "75173052-a493-4d0e-88c0-495a4cf64ac3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9)\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n            # Early stopping based on convergence\n            if np.std(fitness) < 1e-6:\n                break\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce early stopping based on convergence stability to enhance efficiency in Adaptive Differential Evolution.", "configspace": "", "generation": 7, "fitness": 0.4898239716412065, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.490 with standard deviation 0.057. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.4758762715121474, 0.5659009579722163, 0.4276946854392557], "final_y": [4.867076887275987e-06, 4.5087353057338647e-08, 3.534112544483435e-05]}, "mutation_prompt": null}
{"id": "1d01a6c8-6346-4f4d-b953-c6b3fb868edc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.8  # Initial crossover probability adjusted\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.5, 0.9)  # More aggressive mutation factor adjustment\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by modifying the initial crossover probability and dynamically updating the mutation factor more aggressively.", "configspace": "", "generation": 8, "fitness": 0.4031475896536533, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.403 with standard deviation 0.056. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.38652925940605276, 0.4789672861057658, 0.3439462234491415], "final_y": [0.0008221020032459232, 4.846220867717656e-06, 0.001625527072405441]}, "mutation_prompt": null}
{"id": "6d284879-687a-4633-946f-510d8d544d5d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                self.f = np.random.uniform(0.4, 0.9)  # Self-adaptive step-size\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introducing a self-adaptive step-size evolution strategy in the mutation process to improve convergence.", "configspace": "", "generation": 9, "fitness": 0.43378810340222934, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.434 with standard deviation 0.017. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.4542006023785945, 0.41349996015064494, 0.43366374767744864], "final_y": [1.4538270635533636e-05, 4.6135565212979066e-05, 3.252567744265981e-05]}, "mutation_prompt": null}
{"id": "68088284-799b-4221-8e14-26fd6c79da2d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            fitness_variance = np.var(fitness)\n            self.f = np.random.uniform(0.4, 0.9) * (1.0 - fitness_variance)  # Dynamic adaptation\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic adaptation of the differential weight `f` based on the fitness variance to enhance convergence.", "configspace": "", "generation": 10, "fitness": 0.12051232765949964, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.121 with standard deviation 0.018. And the mean value of best solutions found was 2.867 (0. is the best) with standard deviation 0.971.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.11666235193642072, 0.10011199651773361, 0.14476263452434457], "final_y": [3.0043832434304316, 3.980461312446879, 1.6148440520314065]}, "mutation_prompt": null}
{"id": "b3df4b29-039e-4853-9211-91c93df437c0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                adaptive_f = self.f * np.random.uniform(0.8, 1.2)  # Adaptive mutation strategy\n                mutant = np.clip(x1 + adaptive_f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9)\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far, increase elitism\n            best_indices = np.argsort(fitness)[:3]\n            population[:3] = population[best_indices]\n            fitness[:3] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduces adaptive mutation strategy alongside modified elitism to enhance exploration and exploitation balance in Differential Evolution.", "configspace": "", "generation": 11, "fitness": 0.42652805532720234, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.427 with standard deviation 0.082. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.36426534085560325, 0.37314549218101156, 0.542173332944992], "final_y": [0.0009760139727455138, 0.0007968573931954813, 1.8728769094875007e-08]}, "mutation_prompt": null}
{"id": "d639aa6f-a777-48c0-81a9-9ffb71207c7d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a condition to adjust mutation control parameter `f` based on population diversity to enhance exploration.", "configspace": "", "generation": 12, "fitness": 0.504310745559167, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.504 with standard deviation 0.052. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e9003004-f1ed-41cd-b530-8e9ec0a8b8d3", "metadata": {"aucs": [0.5169402830191157, 0.5607198572481301, 0.4352720964102553], "final_y": [4.924687420783526e-07, 1.0959389186176737e-07, 1.2478064611987484e-05]}, "mutation_prompt": null}
{"id": "ddbf97f1-9b71-4efa-9bf8-e2d910fb3eac", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n            # Early stopping criterion based on convergence\n            if np.std(fitness) < 1e-5:\n                break\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a stopping criterion based on convergence to improve efficiency.", "configspace": "", "generation": 13, "fitness": 0.4898239716412065, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.490 with standard deviation 0.057. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d639aa6f-a777-48c0-81a9-9ffb71207c7d", "metadata": {"aucs": [0.4758762715121474, 0.5659009579722163, 0.4276946854392557], "final_y": [4.867076887275987e-06, 4.5087353057338647e-08, 3.534112544483435e-05]}, "mutation_prompt": null}
{"id": "172efa25-88f5-475f-93e6-281032c69727", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.6, 0.9) if diversity > 0.1 else np.random.uniform(0.4, 0.6)\n            self.cr = np.random.uniform(0.8, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune mutation and crossover parameters based on population diversity for improved adaptation.", "configspace": "", "generation": 14, "fitness": 0.4283402570941681, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.428 with standard deviation 0.065. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d639aa6f-a777-48c0-81a9-9ffb71207c7d", "metadata": {"aucs": [0.36474932169066343, 0.51789572013288, 0.40237572945896083], "final_y": [0.0002515166799446886, 1.623254430762373e-07, 2.0480821720932618e-05]}, "mutation_prompt": null}
{"id": "48b229ae-05f6-418c-b285-adec2593ad67", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                self.f = np.random.uniform(0.5, 0.9)  # Update mutation control parameter dynamically\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance the mutation strategy of AdaptiveDifferentialEvolution by incorporating a dynamic scaling factor in the mutation operation for improved convergence.", "configspace": "", "generation": 15, "fitness": 0.41135510728567143, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.411 with standard deviation 0.071. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "d639aa6f-a777-48c0-81a9-9ffb71207c7d", "metadata": {"aucs": [0.5038580525171826, 0.39806953736134154, 0.33213773197849017], "final_y": [1.8296607479907592e-06, 0.00035809785468030286, 0.0031370777006308054]}, "mutation_prompt": null}
{"id": "c5038ca7-5968-4a74-a3d0-3756e296358f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 0.95) if diversity > 0.2 else np.random.uniform(0.75, 0.85)\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a condition to dynamically adjust crossover probability `cr` based on population diversity to enhance exploration.", "configspace": "", "generation": 16, "fitness": 0.4714216663229082, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.471 with standard deviation 0.026. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d639aa6f-a777-48c0-81a9-9ffb71207c7d", "metadata": {"aucs": [0.4711031634259526, 0.4398671100832303, 0.5032947254595417], "final_y": [1.437339345744192e-06, 2.3357854575766732e-05, 6.887967769639786e-07]}, "mutation_prompt": null}
{"id": "6f555f82-ac53-46fd-a223-2d3bdffe05b1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            fitness_change = np.max(fitness) - np.min(fitness)  # Measure fitness change\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 and fitness_change > 0.05 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by adjusting mutation rate based on both diversity and fitness change.", "configspace": "", "generation": 17, "fitness": 0.4898239716412065, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.490 with standard deviation 0.057. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d639aa6f-a777-48c0-81a9-9ffb71207c7d", "metadata": {"aucs": [0.4758762715121474, 0.5659009579722163, 0.4276946854392557], "final_y": [4.867076887275987e-06, 4.5087353057338647e-08, 3.534112544483435e-05]}, "mutation_prompt": null}
{"id": "4b1fe4b6-655b-40ab-9c9a-86460dc1f7d3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                # Change 1: Refine mutation\n                mutant = np.clip(x1 + self.f * ((x2 - x3) + 0.1 * (population.mean(axis=0) - x1)), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            # Change 2: Refine population size adjustment\n            self.population_size = max(4, int(10 * self.dim * (0.9 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Refine mutation step by using weighted averaging of differences to enhance convergence.", "configspace": "", "generation": 18, "fitness": 0.3294988988401779, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.329 with standard deviation 0.022. And the mean value of best solutions found was 0.007 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "d639aa6f-a777-48c0-81a9-9ffb71207c7d", "metadata": {"aucs": [0.29920609239585594, 0.35064601584148336, 0.33864458828319444], "final_y": [0.015254546181664849, 0.0019717636709388506, 0.004257883699924294]}, "mutation_prompt": null}
{"id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by adjusting crossover probability based on population diversity.", "configspace": "", "generation": 19, "fitness": 0.5214975777068988, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.521 with standard deviation 0.078. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d639aa6f-a777-48c0-81a9-9ffb71207c7d", "metadata": {"aucs": [0.5795098437873853, 0.4112872763160912, 0.5736956130172197], "final_y": [3.1715198908980014e-08, 0.00010114915846889675, 5.20753538587927e-08]}, "mutation_prompt": null}
{"id": "d453d36c-e297-4167-aa29-c31d116f6730", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                iteration_progress = budget_used / self.budget\n                adaptive_f = self.f * (1 + 0.5 * np.sin(iteration_progress * np.pi))  # Adaptive mutation scaling\n                mutant = np.clip(x1 + adaptive_f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation scaling based on iteration progress to enhance convergence.", "configspace": "", "generation": 20, "fitness": 0.3310783539904572, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.331 with standard deviation 0.013. And the mean value of best solutions found was 0.003 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.31783323893082494, 0.3488775738544502, 0.32652424918609657], "final_y": [0.0027094995814246734, 0.000853635763111298, 0.004739694672978463]}, "mutation_prompt": null}
{"id": "9758d36d-575f-4630-9b8a-375c7d5fc4cf", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.3, 0.8) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.7, 0.9)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce stochastic control parameter adaptation to improve diversity handling in Adaptive Differential Evolution.", "configspace": "", "generation": 21, "fitness": 0.45826855185405097, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.458 with standard deviation 0.039. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.5134794261126598, 0.43670094367997525, 0.42462528576951786], "final_y": [6.354294676088701e-07, 1.5652911055604458e-05, 5.371529094223266e-05]}, "mutation_prompt": null}
{"id": "b32d3bdf-2ff6-4bb6-af68-bda4210b92f8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n            self.f *= (1 - budget_used / self.budget)  # Adaptive scaling of differential weight\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive scaling of the differential weight based on budget utilization to improve convergence.", "configspace": "", "generation": 22, "fitness": 0.4456522535860137, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.446 with standard deviation 0.081. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.5602675051375776, 0.39655372018011403, 0.3801355354403494], "final_y": [1.945581384060202e-07, 0.00014229167832163973, 0.0010903569148023162]}, "mutation_prompt": null}
{"id": "c38c83cc-d69a-4c90-a2b9-73cc28ca8fe3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                f_local = np.random.uniform(0.4, 0.9) if np.random.rand() < 0.5 else np.random.uniform(0.1, 0.4)\n                mutant = np.clip(x1 + f_local * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptability by refining mutation strategy based on historical success. ", "configspace": "", "generation": 23, "fitness": 0.38206873226415716, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.382 with standard deviation 0.077. And the mean value of best solutions found was 0.004 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4897215977090871, 0.317606405291736, 0.3388781937916483], "final_y": [5.414545376178547e-06, 0.006854402534504363, 0.004306751481858991]}, "mutation_prompt": null}
{"id": "7642dd9c-3b7e-42e6-b410-c31b4c34a73f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.15 else np.random.uniform(0.5, 0.7)  # Adjusted line\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.15 else np.random.uniform(0.75, 0.85)  # Adjusted line\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enrich selection pressure by refining crossover probability adjustment based on improved diversity analysis.", "configspace": "", "generation": 24, "fitness": 0.45077349972962133, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.451 with standard deviation 0.054. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.46904768229785254, 0.37712702381717433, 0.5061457930738371], "final_y": [6.928386180759781e-07, 0.00011796374707335577, 1.2538729618198218e-06]}, "mutation_prompt": null}
{"id": "dd6ef9c3-4d77-467b-b1d6-4e437490abac", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.3, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive scaling of differential weight (f) based on convergence speed to enhance exploitation-exploration balance.", "configspace": "", "generation": 25, "fitness": 0.4506780832391341, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.451 with standard deviation 0.033. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4723914305192871, 0.4033846421660102, 0.47625817703210493], "final_y": [1.2693577172097342e-06, 5.9956860104353936e-05, 8.256838788367493e-07]}, "mutation_prompt": null}
{"id": "6ce6a8c5-b08f-434a-b657-d03a270f2b1c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Add random restart mechanism\n            if diversity < 0.05:  # Trigger random restart if diversity is too low\n                population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                budget_used += self.population_size\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a random restart mechanism to enhance exploration when diversity falls below a threshold.", "configspace": "", "generation": 26, "fitness": 0.4506780832391341, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.451 with standard deviation 0.033. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4723914305192871, 0.4033846421660102, 0.47625817703210493], "final_y": [1.2693577172097342e-06, 5.9956860104353936e-05, 8.256838788367493e-07]}, "mutation_prompt": null}
{"id": "23092be9-5a35-4de3-b054-705f763ef9e3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n            # Adaptive adjustment based on success rates\n            successful_mutations = np.sum(fitness < trial_fitness)\n            self.f = min(0.9, self.f + 0.1 * (successful_mutations / self.population_size))\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Refine control parameter adjustments by introducing adaptive strategies based on mutation and crossover success rates.", "configspace": "", "generation": 27, "fitness": 0.3935951771251003, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.394 with standard deviation 0.030. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.43417535227395443, 0.38506662982483686, 0.36154354927650956], "final_y": [1.1770697520000357e-06, 5.290251820492601e-05, 0.0008137120215175942]}, "mutation_prompt": null}
{"id": "70e1e429-eda5-436b-a12d-7d91425f8eaf", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Tournament selection for more competitive individuals\n                tournament_indices = np.random.choice(self.population_size, 3)\n                indices = sorted(tournament_indices, key=lambda idx: fitness[idx])[:3]\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                self.f = np.random.uniform(0.4, 0.9)  # Adjust mutation strength adaptively\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            # Maintain original logic for crossover probability adjustment\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce tournament selection and adaptive mutation strength for an improved exploration-exploitation balance.", "configspace": "", "generation": 28, "fitness": 0.4766490668008883, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.477 with standard deviation 0.035. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4824660010658308, 0.5162407580980496, 0.43124044123878447], "final_y": [1.627003216647488e-05, 7.083588517300765e-07, 0.00011721880877012558]}, "mutation_prompt": null}
{"id": "64381fde-1389-4c70-b35a-480030e81f7e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            fitness_improvement_rate = (np.min(fitness) - np.mean(fitness)) / np.std(fitness)  # Change line\n            self.f = np.random.uniform(0.4, 0.9) if fitness_improvement_rate > 0.1 else np.random.uniform(0.5, 0.7)  # Change line\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improve exploration by dynamically adjusting differential weight based on fitness improvement rate.", "configspace": "", "generation": 29, "fitness": 0.4021083895414191, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.402 with standard deviation 0.048. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.46865360295732506, 0.35917201204342286, 0.3784995536235093], "final_y": [4.445635506612438e-06, 0.0003742255730927603, 6.613500454841945e-05]}, "mutation_prompt": null}
{"id": "9583bd30-44b2-4b95-a81d-2403ea255f46", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.f = self.f + 0.1 * (fitness[i] - trial_fitness) / max(1, abs(fitness[i]))  # Adjust mutation factor\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by adjusting the mutation factor based on fitness improvement.", "configspace": "", "generation": 30, "fitness": 0.4180361627623683, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.418 with standard deviation 0.028. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.37864319249359224, 0.4445981344782174, 0.43086716131529534], "final_y": [0.001008682325017209, 6.248851087749651e-06, 1.7655420005124412e-05]}, "mutation_prompt": null}
{"id": "311f0279-f0d7-4796-af01-848df5c39846", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n                self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else self.f  # Change mutation strategy\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by modifying the mutation strategy dynamically based on diversity.", "configspace": "", "generation": 31, "fitness": 0.4063015892161858, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.406 with standard deviation 0.033. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.36548029352201317, 0.445078646008768, 0.4083458281177762], "final_y": [0.001239520990870978, 1.518546691597493e-05, 0.00011718977677922198]}, "mutation_prompt": null}
{"id": "f058dfc4-c947-472b-9275-7754382bb9ab", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improve exploitation by dynamically adjusting differential weight based on convergence speed.", "configspace": "", "generation": 32, "fitness": 0.45575126203723965, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.456 with standard deviation 0.022. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4356280506410929, 0.4861999109421081, 0.44542582452851787], "final_y": [4.1557041781396595e-05, 1.329883476152446e-06, 2.0781425825667225e-05]}, "mutation_prompt": null}
{"id": "47461086-6eaf-48ec-9264-ba95a1369d1e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Secondary mutation strategy\n                if np.random.rand() < 0.1:  # 10% chance to apply secondary mutation\n                    trial = np.clip(trial + np.random.normal(0, 0.1, self.dim), lower_bound, upper_bound)\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by tweaking crossover probability and adding a secondary mutation strategy.", "configspace": "", "generation": 33, "fitness": 0.42388218342334555, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.424 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.44112919794361616, 0.43173573689381595, 0.3987816154326046], "final_y": [3.77508354359251e-05, 2.6923761961313226e-06, 6.670910094739179e-05]}, "mutation_prompt": null}
{"id": "3c5d46a7-5366-4448-b474-57f55bf8e916", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - diversity * budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Adjust population size more dynamically based on diversity and budget usage.", "configspace": "", "generation": 34, "fitness": 0.2568679811478694, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.257 with standard deviation 0.026. And the mean value of best solutions found was 0.129 (0. is the best) with standard deviation 0.076.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.2225113037592421, 0.2632218908668237, 0.2848707488175425], "final_y": [0.23398915822099622, 0.09228638644120041, 0.05928424686627132]}, "mutation_prompt": null}
{"id": "93ce5162-2d7c-49f4-b09a-bbd80745fc0c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3) + 0.1 * (population[np.argmin(fitness)] - x1), lower_bound, upper_bound)  # Changed line for mutation strategy\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Modify the mutation strategy for improved exploration in high-dimensional search spaces.", "configspace": "", "generation": 35, "fitness": 0.4370369882517007, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.437 with standard deviation 0.051. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.5018214081688868, 0.4329255006026782, 0.37636405598353706], "final_y": [3.213365790035621e-07, 3.1246393992999045e-05, 0.0005893853744845935]}, "mutation_prompt": null}
{"id": "6ecdffa6-4d53-411b-b217-8dd36e0fc676", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                self.f = 0.4 + 0.5 * (self.budget - budget_used) / self.budget  # Adaptive mutation strategy\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation strategy based on iteration progress to enhance exploration and exploitation balance.", "configspace": "", "generation": 36, "fitness": 0.41420838877090427, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.414 with standard deviation 0.014. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4148194693173356, 0.4313708804044337, 0.3964348165909436], "final_y": [2.95568010475859e-05, 2.5285259597353833e-06, 0.00010511362693775412]}, "mutation_prompt": null}
{"id": "ebeca010-4a01-4437-bb1e-35be4d1f297a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.6, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)  # Adjusted F range\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Integrate adaptive learning for differential weight to improve convergence speed and accuracy.", "configspace": "", "generation": 37, "fitness": 0.39851629147349654, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.399 with standard deviation 0.046. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.45583743839636615, 0.3420992744158393, 0.39761216160828416], "final_y": [4.383430257712834e-06, 0.0010844684095399316, 1.8195694833600044e-05]}, "mutation_prompt": null}
{"id": "97c72c0b-7eb9-4949-a8f9-f01f90052e14", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n            \n            # Best individual secondary mutation\n            best_individual = population[best_indices[0]]\n            for i in range(2, self.population_size):\n                if np.random.rand() < 0.1:  # Adding secondary mutation with a low probability\n                    mutation_vector = np.clip(best_individual + self.f * (population[i] - best_individual), lower_bound, upper_bound)\n                    population[i] = mutation_vector\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improve convergence by introducing a secondary mutation mechanism based on the best individual in the population.", "configspace": "", "generation": 38, "fitness": 0.4415127685589568, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.442 with standard deviation 0.040. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4830735646706722, 0.454760967277259, 0.3867037737289394], "final_y": [2.5152609172977353e-06, 5.431900125854192e-06, 0.00021988814325094738]}, "mutation_prompt": null}
{"id": "77854d3a-179d-4da6-b7f4-747e8c939fe7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n            \n            # Convergence-based adaptive scaling\n            convergence = np.mean(fitness)\n            self.f *= 0.9 if convergence < 0.1 else 1.1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Integrates adaptive scaling of mutation strategy based on the convergence rate to balance exploration and exploitation.", "configspace": "", "generation": 39, "fitness": 0.4233774448976448, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.423 with standard deviation 0.063. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.5097908209985735, 0.3623148102280561, 0.39802670346630464], "final_y": [8.147098642086087e-08, 0.00048534256078669994, 0.00013431870943446148]}, "mutation_prompt": null}
{"id": "5bb4412b-a0ef-4c15-8cec-c1e1093846f1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                self.f = 0.4 + 0.6 * (1 - fitness[i] / np.max(fitness))  # Adaptive mutation factor based on fitness\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation factor based on current fitness to enhance convergence speed.", "configspace": "", "generation": 40, "fitness": 0.28422461062748733, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.284 with standard deviation 0.039. And the mean value of best solutions found was 0.026 (0. is the best) with standard deviation 0.032.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.28446025216212, 0.33246313755711177, 0.23575044216323016], "final_y": [0.0035214324221551187, 0.0027503044724094127, 0.07149031398776261]}, "mutation_prompt": null}
{"id": "d0abb33d-98ae-4522-8cae-245c71b9f522", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                improvement = fitness[i] - np.min(fitness)  # Calculate fitness improvement\n                self.f = 0.4 + 0.5 * (1.0 - (improvement / np.max(fitness)))  # Adjust mutation scaling factor\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by dynamically adjusting mutation scaling factor based on fitness improvement.", "configspace": "", "generation": 41, "fitness": 0.4119212649372542, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.412 with standard deviation 0.047. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.43713548537980285, 0.45252560967746824, 0.3461026997544915], "final_y": [6.32378784780924e-07, 1.2667806779780438e-05, 0.0008944698454504312]}, "mutation_prompt": null}
{"id": "b1aa899e-7eb4-448d-aba0-d83e05bb5ae7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.6, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptation by dynamically adjusting both differential weight and crossover probability based on population diversity.", "configspace": "", "generation": 42, "fitness": 0.39851629147349654, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.399 with standard deviation 0.046. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.45583743839636615, 0.3420992744158393, 0.39761216160828416], "final_y": [4.383430257712834e-06, 0.0010844684095399316, 1.8195694833600044e-05]}, "mutation_prompt": null}
{"id": "b027fd0d-05d1-4df5-9b51-b1856c203d9b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - (budget_used / self.budget)**2)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by dynamically updating both population size and mutation factors based on remaining budget.", "configspace": "", "generation": 43, "fitness": 0.3920071023969969, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.392 with standard deviation 0.020. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4040570922869303, 0.4087945708490629, 0.3631696440549974], "final_y": [1.3861041634543701e-05, 6.368146381707087e-06, 4.60534957712814e-05]}, "mutation_prompt": null}
{"id": "0d612d80-9cc6-419b-908c-75f71b86cc22", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                self.f = 0.4 + 0.5 * (1 - budget_used / self.budget)  # Adaptive scaling factor based on progress\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by using an adaptive scaling factor based on iteration progress.", "configspace": "", "generation": 44, "fitness": 0.39557025437256493, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.396 with standard deviation 0.047. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4409395620611033, 0.415303732431338, 0.33046746862525345], "final_y": [3.3634400657725362e-06, 3.782539265337317e-06, 0.001447672326389166]}, "mutation_prompt": null}
{"id": "8632172a-8cae-4648-bd01-1dc5f9e7aa47", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7) * diversity  # Adjusted differential weight\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic strategy to adjust the differential weight based on population diversity to enhance convergence.", "configspace": "", "generation": 45, "fitness": 0.4506780832391341, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.451 with standard deviation 0.033. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4723914305192871, 0.4033846421660102, 0.47625817703210493], "final_y": [1.2693577172097342e-06, 5.9956860104353936e-05, 8.256838788367493e-07]}, "mutation_prompt": null}
{"id": "012f4fe8-d554-4cc9-9a18-0adb9f728845", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far based on both fitness and diversity\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improve selection by introducing elitism based on both fitness and diversity.", "configspace": "", "generation": 46, "fitness": 0.4506780832391341, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.451 with standard deviation 0.033. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4723914305192871, 0.4033846421660102, 0.47625817703210493], "final_y": [1.2693577172097342e-06, 5.9956860104353936e-05, 8.256838788367493e-07]}, "mutation_prompt": null}
{"id": "02559dcb-d248-48fc-b986-00326846882b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n            # New Line 1: Adjust differential weight based on fitness variance\n            self.f = np.random.uniform(0.4, 1.0) if np.var(fitness) > 0.1 else self.f\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic scaling of the differential weight based on fitness variance to improve exploration.", "configspace": "", "generation": 47, "fitness": 0.4049927633120303, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.405 with standard deviation 0.014. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.3856310532805658, 0.41183228117859405, 0.41751495547693107], "final_y": [0.000977841024158789, 1.5846812282447217e-05, 1.2658032138880329e-05]}, "mutation_prompt": null}
{"id": "76e453e5-98e2-4561-ba5e-ba2522d55471", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                current_f = self.f + 0.1 * np.random.rand() if np.min(fitness) < fitness[i] else self.f  # Adapt F based on fitness\n                mutant = np.clip(x1 + current_f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation factor based on fitness improvements to enhance convergence.", "configspace": "", "generation": 48, "fitness": 0.36414040335852765, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.364 with standard deviation 0.032. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.32090214655361293, 0.3726797242039974, 0.39883933931797255], "final_y": [0.0008853424108359638, 0.00014760535509918251, 8.831826775523316e-05]}, "mutation_prompt": null}
{"id": "84707382-926b-4913-bf0b-50a4a6ddf02a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by dynamically adjusting the mutation factor based on fitness improvement rate.", "configspace": "", "generation": 49, "fitness": 0.4276843107881441, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.428 with standard deviation 0.016. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.40663825509516627, 0.4456791876099132, 0.43073548965935293], "final_y": [0.0001692390577993181, 0.00010637961199341422, 6.217252900912206e-05]}, "mutation_prompt": null}
{"id": "f8b8c0ca-c968-4acd-bac2-11953b68cfdf", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if np.std(fitness) > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Utilize adaptive mutation rates based on fitness variance to enhance exploration and exploitation balance.", "configspace": "", "generation": 50, "fitness": 0.4506780832391341, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.451 with standard deviation 0.033. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4723914305192871, 0.4033846421660102, 0.47625817703210493], "final_y": [1.2693577172097342e-06, 5.9956860104353936e-05, 8.256838788367493e-07]}, "mutation_prompt": null}
{"id": "74fa1f38-bab0-4bbf-87aa-d688e7172aa9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n            # Learning mechanism for parameter tuning\n            if trial_fitness < np.min(fitness):\n                self.f = 0.6  # Adjust differential weight\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improve convergence by introducing a learning mechanism for dynamic parameter tuning based on past performance.", "configspace": "", "generation": 51, "fitness": 0.4506780832391341, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.451 with standard deviation 0.033. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4723914305192871, 0.4033846421660102, 0.47625817703210493], "final_y": [1.2693577172097342e-06, 5.9956860104353936e-05, 8.256838788367493e-07]}, "mutation_prompt": null}
{"id": "3a55e0f5-b2bd-46ff-ab89-a8128b73e155", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.7, 0.9)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce self-adaptive parameter tuning to balance exploration and exploitation dynamically.", "configspace": "", "generation": 52, "fitness": 0.40513583715649454, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.405 with standard deviation 0.097. And the mean value of best solutions found was 0.004 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.30557316053023387, 0.3736862260909375, 0.5361481248483122], "final_y": [0.011125786701318542, 0.00025457895198176473, 3.844517684358058e-07]}, "mutation_prompt": null}
{"id": "3938eea4-105e-4432-9553-e585b29d139c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n            # Adaptive scaling factor based on progress\n            progress = budget_used / self.budget\n            self.f *= (1 - progress)  # New line to adaptively scale f\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce an adaptive scaling factor to enhance convergence speed based on iteration progress.", "configspace": "", "generation": 53, "fitness": 0.4456522535860137, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.446 with standard deviation 0.081. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.5602675051375776, 0.39655372018011403, 0.3801355354403494], "final_y": [1.945581384060202e-07, 0.00014229167832163973, 0.0010903569148023162]}, "mutation_prompt": null}
{"id": "e1576cd3-1655-4081-9a70-c692cd28b407", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            fitness_variance = np.var(fitness)  # Calculate fitness variance\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n            # Adjust mutation scale based on fitness variance\n            self.f *= (1 + fitness_variance)  # New adaptive scaling\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive mutation scaling based on fitness variance to improve convergence speed.", "configspace": "", "generation": 54, "fitness": 0.1498578432608498, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.150 with standard deviation 0.011. And the mean value of best solutions found was 1.330 (0. is the best) with standard deviation 0.495.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.15894168225728467, 0.13418488438071374, 0.15644696314455098], "final_y": [0.7831568479347868, 1.9827276537644825, 1.2235480952535958]}, "mutation_prompt": null}
{"id": "410b7656-679f-4234-a07b-2716a13f956c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            fitness_variance = np.var(fitness)\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)  # Adjusted mutation\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improve exploration by adjusting mutation rate based on population fitness variance.", "configspace": "", "generation": 55, "fitness": 0.4506780832391341, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.451 with standard deviation 0.033. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4723914305192871, 0.4033846421660102, 0.47625817703210493], "final_y": [1.2693577172097342e-06, 5.9956860104353936e-05, 8.256838788367493e-07]}, "mutation_prompt": null}
{"id": "8bdfb604-c4f5-4882-a5ba-2cccfa58b1d7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n            # New adaptive differential weight based on fitness variance\n            fitness_variance = np.var(fitness)\n            self.f = 0.4 + (0.5 * fitness_variance) \n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by introducing adaptive scaling for differential weight based on fitness variance.", "configspace": "", "generation": 56, "fitness": 0.14141928692326197, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.141 with standard deviation 0.011. And the mean value of best solutions found was 1.753 (0. is the best) with standard deviation 0.375.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.13362601324452117, 0.13418488438071374, 0.15644696314455098], "final_y": [2.051463861470096, 1.9827276537644825, 1.2235480952535958]}, "mutation_prompt": null}
{"id": "cfcd0e87-2385-4f2f-9264-919af9c03490", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by integrating adaptive mutation strategies based on fitness improvement rates.", "configspace": "", "generation": 57, "fitness": 0.4506780832391341, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.451 with standard deviation 0.033. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4723914305192871, 0.4033846421660102, 0.47625817703210493], "final_y": [1.2693577172097342e-06, 5.9956860104353936e-05, 8.256838788367493e-07]}, "mutation_prompt": null}
{"id": "5076a446-b056-4b8c-87bd-044e357d4c78", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n            # Adaptive mutation factor scaling based on fitness improvement\n            self.f *= 1.1 if trial_fitness < np.min(fitness) else 0.9\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation factor scaling based on fitness improvement to refine search precision.", "configspace": "", "generation": 58, "fitness": 0.4505175431378395, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.451 with standard deviation 0.059. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4455558542964809, 0.3811084852759009, 0.5248882898411368], "final_y": [1.2078505958133346e-05, 0.0004158425475802853, 3.515272888187485e-08]}, "mutation_prompt": null}
{"id": "6a505ebd-b476-491d-ac4a-e6992eb0dd20", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                self.f = 0.5 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-8))  # Adaptive mutation scaling\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Integrate adaptive mutation scaling based on fitness variance for improved convergence in Differential Evolution.", "configspace": "", "generation": 59, "fitness": 0.32835580814603754, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.328 with standard deviation 0.012. And the mean value of best solutions found was 0.004 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.33536460763147746, 0.3387083925032285, 0.31099442430340674], "final_y": [0.001634556063952303, 0.000751692201589033, 0.010311170582204444]}, "mutation_prompt": null}
{"id": "e5ace0a5-4b24-4d4d-b83f-4e379d9fb05c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.8, 1.0) if diversity < 0.1 else np.random.uniform(0.7, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Refine crossover probability adjustment range for enhanced diversity and convergence.", "configspace": "", "generation": 60, "fitness": 0.43130027529222525, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.431 with standard deviation 0.034. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4676887060334176, 0.38604579353129764, 0.4401663263119605], "final_y": [1.0744505634091714e-05, 0.00010291059960257174, 3.7411729526121583e-06]}, "mutation_prompt": null}
{"id": "8841cc9f-84a2-4340-8f61-0883a0cf2548", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.8, 0.95) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Refine adaptive parameters' adjustment based on convergence rate to enhance solution quality.", "configspace": "", "generation": 61, "fitness": 0.4506780832391341, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.451 with standard deviation 0.033. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4723914305192871, 0.4033846421660102, 0.47625817703210493], "final_y": [1.2693577172097342e-06, 5.9956860104353936e-05, 8.256838788367493e-07]}, "mutation_prompt": null}
{"id": "5748e3e9-157f-4b5c-92ed-6440a6ce8240", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n        self.diversity_memory = []\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.diversity_memory.append(diversity)\n            avg_diversity = np.mean(self.diversity_memory[-10:]) if len(self.diversity_memory) >= 10 else diversity\n            self.f = np.random.uniform(0.4, 0.8) if avg_diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if avg_diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Integrate a memory component to dynamically refine control parameters based on historical diversity patterns.", "configspace": "", "generation": 62, "fitness": 0.4269229316175034, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.427 with standard deviation 0.017. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.42870123308558006, 0.4472598215210175, 0.4048077402459127], "final_y": [1.9725045223979128e-05, 8.470168590546306e-07, 5.762791777763508e-05]}, "mutation_prompt": null}
{"id": "98496055-2040-4807-be5c-d0e56bffb27b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n            # Local search around the best solution\n            best_solution = population[best_indices[0]]\n            perturbation = np.random.normal(0, 0.01, self.dim)  # Small perturbation\n            refined_solution = np.clip(best_solution + perturbation, lower_bound, upper_bound)\n            refined_fitness = func(refined_solution)\n            if refined_fitness < fitness[best_indices[0]]:\n                population[best_indices[0]] = refined_solution\n                fitness[best_indices[0]] = refined_fitness\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improve exploitation by adding local search around the best-known solution to refine it further.", "configspace": "", "generation": 63, "fitness": 0.39816201836864645, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.398 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.3876984748594484, 0.40107180865010617, 0.4057157715963846], "final_y": [0.00011256990434414486, 6.779499922860002e-05, 6.461141272075737e-05]}, "mutation_prompt": null}
{"id": "df8adf93-083c-437d-b13f-ab6357e1a98b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n            self.f *= (1 - diversity)  # Adjust mutation factor based on convergence\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation scaling based on population convergence.", "configspace": "", "generation": 64, "fitness": 0.1335638575452783, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.134 with standard deviation 0.017. And the mean value of best solutions found was 1.802 (0. is the best) with standard deviation 0.716.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.12248211431432166, 0.12024998160066991, 0.15795947672084332], "final_y": [2.129807899745762, 2.467617222282249, 0.8076532200278074]}, "mutation_prompt": null}
{"id": "fc84a6d6-210c-43df-8451-a23a1b7a2fa2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.7, 0.9)  # Changed line\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration and exploitation by adjusting mutation strategies based on diversity.", "configspace": "", "generation": 65, "fitness": 0.4506780832391341, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.451 with standard deviation 0.033. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4723914305192871, 0.4033846421660102, 0.47625817703210493], "final_y": [1.2693577172097342e-06, 5.9956860104353936e-05, 8.256838788367493e-07]}, "mutation_prompt": null}
{"id": "bfa42091-d2a3-45d1-9fc9-63ec3fb9bc1b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = 0.85 + 0.1 * (1 - (fitness.min() / fitness.mean()))  # Adapt based on fitness improvement rate\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Refine crossover strategy by introducing adaptive control based on fitness improvement rate.", "configspace": "", "generation": 66, "fitness": 0.44722409790452594, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.447 with standard deviation 0.019. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.43684180173760634, 0.47346585480886816, 0.4313646371671034], "final_y": [2.297903518463058e-05, 8.380772634799297e-06, 3.08902299121494e-05]}, "mutation_prompt": null}
{"id": "fabc3bf4-b26a-48e8-bdc4-64744640b74c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                rank_based_f = self.f * (1 + (fitness[i] - min(fitness)) / (max(fitness) - min(fitness) + 1e-9))  # Updated line\n                mutant = np.clip(x1 + rank_based_f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a dynamic mutation strategy based on fitness rank to enhance solution diversity.", "configspace": "", "generation": 67, "fitness": 0.4130623134282028, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.413 with standard deviation 0.040. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.46616812402315433, 0.3704761108949146, 0.40254270536653947], "final_y": [1.1168241984541817e-05, 0.0006466379220336579, 4.227972085119574e-05]}, "mutation_prompt": null}
{"id": "131518b8-2640-4019-8ce0-acef9539e88d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n                self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a diversity-driven scaling factor for mutation strength to enhance exploration.", "configspace": "", "generation": 68, "fitness": 0.41954936956100547, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.420 with standard deviation 0.037. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.3787693568510979, 0.46910865949683045, 0.410770092335088], "final_y": [0.00039387644831728155, 2.4695886637484634e-06, 1.5834697009807874e-05]}, "mutation_prompt": null}
{"id": "a95804aa-14db-45b4-b2e7-c494a6700fa1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7) * (1 - budget_used / self.budget)  # Adjust mutation factor\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic scaling of mutation factor based on budget consumption to improve balance between exploration and exploitation.", "configspace": "", "generation": 69, "fitness": 0.3694102545122114, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.369 with standard deviation 0.040. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.3690454966591792, 0.321049133407473, 0.4181361334699819], "final_y": [0.000346197732350156, 0.0006172009856045906, 2.85916634976135e-05]}, "mutation_prompt": null}
{"id": "8d349d91-2118-43af-ba59-7c8a42413168", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = 0.5 + 0.4 * np.cos(np.pi * budget_used / self.budget)  # Adjusted dynamic range for f\n            self.cr = 0.9 * np.sin(np.pi * budget_used / self.budget) + 0.1  # Adjusted dynamic range for cr\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Dynamically adjust both differential weight and crossover probability based on iteration progress to balance exploration and exploitation.", "configspace": "", "generation": 70, "fitness": 0.3697682196450569, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.370 with standard deviation 0.039. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.37560688365614925, 0.4146842079284011, 0.31901356735062025], "final_y": [0.0002907308689797219, 1.6869720051640695e-05, 0.0022196638515953986]}, "mutation_prompt": null}
{"id": "035f09d1-4413-4f19-b96a-454c75fe3f68", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3,\n                                           replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75,\n                                                                                             0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improve convergence by incorporating adaptive mutation scaling based on fitness improvement.", "configspace": "", "generation": 71, "fitness": 0.37412628610710413, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.374 with standard deviation 0.019. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.3575867626544198, 0.4014185054480506, 0.36337359021884197], "final_y": [0.0016409978670311107, 0.0009164237145423543, 0.0002825963726270866]}, "mutation_prompt": null}
{"id": "8819f07e-9026-4ca4-aaff-b96b8a07ab4b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.2 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improve exploration by dynamically adjusting crossover probability based on population diversity and improving trial solution selection.", "configspace": "", "generation": 72, "fitness": 0.4506780832391341, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.451 with standard deviation 0.033. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4723914305192871, 0.4033846421660102, 0.47625817703210493], "final_y": [1.2693577172097342e-06, 5.9956860104353936e-05, 8.256838788367493e-07]}, "mutation_prompt": null}
{"id": "2a459312-9a13-475c-ac6f-b415da424fc6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = 0.5 + 0.4 * (np.mean(fitness) - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-8)  # New mutation strategy\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation factor based on fitness improvement in Adaptive Differential Evolution.", "configspace": "", "generation": 73, "fitness": 0.45572648403369076, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.456 with standard deviation 0.039. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.503962975195037, 0.45432678630365697, 0.40888969060237845], "final_y": [7.579405027253917e-08, 8.406083864735393e-06, 1.9699627387926308e-05]}, "mutation_prompt": null}
{"id": "f056b0cc-4039-4424-b452-313680cf2a42", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            best_index = np.argmin(fitness)\n            best_solution = population[best_index]\n\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(best_solution + self.f * (x2 - x3), lower_bound, upper_bound)  # Mutation strategy changed\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Adjust the mutation strategy to enhance diversity by incorporating the best solution found so far into the mutation process.", "configspace": "", "generation": 74, "fitness": 0.5083904602076706, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.508 with standard deviation 0.022. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.5347129840202494, 0.4811503174315598, 0.5093080791712026], "final_y": [6.482006807738785e-06, 1.7580201050898526e-05, 1.4140342460017333e-06]}, "mutation_prompt": null}
{"id": "ce3fddf9-c0af-433f-96e4-33728818eaee", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n            \n            # Adaptive mutation strategy\n            if budget_used > self.budget * 0.5:\n                self.f *= (1 - (budget_used / self.budget))\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce an adaptive mutation strategy based on convergence speed to enhance solution exploration and exploitation.", "configspace": "", "generation": 75, "fitness": 0.4061236812972879, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.406 with standard deviation 0.057. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.427368971647172, 0.3283138345549409, 0.46268823768975065], "final_y": [3.7929376153387886e-05, 0.004575109468696714, 6.7369819456765134e-06]}, "mutation_prompt": null}
{"id": "6141df2a-f085-469b-a5d9-b4132393c3a2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.6, 0.8)  # Changed\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by introducing adaptive scaling of the differential weight based on diversity.", "configspace": "", "generation": 76, "fitness": 0.4506780832391341, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.451 with standard deviation 0.033. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4723914305192871, 0.4033846421660102, 0.47625817703210493], "final_y": [1.2693577172097342e-06, 5.9956860104353936e-05, 8.256838788367493e-07]}, "mutation_prompt": null}
{"id": "f5590904-812e-477f-9029-42e76576569e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            successful_mutations = 0  # Track number of successful mutations\n\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations += 1  # Count successful mutations\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Adapt mutation factor based on success rate\n            success_rate = successful_mutations / self.population_size\n            if success_rate < 0.2:  # Adjust mutation factor if success rate is low\n                self.f = np.random.uniform(0.4, 0.6)\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive mutation factor adjustment based on success rate to enhance convergence speed.", "configspace": "", "generation": 77, "fitness": 0.39632981543247486, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.396 with standard deviation 0.056. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.39096653255851677, 0.46779776063930434, 0.33022515309960365], "final_y": [0.00038335844624852363, 2.6554773859074525e-06, 0.004714447053372805]}, "mutation_prompt": null}
{"id": "15f8951b-81e2-4133-9813-e61e781ae33f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.8)  # Adjusted\n            self.cr = np.random.uniform(0.8, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.9)  # Adjusted\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Refine Adaptive Differential Evolution by incorporating adaptive mutation and crossover strategies based on fitness improvement trends.", "configspace": "", "generation": 78, "fitness": 0.3977806740054604, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.398 with standard deviation 0.030. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.37877690539655506, 0.3747402264837264, 0.4398248901360998], "final_y": [0.00013582215702400186, 0.00018474304760186222, 1.1793889251971904e-05]}, "mutation_prompt": null}
{"id": "acb9f162-2c37-4b67-84b2-272602e0fa3e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.15 else np.random.uniform(0.6, 0.8)  # Adaptive mutation adjustment\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance diversity by incorporating adaptive mutation strategies based on population convergence. ", "configspace": "", "generation": 79, "fitness": 0.4506780832391341, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.451 with standard deviation 0.033. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4723914305192871, 0.4033846421660102, 0.47625817703210493], "final_y": [1.2693577172097342e-06, 5.9956860104353936e-05, 8.256838788367493e-07]}, "mutation_prompt": null}
{"id": "c06be8ac-b1c1-4e42-a73a-469c0f539647", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.6, 0.8)  # Adjusted scaling factor range\n\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Refine exploration by incorporating adaptive scaling factor adjustment based on population diversity.", "configspace": "", "generation": 80, "fitness": 0.4506780832391341, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.451 with standard deviation 0.033. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4723914305192871, 0.4033846421660102, 0.47625817703210493], "final_y": [1.2693577172097342e-06, 5.9956860104353936e-05, 8.256838788367493e-07]}, "mutation_prompt": null}
{"id": "4902ca98-5750-4789-84f9-a307d2d22b00", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 1.0) if diversity > 0.1 else np.random.uniform(0.5, 0.7)  # Updated line\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive differential weight to enhance exploration based on population diversity.", "configspace": "", "generation": 81, "fitness": 0.3763334341368855, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.376 with standard deviation 0.056. And the mean value of best solutions found was 0.005 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.2986506097888214, 0.42605645216026666, 0.40429324046156834], "final_y": [0.014101462907933756, 1.4004552411006627e-05, 7.008516913644913e-05]}, "mutation_prompt": null}
{"id": "42d24971-2fff-4de3-9e24-8f0217e0a711", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)  # New perturbation factor\n                mutant = np.clip(x1 + self.f * (x2 - x3) + perturbation, lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Further enhance population diversity by introducing a random perturbation factor to the mutation process.", "configspace": "", "generation": 82, "fitness": 0.2530460095940544, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.253 with standard deviation 0.010. And the mean value of best solutions found was 0.020 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.2579149427879466, 0.23854648965833647, 0.26267659633588014], "final_y": [0.02952827699536649, 0.012502315770013341, 0.018063172585639872]}, "mutation_prompt": null}
{"id": "2f687bbd-4dc9-4825-809e-34f778837933", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.15 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improve convergence by enhancing diversity management and adaptive parameter control.", "configspace": "", "generation": 83, "fitness": 0.45077349972962133, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.451 with standard deviation 0.054. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.46904768229785254, 0.37712702381717433, 0.5061457930738371], "final_y": [6.928386180759781e-07, 0.00011796374707335577, 1.2538729618198218e-06]}, "mutation_prompt": null}
{"id": "346e8407-f58e-4167-95a0-348a20a583e9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.5, 1.0) if diversity > 0.1 else np.random.uniform(0.4, 0.7)\n            self.cr = np.random.uniform(0.7, 0.95) if diversity < 0.1 else np.random.uniform(0.8, 0.95)\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration and exploitation balance by refining mutation and crossover strategies in adaptive differential evolution.", "configspace": "", "generation": 84, "fitness": 0.4157404831652037, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.416 with standard deviation 0.029. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.38356303817659965, 0.45462282057832304, 0.4090355907406884], "final_y": [8.99070185650064e-05, 3.2687043014310855e-06, 1.8051841257280658e-05]}, "mutation_prompt": null}
{"id": "68d7f0ad-7a7f-4913-80e2-525060e0bb17", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                # Adjust mutation scaling based on iteration progress\n                adaptive_f = self.f * (1 - budget_used / self.budget)\n                mutant = np.clip(x1 + adaptive_f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation scaling based on iteration progress to enhance convergence.", "configspace": "", "generation": 85, "fitness": 0.3960348565985714, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.396 with standard deviation 0.073. And the mean value of best solutions found was 0.006 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4398514007766017, 0.45447852070406636, 0.2937746483150463], "final_y": [9.961711019940501e-05, 2.6633767897699526e-05, 0.019292059959566933]}, "mutation_prompt": null}
{"id": "2c085c1a-7825-45b2-9f74-baf9cc6241a0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                f_rand = np.random.uniform(0.4, 1.0)  # Random scaling factor for mutation\n                mutant = np.clip(x1 + f_rand * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Integrate a random scaling factor for mutation to enhance exploration capability.", "configspace": "", "generation": 86, "fitness": 0.41320948342793967, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.413 with standard deviation 0.035. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.46297945018214814, 0.38974851742262684, 0.3869004826790441], "final_y": [2.1907293364483317e-06, 0.00023548587077441236, 4.617076784364125e-05]}, "mutation_prompt": null}
{"id": "41d1b7d0-fe4e-4bf6-8020-23bf14a91f7b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.3, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)  # Adjusted mutation range\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Refine exploration and exploitation by dynamically adjusting mutation factor based on population diversity.", "configspace": "", "generation": 87, "fitness": 0.4994142064087079, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.499 with standard deviation 0.041. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.5536864725566182, 0.4882840404569878, 0.45627210621251757], "final_y": [2.8818851853728127e-07, 1.4844227549234405e-06, 8.675101672490902e-06]}, "mutation_prompt": null}
{"id": "04c74af4-c5f9-4725-8015-e95f137da1b7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                self.f = 0.5 + 0.3 * (fitness[i] / max(fitness))  # Adaptive mutation factor\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation based on individual fitness to balance exploration and exploitation.", "configspace": "", "generation": 88, "fitness": 0.4763945866869421, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.476 with standard deviation 0.048. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.431380404125153, 0.45493216221055666, 0.5428711937251167], "final_y": [4.315637912017639e-05, 1.874482859896177e-05, 4.2803861366706036e-08]}, "mutation_prompt": null}
{"id": "0929e375-9448-4d6e-bc2f-211849ebd58e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity * np.min(fitness) < 0.05 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration further by tweaking mutation and crossover strategies based on fitness improvements.", "configspace": "", "generation": 89, "fitness": 0.4746021052814727, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.475 with standard deviation 0.067. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.3838584208848963, 0.5417311802592386, 0.4982167147002833], "final_y": [0.0006654719307638128, 7.754534662157883e-08, 2.955499311838236e-07]}, "mutation_prompt": null}
{"id": "37d3a554-690d-4bf6-8096-7f5cb4baa556", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                random_scaling = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x1 + random_scaling * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a random scaling factor to enhance mutation diversity in the Adaptive Differential Evolution algorithm.", "configspace": "", "generation": 90, "fitness": 0.39472773190908805, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.395 with standard deviation 0.025. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4300610824364106, 0.371954279156674, 0.38216783413417965], "final_y": [2.121813571343172e-05, 9.399024017394855e-05, 2.684252562849992e-05]}, "mutation_prompt": null}
{"id": "5795090d-2aeb-4ec5-84ae-1f8e879cce83", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n            # Modify mutation factor based on fitness variance\n            fitness_variance = np.var(fitness)\n            self.f = min(0.9, max(0.4, 0.8 * (1 - fitness_variance)))\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by incorporating adaptive mutation factor based on fitness variance.", "configspace": "", "generation": 91, "fitness": 0.46469072033013753, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.465 with standard deviation 0.059. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.44986283273827044, 0.5428667394041824, 0.4013425888479596], "final_y": [5.9386994242883455e-05, 2.980593110776377e-08, 0.00026786831409094384]}, "mutation_prompt": null}
{"id": "e72dd9ad-bde7-4373-8738-02569dee67f5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.f = self.f * (0.9 + 0.1 * np.random.rand())  # Adaptive scaling of differential weight\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive scaling of the differential weight based on function value improvements.", "configspace": "", "generation": 92, "fitness": 0.43270675667312375, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.433 with standard deviation 0.063. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.49474317543763857, 0.45676240444872174, 0.34661469013301094], "final_y": [1.886153895981248e-07, 6.590788120345049e-06, 0.0007714732510799764]}, "mutation_prompt": null}
{"id": "950e5eb1-cf33-4a18-8ec6-c0b63f46fcb5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover with new adaptive strategy\n                if np.std(fitness) > 0.05:  \n                    self.f = np.random.uniform(0.5, 0.9)\n                else:\n                    self.f = np.random.uniform(0.4, 0.6)\n\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  \n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Refine exploration and exploitation balance by adding adaptive mutation strategies and elitism preservation in Adaptive Differential Evolution.", "configspace": "", "generation": 93, "fitness": 0.3709342227689105, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.371 with standard deviation 0.045. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.41558088528143633, 0.31009324610925604, 0.3871285369160393], "final_y": [3.137998772163916e-05, 0.0022038507089363504, 0.00013176435678410417]}, "mutation_prompt": null}
{"id": "d015a5a6-fc9b-4fe5-a592-307a04db52fc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            successes = 0  # Track successful trials\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1  # Increment on success\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n            # Adjust scaling factor based on success rate\n            success_rate = successes / self.population_size\n            self.f = 0.5 + 0.5 * success_rate\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Implement adaptive scaling factor based on success rate to improve convergence.", "configspace": "", "generation": 94, "fitness": 0.34816633053209695, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.348 with standard deviation 0.048. And the mean value of best solutions found was 0.005 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.3543049863107429, 0.28600266827248144, 0.4041913370130664], "final_y": [0.0004114645761357865, 0.013210245517009743, 2.8078060734242e-05]}, "mutation_prompt": null}
{"id": "39389ca3-9cd9-408e-a2cd-2d8b811f179b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n                adaptive_f = 0.6 + 0.1 * diversity  # Modify scaling factor based on diversity\n                mutant = np.clip(x1 + adaptive_f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Increase convergence speed by improving trial vector generation with diversity-based scaling factor adjustment.", "configspace": "", "generation": 95, "fitness": 0.2619663810607669, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.262 with standard deviation 0.030. And the mean value of best solutions found was 0.013 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.3021723337660579, 0.2538709436806037, 0.2298558657356391], "final_y": [0.003495389979221239, 0.0046868344492010825, 0.02932919978421987]}, "mutation_prompt": null}
{"id": "2f253c51-92de-4280-939c-89c9a42bda43", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(self.population_size * (1 - 0.1 * (budget_used / self.budget))))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improve exploration by dynamically adapting population size based on convergence speed.", "configspace": "", "generation": 96, "fitness": 0.2832788327970626, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.283 with standard deviation 0.011. And the mean value of best solutions found was 0.039 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.2795679402772814, 0.27232314515122735, 0.29794541296267907], "final_y": [0.044575011896866905, 0.050129766051806315, 0.023592889316662594]}, "mutation_prompt": null}
{"id": "383d592e-763c-4580-8594-837bc3978907", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        best_solution = None\n        best_fitness = np.inf\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 1.0) if diversity > 0.1 else np.random.uniform(0.5, 0.7)  # Extended mutation range\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n            if budget_used / self.budget > 0.5 and best_solution is not None:\n                population[-1] = best_solution  # Inject best solution so far\n\n        # Return the best solution found\n        return best_solution if best_solution is not None else population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive mutation scaling and elitist restart for enhanced exploration and exploitation balance.", "configspace": "", "generation": 97, "fitness": 0.3513346185567349, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.351 with standard deviation 0.059. And the mean value of best solutions found was 0.003 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.3278578125912016, 0.29384279935732605, 0.43230324372167717], "final_y": [0.0010055274876141598, 0.0081629372817564, 9.365031701351452e-05]}, "mutation_prompt": null}
{"id": "61b06a76-3a34-42d3-a0fa-15e5d5f351c1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.85, 1.0) if diversity < 0.1 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n            # Increase mutation factor adaptively\n            self.f += 0.1 * (budget_used / self.budget)\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Increase mutation factor adaptively to boost exploration based on budget usage.", "configspace": "", "generation": 98, "fitness": 0.39849092567233324, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.398 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.40523757282870754, 0.4024597126224563, 0.3877754915658359], "final_y": [0.00010788569423073886, 0.0002283486645404513, 9.81901245800613e-05]}, "mutation_prompt": null}
{"id": "1eaeb8c3-92da-4e77-ad2f-c2fd21d0da56", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.f = 0.5  # Initial differential weight\n        self.cr = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        lower_bound = func.bounds.lb\n        upper_bound = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        # Main optimization loop\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                # Randomly select three individuals different from i\n                indices = np.random.choice([ind for ind in range(self.population_size) if ind != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Mutation and crossover\n                mutant = np.clip(x1 + self.f * (x2 - x3), lower_bound, upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Break if budget is exhausted\n                if budget_used >= self.budget:\n                    break\n\n            # Update population\n            population = new_population\n\n            # Dynamically adjust control parameters\n            diversity = np.mean(np.std(population, axis=0))  # Measure population diversity\n            self.f = np.random.uniform(0.4, 0.9) if diversity > 0.1 else np.random.uniform(0.5, 0.7)\n            self.cr = np.random.uniform(0.9, 1.0) if diversity < 0.05 else np.random.uniform(0.75, 0.85)  # Adjusted crossover range\n\n            # Dynamically adjust population size\n            self.population_size = max(4, int(10 * self.dim * (1 - budget_used / self.budget)))\n\n            # Elitism: Retain the best solution found so far\n            best_indices = np.argsort(fitness)[:2]\n            population[:2] = population[best_indices]\n            fitness[:2] = fitness[best_indices]\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improve balance between exploration and exploitation by dynamically adjusting crossover probability based on population diversity.", "configspace": "", "generation": 99, "fitness": 0.4506780832391341, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.451 with standard deviation 0.033. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4b1c439e-8c38-40a6-9f74-86197452bdf7", "metadata": {"aucs": [0.4723914305192871, 0.4033846421660102, 0.47625817703210493], "final_y": [1.2693577172097342e-06, 5.9956860104353936e-05, 8.256838788367493e-07]}, "mutation_prompt": null}
