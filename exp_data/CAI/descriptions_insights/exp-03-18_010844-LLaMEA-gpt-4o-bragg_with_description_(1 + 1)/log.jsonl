{"id": "ae876def-2177-4e6f-b114-facc278f6217", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        mutant = np.clip(a + self.F * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "This algorithm combines differential evolution with adaptive mutation strategies to efficiently explore and exploit the search space for optimal solutions in multilayer photonic structure design.", "configspace": "", "generation": 0, "fitness": 0.7203727067963399, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.720 with standard deviation 0.022. And the mean value of best solutions found was 0.214 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6893407048906435, 0.7314098776398212, 0.7403675378585548], "final_y": [0.23293074005687076, 0.21202536100628055, 0.19815749627634027]}, "mutation_prompt": null}
{"id": "78589e2e-e118-47e5-8fc9-13894ec4fb85", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)  # Dynamic adjustment of F\n        mutant = np.clip(a + current_F * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "This refined algorithm incorporates a dynamic adjustment of the mutation factor (F) based on evaluation progress to enhance exploitation as the search approaches the budget limit.", "configspace": "", "generation": 1, "fitness": 0.7993224604687345, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.799 with standard deviation 0.023. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "ae876def-2177-4e6f-b114-facc278f6217", "metadata": {"aucs": [0.810171952885365, 0.8208516463786779, 0.7669437821421604], "final_y": [0.1697351648806943, 0.17120660661110898, 0.1684592693052298]}, "mutation_prompt": null}
{"id": "66f16237-d26a-4c1d-9eb9-1ff484f75082", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * (1 - (self.evaluate_count / self.budget))  # Adjusted dynamic adjustment of F\n        mutant = np.clip(a + current_F * np.sign(b - c) * (b - c), bounds.lb, bounds.ub)  # Sign-based mutation\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Adjusted adaptive mutation factor scaling and mutation strategy to enhance convergence.", "configspace": "", "generation": 2, "fitness": 0.6561518514880668, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.656 with standard deviation 0.010. And the mean value of best solutions found was 0.247 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "78589e2e-e118-47e5-8fc9-13894ec4fb85", "metadata": {"aucs": [0.6657911577564921, 0.6431439828446645, 0.6595204138630439], "final_y": [0.2530274501176647, 0.256456418917154, 0.23082383206937562]}, "mutation_prompt": null}
{"id": "cdc23aa5-c462-4cc0-9bb3-f5f5c4ebed44", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)  # Dynamic adjustment of F\n        mutant = np.clip(a + current_F * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * (self.evaluate_count / self.budget)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introducing adaptive crossover probability (CR) to enhance exploration and exploitation balance as the search progresses.", "configspace": "", "generation": 3, "fitness": 0.8029221086125249, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.803 with standard deviation 0.036. And the mean value of best solutions found was 0.176 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "78589e2e-e118-47e5-8fc9-13894ec4fb85", "metadata": {"aucs": [0.7860304220008545, 0.7698725543565381, 0.8528633494801819], "final_y": [0.18042050375346386, 0.1745700693634452, 0.17410693339353223]}, "mutation_prompt": null}
{"id": "534b3fdf-8f52-45f1-b88b-ca9d0adf78db", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        dynamic_F = self.F + 0.5 * (1 - self.evaluate_count / self.budget)  # Adaptive mutation factor\n        mutant = np.clip(a + dynamic_F * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * (self.evaluate_count / self.budget)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation factor to improve exploration as the budget decreases.", "configspace": "", "generation": 4, "fitness": 0.7065202806646297, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.707 with standard deviation 0.018. And the mean value of best solutions found was 0.252 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "cdc23aa5-c462-4cc0-9bb3-f5f5c4ebed44", "metadata": {"aucs": [0.7055060922594507, 0.6855308081807623, 0.7285239415536761], "final_y": [0.26597190360772904, 0.25313163136885264, 0.2380618085087287]}, "mutation_prompt": null}
{"id": "c3c2d7ff-d527-4d6a-93ec-31698c7f977d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / (2 * self.budget))  # Dynamically adjusted F\n        mutant = np.clip(a + current_F * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * (self.evaluate_count / self.budget)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with dynamically adjusted mutation factor to enhance convergence and solution quality.", "configspace": "", "generation": 5, "fitness": 0.8007623160784122, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.801 with standard deviation 0.003. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cdc23aa5-c462-4cc0-9bb3-f5f5c4ebed44", "metadata": {"aucs": [0.8040583631483655, 0.7960540022326088, 0.8021745828542624], "final_y": [0.17153143297083429, 0.17137911542139628, 0.17109485158250204]}, "mutation_prompt": null}
{"id": "6246e68f-0c7e-475f-8f24-447ebb7971c8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget) + 0.1  # Dynamic adjustment of F with scaling factor\n        mutant = np.clip(a + current_F * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * (self.evaluate_count / self.budget)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic scaling factor for the mutation operation to further improve adaptability and exploration.", "configspace": "", "generation": 6, "fitness": 0.7875221653967334, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.788 with standard deviation 0.015. And the mean value of best solutions found was 0.177 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "cdc23aa5-c462-4cc0-9bb3-f5f5c4ebed44", "metadata": {"aucs": [0.8045193060360716, 0.7673898560367438, 0.7906573341173847], "final_y": [0.17797226646567121, 0.18283571950667488, 0.17154999730634424]}, "mutation_prompt": null}
{"id": "b7dae182-08b3-426b-9cd5-a0ccbce68feb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        perturbation = np.random.uniform(0.9, 1.1)  # slight perturbation for F\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget) * perturbation\n        mutant = np.clip(a + current_F * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * (self.evaluate_count / self.budget)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance mutation strategy by introducing a slight perturbation to mutation factor F for diversity.", "configspace": "", "generation": 7, "fitness": 0.7669969166533844, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.767 with standard deviation 0.031. And the mean value of best solutions found was 0.181 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "cdc23aa5-c462-4cc0-9bb3-f5f5c4ebed44", "metadata": {"aucs": [0.7958351912680698, 0.7244032357457263, 0.7807523229463569], "final_y": [0.17680292456943836, 0.1854829911687873, 0.18003232963172455]}, "mutation_prompt": null}
{"id": "23724c20-2f06-43d7-84fa-5b3e64a92f76", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget) + np.random.rand() * 0.1  # added dynamic scaling\n        mutant = np.clip(a + current_F * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * (self.evaluate_count / self.budget)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            if self.budget - self.evaluate_count < self.population_size:  # adaptive population size adjustment\n                self.population_size = self.budget - self.evaluate_count\n            new_population = np.zeros_like(self.population[:self.population_size])\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance the exploration-exploitation balance by introducing dynamic mutation factor scaling and adaptive population size adjustment.", "configspace": "", "generation": 8, "fitness": 0.7747038404285199, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.775 with standard deviation 0.017. And the mean value of best solutions found was 0.179 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "cdc23aa5-c462-4cc0-9bb3-f5f5c4ebed44", "metadata": {"aucs": [0.7866428201984551, 0.7509210941143851, 0.7865476069727197], "final_y": [0.18211141711722822, 0.18067306441592923, 0.17534708498413132]}, "mutation_prompt": null}
{"id": "9aaf5463-7628-4f2f-9c6c-a2b9016f3d91", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds, fitness):\n        a, b, c = self.select_parents()\n        # Dynamic adjustment of F based on fitness\n        avg_fitness = np.mean(fitness)\n        current_F = self.F * np.exp(-abs(fitness[target_idx] - avg_fitness) / avg_fitness)\n        mutant = np.clip(a + current_F * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * (self.evaluate_count / self.budget)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds, fitness)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Incorporating a fitness-based adaptive mutation factor to enhance diversity and maintain convergence speed.", "configspace": "", "generation": 9, "fitness": 0.7759720215431983, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.776 with standard deviation 0.040. And the mean value of best solutions found was 0.201 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "cdc23aa5-c462-4cc0-9bb3-f5f5c4ebed44", "metadata": {"aucs": [0.7871714687638571, 0.7221175819412841, 0.8186270139244538], "final_y": [0.2016656566259889, 0.21852883362415276, 0.18211697759549061]}, "mutation_prompt": null}
{"id": "ca59ceff-d739-48c7-9acd-03a7ba5d6ceb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)  # Dynamic adjustment of F\n        mutant = np.clip(a + current_F * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * (self.evaluate_count / self.budget)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a dynamic population size to enhance exploration and convergence as the optimization progresses.", "configspace": "", "generation": 10, "fitness": 0.8155675825614302, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.816 with standard deviation 0.011. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "cdc23aa5-c462-4cc0-9bb3-f5f5c4ebed44", "metadata": {"aucs": [0.8014410780018002, 0.8163342251734517, 0.8289274445090389], "final_y": [0.16548687525752193, 0.16627605819079172, 0.16617743622372472]}, "mutation_prompt": null}
{"id": "f0df4672-2846-455b-ab58-8ed378ac6614", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget) * np.random.laplace(1.0, 0.1)  # Adaptive mutation factor\n        mutant = np.clip(a + current_F * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * (self.evaluate_count / self.budget)\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration and exploitation by incorporating Lévy flights and adaptive mutation factor scaling.", "configspace": "", "generation": 11, "fitness": 0.8096907735736326, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.810 with standard deviation 0.029. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "ca59ceff-d739-48c7-9acd-03a7ba5d6ceb", "metadata": {"aucs": [0.7703106545163948, 0.838477270834076, 0.8202843953704271], "final_y": [0.16752934697567168, 0.16579463110843307, 0.16882826314031618]}, "mutation_prompt": null}
{"id": "a695a4fd-fda2-4eb1-8298-c78713e64d2b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        dynamic_F = self.F + 0.1 * ((self.budget - self.evaluate_count) / self.budget)  # Dynamic adjustment\n        mutant = np.clip(a + dynamic_F * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * (self.evaluate_count / self.budget)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic adjustment for the mutation factor F to enhance balance between exploration and exploitation based on the budget.", "configspace": "", "generation": 12, "fitness": 0.7699359314455304, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.770 with standard deviation 0.010. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "ca59ceff-d739-48c7-9acd-03a7ba5d6ceb", "metadata": {"aucs": [0.7637553073721028, 0.7846362077827941, 0.7614162791816943], "final_y": [0.1710346967245645, 0.16739003366179583, 0.16895975079576575]}, "mutation_prompt": null}
{"id": "f4896457-9084-44e6-bd04-69a22cf9f611", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 4, replace=False)  # Increased to 4 for better diversity\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c, d = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)  # Dynamic adjustment of F\n        mutant = np.clip(a + current_F * (b - c + d), bounds.lb, bounds.ub)  # Enhanced mutation strategy\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * (self.evaluate_count / self.budget)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce self-adaptive parameter control and enhanced mutation strategy to improve convergence and solution quality.", "configspace": "", "generation": 13, "fitness": 0.751536622820853, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.752 with standard deviation 0.017. And the mean value of best solutions found was 0.222 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "ca59ceff-d739-48c7-9acd-03a7ba5d6ceb", "metadata": {"aucs": [0.7633664386126878, 0.7279079025296157, 0.7633355273202556], "final_y": [0.226681299141832, 0.23119493387172163, 0.20800082484758076]}, "mutation_prompt": null}
{"id": "5cd1fd25-2634-4b76-92f6-b55e89031533", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)  # Dynamic adjustment of F\n        diversity_factor = np.std(self.population) / np.mean(self.population)  # Measure diversity\n        current_F *= (1 + diversity_factor)  # Adjust F based on diversity\n        mutant = np.clip(a + current_F * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        diversity_factor = np.std(self.population) / np.mean(self.population)  # Measure diversity\n        current_CR = self.CR * (self.evaluate_count / self.budget) * (1 - diversity_factor)  # Adaptive crossover probability with diversity\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, individual, bounds):\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(individual + perturbation, bounds.lb, bounds.ub)\n        return candidate\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n                if np.random.rand() < 0.1:  # 10% chance to perform local search\n                    local_candidate = self.local_search(new_population[i], bounds)\n                    local_fitness = func(local_candidate)\n                    self.evaluate_count += 1\n                    if local_fitness < fitness[i]:\n                        new_population[i] = local_candidate\n                        fitness[i] = local_fitness\n                        if local_fitness < best_fitness:\n                            best_fitness = local_fitness\n                            best_solution = local_candidate\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploitation by introducing a local search step and adaptively adjust crossover and mutation rates based on population diversity.", "configspace": "", "generation": 14, "fitness": 0.7374776000809931, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.737 with standard deviation 0.028. And the mean value of best solutions found was 0.199 (0. is the best) with standard deviation 0.026.", "error": "", "parent_id": "ca59ceff-d739-48c7-9acd-03a7ba5d6ceb", "metadata": {"aucs": [0.698774779189735, 0.7497645362743001, 0.7638934847789439], "final_y": [0.23619328864938682, 0.18522123736377616, 0.17662397554932452]}, "mutation_prompt": null}
{"id": "1a5a76c5-6adf-49f0-9b75-d327546a054a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)  # Dynamic adjustment of F\n        mutant = np.clip(a + (0.5 * current_F) * (b - c), bounds.lb, bounds.ub)  # Reduced final mutation factor\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * (self.evaluate_count / self.budget)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a decaying mutation factor to balance exploration and exploitation over time.", "configspace": "", "generation": 15, "fitness": 0.8372904585515766, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.837 with standard deviation 0.007. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "ca59ceff-d739-48c7-9acd-03a7ba5d6ceb", "metadata": {"aucs": [0.828093208881874, 0.8459573291137545, 0.8378208376591013], "final_y": [0.16733709771553218, 0.16792592178944477, 0.16585435352502353]}, "mutation_prompt": null}
{"id": "100f9955-46eb-407b-a3e0-2d71c651d0b4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)  # Dynamic adjustment of F\n        mutant = np.clip(a + current_F * (b - c), bounds.lb, bounds.ub)  # Removed 0.5 factor for stronger mutations\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * (self.evaluate_count / self.budget)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def migrate(self, bounds):\n        \"\"\"Introduce new individuals to maintain diversity.\"\"\"\n        migrants = np.random.uniform(bounds.lb, bounds.ub, (self.dim, self.dim))\n        self.population[-self.dim:] = migrants\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count % (self.budget // 5) == 0:  # Migrate every 20% of budget usage\n                self.migrate(bounds)\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic population size and a migration mechanism to enhance diversity and convergence.", "configspace": "", "generation": 16, "fitness": 0.8155675825614302, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.816 with standard deviation 0.011. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1a5a76c5-6adf-49f0-9b75-d327546a054a", "metadata": {"aucs": [0.8014410780018002, 0.8163342251734517, 0.8289274445090389], "final_y": [0.16548687525752193, 0.16627605819079172, 0.16617743622372472]}, "mutation_prompt": null}
{"id": "32261232-8a6b-4eb8-8721-2eb03ede6cd8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)  # Dynamic adjustment of F\n        fitness_scaled_F = current_F * np.exp(-0.1 * self.evaluate_count / self.budget)  # Fitness-scaled F\n        mutant = np.clip(a + fitness_scaled_F * (b - c), bounds.lb, bounds.ub)  # Fitness-scaled mutation\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * (self.evaluate_count / self.budget)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adaptive_local_search(self, trial, bounds, func):\n        step_size = 0.05 * (self.budget - self.evaluate_count) / self.budget\n        perturbed = trial + np.random.uniform(-step_size, step_size, self.dim)\n        perturbed = np.clip(perturbed, bounds.lb, bounds.ub)\n        if func(perturbed) < func(trial):\n            return perturbed\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                trial = self.adaptive_local_search(trial, bounds, func)  # New adaptive local search step\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution using Fitness-Scaled Mutation and Adaptive Local Search for enhanced convergence.", "configspace": "", "generation": 17, "fitness": 0.6678694234569398, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.668 with standard deviation 0.012. And the mean value of best solutions found was 0.267 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "1a5a76c5-6adf-49f0-9b75-d327546a054a", "metadata": {"aucs": [0.6523842936400188, 0.6825136157849059, 0.6687103609458946], "final_y": [0.2730149112216782, 0.27481688873859444, 0.2526216161110322]}, "mutation_prompt": null}
{"id": "8cb65e3b-73cf-4dee-8854-bb643f7c2aaf", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget) * (1.1 - 0.1 * (self.evaluate_count / self.budget))  # Dynamic adjustment of F\n        mutant = np.clip(a + (0.5 * current_F) * (b - c), bounds.lb, bounds.ub)  # Reduced final mutation factor\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * (self.evaluate_count / self.budget) * (1.1 - 0.1 * (self.evaluate_count / self.budget))  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic mutation and crossover strategies to enhance convergence by adapting based on fitness improvement.", "configspace": "", "generation": 18, "fitness": 0.8271016232690949, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.827 with standard deviation 0.005. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "1a5a76c5-6adf-49f0-9b75-d327546a054a", "metadata": {"aucs": [0.8314359895243048, 0.8291010210284104, 0.8207678592545694], "final_y": [0.16763415549982774, 0.16885016087700833, 0.16732007918214964]}, "mutation_prompt": null}
{"id": "fe992391-4063-4601-b12d-a5a152a88bb0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)  # Dynamic adjustment of F\n        mutant = np.clip(a + (0.5 * current_F) * (b - c), bounds.lb, bounds.ub)  # Reduced final mutation factor\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * (self.evaluate_count / self.budget)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def dynamic_diversity_management(self, trial, bounds):\n        if np.random.rand() < (self.evaluate_count / self.budget):\n            trial = np.random.uniform(bounds.lb, bounds.ub, self.dim)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial = self.dynamic_diversity_management(trial, bounds)  # Ensure diversity\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic diversity preservation mechanism to enhance exploration and prevent premature convergence.", "configspace": "", "generation": 19, "fitness": 0.8011545005569616, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.801 with standard deviation 0.045. And the mean value of best solutions found was 0.184 (0. is the best) with standard deviation 0.012.", "error": "", "parent_id": "1a5a76c5-6adf-49f0-9b75-d327546a054a", "metadata": {"aucs": [0.7371648593278818, 0.8374998809104788, 0.8287987614325243], "final_y": [0.2008433614421803, 0.17198242445206635, 0.17903479846730985]}, "mutation_prompt": null}
{"id": "99987260-8d7f-448d-b6b7-935b700e722c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget) * (1 - best_fitness / np.max(fitness))  # Added term for adaptation\n        mutant = np.clip(a + (0.5 * current_F) * (b - c), bounds.lb, bounds.ub)  # Reduced final mutation factor\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * (self.evaluate_count / self.budget)  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce an adaptive mutation factor based on the best solution found so far to enhance convergence speed.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'best_fitness' is not defined\").", "error": "NameError(\"name 'best_fitness' is not defined\")", "parent_id": "1a5a76c5-6adf-49f0-9b75-d327546a054a", "metadata": {}, "mutation_prompt": null}
{"id": "5e8ed67f-90a2-4287-8df1-d17718cbbc25", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget) + np.random.normal(0, 0.1)  # Add noise\n        mutant = np.clip(a + current_F * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * (self.evaluate_count / self.budget) + np.random.normal(0, 0.05)  # Adaptive with noise\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, bounds):\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        new_candidate = np.clip(candidate + perturbation, bounds.lb, bounds.ub)\n        return new_candidate\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n                local_candidate = self.local_search(target, bounds)\n                local_fitness = func(local_candidate)\n                self.evaluate_count += 1\n\n                if local_fitness < best_fitness:\n                    best_fitness = local_fitness\n                    best_solution = local_candidate\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce self-adaptive parameters and local search strategies to enhance convergence speed and solution quality.", "configspace": "", "generation": 21, "fitness": 0.7747357587828393, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.775 with standard deviation 0.028. And the mean value of best solutions found was 0.176 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "1a5a76c5-6adf-49f0-9b75-d327546a054a", "metadata": {"aucs": [0.73598475404386, 0.7989739517698802, 0.7892485705347776], "final_y": [0.18170543661999972, 0.17565654076051607, 0.1721104101016323]}, "mutation_prompt": null}
{"id": "a693e62c-c01b-43ba-a21f-f578b6c439a9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)  # Dynamic adjustment of F\n        mutant = np.clip(a + (0.5 * current_F) * (b - c), bounds.lb, bounds.ub)  # Reduced final mutation factor\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)  # Dynamic adjustment of CR\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by dynamically adjusting both mutation factor and crossover probability based on remaining budget.", "configspace": "", "generation": 22, "fitness": 0.8780836953455676, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.878 with standard deviation 0.006. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1a5a76c5-6adf-49f0-9b75-d327546a054a", "metadata": {"aucs": [0.8691424102724645, 0.8839410137199067, 0.8811676620443317], "final_y": [0.16551111787858086, 0.16507545957194936, 0.16535854727161092]}, "mutation_prompt": null}
{"id": "e2426f12-6920-4289-9c1e-bd8531cd6650", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)\n        # Adjusted contribution of mutation factor in mutant vector calculation\n        mutant = np.clip(a + current_F * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Improve mutation by dynamically adjusting the contribution of the mutation factor in the mutant vector calculation.", "configspace": "", "generation": 23, "fitness": 0.8428412871940963, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.843 with standard deviation 0.009. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a693e62c-c01b-43ba-a21f-f578b6c439a9", "metadata": {"aucs": [0.8337378233322996, 0.8403554982033813, 0.8544305400466081], "final_y": [0.1669075028230641, 0.16539862561868723, 0.1655585494300712]}, "mutation_prompt": null}
{"id": "be4da629-7d0f-476f-8acd-5d628a4625d1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)**2  # Non-linear decay for F\n        mutant = np.clip(a + (0.5 * current_F) * (b - c), bounds.lb, bounds.ub)  # Reduced final mutation factor\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)  # Dynamic adjustment of CR\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a non-linear decay for mutation factor F to fine-tune the exploration-exploitation balance.", "configspace": "", "generation": 24, "fitness": 0.8782005540907676, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.878 with standard deviation 0.004. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a693e62c-c01b-43ba-a21f-f578b6c439a9", "metadata": {"aucs": [0.8839985952220916, 0.8737734076012118, 0.8768296594489994], "final_y": [0.16595313460978423, 0.16567415710661348, 0.1677961694755069]}, "mutation_prompt": null}
{"id": "bb86ec02-cdf9-45c1-abb9-e16d60d3c34a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        fitness_improvement = (1 - (self.evaluate_count / self.budget))  # self-adaptive factor\n        current_F = self.F + 0.3 * fitness_improvement  # Change here to introduce self-adaptive mutation factor\n        mutant = np.clip(a + (0.5 * current_F) * (b - c), bounds.lb, bounds.ub)  # Reduced final mutation factor\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)  # Dynamic adjustment of CR\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce self-adaptive mutation factor F by incorporating fitness improvement rate to enhance exploration-exploitation balance.", "configspace": "", "generation": 25, "fitness": 0.8385432006930301, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.839 with standard deviation 0.016. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "be4da629-7d0f-476f-8acd-5d628a4625d1", "metadata": {"aucs": [0.8235084928256688, 0.8607405945397761, 0.8313805147136452], "final_y": [0.1660633733659499, 0.16560346997779263, 0.16838730595435347]}, "mutation_prompt": null}
{"id": "a036ab40-9456-415e-83ba-a3c7db90fd57", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget + 0.5 * (1 - np.min([1.0, np.std(self.evaluate_population(func))])))  # Dynamic adjustment of F\n        mutant = np.clip(a + (0.5 * current_F) * (b - c), bounds.lb, bounds.ub)  # Reduced final mutation factor\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)  # Dynamic adjustment of CR\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic adjustment of F based on fitness improvements to better balance exploration and exploitation.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "be4da629-7d0f-476f-8acd-5d628a4625d1", "metadata": {}, "mutation_prompt": null}
{"id": "428d91b0-32eb-450e-9886-c84ca4450ef6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F_init = 0.5  # Initial mutation factor\n        self.CR_init = 0.9  # Initial crossover probability\n        self.population = None\n        self.evaluate_count = 0\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        # Initialize self-adaptive parameters for each individual\n        self.F = np.full(self.population_size, self.F_init)\n        self.CR = np.full(self.population_size, self.CR_init)\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F[target_idx] * ((self.budget - self.evaluate_count) / self.budget)**2  # Non-linear decay for F\n        mutant = np.clip(a + (0.5 * current_F) * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant, target_idx):\n        current_CR = self.CR[target_idx] * ((self.budget - self.evaluate_count) / self.budget)  # Dynamic adjustment of CR\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def update_parameters(self, idx, success):\n        if success:\n            self.F[idx] = np.clip(self.F[idx] + 0.05, 0, 1)\n            self.CR[idx] = np.clip(self.CR[idx] + 0.1, 0, 1)\n        else:\n            self.F[idx] = np.clip(self.F[idx] * 0.95, 0, 1)\n            self.CR[idx] = np.clip(self.CR[idx] * 0.9, 0, 1)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant, i)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                success = trial_fitness < fitness[i]\n                if success:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                self.update_parameters(i, success)\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n\n            self.population = new_population\n        return self.best_solution", "name": "AdaptiveDifferentialEvolution", "description": "AdaptiveDifferentialEvolution with Self-adaptive Parameters and Elite Retention introduces self-adaptive rates for mutation and crossover along with elite retention to enhance convergence.", "configspace": "", "generation": 27, "fitness": 0.8601182308325525, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.860 with standard deviation 0.018. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "be4da629-7d0f-476f-8acd-5d628a4625d1", "metadata": {"aucs": [0.8366899578793, 0.8818591660211235, 0.8618055685972335], "final_y": [0.1735490027178166, 0.16904912277495665, 0.16927965378835197]}, "mutation_prompt": null}
{"id": "0b4de702-1298-4b30-8515-391f09f4b1f4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.learning_rate = 0.1  # New adaptive learning rate\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * np.exp(-self.learning_rate * (self.evaluate_count / self.budget))  # Adaptive rate for F\n        mutant = np.clip(a + (0.5 * current_F) * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive learning rate for mutation factor to enhance convergence speed while maintaining diversity.", "configspace": "", "generation": 28, "fitness": 0.8747611469907263, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.875 with standard deviation 0.016. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "be4da629-7d0f-476f-8acd-5d628a4625d1", "metadata": {"aucs": [0.8629862307232439, 0.8644857708777659, 0.8968114393711695], "final_y": [0.16606100513812128, 0.16506522728989648, 0.1654337119343492]}, "mutation_prompt": null}
{"id": "0365e333-aeaf-4189-9101-c0d646cbfef4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)**2  # Non-linear decay for F\n        mutant = np.clip(a + (0.5 * current_F) * (b - c), bounds.lb, bounds.ub)  # Reduced final mutation factor\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**2  # Adaptive CR decay\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive crossover probability decay to further refine the exploration-exploitation balance.", "configspace": "", "generation": 29, "fitness": 0.8831621987817245, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.883 with standard deviation 0.013. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "be4da629-7d0f-476f-8acd-5d628a4625d1", "metadata": {"aucs": [0.882983638686713, 0.8669988163733917, 0.8995041412850688], "final_y": [0.16867865833037032, 0.171413826400852, 0.16568708019487732]}, "mutation_prompt": null}
{"id": "0eda77ea-e739-4e6a-9e5d-4f99965a561f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        diversity_factor = np.std(self.population, axis=0).mean() / (bounds.ub - bounds.lb).mean()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)**2 * (1 + diversity_factor)  # Adjusted mutation factor\n        mutant = np.clip(a + (0.5 * current_F) * (b - c), bounds.lb, bounds.ub)  # Reduced final mutation factor\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**2  # Adaptive CR decay\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic mutation factor based on the current diversity of the population to enhance convergence rates.", "configspace": "", "generation": 30, "fitness": 0.8796561496198927, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.880 with standard deviation 0.013. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "0365e333-aeaf-4189-9101-c0d646cbfef4", "metadata": {"aucs": [0.8619736600170878, 0.8900873223333737, 0.8869074665092165], "final_y": [0.17076613223743287, 0.16619785701422518, 0.16560902028529134]}, "mutation_prompt": null}
{"id": "31e16519-016c-47fc-b744-9d5d3b82c853", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)**2  # Non-linear decay for F\n        # Change: More sophisticated mutation strategy\n        mutant = np.clip((0.5 * a + 0.3 * b + 0.2 * c) + current_F * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**2  # Adaptive CR decay\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a more sophisticated mutation strategy using a weighted average of selected individuals to enhance convergence.", "configspace": "", "generation": 31, "fitness": 0.9243263868468711, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.924 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0365e333-aeaf-4189-9101-c0d646cbfef4", "metadata": {"aucs": [0.9211949566357688, 0.9204320178580171, 0.9313521860468275], "final_y": [0.16494361045918382, 0.16539603784262547, 0.16488468705881187]}, "mutation_prompt": null}
{"id": "769568d4-41d3-4079-a6d4-c396eeeaafe6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)**1.5  # Adjusted non-linear decay for F\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c), bounds.lb, bounds.ub)  # Adjusted mutation weights\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**2  # Adaptive CR decay\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance the adaptation mechanism by modifying mutation and crossover strategies to improve convergence stability.", "configspace": "", "generation": 32, "fitness": 0.9246300258525332, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.925 with standard deviation 0.008. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "31e16519-016c-47fc-b744-9d5d3b82c853", "metadata": {"aucs": [0.9147940408071362, 0.9240836712138233, 0.93501236553664], "final_y": [0.16503403689678908, 0.16496472757083347, 0.16489098461108387]}, "mutation_prompt": null}
{"id": "d56ee3f9-007f-4963-a679-fb62f0acd43a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)**1.7  # Adjusted non-linear decay for F\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c), bounds.lb, bounds.ub)  # Adjusted mutation weights\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**2.1  # Adaptive CR decay\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Refine mutation and crossover strategies with non-linear decay to improve solution quality.", "configspace": "", "generation": 33, "fitness": 0.9241161555146163, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.924 with standard deviation 0.011. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "769568d4-41d3-4079-a6d4-c396eeeaafe6", "metadata": {"aucs": [0.9092906684549794, 0.9299272596292051, 0.9331305384596644], "final_y": [0.16521311651211867, 0.16508886025096947, 0.1651014856172811]}, "mutation_prompt": null}
{"id": "da2a2d6a-88c2-4d4c-8fa6-e99158f28d91", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * np.std(self.population)  # Adjusted mutation factor based on population diversity\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c), bounds.lb, bounds.ub)  # Adjusted mutation weights\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**2  # Adaptive CR decay\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance mutation strategy by introducing a dynamic scaling factor based on population diversity to improve convergence.", "configspace": "", "generation": 34, "fitness": 0.5191151214087494, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.519 with standard deviation 0.012. And the mean value of best solutions found was 0.363 (0. is the best) with standard deviation 0.019.", "error": "", "parent_id": "769568d4-41d3-4079-a6d4-c396eeeaafe6", "metadata": {"aucs": [0.5121899233546855, 0.5361240795272353, 0.5090313613443274], "final_y": [0.3528530371198755, 0.34740940167126855, 0.38923261871412684]}, "mutation_prompt": null}
{"id": "d8242d83-6101-43ad-aab8-8dae6d0982c9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)**1.7  # Adjusted non-linear decay for F\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c), bounds.lb, bounds.ub)  # Adjusted mutation weights\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**2  # Adaptive CR decay\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic scaling for the mutation factor to enhance exploration-exploitation balance.", "configspace": "", "generation": 35, "fitness": 0.9259222971371192, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.012. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "769568d4-41d3-4079-a6d4-c396eeeaafe6", "metadata": {"aucs": [0.9088400381662606, 0.931518432690828, 0.9374084205542688], "final_y": [0.16530289914827934, 0.1649967022991684, 0.16490641630646274]}, "mutation_prompt": null}
{"id": "f1d57a08-c2af-4730-a622-0d4e1231b78f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)**1.9  # Adjusted non-linear decay for F\n        mutant = np.clip(a + current_F * (b - c), bounds.lb, bounds.ub)  # Adjusted mutation strategy\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**2  # Adaptive CR decay\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by refining mutation and crossover strategies using dynamic adjustments.", "configspace": "", "generation": 36, "fitness": 0.8402617108890281, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.840 with standard deviation 0.011. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d8242d83-6101-43ad-aab8-8dae6d0982c9", "metadata": {"aucs": [0.845677957829565, 0.8507841303503156, 0.8243230444872041], "final_y": [0.16844882332713462, 0.16797337421209746, 0.16836181185613353]}, "mutation_prompt": null}
{"id": "2338c48f-9fa3-4c22-b73c-cdc66647ebbc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)**1.7  # Adjusted non-linear decay for F\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c), bounds.lb, bounds.ub)  # Adjusted mutation weights\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**2  # Adaptive CR decay\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 2:  # Introduce elitism in the second half of evaluations\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce early random elitism to enhance solution quality by preserving the best solution in half of the iterations.", "configspace": "", "generation": 37, "fitness": 0.9260915046530037, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.012. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d8242d83-6101-43ad-aab8-8dae6d0982c9", "metadata": {"aucs": [0.909132427989925, 0.9315939977356947, 0.9375480882333911], "final_y": [0.165294513614047, 0.16500141725400186, 0.16488114118969432]}, "mutation_prompt": null}
{"id": "ed1bac19-9a52-45da-9df3-ea3cb5d560fa", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        inertia = np.random.rand()  # Introduce random inertia\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)**1.7  # Adjusted non-linear decay for F\n        mutant = np.clip(inertia * (0.6 * a + 0.2 * b + 0.2 * c) + (1 - inertia) * current_F * (b - c), bounds.lb, bounds.ub)  # Adjusted mutation weights\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**2  # Adaptive CR decay\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 2:  # Introduce elitism in the second half of evaluations\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce random inertia to the mutation step to exploit dynamic exploration, enhancing the search capability and solution quality.", "configspace": "", "generation": 38, "fitness": 0.8619088659907509, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.862 with standard deviation 0.029. And the mean value of best solutions found was 0.184 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "2338c48f-9fa3-4c22-b73c-cdc66647ebbc", "metadata": {"aucs": [0.8930231918011421, 0.8696699186683869, 0.8230334875027236], "final_y": [0.1794217408870985, 0.1898150917438549, 0.18186025336923217]}, "mutation_prompt": null}
{"id": "693c50d6-9260-4e98-b916-7520bdee6c4e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n        self.memory_factor = 0.5  # Introduced memory factor for learning from past\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.fitness_history = np.full(self.population_size, np.inf)  # Store past fitness values\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)**1.7\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**2\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                # Memory-based learning to enhance the decision-making process\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    self.fitness_history[i] = trial_fitness  # Update memory\n                    new_population[i] = trial\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 2:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n\n        # Adjusted learning from best solutions in memory\n        elite_idx = np.argmin(self.fitness_history)\n        best_memory_solution = self.population[elite_idx]\n        return best_memory_solution", "name": "AdaptiveDifferentialEvolution", "description": "Integrate adaptive differential evolution with memory-based learning to enhance exploitation and exploration balance.", "configspace": "", "generation": 39, "fitness": 0.9260915046530037, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.012. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2338c48f-9fa3-4c22-b73c-cdc66647ebbc", "metadata": {"aucs": [0.909132427989925, 0.9315939977356947, 0.9375480882333911], "final_y": [0.165294513614047, 0.16500141725400186, 0.16488114118969432]}, "mutation_prompt": null}
{"id": "8dc49c0b-d2f1-4018-b824-64b3e861905f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)**1.7  # Adjusted non-linear decay for F\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c), bounds.lb, bounds.ub)  # Adjusted mutation weights\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.5  # Adaptive CR decay\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:  # Introduce elitism after the first quarter of evaluations\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic elitism by preserving the current best solution after 25% of evaluations and include adaptive crossover probability decay to enhance exploration and exploitation.", "configspace": "", "generation": 40, "fitness": 0.9348405116236167, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.935 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "2338c48f-9fa3-4c22-b73c-cdc66647ebbc", "metadata": {"aucs": [0.9312065915801239, 0.9307394878077723, 0.9425754554829541], "final_y": [0.16490484309751552, 0.16506828063819345, 0.16501679393833546]}, "mutation_prompt": null}
{"id": "b2f7f0a1-97e0-40f2-bff4-14126395606e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n        self.stagnation_counter = 0\n        self.max_stagnation = 20  # Criterion to trigger local search\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        diversity = np.std([func(ind) for ind in self.population]) + 1e-5  # Fitness diversity\n        adaptive_F = self.F * (1 + 0.5 * diversity)  # Adaptive mutation based on diversity\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + adaptive_F * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.5\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, bounds):\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        local_candidate = np.clip(candidate + perturbation, bounds.lb, bounds.ub)\n        return local_candidate\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.stagnation_counter = 0\n                else:\n                    new_population[i] = target\n                    self.stagnation_counter += 1\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.stagnation_counter > self.max_stagnation:\n                local_candidate = self.local_search(best_solution, bounds)\n                local_fitness = func(local_candidate)\n                self.evaluate_count += 1\n                if local_fitness < best_fitness:\n                    best_fitness = local_fitness\n                    best_solution = local_candidate\n                self.stagnation_counter = 0\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by integrating adaptive mutation scaling based on fitness diversity and introduce a local search mechanism during stagnation to improve solution convergence.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "8dc49c0b-d2f1-4018-b824-64b3e861905f", "metadata": {}, "mutation_prompt": null}
{"id": "7b430d25-2af8-4eb3-9616-cb49ca96ca45", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        diversity = np.std(self.population, axis=0)\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)**1.2 * diversity.mean()\n        mutant = np.clip(a + current_F * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        neighbors = np.array([func(ind) for ind in self.population[:min(5, self.population_size)]])  # Neighborhood selection\n        best_neighbor = neighbors[np.argmin(neighbors)]\n        current_CR = self.CR * (1.0 - np.linalg.norm(target - best_neighbor) / self.dim)  # Adapt CR based on distance\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic mutation based on population diversity and incorporate a neighborhood-based crossover strategy for improved exploitation.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "8dc49c0b-d2f1-4018-b824-64b3e861905f", "metadata": {}, "mutation_prompt": null}
{"id": "80cd78bb-9d8c-4672-9353-e62c97492919", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = self.F * ((self.budget - self.evaluate_count) / self.budget)**2.0  # Adjusted non-linear decay for F\n        mutation_factor = 0.5 + 0.5 * np.random.rand()  # Adaptive mutation factor\n        mutant = np.clip((mutation_factor * a + 0.5 * b + 0.5 * c) + current_F * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.2  # Adaptive CR decay\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:  # Introduce elitism after the first quarter of evaluations\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce time-varying selection pressure and adaptive mutation strategy to enhance diversity and convergence.", "configspace": "", "generation": 43, "fitness": 0.5644283500677639, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.564 with standard deviation 0.021. And the mean value of best solutions found was 0.329 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "8dc49c0b-d2f1-4018-b824-64b3e861905f", "metadata": {"aucs": [0.5881364361963943, 0.5673113312353306, 0.5378372827715666], "final_y": [0.32525908263615966, 0.328906037004308, 0.3334325225427869]}, "mutation_prompt": null}
{"id": "278a1cf6-6e96-40a7-bad8-08418170d3f0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)  # Variable F with sinusoidal pattern\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.5  # Adaptive CR decay\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:  # Introduce elitism after the first quarter of evaluations\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Integrate a variable F strategy with a sinusoidal pattern for enhancing exploration and exploitation balance.", "configspace": "", "generation": 44, "fitness": 0.9357123691311012, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.936 with standard deviation 0.007. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8dc49c0b-d2f1-4018-b824-64b3e861905f", "metadata": {"aucs": [0.9414829559701041, 0.9261701057582999, 0.9394840456648996], "final_y": [0.1648658605839044, 0.1650893111479551, 0.16495120021710807]}, "mutation_prompt": null}
{"id": "fa6b1672-e73f-4f1e-aa85-703e3a02690c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaotic behavior\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        chaotic_factor = self.chaotic_map(self.evaluate_count / self.budget)\n        current_F = 0.3 + chaotic_factor * 0.4  # Chaotic adaptation of F\n        mutant = np.clip(a + current_F * (b - c), bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        chaotic_factor = self.chaotic_map(self.evaluate_count / self.budget)\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**chaotic_factor  # Chaotic CR decay\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:  # Introduce elitism after the first quarter of evaluations\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration and exploitation balance using chaotic maps for parameter adaptation and a hybrid mutation strategy.", "configspace": "", "generation": 45, "fitness": 0.7855994543968671, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.786 with standard deviation 0.021. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "278a1cf6-6e96-40a7-bad8-08418170d3f0", "metadata": {"aucs": [0.761294390517134, 0.8133425539656762, 0.782161418707791], "final_y": [0.16815561566020443, 0.1660678261473172, 0.1679252894382366]}, "mutation_prompt": null}
{"id": "d58f4a4e-70be-466e-8f84-9d8b0df6a607", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)  # Variable F with sinusoidal pattern\n        random_factor = np.random.uniform(0.8, 1.2)  # Introduce randomization factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.5  # Adaptive CR decay\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:  # Introduce elitism after the first quarter of evaluations\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a randomization factor to the mutation strategy for enhanced exploration.", "configspace": "", "generation": 46, "fitness": 0.9563971225903583, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.956 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "278a1cf6-6e96-40a7-bad8-08418170d3f0", "metadata": {"aucs": [0.9591338755233458, 0.957907623878651, 0.952149868369078], "final_y": [0.16489208279575174, 0.1648648013863917, 0.1649300296061612]}, "mutation_prompt": null}
{"id": "6d980c65-a27c-49ca-8f6b-bdaafe0b104d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        fitness_std = np.std([func(ind) for ind in self.population])\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget) + 0.1 * (fitness_std / np.mean([func(ind) for ind in self.population]))\n        random_factor = np.random.uniform(0.8, 1.2)  # Introduce randomization factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.5  # Adaptive CR decay\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:  # Introduce elitism after the first quarter of evaluations\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Add a dynamic adjustment to the mutation factor F based on fitness diversity to improve convergence.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "d58f4a4e-70be-466e-8f84-9d8b0df6a607", "metadata": {}, "mutation_prompt": null}
{"id": "ef639784-16bc-4624-95b4-53350a2188fb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.4 * np.sin(2 * np.pi * self.evaluate_count / self.budget)  # Adjusted F with frequency-based scaling\n        random_factor = np.random.uniform(0.9, 1.1)  # Narrowed randomization factor\n        mutant = np.clip((0.5 * a + 0.25 * b + 0.25 * c) + current_F * (b - c) * random_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**2  # Adjusted CR decay\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))  # Dynamic population size\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:  # Introduce elitism after the first quarter of evaluations\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance mutation and crossover adaptability with frequency-based scaling and probabilistic crossover to boost exploration and exploitation balance.", "configspace": "", "generation": 48, "fitness": 0.9121137875309387, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.912 with standard deviation 0.008. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d58f4a4e-70be-466e-8f84-9d8b0df6a607", "metadata": {"aucs": [0.9020953648732376, 0.9204314441955557, 0.913814553524023], "final_y": [0.16569595999571496, 0.16535383799890402, 0.16489300911567772]}, "mutation_prompt": null}
{"id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)  # Adjusted randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)  # New dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.5\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic mutation scaling and enhanced convergence criteria to improve solution quality.", "configspace": "", "generation": 49, "fitness": 0.9586429115479381, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.959 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "d58f4a4e-70be-466e-8f84-9d8b0df6a607", "metadata": {"aucs": [0.960961956583025, 0.9602457455052801, 0.9547210325555093], "final_y": [0.16502059179912199, 0.1648936712564415, 0.1648801882686649]}, "mutation_prompt": null}
{"id": "16bbef73-551f-4aae-816a-dbd234ddbe47", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)  # Adjusted randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)  # New dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**2  # Adjusted power for better adaptiveness\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    for k in range(min(2, len(new_population))):  # Enhanced elitism by updating more individuals\n                        new_population[k] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive crossover probability and enhanced elitism to improve convergence in later stages.", "configspace": "", "generation": 50, "fitness": 0.9527267278104258, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.953 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9586816935974297, 0.9508195421233361, 0.9486789477105118], "final_y": [0.16507090510610944, 0.16487351613775314, 0.16589354062097772]}, "mutation_prompt": null}
{"id": "793aa7d4-9ebc-4c3a-ae01-5107326bbb3e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = 5\n        self.memory = np.zeros(self.memory_size)\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.85, 1.15)  # Adjusted randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.5\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def update_memory(self, fitness):\n        self.memory = np.roll(self.memory, -1)\n        self.memory[-1] = np.mean(fitness)\n        self.CR = 0.9 + 0.1 * np.std(self.memory)\n    \n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.update_memory(fitness)\n            \n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptive differential evolution with a memory mechanism for dynamic parameter adjustment and elitism to maintain high-quality solutions.", "configspace": "", "generation": 51, "fitness": 0.9569594386021741, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.957 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9622452282297591, 0.9520957074602467, 0.9565373801165166], "final_y": [0.1649475175614331, 0.16498355501274142, 0.16514253593370598]}, "mutation_prompt": null}
{"id": "ba953093-6730-4060-843c-fd93786cb870", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)\n        scaling_factor = 1 - (self.evaluate_count / self.budget)\n        if np.random.rand() < 0.5:  # Added probabilistic element\n            mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        else:\n            mutant = np.clip(a + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.5\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Refine mutation strategy by introducing a probabilistic element to increase exploration.", "configspace": "", "generation": 52, "fitness": 0.9326932425335, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.933 with standard deviation 0.006. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9411681276581165, 0.9268979847691367, 0.9300136151732472], "final_y": [0.16495769671430216, 0.16495156079765216, 0.1651807553460305]}, "mutation_prompt": null}
{"id": "852bbdc3-f4fb-431e-9726-9b3c9715889e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)\n        scaling_factor = 1 - (self.evaluate_count / self.budget)\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.5\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def neighborhood_search(self, individual, bounds):\n        perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n        neighbor = np.clip(individual + perturbation, bounds.lb, bounds.ub)\n        return neighbor\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if self.evaluate_count % 10 == 0:\n                    neighbor = self.neighborhood_search(target, bounds)\n                    neighbor_fitness = func(neighbor)\n                    self.evaluate_count += 1\n                    if neighbor_fitness < trial_fitness:\n                        trial = neighbor\n                        trial_fitness = neighbor_fitness\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration with adaptive population size and introduce a neighborhood search mechanism to improve convergence.", "configspace": "", "generation": 53, "fitness": 0.9473576013100704, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.947 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9464908476562665, 0.9482116293152387, 0.9473703269587059], "final_y": [0.1651681317358067, 0.16491797475380288, 0.16499379273428416]}, "mutation_prompt": null}
{"id": "a7357bf6-288f-4fbe-8db6-9f8b44ae54ed", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.5 * np.sin(np.pi * self.evaluate_count / self.budget)  # Changed dynamic F adjustment\n        random_factor = np.random.uniform(0.9, 1.1)\n        scaling_factor = 1 - (self.evaluate_count / self.budget)  # Unchanged\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.2  # Adjusted crossover control\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Improve dynamic scaling and crossover by introducing adaptive control over mutation rates based on the current evaluation phase.", "configspace": "", "generation": 54, "fitness": 0.9478351318502556, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.948 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9465806210617027, 0.942286221965438, 0.9546385525236261], "final_y": [0.16486248549935045, 0.16487029335427839, 0.16486165667787367]}, "mutation_prompt": null}
{"id": "268f4e60-d7c6-40b3-a322-af792e469f3f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1) \n        scaling_factor = 1 - (self.evaluate_count / self.budget)  \n        adaptive_factor = 1 + (0.1 * np.cos(np.pi * self.evaluate_count / self.budget))  # Adaptive learning rate\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor * adaptive_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.5\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Implement adaptive learning rates for mutation and crossover to enhance exploration and exploitation balance.", "configspace": "", "generation": 55, "fitness": 0.9537710607954191, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.954 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9534944654872175, 0.9543037632251261, 0.9535149536739135], "final_y": [0.1648640071483335, 0.1648700504318108, 0.16488235426431186]}, "mutation_prompt": null}
{"id": "663ac540-5162-486a-82c8-e4f52b42a01f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 5, replace=False)\n        return self.population[idxs[np.argsort([func(self.population[i]) for i in idxs])[:3]]]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)\n        scaling_factor = 1 - (self.evaluate_count / self.budget)\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.5\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Integrate adaptive population resizing and tournament selection for robust convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {}, "mutation_prompt": null}
{"id": "6b5d53ec-5715-40e2-9a70-865e0cd978a0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n        self.history = []  # Added to track historical best\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)\n        scaling_factor = 1 - np.exp(-self.evaluate_count / self.budget)  # Changed to exponential decay\n        non_uniform_factor = np.random.uniform(1.1, 1.3)  # New non-uniform adjustment\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * non_uniform_factor * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adapt_CR = self.CR * (1 - np.mean([f < np.mean(self.history) for f in self.history]))  # Adaptive based on history\n        cross_points = np.random.rand(self.dim) < adapt_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            self.history.append(best_fitness)  # Track historical best fitness\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Integrate non-uniform mutation and adaptive crossover with historical learning to improve global exploration and convergence.", "configspace": "", "generation": 57, "fitness": 0.9313664362446795, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.931 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9242660409508753, 0.9362266686775449, 0.9336065991056183], "final_y": [0.16571455598715445, 0.16519411112802285, 0.165019937327185]}, "mutation_prompt": null}
{"id": "3c312622-199b-404d-a1fe-962d838127a8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)  \n        scaling_factor = 1 - (self.evaluate_count / self.budget) \n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        if np.random.rand() < 0.05:  # Stochastic local search with 5% probability\n            mutant += np.random.normal(0, 0.01, self.dim)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.5\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Integrate adaptive convergence bias and stochastic local search to enhance exploration-exploitation balance in solution discovery.", "configspace": "", "generation": 58, "fitness": 0.9471118838937137, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.947 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9489286720473956, 0.9421584296818962, 0.950248549951849], "final_y": [0.16530362533299892, 0.164883959261672, 0.16604709569116116]}, "mutation_prompt": null}
{"id": "e9981d65-4061-4ff3-a183-756b5b26c017", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)  # Adjusted randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)  # New dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        # Modified line: Introduced dynamic crossover probability based on fitness improvement\n        fitness_improvement = 1 - (np.min(self.population) / np.mean(self.population))\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget) ** 1.5 * fitness_improvement\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic crossover probability based on fitness improvement to enhance exploration-exploitation balance.", "configspace": "", "generation": 59, "fitness": 0.9579323137683811, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.958 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.960961956583025, 0.9602457455052801, 0.9525892392168381], "final_y": [0.16502059179912199, 0.1648936712564415, 0.16500678285440185]}, "mutation_prompt": null}
{"id": "bb8cee0b-57e9-47ff-8bf5-9b2aae8e2d61", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.2)  # Adjusted randomization factor\n        scaling_factor = 1 - (self.evaluate_count / self.budget)  # New dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**2  # Adjusted power for crossover rate\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Strengthen convergence and exploration by adapting crossover probability and refining mutation strategy.", "configspace": "", "generation": 60, "fitness": 0.9514048829080001, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.951 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9562568031156272, 0.9505792078062224, 0.9473786378021505], "final_y": [0.1650373947018715, 0.16487116532189894, 0.16531019949017378]}, "mutation_prompt": null}
{"id": "b769fef2-32c5-4e1e-a3de-355c3afa6406", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        adaptive_F = self.F * (1 - np.tanh(self.evaluate_count / self.budget))  # Adaptive learning rate\n        exploration_factor = 0.8 + 0.4 * np.random.rand()  # Enhanced mutation strategy\n        scaling_factor = 1 - (self.evaluate_count / self.budget)\n        mutant = np.clip(a + adaptive_F * (b - c) * exploration_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.5\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive learning rate and improve mutation strategy for enhanced exploration and exploitation balance.", "configspace": "", "generation": 61, "fitness": 0.8563110453726147, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.856 with standard deviation 0.010. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.8419349483106693, 0.8624704173687954, 0.8645277704383794], "final_y": [0.1673652712535476, 0.1681113459917556, 0.16719829027750432]}, "mutation_prompt": null}
{"id": "21dfc94b-e489-4edb-9ab7-ac195d0d7f30", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.cos(np.pi * self.evaluate_count / self.budget)  # Changed sine to cosine\n        random_factor = np.random.uniform(0.9, 1.1)\n        scaling_factor = 1 - (self.evaluate_count / self.budget)\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**2  # Adjusted power from 1.5 to 2\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance mutation diversity by introducing cosine-based scaling and adaptive crossover probability.", "configspace": "", "generation": 62, "fitness": 0.9307032986763897, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.931 with standard deviation 0.009. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9190459587140729, 0.9417430375173532, 0.931320899797743], "final_y": [0.165026042928049, 0.16498619534800774, 0.16527748011135235]}, "mutation_prompt": null}
{"id": "eb23b8a1-25f2-4faa-9d28-c36c5a63de97", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)\n        scaling_factor = 1 - (self.evaluate_count / self.budget)\n        elite = self.population[np.argmin(self.evaluate_population(func))]  # New elitist strategy\n        mutant = np.clip((a + 0.2 * b + 0.2 * elite) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.5\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptive differential evolution with elitist selection and strategic mutation to improve convergence speed and accuracy.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {}, "mutation_prompt": null}
{"id": "ada5e065-4b1d-4733-974b-d272fe994a4b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)\n        scaling_factor = 1 - (self.evaluate_count / self.budget)\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adaptive_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**np.random.uniform(1.0, 2.0)  # Adjusted adaptive CR\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            # Introduce random elitism to prevent premature convergence\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None and np.random.rand() < 0.5:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by introducing adaptive crossover strategy and random elitism to prevent premature convergence.", "configspace": "", "generation": 64, "fitness": 0.9510615268560908, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.951 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9488236680603049, 0.9464556534671995, 0.957905259040768], "final_y": [0.16562743061939533, 0.164888480764117, 0.1648711822699499]}, "mutation_prompt": null}
{"id": "bb2b5977-d2eb-4b08-94d7-d1a5254cce9e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.4 + 0.3 * np.sin(np.pi * self.evaluate_count / self.budget)  # Modified mutation factor\n        random_factor = np.random.uniform(0.8, 1.2)  # Adjusted randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.2  # Adjusted crossover probability\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(12 * self.dim * (1 - self.evaluate_count / self.budget)))  # Adjusted population dynamics\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive population resizing and dynamic crossover to enhance exploration and exploitation balance.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 115 is out of bounds for axis 0 with size 100').", "error": "IndexError('index 115 is out of bounds for axis 0 with size 100')", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {}, "mutation_prompt": null}
{"id": "47cbcfa9-c841-4021-9ce5-90b779318963", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)  # Adjusted randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)  # New dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.5\n        current_CR = min(0.1 + 0.9 * (self.evaluate_count / self.budget), current_CR)  # Adaptive CR\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce an adaptive crossover probability and elitism strategy to balance exploration and exploitation.", "configspace": "", "generation": 66, "fitness": 0.8828314998805699, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.883 with standard deviation 0.014. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.8937737405544145, 0.8631241926995321, 0.8915965663877632], "final_y": [0.16493564810110284, 0.16505449372485148, 0.1649950935114335]}, "mutation_prompt": null}
{"id": "5cd550eb-0b80-4767-af04-96abc031d22b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)  # Adjusted randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)  # New dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.5\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                self.CR = 0.8  # Adjusting the crossover rate adaptively\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Integrate an adaptive crossover rate adjustment for improved diversity in the search process.", "configspace": "", "generation": 67, "fitness": 0.9492565859898744, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.949 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9433234574169114, 0.9491967197098543, 0.9552495808428574], "final_y": [0.1651538710855338, 0.1649332994673608, 0.16503006753595373]}, "mutation_prompt": null}
{"id": "5ad519fa-7a8f-451f-b19f-aa5f5eac741c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.95, 1.05)  # Adjusted randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)  # New dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.2\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce an adaptive crossover rate and enhanced mutation scaling to improve solution diversity and exploration.", "configspace": "", "generation": 68, "fitness": 0.955506215634334, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.956 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9584347689291746, 0.9551561730916989, 0.9529277048821284], "final_y": [0.16532563952266577, 0.16491051411831203, 0.16595396274906238]}, "mutation_prompt": null}
{"id": "e70bae60-a8b3-4b60-83c0-51d5a0706efb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)  \n        scaling_factor = 1 - (self.evaluate_count / self.budget)  \n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.5\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.CR = 0.9 - 0.3 * (self.evaluate_count / self.budget)  # Adaptive crossover rate\n            self.F = 0.5 + 0.3 * (1 - self.evaluate_count / self.budget)  # Adaptive mutation factor\n            \n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Integrate adaptive crossover and mutation strategies to enhance exploration and exploitation balance.", "configspace": "", "generation": 69, "fitness": 0.9534767012841433, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.953 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9571109728555314, 0.9530765998643985, 0.9502425311325001], "final_y": [0.16492194208477018, 0.164874118396226, 0.16540962300093465]}, "mutation_prompt": null}
{"id": "7a3f515d-1f06-47d9-b4e9-3d87a31133b8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)  # Adjusted randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)  # New dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**2\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive crossover rate scaling to balance exploration and exploitation in solution search.", "configspace": "", "generation": 70, "fitness": 0.9524761599456818, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.952 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9593950148213384, 0.9500502091335015, 0.9479832558822056], "final_y": [0.16500191925707997, 0.16494088072834945, 0.1659247037787116]}, "mutation_prompt": null}
{"id": "625176f1-8f61-4815-afe2-3208a796c96c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.3 * np.sin(np.pi * self.evaluate_count / self.budget)  # Adjusted mutation\n        random_factor = np.random.uniform(0.8, 1.2)  # Adjusted randomization factor range\n        diversity_factor = np.std(self.population) / (bounds.ub - bounds.lb)  # New diversity-based scaling\n        mutant = np.clip(a + current_F * (b - c) * random_factor * diversity_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        diversity_based_CR = self.CR * (1 + np.std(self.population) / (bounds.ub - bounds.lb))**1.5  # New crossover scaling\n        cross_points = np.random.rand(self.dim) < diversity_based_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce time-variant adaptive population resizing and adaptive crossover scaling based on diversity to enhance exploration and exploitation balance.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'bounds' is not defined\").", "error": "NameError(\"name 'bounds' is not defined\")", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {}, "mutation_prompt": null}
{"id": "2b71bf27-bd54-4688-8ae3-a0f66ea893a9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)\n        scaling_factor = 1 - (self.evaluate_count / self.budget)\n        perturbation = np.random.uniform(-0.05, 0.05, self.dim)  # New perturbation for diversity\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor + perturbation, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.2  # Adjusted exponent for adaptivity\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by incorporating adaptive crossover rates and diversity-promoting perturbations.", "configspace": "", "generation": 72, "fitness": 0.9526801718133983, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.953 with standard deviation 0.009. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9604865807191091, 0.9397149986882034, 0.9578389360328826], "final_y": [0.16513357214580016, 0.16582734146911815, 0.16505881046193505]}, "mutation_prompt": null}
{"id": "17907380-8602-47ed-99de-c2a9d5527699", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 5, replace=False)\n        return self.population[idxs[:3]], self.population[idxs[3:]]\n\n    def mutate(self, target_idx, bounds):\n        (a, b, c), _ = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)\n        scaling_factor = 1 - (self.evaluate_count / self.budget)\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        _, (best,) = self.select_parents()\n        current_CR = self.CR * (1 - np.linalg.norm(target - best) / np.linalg.norm(bounds.ub - bounds.lb))\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover and enhanced parent selection to balance exploration and exploitation.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 1)').", "error": "ValueError('too many values to unpack (expected 1)')", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {}, "mutation_prompt": null}
{"id": "3594ccc6-3b9c-46e2-a7c1-593fb6d1f9c4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.85, 1.15)  # Slightly expanded randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)  # New dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.5\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance solution diversity through adaptive parameter variation for improved exploration.", "configspace": "", "generation": 74, "fitness": 0.9576259640744395, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.958 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9609898692168588, 0.9596055656872942, 0.9522824573191654], "final_y": [0.164951518987426, 0.16501728213977795, 0.16557700687651]}, "mutation_prompt": null}
{"id": "a2c5c3ec-75f8-433c-9c19-5ba9be1d6a30", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)\n        scaling_factor = 1 - (self.evaluate_count / self.budget)\n        fitness_factor = np.exp(-func(self.population[target_idx]))  # Line changed\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor * fitness_factor, bounds.lb, bounds.ub)  # Line changed\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.5\n        adaptive_CR = current_CR + 0.05 * np.sin(2 * np.pi * self.evaluate_count / self.budget)  # Line changed\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive crossover rate scaling and fitness-based mutation probability to enhance exploration-exploitation balance.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {}, "mutation_prompt": null}
{"id": "f492a22a-927e-44c9-8396-84313d7c5250", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.4 * np.cos(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.85, 1.15)  # Adjusted randomization factor range\n        scaling_factor = (1 - (self.evaluate_count / self.budget))**2  # New dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.5\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)**0.5))  # Nonlinear resizing\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive population resizing and nonlinear mutation scaling to enhance convergence in optimization tasks.", "configspace": "", "generation": 76, "fitness": 0.9043898055195813, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.904 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.8985135628951861, 0.9041007145554456, 0.9105551391081121], "final_y": [0.1654932582826305, 0.16535929001428085, 0.1653211113255615]}, "mutation_prompt": null}
{"id": "90e9eefa-2299-4b33-9103-96168543e3ae", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.85, 1.15)  # Adjusted randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)  # New dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.7  # Adjusted crossover rate decay\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a decay-adjusted crossover rate and improved randomization to enhance exploration.", "configspace": "", "generation": 77, "fitness": 0.9583127515015564, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.958 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9626971445908533, 0.9600878230132373, 0.9521532869005787], "final_y": [0.16489951823078552, 0.16486576526450902, 0.16547648870586673]}, "mutation_prompt": null}
{"id": "491cbfa0-3a33-456a-9665-9d7410f849f3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)  # Adjusted randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)  # New dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.2  # Adjusted exponent for cooling schedule\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a cooling schedule for crossover probability to enhance exploration-exploitation balance.", "configspace": "", "generation": 78, "fitness": 0.9549573482871088, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.955 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9581295222997513, 0.9539862386462975, 0.9527562839152776], "final_y": [0.16503715351991277, 0.16499174142400297, 0.16567182493512]}, "mutation_prompt": null}
{"id": "eb0e9f79-5a69-4fed-9af5-0ce0a11bcdad", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.95, 1.05)  # Adjusted randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)  # New dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.5\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n                    fitness[0] = best_fitness  # Ensure the best fitness is maintained\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Refine adaptive parameters and introduce elitism to enhance convergence speed and solution quality.", "configspace": "", "generation": 79, "fitness": 0.9555788989362201, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.956 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9539462959785381, 0.9586467522998464, 0.9541436485302756], "final_y": [0.16519953187945702, 0.1650487717286313, 0.1648918591127162]}, "mutation_prompt": null}
{"id": "e8095e86-ba75-4eb6-b5d5-30c83608f5a8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1) \n        scaling_factor = 1 - (self.evaluate_count / self.budget) \n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.9  # Changed exponent for adaptive crossover\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive crossover scaling and dynamic population variance to enhance exploration-exploitation balance.  ", "configspace": "", "generation": 80, "fitness": 0.9520453789179889, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.952 with standard deviation 0.005. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9594382307677349, 0.947653450152551, 0.9490444558336807], "final_y": [0.16509023822169278, 0.16496590895033914, 0.16607619006092067]}, "mutation_prompt": null}
{"id": "902d44b1-619a-4b91-973e-6c2f0c8e0021", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)  # Adjusted randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)  # New dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget - self.evaluate_count) / self.budget)**1.5\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.F *= 1.05  # Enhance F on success\n                else:\n                    new_population[i] = target\n                    self.CR *= 0.95  # Reduce CR on failure\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Integrate adaptive F and CR strategies based on performance feedback to enhance convergence and diversity.", "configspace": "", "generation": 81, "fitness": 0.8305367910501783, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.831 with standard deviation 0.010. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.8255512830271374, 0.8217112814026721, 0.8443478087207257], "final_y": [0.16858641926666584, 0.16935297041905994, 0.17496678610007788]}, "mutation_prompt": null}
{"id": "2bf0adae-1831-4b9d-abfe-162b3aa8b14c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def hybrid_mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        d = self.population[np.random.randint(self.population_size)]  # Introduce a fourth parent for diversity\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        scaling_factor = 1 - (self.evaluate_count / self.budget)\n        if np.random.rand() > 0.5:  # Hybrid mutation strategy\n            mutant = np.clip(a + current_F * (b - c), bounds.lb, bounds.ub)\n        else:\n            mutant = np.clip(a + current_F * (b - c + d - a) * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def adaptive_crossover(self, target, mutant):\n        current_CR = self.CR * (1 - (self.evaluate_count / self.budget)**1.5)  # Modified crossover rate adaptation\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.hybrid_mutate(i, bounds)\n                trial = self.adaptive_crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a hybrid mutation strategy and adaptive crossover rate to enhance exploration and exploitation balance.", "configspace": "", "generation": 82, "fitness": 0.9127926123675487, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.913 with standard deviation 0.011. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9266555198867065, 0.9000852696310792, 0.9116370475848605], "final_y": [0.16486197355271748, 0.1649672418336029, 0.16485975309180012]}, "mutation_prompt": null}
{"id": "f241a5de-36e7-44e7-8c19-f8b182147079", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)  # Adjusted randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)  # New dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * ((self.budget / 2 - self.evaluate_count) / self.budget)**1.5  # Change made here\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic crossover rate scaling to adaptively balance exploration and exploitation throughout the optimization process.", "configspace": "", "generation": 83, "fitness": 0.8725070082709626, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.873 with standard deviation 0.027. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.834593325277442, 0.8946942703313967, 0.8882334292040492], "final_y": [0.16692622028273973, 0.1658613873113266, 0.16819624951121903]}, "mutation_prompt": null}
{"id": "5cb60189-4f8c-4667-961c-2e4659577686", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)  # Adjusted randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)  # New dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * np.cos(np.pi * self.evaluate_count / (2 * self.budget))  # Adaptive crossover rate modulation\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive crossover rate modulation to enhance performance.", "configspace": "", "generation": 84, "fitness": 0.960067963130833, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.960 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1ee48bc5-8d7c-4999-a7a0-5b0eceaee660", "metadata": {"aucs": [0.9649744245671024, 0.9546755297880278, 0.9605539350373689], "final_y": [0.16510827418292784, 0.16522431480226973, 0.16540604530997316]}, "mutation_prompt": null}
{"id": "63f21fa1-3b84-49c9-84e7-45265187d66f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)  # Adjusted randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)  # New dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * np.abs(np.sin(np.pi * self.evaluate_count / self.budget))  # Oscillating adaptive crossover rate modulation\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce oscillating crossover rate modulation that adapts periodically to exploration-exploitation balance.", "configspace": "", "generation": 85, "fitness": 0.9173224662537917, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.917 with standard deviation 0.004. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "5cb60189-4f8c-4667-961c-2e4659577686", "metadata": {"aucs": [0.9116793838316053, 0.9183597810806432, 0.9219282338491265], "final_y": [0.16685913467358904, 0.16502013127224802, 0.16501232664730237]}, "mutation_prompt": null}
{"id": "e4d60854-64ad-4597-aab9-a38f3b99652e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)  # Adjusted randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)  # New dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * np.cos(np.pi * self.evaluate_count / (2 * self.budget))  # Adaptive crossover rate modulation\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by introducing a sine function-based dynamic adjustment to the mutation factor.", "configspace": "", "generation": 86, "fitness": 0.960067963130833, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.960 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5cb60189-4f8c-4667-961c-2e4659577686", "metadata": {"aucs": [0.9649744245671024, 0.9546755297880278, 0.9605539350373689], "final_y": [0.16510827418292784, 0.16522431480226973, 0.16540604530997316]}, "mutation_prompt": null}
{"id": "3a96e7ab-5049-483c-95d8-7ed6bd6226d2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget) + 0.1 * np.cos(np.pi * self.evaluate_count / self.budget)  # Added dynamic mutation adjustment\n        random_factor = np.random.uniform(0.9, 1.1)  # Adjusted randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)  # New dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * np.cos(np.pi * self.evaluate_count / (2 * self.budget))  # Adaptive crossover rate modulation\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic mutation strategy to enhance solution exploration.", "configspace": "", "generation": 87, "fitness": 0.952270359096973, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.952 with standard deviation 0.002. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5cb60189-4f8c-4667-961c-2e4659577686", "metadata": {"aucs": [0.9543175989245406, 0.9534808266061918, 0.9490126517601862], "final_y": [0.16523160174262097, 0.16491732410187754, 0.16506232949950395]}, "mutation_prompt": null}
{"id": "48d88af9-9f6a-4fb6-a779-cdd507af88a6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)  # Adjusted randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)  # New dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * np.cos(np.pi * self.evaluate_count / (2 * self.budget))  # Adaptive crossover rate modulation\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(8 * self.dim * (1 - self.evaluate_count / self.budget)))  # Changed from 10 to 8\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Integrate a dynamic population size reduction to enhance convergence speed.", "configspace": "", "generation": 88, "fitness": 0.9525917092887259, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.953 with standard deviation 0.010. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "5cb60189-4f8c-4667-961c-2e4659577686", "metadata": {"aucs": [0.9608580264898581, 0.9386719708250423, 0.9582451305512777], "final_y": [0.16583585168049242, 0.16969414983558373, 0.16595574066359864]}, "mutation_prompt": null}
{"id": "aafddd56-aeca-4387-b854-69e108d2bfd2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        annealing_factor = 1 - (self.evaluate_count / self.budget)  # Annealing strategy for mutation factor\n        random_factor = np.random.uniform(0.9, 1.1)\n        scaling_factor = annealing_factor  # Use annealing factor directly for mutation scaling\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * np.cos(np.pi * self.evaluate_count / (2 * self.budget))\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate annealing strategy for dynamically adjusting mutation factor to enhance convergence.", "configspace": "", "generation": 89, "fitness": 0.960067963130833, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.960 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5cb60189-4f8c-4667-961c-2e4659577686", "metadata": {"aucs": [0.9649744245671024, 0.9546755297880278, 0.9605539350373689], "final_y": [0.16510827418292784, 0.16522431480226973, 0.16540604530997316]}, "mutation_prompt": null}
{"id": "5f87766e-1c1a-4136-9380-bfd24c07b442", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        # Changed line: Introduced adaptive mutation scaling factor using a cosine function\n        random_factor = np.random.uniform(0.9, 1.1) * (0.5 + 0.5 * np.cos(np.pi * self.evaluate_count / self.budget))\n        scaling_factor = 1 - (self.evaluate_count / self.budget)\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * np.cos(np.pi * self.evaluate_count / (2 * self.budget))\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation scaling based on a cosine function to enhance the exploration-exploitation balance.", "configspace": "", "generation": 90, "fitness": 0.9584571500556959, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.958 with standard deviation 0.005. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5cb60189-4f8c-4667-961c-2e4659577686", "metadata": {"aucs": [0.9636621883632634, 0.9518374849624467, 0.9598717768413773], "final_y": [0.16566010986759672, 0.1658571110554039, 0.16574432421435792]}, "mutation_prompt": null}
{"id": "8c1eeb65-8336-45f9-92f5-0b4cfb81b2fe", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)  # Adjusted randomization factor range\n        scaling_factor = 1 - np.sin(np.pi * self.evaluate_count / self.budget)  # Refined dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * np.cos(np.pi * self.evaluate_count / (2 * self.budget))  # Adaptive crossover rate modulation\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Refine adaptive scaling factor for enhanced exploration and exploitation balance.", "configspace": "", "generation": 91, "fitness": 0.9596283703846794, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.960 with standard deviation 0.004. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "5cb60189-4f8c-4667-961c-2e4659577686", "metadata": {"aucs": [0.9634893699911419, 0.9541566515761558, 0.9612390895867405], "final_y": [0.16644713556053414, 0.165183187818714, 0.1659149428442428]}, "mutation_prompt": null}
{"id": "c681d1d4-cf1c-4fbc-958b-64ed0d193a45", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)  # Adjusted randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)  # New dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * np.cos(np.pi * self.evaluate_count / (2 * self.budget))  # Adaptive crossover rate modulation\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - (2 * self.evaluate_count / self.budget))))  # Change line to adjust population size.\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic population resizing to enhance diversity and convergence.", "configspace": "", "generation": 92, "fitness": 0.9594174579864702, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.959 with standard deviation 0.005. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "5cb60189-4f8c-4667-961c-2e4659577686", "metadata": {"aucs": [0.9636607854924827, 0.9615597095904643, 0.9530318788764635], "final_y": [0.1650562811178855, 0.16510311067142747, 0.1665051950975458]}, "mutation_prompt": null}
{"id": "bfdb2112-63e6-49f3-bb51-bb452b574c36", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.85, 1.15)  # Adjusted randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)**2  # New dynamic scaling factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * np.cos(np.pi * self.evaluate_count / (2 * self.budget))  # Adaptive crossover rate modulation\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance mutation strategy with dynamic scaling and randomization. ", "configspace": "", "generation": 93, "fitness": 0.9579029349301083, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.958 with standard deviation 0.004. And the mean value of best solutions found was 0.165 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5cb60189-4f8c-4667-961c-2e4659577686", "metadata": {"aucs": [0.9630628652672746, 0.9527012687044589, 0.9579446708185915], "final_y": [0.16487315204420538, 0.16487762980357545, 0.1655658490372931]}, "mutation_prompt": null}
{"id": "31ec79d5-bc4b-4933-bd72-6d8acfddebfa", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)  # Adjusted randomization factor range\n        scaling_factor = 1 - (self.evaluate_count / self.budget)  # New dynamic scaling factor\n        chaos_factor = np.abs(np.sin(self.evaluate_count))  # Added chaos-induced randomization\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor * chaos_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * np.cos(np.pi * self.evaluate_count / (2 * self.budget))  # Adaptive crossover rate modulation\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Add diversity preservation through chaos-induced randomization in mutation.", "configspace": "", "generation": 94, "fitness": 0.9623644977986551, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.962 with standard deviation 0.004. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "5cb60189-4f8c-4667-961c-2e4659577686", "metadata": {"aucs": [0.9636645152259452, 0.9570144085520826, 0.9664145696179374], "final_y": [0.16654366054128478, 0.1656088577483028, 0.16606743497002752]}, "mutation_prompt": null}
{"id": "8903b0fb-692b-4447-8089-b1ef8ff47ab9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)  # Adjusted randomization factor range\n        scaling_factor = 1 - np.abs(np.sin(2 * np.pi * self.evaluate_count / self.budget))  # New dynamic scaling factor with sinusoidal pattern\n        chaos_factor = np.abs(np.sin(self.evaluate_count))  # Added chaos-induced randomization\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor * chaos_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * np.cos(np.pi * self.evaluate_count / (2 * self.budget))  # Adaptive crossover rate modulation\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance diversity by introducing a sinusoidal adaptive dynamic scaling factor in mutation.", "configspace": "", "generation": 95, "fitness": 0.963465977828985, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.963 with standard deviation 0.007. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "31ec79d5-bc4b-4933-bd72-6d8acfddebfa", "metadata": {"aucs": [0.9679559419677193, 0.9541828902961652, 0.9682591012230707], "final_y": [0.16654443501280347, 0.16679342847552192, 0.16659723931294912]}, "mutation_prompt": null}
{"id": "6a8d900d-d6e4-403c-a471-0b8c15c1e4f6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)  # Adjusted randomization factor range\n        scaling_factor = 1 - np.abs(np.cos(2 * np.pi * self.evaluate_count / self.budget))  # New dynamic scaling factor with cosine pattern\n        chaos_factor = np.abs(np.sin(self.evaluate_count))  # Added chaos-induced randomization\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor * chaos_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * np.cos(np.pi * self.evaluate_count / (2 * self.budget))  # Adaptive crossover rate modulation\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a cosine-based adaptive scaling factor to enhance convergence speed.", "configspace": "", "generation": 96, "fitness": 0.9658680121376522, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.966 with standard deviation 0.006. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "8903b0fb-692b-4447-8089-b1ef8ff47ab9", "metadata": {"aucs": [0.9667216473664185, 0.9586614339825127, 0.9722209550640251], "final_y": [0.16595021071473215, 0.16665080842270308, 0.16559254730407758]}, "mutation_prompt": null}
{"id": "0d77d58b-0355-4f5a-932f-4d69a1e6ac62", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)\n        scaling_factor = 1 - np.abs(np.cos(2 * np.pi * self.evaluate_count / self.budget))\n        chaos_factor = np.abs(np.sin(self.evaluate_count))  \n        phase_adjustment = np.sin(2 * np.pi * (self.evaluate_count / self.budget))  # New phase adjustment factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor * chaos_factor * phase_adjustment, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * np.cos(np.pi * self.evaluate_count / (2 * self.budget)) \n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a phase adjustment factor in mutation to improve exploration of the search space.", "configspace": "", "generation": 97, "fitness": 0.9630773580139764, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.963 with standard deviation 0.006. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "6a8d900d-d6e4-403c-a471-0b8c15c1e4f6", "metadata": {"aucs": [0.959576059503503, 0.957628008034605, 0.9720280065038215], "final_y": [0.1678044320965426, 0.16738185064376954, 0.165660156286081]}, "mutation_prompt": null}
{"id": "7e8caa56-193d-4024-8f7b-1c5f52e5f49a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)  # Adjusted randomization factor range\n        scaling_factor = 1 - np.abs(np.cos(2 * np.pi * self.evaluate_count / self.budget))  # New dynamic scaling factor with cosine pattern\n        chaos_factor = np.abs(np.sin(self.evaluate_count))  # Added chaos-induced randomization\n        adaptive_prob = 0.5 + 0.5 * np.random.rand()  # New adaptive probability factor\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor * chaos_factor * adaptive_prob, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * np.cos(np.pi * self.evaluate_count / (2 * self.budget))  # Adaptive crossover rate modulation\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce an adaptive probability factor to enhance exploration during mutation.", "configspace": "", "generation": 98, "fitness": 0.9612130174547389, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.961 with standard deviation 0.004. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "6a8d900d-d6e4-403c-a471-0b8c15c1e4f6", "metadata": {"aucs": [0.9559780448216899, 0.9651134617250535, 0.962547545817473], "final_y": [0.16873613604036097, 0.16538897327471014, 0.16858532596980402]}, "mutation_prompt": null}
{"id": "9d11d5a5-8e6c-4a20-a18c-ea515a06aa78", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.evaluate_count = 0\n\n    def initialize_population(self, bounds):\n        self.population = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.evaluate_count += len(self.population)\n        return fitness\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target_idx, bounds):\n        a, b, c = self.select_parents()\n        current_F = 0.3 + 0.2 * np.sin(np.pi * self.evaluate_count / self.budget)\n        random_factor = np.random.uniform(0.9, 1.1)  # Adjusted randomization factor range\n        scaling_factor = 1 - np.abs(np.cos(2 * np.pi * self.evaluate_count / self.budget))  # New dynamic scaling factor with cosine pattern\n        chaos_factor = np.abs(np.sin(self.evaluate_count / 2))  # Modified chaos-induced randomization to enhance exploration\n        mutant = np.clip((0.6 * a + 0.2 * b + 0.2 * c) + current_F * (b - c) * random_factor * scaling_factor * chaos_factor, bounds.lb, bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        current_CR = self.CR * np.cos(np.pi * self.evaluate_count / (2 * self.budget))  # Adaptive crossover rate modulation\n        cross_points = np.random.rand(self.dim) < current_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.initialize_population(bounds)\n        best_solution = None\n        best_fitness = np.inf\n\n        fitness = self.evaluate_population(func)\n\n        while self.evaluate_count < self.budget:\n            self.population_size = max(5, int(10 * self.dim * (1 - self.evaluate_count / self.budget)))\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i, bounds)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluate_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = target\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best_solution = trial\n\n            if self.evaluate_count > self.budget / 4:\n                if best_solution is not None:\n                    new_population[0] = best_solution\n\n            self.population = new_population\n        return best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Enhance the algorithm by adjusting the chaos factor to improve exploration capabilities.", "configspace": "", "generation": 99, "fitness": 0.966553889689875, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.967 with standard deviation 0.004. And the mean value of best solutions found was 0.166 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "6a8d900d-d6e4-403c-a471-0b8c15c1e4f6", "metadata": {"aucs": [0.9663906791239197, 0.961346417694976, 0.9719245722507296], "final_y": [0.16607432217226037, 0.16586703955490822, 0.16564906993862205]}, "mutation_prompt": null}
