{"id": "1cec9161-66c1-4bad-a3a6-fc3c018f092a", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.5\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.1\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Adaptive Swarm Evolution Algorithm (ASEA) that combines swarm intelligence with adaptive mutation strategies to efficiently explore and exploit the search space.", "configspace": "", "generation": 0, "fitness": 0.888512954642034, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.889 with standard deviation 0.011. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8750965910320929, 0.9009982794969131, 0.8894439933970959], "final_y": [0.11507179714604154, 0.11398504456893921, 0.11979080570777667]}, "mutation_prompt": null}
{"id": "8a32d1a2-2c97-42fe-b59d-f9550a8f405d", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.7  # Increased cognitive component\n        self.social_component = 1.5\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.1\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm (EASEA) with increased cognitive component for improved personal best exploration.", "configspace": "", "generation": 1, "fitness": 0.8767351495172292, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.877 with standard deviation 0.027. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "1cec9161-66c1-4bad-a3a6-fc3c018f092a", "metadata": {"aucs": [0.8405169691163356, 0.9051621437385056, 0.8845263356968464], "final_y": [0.13060941053185426, 0.1120495375833207, 0.11749678536055808]}, "mutation_prompt": null}
{"id": "d80f8e6e-2a4b-43b9-b8ad-9afc30b05e0f", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.5\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.1\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            # Dynamic inertia adjustment\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm (EASEA) with dynamic inertia adjustment for improved exploration and exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.8623240463633689, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.862 with standard deviation 0.009. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "1cec9161-66c1-4bad-a3a6-fc3c018f092a", "metadata": {"aucs": [0.8514397818592203, 0.8729122454813921, 0.8626201117494942], "final_y": [0.12512691084940242, 0.11869510349979906, 0.12130853967351929]}, "mutation_prompt": null}
{"id": "91c3ba68-e3cb-4129-bd7d-6c619b88fd06", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.5\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.1\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with dynamic population size adjustment to improve exploration-exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.888512954642034, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.889 with standard deviation 0.011. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "1cec9161-66c1-4bad-a3a6-fc3c018f092a", "metadata": {"aucs": [0.8750965910320929, 0.9009982794969131, 0.8894439933970959], "final_y": [0.11507179714604154, 0.11398504456893921, 0.11979080570777667]}, "mutation_prompt": null}
{"id": "50027401-4f04-48e0-bcf3-7a4262f026bb", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight for improved convergence\n        self.cognitive_component = 1.5\n        self.social_component = 1.5\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.1\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with improved dynamic inertia weight for better convergence and exploration balance.", "configspace": "", "generation": 4, "fitness": 0.8658970330240644, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.866 with standard deviation 0.018. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "1cec9161-66c1-4bad-a3a6-fc3c018f092a", "metadata": {"aucs": [0.8422800431294009, 0.8842964035537949, 0.8711146523889973], "final_y": [0.13606355994873987, 0.12190727929088818, 0.12130340198466083]}, "mutation_prompt": null}
{"id": "5696b71e-de27-43a0-b8e4-0b539f64427c", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.5\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.15  # Increased mutation scale for better exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with increased mutation scale for better exploration during optimization.", "configspace": "", "generation": 5, "fitness": 0.8885361065002528, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.889 with standard deviation 0.011. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "1cec9161-66c1-4bad-a3a6-fc3c018f092a", "metadata": {"aucs": [0.8751486039635905, 0.9010024662374281, 0.88945724929974], "final_y": [0.11519484890689036, 0.11421635134145891, 0.11984527719813576]}, "mutation_prompt": null}
{"id": "2b86c3f5-3350-4ce8-aef8-59e9abc3fc7d", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.7  # Increased inertia weight for improved convergence speed\n        self.cognitive_component = 1.5\n        self.social_component = 1.5\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.15  # Increased mutation scale for better exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Adaptive Swarm Evolution Algorithm with increased inertia weight for improved convergence speed.", "configspace": "", "generation": 6, "fitness": 0.8829453237319004, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.883 with standard deviation 0.011. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "5696b71e-de27-43a0-b8e4-0b539f64427c", "metadata": {"aucs": [0.8733903303411702, 0.8775541255481059, 0.897891515306425], "final_y": [0.1279990438881503, 0.12034839764685634, 0.1163000804130877]}, "mutation_prompt": null}
{"id": "c7709684-449f-4cfc-b3b6-6e3721b4131b", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.5\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.15  # Increased mutation scale for better exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + (self.cognitive_component * (1 - eval_count / self.budget)) * r1 * (personal_best_positions - positions)  # Dynamic adjustment\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with dynamic adjustment of cognitive and social components for improved convergence.", "configspace": "", "generation": 7, "fitness": 0.8587125502857536, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.859 with standard deviation 0.065. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.025.", "error": "", "parent_id": "5696b71e-de27-43a0-b8e4-0b539f64427c", "metadata": {"aucs": [0.7668301129940148, 0.9129284541057807, 0.8963790837574652], "final_y": [0.1695114134394492, 0.1118530148051925, 0.11999136871825089]}, "mutation_prompt": null}
{"id": "336c8f33-23b5-4dff-aceb-2058f7563916", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.5\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.15  # Increased mutation scale for better exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with dynamic inertia weight for improved balance between exploration and exploitation.", "configspace": "", "generation": 8, "fitness": 0.860347004964286, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.860 with standard deviation 0.011. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "5696b71e-de27-43a0-b8e4-0b539f64427c", "metadata": {"aucs": [0.8455002799020893, 0.8729179936324588, 0.86262274135831], "final_y": [0.13539058094616319, 0.11868682537963704, 0.12130384534067062]}, "mutation_prompt": null}
{"id": "d84fc7b9-4625-4d54-9988-f9535ed05758", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.6  # Tuning the inertia weight for better balance\n        self.cognitive_component = 1.5\n        self.social_component = 1.5\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.15  # Increased mutation scale for better exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with minor tuning of the inertia weight for better balance between exploration and exploitation.", "configspace": "", "generation": 9, "fitness": 0.8819778202477183, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.882 with standard deviation 0.009. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "5696b71e-de27-43a0-b8e4-0b539f64427c", "metadata": {"aucs": [0.8700553261580226, 0.8846848802938887, 0.891193254291244], "final_y": [0.12680458274016637, 0.11984272584969446, 0.12060534717584415]}, "mutation_prompt": null}
{"id": "4cab2d46-c80e-4f63-9ca1-1f5ffcdc6c8e", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.5\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.15  # Increased mutation scale for better exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - 0.4 * (eval_count / self.budget)  # Dynamic inertia weight adjustment\n            velocities = (inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Improved convergence by dynamically adjusting inertia weight based on function evaluations.", "configspace": "", "generation": 10, "fitness": 0.8542322497261953, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.854 with standard deviation 0.008. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "5696b71e-de27-43a0-b8e4-0b539f64427c", "metadata": {"aucs": [0.8621770951197643, 0.8441192417763665, 0.8564004122824549], "final_y": [0.1264762299926997, 0.13980348613220406, 0.12382814629595706]}, "mutation_prompt": null}
{"id": "abde1602-6f54-4d0d-b9ce-0916e9ca5528", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.5\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.15  # Increased mutation scale for better exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.9 - 0.7 * (eval_count / self.budget)\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Improved Enhanced Adaptive Swarm Evolution Algorithm with dynamic inertia weight adjustment for better balance between exploration and exploitation.", "configspace": "", "generation": 11, "fitness": 0.8702929024535436, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.870 with standard deviation 0.007. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "5696b71e-de27-43a0-b8e4-0b539f64427c", "metadata": {"aucs": [0.8621062032030362, 0.8798071789841577, 0.8689653251734368], "final_y": [0.12155910041775453, 0.11810386456974853, 0.12014336641330048]}, "mutation_prompt": null}
{"id": "dc0397d1-8247-41a2-83e2-681f31fdaa37", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.5\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Improved Adaptive Swarm Evolution Algorithm with fine-tuned mutation scale for enhanced exploitation capabilities.", "configspace": "", "generation": 12, "fitness": 0.8885429822892883, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.889 with standard deviation 0.011. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "5696b71e-de27-43a0-b8e4-0b539f64427c", "metadata": {"aucs": [0.8751818193831121, 0.9010037347732298, 0.8894433927115231], "final_y": [0.11518058359197625, 0.11397937214449005, 0.11983106279544065]}, "mutation_prompt": null}
{"id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with improved social component for better convergence speed.", "configspace": "", "generation": 13, "fitness": 0.9016518207581709, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.902 with standard deviation 0.011. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "dc0397d1-8247-41a2-83e2-681f31fdaa37", "metadata": {"aucs": [0.9011197787362429, 0.914797993189745, 0.8890376903485248], "final_y": [0.11611950497229429, 0.11184680079723486, 0.11872027786356809]}, "mutation_prompt": null}
{"id": "634c2220-a6b8-4361-a27f-791ed494ac33", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.inertia_weight = 0.9 - 0.4 * eval_count / self.budget  # Adaptive inertia weight\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with adaptive inertia weight for improved exploration-exploitation balance.", "configspace": "", "generation": 14, "fitness": 0.8129187440343913, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.813 with standard deviation 0.035. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.809289055326312, 0.8579421921876299, 0.7715249845892324], "final_y": [0.14676127498770708, 0.12304660649992694, 0.16103211823244512]}, "mutation_prompt": null}
{"id": "802d0129-dde5-4359-ad6b-233c1d7db867", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.inertia_weight = 0.9 - 0.4 * (eval_count / self.budget)  # Dynamic inertia weight decay\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introduced a dynamic inertia weight decay strategy to enhance exploration in early iterations and exploitation in later stages.", "configspace": "", "generation": 15, "fitness": 0.8129187440343913, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.813 with standard deviation 0.035. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.809289055326312, 0.8579421921876299, 0.7715249845892324], "final_y": [0.14676127498770708, 0.12304660649992694, 0.161032118232445]}, "mutation_prompt": null}
{"id": "29f51493-3811-46d6-80c1-142ddfbca9cd", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.7  # Optimized inertia weight for improved balance\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with optimized inertia weight for improved exploration-exploitation balance.", "configspace": "", "generation": 16, "fitness": 0.855174588156563, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.855 with standard deviation 0.024. And the mean value of best solutions found was 0.128 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8220719836740804, 0.8662019063503206, 0.8772498744452879], "final_y": [0.135820999426286, 0.12890704309379797, 0.12032984873398123]}, "mutation_prompt": null}
{"id": "0d2fe662-3c54-40ae-a3b7-f33c06f06059", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.initial_social_component = 1.7  # Initial social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            current_social_component = self.initial_social_component * (1 - eval_count / self.budget)  # Adaptive scaling\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + current_social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introduced adaptive social component scaling to further enhance convergence speed.", "configspace": "", "generation": 17, "fitness": 0.8929601927472616, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.893 with standard deviation 0.010. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.9040070562553398, 0.8793399369977807, 0.8955335849886643], "final_y": [0.11437274964521127, 0.12243590597823595, 0.11901091526701069]}, "mutation_prompt": null}
{"id": "92e2ce73-87fe-4fda-85dc-1e9efcba7644", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.6  # Changed from 0.5 for better exploration-exploitation balance\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with increased inertia weight for better exploration-exploitation balance.", "configspace": "", "generation": 18, "fitness": 0.8733171244619378, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.873 with standard deviation 0.018. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8959094403547562, 0.8722387877943916, 0.8518031452366654], "final_y": [0.11743236244144828, 0.12747169190344432, 0.12028706866032668]}, "mutation_prompt": null}
{"id": "722cffea-a5de-40b9-bfe9-ced2e77b824e", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.8  # Increased cognitive component for improved individual exploration\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with increased cognitive component for improved individual exploration.", "configspace": "", "generation": 19, "fitness": 0.892948106065531, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.893 with standard deviation 0.017. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.9025580776085192, 0.9065717107775992, 0.8697145298104744], "final_y": [0.11491598139994497, 0.11477324424553736, 0.12400498852536257]}, "mutation_prompt": null}
{"id": "de012b5b-192a-4631-b9cb-926891e90fe6", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.9  # Changed from 0.5 for better exploration at the beginning\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Improved inertia weight adaptation for enhanced exploration-exploitation balance in swarm convergence.", "configspace": "", "generation": 20, "fitness": 0.7983242543975936, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.798 with standard deviation 0.021. And the mean value of best solutions found was 0.153 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8069093094688881, 0.8183945514001507, 0.7696689023237419], "final_y": [0.14459829045108497, 0.14523393831894904, 0.16768218482712904]}, "mutation_prompt": null}
{"id": "58c00301-894d-4edd-86bb-53dca4fac0e1", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm leveraging dynamic inertia weight for improved balance between exploration and exploitation.", "configspace": "", "generation": 21, "fitness": 0.8444901225114757, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.844 with standard deviation 0.015. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8297210513978406, 0.837945250660769, 0.8658040654758176], "final_y": [0.13229978229505057, 0.13043600684605916, 0.1285712175533128]}, "mutation_prompt": null}
{"id": "b769718c-cbec-4bff-aad8-7cf192bc3bae", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.9  # Start with a high inertia weight\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Update inertia weight dynamically\n            self.inertia_weight = 0.9 - (0.9 - 0.4) * (eval_count / self.budget)  # Nonlinear decrease from 0.9 to 0.4\n            \n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introduced nonlinear dynamic inertia weight to balance exploration and exploitation phases for improved convergence.", "configspace": "", "generation": 22, "fitness": 0.8072638093373868, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.807 with standard deviation 0.030. And the mean value of best solutions found was 0.146 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8133794748527168, 0.8401692347041159, 0.7682427184553282], "final_y": [0.14162642973808026, 0.13407262252942798, 0.16134974368550814]}, "mutation_prompt": null}
{"id": "6da3aa29-28a0-477f-b001-d3d6cb9ee515", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.3  # Adjusted cognitive component for balanced exploration\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with adjusted cognitive component for balanced exploration and exploitation.", "configspace": "", "generation": 23, "fitness": 0.870614723559436, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.871 with standard deviation 0.019. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8768963048213375, 0.8902179131014321, 0.8447299527555385], "final_y": [0.12467839084619703, 0.12133657225463557, 0.13107349718637784]}, "mutation_prompt": null}
{"id": "92119cc5-9a44-4174-b6e8-492fcd2f8e6e", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.6  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Refined Adaptive Swarm Evolution Algorithm with optimized inertia weight for improved convergence efficiency.", "configspace": "", "generation": 24, "fitness": 0.8733171244619378, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.873 with standard deviation 0.018. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8959094403547562, 0.8722387877943916, 0.8518031452366654], "final_y": [0.11743236244144828, 0.12747169190344432, 0.12028706866032668]}, "mutation_prompt": null}
{"id": "3c860134-823d-4026-87ee-111760a36b51", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.7  # Fine-tuned inertia weight for better balance\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with fine-tuned inertia weight for better balance between exploration and exploitation.", "configspace": "", "generation": 25, "fitness": 0.855174588156563, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.855 with standard deviation 0.024. And the mean value of best solutions found was 0.128 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8220719836740804, 0.8662019063503206, 0.8772498744452879], "final_y": [0.135820999426286, 0.12890704309379797, 0.12032984873398123]}, "mutation_prompt": null}
{"id": "ff694a02-7836-493a-a429-5c81e261a351", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.6  # Optimized cognitive component for improved exploration-exploitation balance\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with optimized cognitive component for improved exploration-exploitation balance.", "configspace": "", "generation": 26, "fitness": 0.8981810327040934, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.898 with standard deviation 0.011. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8953150140244553, 0.9132520619669107, 0.8859760221209142], "final_y": [0.1160904935758722, 0.11220868867870448, 0.11765749314285834]}, "mutation_prompt": null}
{"id": "cba39fb9-a4ea-468c-a3eb-0fe4decccbad", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.7  # Fine-tuned cognitive component for improved exploration\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in the population_size:\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with a fine-tuned cognitive component for improved individual exploration.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 33, 26, '            for i in the population_size:\\n', 33, 41)).", "error": "SyntaxError('invalid syntax', ('<string>', 33, 26, '            for i in the population_size:\\n', 33, 41))", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {}, "mutation_prompt": null}
{"id": "7589b59f-3d7a-408e-b22b-186bdfe1dce3", "solution": "import numpy as np\n\nclass HybridAdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12\n        self.de_scale_factor = 0.8  # Differential Evolution scale factor\n        self.de_crossover_rate = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Integrate Differential Evolution Strategy\n            for i in range(self.population_size):\n                a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                mutant = positions[a] + self.de_scale_factor * (positions[b] - positions[c])\n                j_rand = np.random.randint(self.dim)\n                trial = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.de_crossover_rate or j == j_rand:\n                        trial[j] = mutant[j]\n                if func(trial) < scores[i]:\n                    positions[i] = trial\n            \n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "HybridAdaptiveSwarmEvolutionAlgorithm", "description": "Hybrid Adaptive Swarm Evolution Algorithm integrating differential evolution for enhanced exploration and exploitation balance.", "configspace": "", "generation": 28, "fitness": 0.8545728184612634, "feedback": "The algorithm HybridAdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.855 with standard deviation 0.011. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8417085855865853, 0.86828536410849, 0.853724505688715], "final_y": [0.12524396797324322, 0.1212723141265808, 0.13148914283496682]}, "mutation_prompt": null}
{"id": "8b21a8db-9b22-4853-9e40-31d72135d3f7", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.7  # Updated cognitive component for adaptive balance\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Fine-tuned particle swarm algorithm with dynamic cognitive component for adaptive exploration-exploitation balance.", "configspace": "", "generation": 29, "fitness": 0.8913760902455256, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.891 with standard deviation 0.021. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8984292003270558, 0.9127902247934496, 0.8629088456160715], "final_y": [0.11522864532861454, 0.11264625790595517, 0.12623806170471474]}, "mutation_prompt": null}
{"id": "0839ceaa-a2b0-4d9d-8b60-9e2d2a946acd", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5  # This will be dynamically adjusted\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.inertia_weight = 0.9 - 0.8 * (eval_count / self.budget)  # Dynamic adjustment\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with dynamic inertia weight for better exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": 0.8626170147925155, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.863 with standard deviation 0.002. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8629686388263798, 0.8600089703416836, 0.8648734352094831], "final_y": [0.11455802679219673, 0.11991445899676689, 0.12414913697758378]}, "mutation_prompt": null}
{"id": "88de43da-96a4-4dda-8607-83103fa8e4aa", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            self.inertia_weight = 0.4 + 0.5 * (1 - eval_count / self.budget)  # Time-varying inertia weight\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introduced time-varying inertia weight for better balance between exploration and exploitation.", "configspace": "", "generation": 31, "fitness": 0.8444901225114757, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.844 with standard deviation 0.015. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8297210513978406, 0.837945250660769, 0.8658040654758176], "final_y": [0.13229978229505024, 0.13043600684605916, 0.1285712175533128]}, "mutation_prompt": null}
{"id": "be6fece5-3672-439f-ac01-bf822a60a88b", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Dynamic inertia weight adjustment\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introduced dynamic inertia weight adjustment to balance exploration and exploitation more effectively.", "configspace": "", "generation": 32, "fitness": 0.8444901225114757, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.844 with standard deviation 0.015. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8297210513978406, 0.837945250660769, 0.8658040654758176], "final_y": [0.13229978229505057, 0.13043600684605916, 0.1285712175533128]}, "mutation_prompt": null}
{"id": "83aef3f7-86d8-416c-916a-78eda37b67b5", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.inertia_weight = 0.9 - (0.5 * (eval_count / self.budget))  # Dynamic adjustment\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introduced a dynamic adjustment of inertia weight to balance exploration and exploitation in the swarm evolution.", "configspace": "", "generation": 33, "fitness": 0.8444901225114757, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.844 with standard deviation 0.015. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8297210513978406, 0.837945250660769, 0.8658040654758176], "final_y": [0.13229978229505057, 0.13043600684605916, 0.1285712175533128]}, "mutation_prompt": null}
{"id": "24dc3850-334d-4ec9-808d-80a20c48ced5", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.social_component = 1.7 * (1 - eval_count / self.budget)  # Dynamic adjustment\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introduced dynamic social component adjustment based on evaluation progress for improved convergence control.", "configspace": "", "generation": 34, "fitness": 0.8929601927472616, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.893 with standard deviation 0.010. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.9040070562553398, 0.8793399369977807, 0.8955335849886643], "final_y": [0.11437274964521127, 0.12243590597823595, 0.11901091526701069]}, "mutation_prompt": null}
{"id": "492d2004-c5a9-41d2-9a52-cd38169ce9c2", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.8  # Adjusted cognitive component for better personal best updates\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhance the convergence speed by fine-tuning the cognitive component.", "configspace": "", "generation": 35, "fitness": 0.892948106065531, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.893 with standard deviation 0.017. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.9025580776085192, 0.9065717107775992, 0.8697145298104744], "final_y": [0.11491598139994497, 0.11477324424553736, 0.12400498852536257]}, "mutation_prompt": null}
{"id": "eeee3115-3445-4b29-9547-039eb27738fc", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.6  # Increased cognitive component for better local search\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhance exploitation by slightly increasing the cognitive component to improve local search capabilities.", "configspace": "", "generation": 36, "fitness": 0.8981810327040934, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.898 with standard deviation 0.011. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8953150140244553, 0.9132520619669107, 0.8859760221209142], "final_y": [0.1160904935758722, 0.11220868867870448, 0.11765749314285834]}, "mutation_prompt": null}
{"id": "15b151b4-0153-4197-a670-64bb8ad99164", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5  # Initial inertia weight\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introduced a dynamic inertia weight to balance exploration and exploitation more effectively.", "configspace": "", "generation": 37, "fitness": 0.8444901225114757, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.844 with standard deviation 0.015. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8297210513978406, 0.837945250660769, 0.8658040654758176], "final_y": [0.13229978229505057, 0.13043600684605916, 0.1285712175533128]}, "mutation_prompt": null}
{"id": "2ae8a648-c822-4b95-a282-c23f3376baea", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.6  # Refined cognitive component for improved solution accuracy\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with a refined cognitive component for improved solution accuracy.", "configspace": "", "generation": 38, "fitness": 0.8981810327040934, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.898 with standard deviation 0.011. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8953150140244553, 0.9132520619669107, 0.8859760221209142], "final_y": [0.1160904935758722, 0.11220868867870448, 0.11765749314285834]}, "mutation_prompt": null}
{"id": "4d8e4f3f-6f24-446e-b20a-2234d7a48337", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.social_component = 1.5 + 0.2 * (1 - eval_count / self.budget)  # Dynamic adjustment\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introduced a dynamic social component adjustment based on evaluations to enhance convergence adaptability.", "configspace": "", "generation": 39, "fitness": 0.8992785812394081, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.899 with standard deviation 0.012. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.9009605566504472, 0.9135598080023372, 0.8833153790654402], "final_y": [0.11525927732735808, 0.1117159607774244, 0.12127664896042689]}, "mutation_prompt": null}
{"id": "fdd16185-c76c-426f-9a37-58b84c132a63", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            decay_factor = np.exp(-eval_count / self.budget)  # Exponentially decaying factor\n            velocities = (decay_factor * self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Incorporate an exponentially decaying inertia weight to balance exploration and exploitation.", "configspace": "", "generation": 40, "fitness": 0.8949721607810046, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.895 with standard deviation 0.018. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.9076055210638276, 0.9073563178357928, 0.8699546434433936], "final_y": [0.11494974124454471, 0.11179942513502261, 0.12641975861183274]}, "mutation_prompt": null}
{"id": "5479ee45-5ab2-4a2f-ba21-178988e61097", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.7  # Optimized inertia weight for better convergence\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Optimized inertia weight for enhanced exploration-exploitation balance.", "configspace": "", "generation": 41, "fitness": 0.855174588156563, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.855 with standard deviation 0.024. And the mean value of best solutions found was 0.128 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8220719836740804, 0.8662019063503206, 0.8772498744452879], "final_y": [0.135820999426286, 0.12890704309379797, 0.12032984873398123]}, "mutation_prompt": null}
{"id": "c99097f3-0f94-4be2-94d0-5bee7d0b75ba", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            self.mutation_scale *= (1 - eval_count / self.budget)  # Adaptive mutation scale\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Adaptive mutation scale based on iteration progress for improved exploitation and exploration balance.", "configspace": "", "generation": 42, "fitness": 0.9015916899021782, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.902 with standard deviation 0.011. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.9009948861222374, 0.9147503412198518, 0.8890298423644454], "final_y": [0.11622889866804453, 0.11186101753024247, 0.11872748216575502]}, "mutation_prompt": null}
{"id": "07ef9c6e-431e-4de3-8a97-2c988b25e287", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.inertia_weight = 0.5 + 0.4 * (1 - eval_count / self.budget)  # Dynamic inertia weight adaptation\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introducing a dynamic inertia weight adaptation for improved convergence and exploration balance.", "configspace": "", "generation": 43, "fitness": 0.8129187440343913, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.813 with standard deviation 0.035. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.809289055326312, 0.8579421921876299, 0.7715249845892324], "final_y": [0.14676127498770697, 0.12304660649992694, 0.161032118232445]}, "mutation_prompt": null}
{"id": "f911c26c-1a00-4c5f-9c98-6eb20c142130", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with improved social component for better convergence speed.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: InternalServerError(\"Error code: 500 - {'error': {'message': 'The server had an error processing your request. Sorry about that! You can retry your request, or contact us through our help center at help.openai.com if you keep seeing this error. (Please include the request ID req_d86b49f9180485028eeeee30fd05a2e8 in your email.)', 'type': 'server_error', 'param': None, 'code': None}}\").", "error": "InternalServerError(\"Error code: 500 - {'error': {'message': 'The server had an error processing your request. Sorry about that! You can retry your request, or contact us through our help center at help.openai.com if you keep seeing this error. (Please include the request ID req_d86b49f9180485028eeeee30fd05a2e8 in your email.)', 'type': 'server_error', 'param': None, 'code': None}}\")", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.9011197787362429, 0.914797993189745, 0.8890376903485248], "final_y": [0.11611950497229429, 0.11184680079723486, 0.11872027786356809]}, "mutation_prompt": null}
{"id": "7f6697d9-a8cc-4923-8389-47482705f9ac", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with improved social component for better convergence speed.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: InternalServerError(\"Error code: 500 - {'error': {'message': 'The server had an error processing your request. Sorry about that! You can retry your request, or contact us through our help center at help.openai.com if you keep seeing this error. (Please include the request ID req_3f43ad74bcfe0ede7c9000f7b031c3ab in your email.)', 'type': 'server_error', 'param': None, 'code': None}}\").", "error": "InternalServerError(\"Error code: 500 - {'error': {'message': 'The server had an error processing your request. Sorry about that! You can retry your request, or contact us through our help center at help.openai.com if you keep seeing this error. (Please include the request ID req_3f43ad74bcfe0ede7c9000f7b031c3ab in your email.)', 'type': 'server_error', 'param': None, 'code': None}}\")", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.9011197787362429, 0.914797993189745, 0.8890376903485248], "final_y": [0.11611950497229429, 0.11184680079723486, 0.11872027786356809]}, "mutation_prompt": null}
{"id": "a94b59aa-b545-40ac-869c-2e0005ba6cbd", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + (self.social_component + 0.3 * (1 - eval_count / self.budget)) * r2 * (global_best_position - positions))  # Adjusted social component\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with dynamic social component adjustment for improved exploration-exploitation balance.", "configspace": "", "generation": 46, "fitness": 0.8475530598221429, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.848 with standard deviation 0.024. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8754961613366254, 0.8495596123116663, 0.8176034058181367], "final_y": [0.12265949814165167, 0.14012787483058808, 0.13938702714818363]}, "mutation_prompt": null}
{"id": "3d3d8672-1c74-43e5-8ce9-e03d3e4732e5", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.9  # Changed inertia weight to a variable value\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introduced a variable inertia weight for better exploration and exploitation balance.", "configspace": "", "generation": 47, "fitness": 0.7983242543975936, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.798 with standard deviation 0.021. And the mean value of best solutions found was 0.153 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8069093094688881, 0.8183945514001507, 0.7696689023237419], "final_y": [0.14459829045108497, 0.14523393831894904, 0.16768218482712904]}, "mutation_prompt": null}
{"id": "abe9a399-3d4c-41bd-9e0d-2b573202d3af", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = ((self.inertia_weight * (1 + 0.5 * (eval_count / self.budget))) * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Improved Adaptive Swarm Evolution Algorithm with enhanced social component and inertia adjustment for better convergence balance.", "configspace": "", "generation": 48, "fitness": 0.8892471258205342, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.889 with standard deviation 0.013. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.9045516929727002, 0.8899934157038529, 0.8731962687850499], "final_y": [0.11499100245206162, 0.12103543784504578, 0.12264797302507391]}, "mutation_prompt": null}
{"id": "70dbfc5e-d398-4a3e-b7f5-5bec1c264561", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            dynamic_social_component = self.social_component * (1 - eval_count / self.budget)  # Dynamic adjustment\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + dynamic_social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introduced dynamic social component scaling for improved convergence adaptability.", "configspace": "", "generation": 49, "fitness": 0.8929601927472616, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.893 with standard deviation 0.010. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.9040070562553398, 0.8793399369977807, 0.8955335849886643], "final_y": [0.11437274964521127, 0.12243590597823595, 0.11901091526701069]}, "mutation_prompt": null}
{"id": "c629502b-89ad-4371-bfca-d55bc45230a0", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            current_cognitive_component = self.cognitive_component * (1 - eval_count / self.budget)\n            velocities = (self.inertia_weight * velocities\n                          + current_cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introduced dynamic cognitive component to balance exploration and exploitation throughout the optimization process.", "configspace": "", "generation": 50, "fitness": 0.8728473062357188, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.873 with standard deviation 0.025. And the mean value of best solutions found was 0.126 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8806104579891545, 0.8988743474076939, 0.8390571133103083], "final_y": [0.12259335729762355, 0.11869389460915802, 0.13644565981691004]}, "mutation_prompt": null}
{"id": "30f2e8fd-1d7f-4da8-ac90-24937f14c65b", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.inertia_weight = max(0.3, 0.5 * (1 - eval_count / self.budget))  # Decay-based inertia\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with decay-based inertia for improved exploration-exploitation balance.", "configspace": "", "generation": 51, "fitness": 0.8963551065344358, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.896 with standard deviation 0.019. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.9079994651596963, 0.91100092932269, 0.8700649251209214], "final_y": [0.11482441963779777, 0.11200958201754407, 0.12608571412762393]}, "mutation_prompt": null}
{"id": "977ad43b-eb60-4b72-af42-d52fb8fc4597", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.9 - (0.5 * (eval_count / self.budget))\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with dynamic inertia weight adjustment for improved convergence and exploration balance.", "configspace": "", "generation": 52, "fitness": 0.8444901225114757, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.844 with standard deviation 0.015. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8297210513978406, 0.837945250660769, 0.8658040654758176], "final_y": [0.13229978229505057, 0.13043600684605916, 0.1285712175533128]}, "mutation_prompt": null}
{"id": "6d23a150-5725-406f-8543-c10641178238", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.6  # Optimized cognitive component for better individual learning\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with an optimized cognitive component for better individual learning.", "configspace": "", "generation": 53, "fitness": 0.8981810327040934, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.898 with standard deviation 0.011. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8953150140244553, 0.9132520619669107, 0.8859760221209142], "final_y": [0.1160904935758722, 0.11220868867870448, 0.11765749314285834]}, "mutation_prompt": null}
{"id": "a542087b-c308-41ef-b2ce-e505a8e48f42", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + (self.social_component * (1 - eval_count/self.budget)) * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with a dynamically adjusted social component for improved convergence speed.", "configspace": "", "generation": 54, "fitness": 0.8929601927472616, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.893 with standard deviation 0.010. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.9040070562553398, 0.8793399369977807, 0.8955335849886643], "final_y": [0.11437274964521127, 0.12243590597823595, 0.11901091526701069]}, "mutation_prompt": null}
{"id": "87613b6e-4fef-424a-9321-b76c22aad298", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        # Dynamic social component for enhanced exploration and convergence\n        self.social_component = 1.7 + 0.3 * (np.random.rand() - 0.5)  \n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introducing a dynamic social component to enhance global exploration and convergence in a swarm-based optimization algorithm.", "configspace": "", "generation": 55, "fitness": 0.8643289884533062, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.864 with standard deviation 0.029. And the mean value of best solutions found was 0.128 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8324217938950433, 0.9019447908972369, 0.8586203805676382], "final_y": [0.13992096996917858, 0.1161201448754714, 0.12910057730143265]}, "mutation_prompt": null}
{"id": "e5f399a8-608e-4a9a-9489-277cc4e619d1", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Initialize with higher inertia weight\n        self.cognitive_component = 1.5\n        self.social_component = 1.9  # Slightly increased for better convergence\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        chaos = np.random.rand(self.population_size)  # Initialize chaotic map\n        while eval_count < self.budget:\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n            \n            positions = np.clip(positions, lb, ub)\n            \n            self.inertia_weight = 0.4 + 0.5 * (1 - eval_count / self.budget)  # Dynamic inertia weight\n            chaos = 4 * chaos * (1 - chaos)  # Logistic map for chaos\n\n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Incorporate dynamic inertia weight and chaotic map strategies to enhance exploration-exploitation balance.", "configspace": "", "generation": 56, "fitness": 0.8214082746474887, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.821 with standard deviation 0.035. And the mean value of best solutions found was 0.145 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8139835421467008, 0.8675199172344821, 0.7827213645612833], "final_y": [0.15118851204929684, 0.12112724730220292, 0.16403121387519648]}, "mutation_prompt": null}
{"id": "0113052f-f7f2-4381-bbd3-35096e589258", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * (1 - eval_count / self.budget) * velocities  # Inertia weight decay\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with strategic inertia weight decay for improved convergence precision.", "configspace": "", "generation": 57, "fitness": 0.8960908286893269, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.896 with standard deviation 0.018. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.907305924518858, 0.9108273766859616, 0.8701391848631608], "final_y": [0.11522143540913599, 0.11206713083967679, 0.126269297148365]}, "mutation_prompt": null}
{"id": "fce93a59-e258-45ac-a185-5bf06adca948", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.75  # Slightly increased social component for further improved convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "A minor adjustment in the social component to further enhance convergence speed.", "configspace": "", "generation": 58, "fitness": 0.877926559857794, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.878 with standard deviation 0.034. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8981449981825369, 0.9056619031916139, 0.8299727781992317], "final_y": [0.1148047106538268, 0.11198097378841909, 0.1398252054959629]}, "mutation_prompt": null}
{"id": "0a5c7b88-e2d5-42f0-bc8c-b5738110bb88", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Dynamic adjustment for better convergence balance\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.social_component = 1.5 + 0.2 * np.tanh(eval_count / self.budget)  # Dynamic adjustment\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Refined Adaptive Swarm Evolution Algorithm with dynamically adjusted social component for improved convergence balance.", "configspace": "", "generation": 59, "fitness": 0.8807518749497261, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.881 with standard deviation 0.007. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.878049253404975, 0.8733636196385715, 0.8908427518056317], "final_y": [0.11355158385414299, 0.13033223545197092, 0.12027787368194143]}, "mutation_prompt": null}
{"id": "a1f83a8c-96f7-4d63-bfda-de9ded59e9d7", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introduced dynamic inertia weight for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": 0.8444901225114757, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.844 with standard deviation 0.015. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8297210513978406, 0.837945250660769, 0.8658040654758176], "final_y": [0.13229978229505057, 0.13043600684605916, 0.1285712175533128]}, "mutation_prompt": null}
{"id": "557176c9-1368-4096-a140-3d5ac686af46", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.6  # Slight increase in cognitive component for enhanced individual learning\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Refined Adaptive Swarm Evolution Algorithm by slightly increasing the cognitive component to enhance individual learning.", "configspace": "", "generation": 61, "fitness": 0.8981810327040934, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.898 with standard deviation 0.011. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8953150140244553, 0.9132520619669107, 0.8859760221209142], "final_y": [0.1160904935758722, 0.11220868867870448, 0.11765749314285834]}, "mutation_prompt": null}
{"id": "c093fdda-feb5-4f2f-942a-452f007e625a", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.7  # Modified inertia weight for better exploration\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Modified inertia weight to increase exploration at the start and improve convergence speed.", "configspace": "", "generation": 62, "fitness": 0.855174588156563, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.855 with standard deviation 0.024. And the mean value of best solutions found was 0.128 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8220719836740804, 0.8662019063503206, 0.8772498744452879], "final_y": [0.135820999426286, 0.12890704309379797, 0.12032984873398123]}, "mutation_prompt": null}
{"id": "47d0a5e0-7a7e-40f8-93d6-c33e03411243", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * (self.mutation_scale * (1 - eval_count / self.budget))\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with improved mutation scale adaptation for better exploration and convergence.", "configspace": "", "generation": 63, "fitness": 0.9016456949507523, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.902 with standard deviation 0.011. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.9011214390641137, 0.9147798224469912, 0.8890358233411517], "final_y": [0.11611667937679782, 0.11185221844902649, 0.11872232950701056]}, "mutation_prompt": null}
{"id": "e30b38a6-50f6-497d-89fd-91018a85a74b", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.8  # Refined social component for improved convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Further optimize the convergence speed by refining the balance between exploration and exploitation using a 1.8 social component.", "configspace": "", "generation": 64, "fitness": 0.8673537509722475, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.867 with standard deviation 0.030. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8826577581938684, 0.8936221615202745, 0.8257813332026], "final_y": [0.11901700831551043, 0.11572017689680991, 0.13979580448282014]}, "mutation_prompt": null}
{"id": "9fa05eb8-d4c0-4e75-8933-e22cff0b602e", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.8  # Refined cognitive component for improved exploration\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with a refined cognitive component for improved individual exploration.", "configspace": "", "generation": 65, "fitness": 0.892948106065531, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.893 with standard deviation 0.017. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.9025580776085192, 0.9065717107775992, 0.8697145298104744], "final_y": [0.11491598139994497, 0.11477324424553736, 0.12400498852536257]}, "mutation_prompt": null}
{"id": "ab19481d-89c7-4b5f-b4be-9d54b7fcc554", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            dynamic_inertia_weight = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Dynamically adjust inertia weight\n            velocities = (dynamic_inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhance the convergence rate by adjusting the inertia weight dynamically based on the evaluation progress.", "configspace": "", "generation": 66, "fitness": 0.8185154082340125, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.819 with standard deviation 0.015. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8394598670981093, 0.8115769772525149, 0.8045093803514133], "final_y": [0.13312924504151247, 0.1379793241891888, 0.15364142747283127]}, "mutation_prompt": null}
{"id": "54c5b29a-e3d7-4cbd-a725-73fbeb0eca18", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamically adjust inertia weight\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introduced dynamic inertia weight for enhanced exploration and exploitation balance.", "configspace": "", "generation": 67, "fitness": 0.8444901225114757, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.844 with standard deviation 0.015. And the mean value of best solutions found was 0.130 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8297210513978406, 0.837945250660769, 0.8658040654758176], "final_y": [0.13229978229505057, 0.13043600684605916, 0.1285712175533128]}, "mutation_prompt": null}
{"id": "5005437b-0c2b-4a92-b84a-b218d56777eb", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.6  # Optimized inertia weight for better balance\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with optimized inertia weight for improved exploration-exploitation balance.", "configspace": "", "generation": 68, "fitness": 0.8733171244619378, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.873 with standard deviation 0.018. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8959094403547562, 0.8722387877943916, 0.8518031452366654], "final_y": [0.11743236244144828, 0.12747169190344432, 0.12028706866032668]}, "mutation_prompt": null}
{"id": "4c54243b-91e8-4770-b71b-32aca862e95f", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.social_component = 1.7 + 0.3 * (eval_count / self.budget)  # Dynamic scaling\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with dynamic social component scaling based on evaluation progress for improved adaptability.", "configspace": "", "generation": 69, "fitness": 0.8943376824509103, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.894 with standard deviation 0.016. And the mean value of best solutions found was 0.117 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8928394130840042, 0.9141291562899541, 0.8760444779787728], "final_y": [0.11424476776998949, 0.11260654874722198, 0.12441538139868213]}, "mutation_prompt": null}
{"id": "925c12c7-5b2b-4e86-a266-0585902ef28f", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Changed line below for dynamic social component\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * (1 + eval_count / self.budget) * r2 * (global_best_position - positions))  # Dynamically scale social component\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introduce a dynamic social component to enhance convergence by scaling it based on global improvement.", "configspace": "", "generation": 70, "fitness": 0.856660301401575, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.857 with standard deviation 0.036. And the mean value of best solutions found was 0.132 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.8958811410062805, 0.8649755940922664, 0.809124169106178], "final_y": [0.11762993458943283, 0.12320610755164263, 0.15368675145912936]}, "mutation_prompt": null}
{"id": "13d39506-1101-4f4d-b430-81a2d6e3c510", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.72  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Slightly increase the social component to further enhance convergence speed.", "configspace": "", "generation": 71, "fitness": 0.8977099088983834, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.898 with standard deviation 0.010. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.9082395330391577, 0.9008865459670315, 0.8840036476889611], "final_y": [0.1136996801175405, 0.11462151968926748, 0.11881044580666078]}, "mutation_prompt": null}
{"id": "3e811581-b45b-463c-9115-5053cfd73807", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.12  # Fine-tuned mutation scale for enhanced exploitation\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = ((0.9 - (0.9 - self.inertia_weight) * eval_count / self.budget) * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced Adaptive Swarm Evolution Algorithm with dynamic inertia adjustment for improved exploration-exploitation balance.", "configspace": "", "generation": 72, "fitness": 0.8129187440343913, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.813 with standard deviation 0.035. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.809289055326312, 0.8579421921876299, 0.7715249845892324], "final_y": [0.14676127498770708, 0.12304660649992694, 0.16103211823244512]}, "mutation_prompt": null}
{"id": "f9034072-62bc-4daa-9134-bf8328f3dfb1", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.14  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Slightly enhanced the mutation scale for better exploration and exploitation balance.", "configspace": "", "generation": 73, "fitness": 0.901652149017135, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.902 with standard deviation 0.011. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "61eb0d4c-db12-4b4a-97eb-d95bb5bd4b1a", "metadata": {"aucs": [0.9011064620008281, 0.9148120061326044, 0.8890379789179726], "final_y": [0.11609591531641716, 0.11184479917967072, 0.11871953256279077]}, "mutation_prompt": null}
{"id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced exploration by increasing mutation scale to improve search diversity.", "configspace": "", "generation": 74, "fitness": 0.9016548661015391, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.902 with standard deviation 0.011. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "f9034072-62bc-4daa-9134-bf8328f3dfb1", "metadata": {"aucs": [0.9011008983528931, 0.9148255374054931, 0.8890381625462311], "final_y": [0.11612424000763333, 0.11184305038307374, 0.11871883169018516]}, "mutation_prompt": null}
{"id": "089957e2-403b-4e78-96b2-7137140204f0", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale * (self.budget - eval_count) / self.budget\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Leverage adaptive mutation scale for improved exploration and exploitation balance.", "configspace": "", "generation": 75, "fitness": 0.9016532370131153, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.902 with standard deviation 0.011. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.9011201467490203, 0.914803487840069, 0.8890360764502562], "final_y": [0.11611734393385287, 0.11184906591836064, 0.11872138730264892]}, "mutation_prompt": null}
{"id": "d40c5c5f-d3b7-4671-9dcf-4b9f00f9b286", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.8  # Refined social component for improved convergence\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Refined social component for improved convergence by adjusting exploration-exploitation balance.", "configspace": "", "generation": 76, "fitness": 0.8673962405950432, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.867 with standard deviation 0.030. And the mean value of best solutions found was 0.125 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.8826522162108854, 0.8936208213044375, 0.8259156842698062], "final_y": [0.11898265440201394, 0.11573517766532115, 0.13949893591794182]}, "mutation_prompt": null}
{"id": "2a22cbf5-3414-419a-84df-90023c79c50c", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introduced a dynamic inertia weight to enable better exploitation-exploration balance.", "configspace": "", "generation": 77, "fitness": 0.8445170169099413, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.845 with standard deviation 0.015. And the mean value of best solutions found was 0.131 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.8296519523907524, 0.8380587447705609, 0.8658403535685109], "final_y": [0.13331724520474808, 0.13000131288518602, 0.12855939217771517]}, "mutation_prompt": null}
{"id": "0eab28ac-fa61-4846-9a81-95676ec1003e", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.inertia_weight = 0.9 - (eval_count / self.budget) * 0.4  # Dynamic inertia weight\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Apply a dynamic inertia weight adjustment for better balance between exploration and exploitation.", "configspace": "", "generation": 78, "fitness": 0.8129365398130727, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.813 with standard deviation 0.035. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.8093835002896552, 0.8579387780104721, 0.7714873411390907], "final_y": [0.1467559395813396, 0.12303464835211186, 0.16105254746333075]}, "mutation_prompt": null}
{"id": "02980cd8-0e3c-4081-9264-52931ab81b66", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.6  # Adjusted inertia weight for balanced dynamics\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Refine swarm dynamics by adjusting inertia weight for balanced exploration and exploitation.", "configspace": "", "generation": 79, "fitness": 0.8726044333797461, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.873 with standard deviation 0.019. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.8958506810741702, 0.8722673125560004, 0.8496953065090675], "final_y": [0.11746082044650508, 0.12746322488442197, 0.12442733820452911]}, "mutation_prompt": null}
{"id": "332a1a65-5ce4-4082-b0e8-5569ef77026d", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation with dynamic mutation scale\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            dynamic_mutation_scale = self.mutation_scale * (global_best_score / np.mean(scores))\n            positions += mutation_mask * mutations * dynamic_mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Improved search by dynamically adjusting the mutation scale based on convergence rate.", "configspace": "", "generation": 80, "fitness": 0.9016446029259715, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.902 with standard deviation 0.011. And the mean value of best solutions found was 0.116 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.9011086118565251, 0.9147881394387848, 0.8890370574826048], "final_y": [0.11609580485358428, 0.11184664992864635, 0.11871993527225388]}, "mutation_prompt": null}
{"id": "947f6207-2b93-4973-8e16-dd51e32f3fac", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + (self.social_component * (1 - eval_count / self.budget)) * r2 * (global_best_position - positions))  # Adjusting social component dynamically\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introduces dynamic adjustment of the social component for improved convergence control.", "configspace": "", "generation": 81, "fitness": 0.8929563531509769, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.893 with standard deviation 0.010. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.9040062486337399, 0.8793251198185501, 0.8955376910006407], "final_y": [0.11437308142318658, 0.12244830877341928, 0.11900808928150908]}, "mutation_prompt": null}
{"id": "9a2fdbbc-030c-4b23-b5b9-32c28934caa6", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            decay_factor = 1 - eval_count / self.budget  # Introduce decay factor\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + decay_factor * self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introduce a decay factor on the social component to balance exploration and exploitation dynamically.", "configspace": "", "generation": 82, "fitness": 0.8929563531509769, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.893 with standard deviation 0.010. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.9040062486337399, 0.8793251198185501, 0.8955376910006407], "final_y": [0.11437308142318658, 0.12244830877341928, 0.11900808928150908]}, "mutation_prompt": null}
{"id": "9d7b0768-703d-4540-9aa0-80d44bd7e93e", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.6  # Adjusted inertia weight for better velocity control\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced exploration and exploitation balance by fine-tuning the inertia weight for adaptive velocity adjustments.", "configspace": "", "generation": 83, "fitness": 0.8726044333797461, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.873 with standard deviation 0.019. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.8958506810741702, 0.8722673125560004, 0.8496953065090675], "final_y": [0.11746082044650508, 0.12746322488442197, 0.12442733820452911]}, "mutation_prompt": null}
{"id": "cce03caf-bf19-4d6d-8066-e216b2294ccc", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.4  # Adjusted cognitive component for improved balance\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in  range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Refine strategy by adjusting cognitive component for improved individual search balance.", "configspace": "", "generation": 84, "fitness": 0.8786779517238453, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.879 with standard deviation 0.026. And the mean value of best solutions found was 0.124 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.8899394485504782, 0.9030493298223378, 0.84304507679872], "final_y": [0.11997127638219485, 0.11653639055734832, 0.13515152073608316]}, "mutation_prompt": null}
{"id": "21a63b74-b385-4b4e-b639-26894b7a54c5", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.inertia_weight = 0.9 - 0.4 * (eval_count / self.budget)  # Adaptive inertia weight\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Utilize adaptive inertia for dynamic exploration-exploitation balance within the swarm.", "configspace": "", "generation": 85, "fitness": 0.8129365398130727, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.813 with standard deviation 0.035. And the mean value of best solutions found was 0.144 (0. is the best) with standard deviation 0.016.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.8093835002896552, 0.8579387780104721, 0.7714873411390907], "final_y": [0.1467559395813396, 0.12303464835211186, 0.16105254746333075]}, "mutation_prompt": null}
{"id": "ad5ae650-359c-4c92-b4f9-6104e06b5ca5", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.social_component = 1.5 + 0.5 * (1 - eval_count / self.budget)  # Dynamic social component\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced exploration by varying social component dynamically to improve convergence.", "configspace": "", "generation": 86, "fitness": 0.8646122501597951, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.865 with standard deviation 0.015. And the mean value of best solutions found was 0.123 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.87479106878423, 0.8760166932792754, 0.8430289884158799], "final_y": [0.12425673909446744, 0.1273733250351936, 0.11838425550316045]}, "mutation_prompt": null}
{"id": "3b3bb9d0-72c9-416b-b453-bd1793cfdf80", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.55  # Increased inertia for better exploration-exploitation balance\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced exploration and exploitation balance by slightly increasing inertia weight.", "configspace": "", "generation": 87, "fitness": 0.8850866068352636, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.885 with standard deviation 0.016. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.9029239913843476, 0.887918838548992, 0.8644169905724512], "final_y": [0.11688644122784142, 0.12033759840258584, 0.12137738012953214]}, "mutation_prompt": null}
{"id": "6ae7dad3-ee91-4e1d-8c41-fbc8823a1926", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.6  # Adjusted cognitive component for better personal best exploitation\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in 0 to self.population_size-1:\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Adjusted the cognitive component to enhance personal best exploitation and balance exploration.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 33, 24, '            for i in 0 to self.population_size-1:\\n', 33, 26)).", "error": "SyntaxError('invalid syntax', ('<string>', 33, 24, '            for i in 0 to self.population_size-1:\\n', 33, 26))", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {}, "mutation_prompt": null}
{"id": "9b543133-a020-4344-b4e8-0bf1c6a76afb", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.7  # Increased inertia for better exploration\n        self.cognitive_component = 1.4  # Reduced cognitive component for balance\n        self.social_component = 1.8  # Modified social component for stronger convergence\n        self.adaptive_mutation_rate = 0.05  # Reduced adaptive mutation rate\n        self.mutation_scale = 0.12  # Further refined mutation scale for exploration\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            dynamic_mutation_scale = self.mutation_scale * (1 + eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * dynamic_mutation_scale\n\n            positions = np.clip(positions, lb, ub)\n\n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Improved swarm adaptation through dynamic parameter adjustment for enhanced convergence and exploration. ", "configspace": "", "generation": 89, "fitness": 0.8184428808081919, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.818 with standard deviation 0.035. And the mean value of best solutions found was 0.146 (0. is the best) with standard deviation 0.017.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.8367816093782195, 0.8487552685267159, 0.7697917645196407], "final_y": [0.1379349087617261, 0.13058405981229693, 0.16936259326899294]}, "mutation_prompt": null}
{"id": "ba785403-d8e6-4d86-a2c3-a3e83c507b18", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            # Nonlinear inertia weight adaptation\n            inertia_weight = self.inertia_weight * (1 - eval_count / self.budget) ** 0.5\n            velocities = (inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introduced nonlinear inertia weight adaptation for improved convergence dynamics.", "configspace": "", "generation": 90, "fitness": 0.8980387629844525, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.898 with standard deviation 0.020. And the mean value of best solutions found was 0.118 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.9066100173656659, 0.9164658275337444, 0.8710404440539473], "final_y": [0.1150402845859625, 0.11169240506689837, 0.12585838320054166]}, "mutation_prompt": null}
{"id": "bd0cfbe2-b398-4b6f-8aa2-6360b90590db", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.75  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Improved convergence speed by slightly increasing social influence, enhancing solution accuracy.", "configspace": "", "generation": 91, "fitness": 0.8779469388763896, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.878 with standard deviation 0.034. And the mean value of best solutions found was 0.122 (0. is the best) with standard deviation 0.013.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.898154587647708, 0.9056796730732579, 0.8300065559082033], "final_y": [0.11481371822500841, 0.11179647253712444, 0.1398262629228333]}, "mutation_prompt": null}
{"id": "d1925e4c-be84-4d72-a36b-e9722be2ead7", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.6  # Fine-tuned cognitive component for better personal best attraction\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in the range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced convergence by fine-tuning the cognitive component for improved personal best attraction.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 33, 26, '            for i in the range(self.population_size):\\n', 33, 31)).", "error": "SyntaxError('invalid syntax', ('<string>', 33, 26, '            for i in the range(self.population_size):\\n', 33, 31))", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {}, "mutation_prompt": null}
{"id": "b08098eb-f8dc-4bb2-a6a6-2d656e83ce47", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.9  # Dynamic inertia weight starts high\n        self.cognitive_component = 1.5\n        self.social_component = 1.8  # Slightly enhanced social component\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = lb + (ub - lb) * np.random.rand(self.population_size, self.dim) ** 2  # Chaotic initialization\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Dynamic inertia weight\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Gradually decrease\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introduce dynamic inertia weight and chaotic initialization to enhance exploration and convergence speed.", "configspace": "", "generation": 93, "fitness": 0.8481341635302028, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.848 with standard deviation 0.023. And the mean value of best solutions found was 0.134 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.8730228703539529, 0.8181050580189796, 0.853274562217676], "final_y": [0.12597645487862275, 0.1498450958169658, 0.12648600903336404]}, "mutation_prompt": null}
{"id": "f05f6aca-7093-4ab0-b7d8-297190454aac", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.9  # Improved social component for stronger information sharing\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n            \n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Improve convergence by increasing the social component for stronger information sharing.", "configspace": "", "generation": 94, "fitness": 0.8592543089387319, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.859 with standard deviation 0.015. And the mean value of best solutions found was 0.127 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.8591223488373839, 0.8774007387331735, 0.841239839245638], "final_y": [0.13035654793263296, 0.1263281716479422, 0.12365079661698997]}, "mutation_prompt": null}
{"id": "1f258e3d-5161-428a-932e-eb3783998bbc", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Dynamic update of the cognitive and social components\n            self.cognitive_component = max(0.5, 2.0 - (1.0 * eval_count / self.budget))\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Introduce Dynamic Cognitive and Social Components for Improved Balance between Exploration and Exploitation.", "configspace": "", "generation": 95, "fitness": 0.8842727367102049, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.884 with standard deviation 0.017. And the mean value of best solutions found was 0.121 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.9003510381104401, 0.8918406906945504, 0.8606264813256242], "final_y": [0.11474349100772419, 0.12274310963963697, 0.12650315685994773]}, "mutation_prompt": null}
{"id": "b2983fac-f99e-4e0e-91b2-336ad722d153", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.6  # Adjusted cognitive component for better individual search\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Improved convergence speed and final solution quality by slightly enhancing the cognitive component.", "configspace": "", "generation": 96, "fitness": 0.8981732094320902, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.898 with standard deviation 0.011. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.8953073539237354, 0.9132648718984765, 0.885947402474059], "final_y": [0.11612740010403766, 0.11220793323691436, 0.11766734659626477]}, "mutation_prompt": null}
{"id": "1c1f4ebc-abb9-4afc-a287-95e31b2c4c85", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.48  # Decreased inertia weight for improved convergence\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Refine exploration by slightly decreasing inertia weight for improved balance between exploration and exploitation.", "configspace": "", "generation": 97, "fitness": 0.892887947222443, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.893 with standard deviation 0.022. And the mean value of best solutions found was 0.119 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.9063367870170679, 0.9104536400946363, 0.8618734145556248], "final_y": [0.11479781741784023, 0.11212856073405608, 0.12872277375066754]}, "mutation_prompt": null}
{"id": "898b2253-dcaa-4f37-ac84-0bdb992fe265", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.73  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced convergence by slightly increasing the social component for more effective global learning.", "configspace": "", "generation": 98, "fitness": 0.8850916013795581, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.885 with standard deviation 0.030. And the mean value of best solutions found was 0.120 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.9085944718698761, 0.9045663997148189, 0.8421139325539794], "final_y": [0.11343843106448348, 0.11189933836446264, 0.13506862137999454]}, "mutation_prompt": null}
{"id": "f34b5240-577e-4f7b-ba01-456ee14cb066", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Typical swarm size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.7  # Improved social component for better convergence speed\n        self.adaptive_mutation_rate = 0.1\n        self.mutation_scale = 0.16  # Changed mutation scale for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize swarm positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n        \n        eval_count = 0\n        \n        while eval_count < self.budget:\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = positions[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = positions[i]\n            \n            # Update velocities and positions\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.inertia_weight *= 0.99  # Non-linear inertia weight decay\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_component * r1 * (personal_best_positions - positions)\n                          + self.social_component * r2 * (global_best_position - positions))\n            positions += velocities\n            \n            # Adaptive mutation\n            mutation_rate = self.adaptive_mutation_rate * (1 - eval_count / self.budget)\n            mutations = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            positions += mutation_mask * mutations * self.mutation_scale\n\n            # Ensure positions are within bounds\n            positions = np.clip(positions, lb, ub)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveSwarmEvolutionAlgorithm", "description": "Enhanced exploration by introducing non-linear inertia weight decay for better convergence.", "configspace": "", "generation": 99, "fitness": 0.9028380892871972, "feedback": "The algorithm AdaptiveSwarmEvolutionAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.903 with standard deviation 0.011. And the mean value of best solutions found was 0.115 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "09de140a-9167-4740-bb9d-5b93f1c37ac7", "metadata": {"aucs": [0.9054055933867158, 0.9153368557738146, 0.8877718187010613], "final_y": [0.11581160054953832, 0.11189264868782367, 0.11865128435690964]}, "mutation_prompt": null}
