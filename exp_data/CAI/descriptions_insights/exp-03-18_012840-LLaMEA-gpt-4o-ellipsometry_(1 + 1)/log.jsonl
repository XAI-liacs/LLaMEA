{"id": "3780aace-c3fb-4a0e-be39-7cf364d42bfd", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + np.random.rand() / 2\n            c1 = c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.9\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization (PSO) with Adaptive Differential Evolution (DE) crossover strategy for enhanced exploration and exploitation in black-box optimization problems.", "configspace": "", "generation": 0, "fitness": 0.22401872227633468, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.224 with standard deviation 0.021. And the mean value of best solutions found was 0.145 (0. is the best) with standard deviation 0.113.", "error": "", "parent_id": null, "metadata": {"aucs": [0.20836011606493632, 0.21000701169983638, 0.25368903906423135], "final_y": [0.30388414571003536, 0.07466984810533882, 0.05573472562564738]}, "mutation_prompt": null}
{"id": "2ebf2e6a-6b82-4a46-8069-5adcd53df392", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + np.random.rand() / 2\n            c1 = c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9  # Change applied here\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.9\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced velocity update in PSO to improve solution quality and convergence.", "configspace": "", "generation": 1, "fitness": 0.24392882217362952, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.244 with standard deviation 0.011. And the mean value of best solutions found was 0.040 (0. is the best) with standard deviation 0.019.", "error": "", "parent_id": "3780aace-c3fb-4a0e-be39-7cf364d42bfd", "metadata": {"aucs": [0.24435960783666644, 0.25666019866968826, 0.23076666001453383], "final_y": [0.05246998427272941, 0.013285397115227882, 0.053927249022532535]}, "mutation_prompt": null}
{"id": "1b1e4a5f-c65a-4d08-89ea-5d70d23d31a1", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + np.random.rand() / 2\n            c1 = 1.5 + np.random.rand() * 0.5  # Change applied here\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.9\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced learning factor adaptation in PSO's velocity update to enhance convergence speed and quality.", "configspace": "", "generation": 2, "fitness": 0.2499420466422891, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.250 with standard deviation 0.020. And the mean value of best solutions found was 0.021 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "2ebf2e6a-6b82-4a46-8069-5adcd53df392", "metadata": {"aucs": [0.27779544092850716, 0.2331714822095523, 0.23885921678880784], "final_y": [0.011306998770328458, 0.035089343230070215, 0.017926153240863545]}, "mutation_prompt": null}
{"id": "98dfafb0-b9b1-40a4-b35a-8e9ac9ce34c9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.9\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced the dynamic adaptation of the inertia weight in PSO to improve exploration and exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.3401065046924194, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.340 with standard deviation 0.014. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "1b1e4a5f-c65a-4d08-89ea-5d70d23d31a1", "metadata": {"aucs": [0.3329053816536932, 0.3273252343799834, 0.36008889804358146], "final_y": [0.0006104841545707365, 0.000658332133204789, 0.00047703587206836024]}, "mutation_prompt": null}
{"id": "ef5d1247-7693-46ee-9270-2eee8f6646da", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.7 + 0.3  # Slight tweak here.\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.9\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Tweaked the differential evolution mutation factor for better exploration-exploitation trade-off.", "configspace": "", "generation": 4, "fitness": 0.3266848568601571, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.327 with standard deviation 0.032. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "98dfafb0-b9b1-40a4-b35a-8e9ac9ce34c9", "metadata": {"aucs": [0.3360037659231079, 0.2832086752401376, 0.3608421294172257], "final_y": [0.0003500800904879811, 0.0013499930921221372, 0.0004612716212528403]}, "mutation_prompt": null}
{"id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced adaptive crossover rate in DE to enhance exploration capabilities.", "configspace": "", "generation": 5, "fitness": 0.3418035335180794, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.342 with standard deviation 0.011. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "98dfafb0-b9b1-40a4-b35a-8e9ac9ce34c9", "metadata": {"aucs": [0.3346380960181542, 0.33383060784117136, 0.3569418966949126], "final_y": [0.00029975330293733634, 0.00019900480136867635, 0.0004413438052892716]}, "mutation_prompt": null}
{"id": "65f48bf2-9771-4ccc-909b-2ff1da9b34ef", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.5 * np.cos(evals / self.budget * np.pi)  # Dynamic mutation factor\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced DE mutation factor to dynamically respond to optimization progress.", "configspace": "", "generation": 6, "fitness": 0.32774375285488055, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.328 with standard deviation 0.005. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.3278912970728144, 0.32099389610113305, 0.3343460653906942], "final_y": [0.00019530388702958414, 0.00043018389644871425, 0.0005226880607969029]}, "mutation_prompt": null}
{"id": "6094f493-9308-4dbf-b565-dd70a9b24c04", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.9 - 0.5 * (evals / self.budget)  # Dynamic inertia weight\n            c1 = 1.5 + np.random.rand(self.pop_size, self.dim) * 0.5  # Chaotic sequence\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced dynamic inertia weight in PSO and chaotic sequence to enhance exploration and exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.2294540901717693, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.229 with standard deviation 0.016. And the mean value of best solutions found was 0.026 (0. is the best) with standard deviation 0.015.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.21277568925257162, 0.22504974268780487, 0.25053683857493136], "final_y": [0.04563820233393574, 0.008134999100937002, 0.022973636476565907]}, "mutation_prompt": null}
{"id": "48a3d0d1-d982-4ccf-aaa0-9120427c0c2a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + (0.4 * np.cos(evals / self.budget * np.pi)) # Dynamic inertia weight adjustment\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced convergence by introducing dynamic inertia weight adjustment in PSO update.", "configspace": "", "generation": 8, "fitness": 0.2955896873336769, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.296 with standard deviation 0.014. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.2891685925331724, 0.3154849910027888, 0.28211547846506957], "final_y": [0.0010663100061310531, 0.000252224995055844, 0.0005067488825655916]}, "mutation_prompt": null}
{"id": "3f661715-c58d-4f6b-a75e-f57bb6ab9116", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.4 * np.cos(evals / self.budget * np.pi)  # Adaptive F scaling factor\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced exploration by adjusting the F scaling factor adaptively based on evaluation progress.", "configspace": "", "generation": 9, "fitness": 0.32720018774860654, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.327 with standard deviation 0.013. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.311197789955998, 0.32837434625349293, 0.34202842703632863], "final_y": [0.00037218278923101955, 0.000292283596697245, 0.00024309220223133084]}, "mutation_prompt": null}
{"id": "ce6ecf9e-4efa-4b15-ab0c-4157711238d6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + 0.4 * np.cos(evals / self.budget * np.pi)  # Dynamic inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + np.random.rand() * 0.3  # Modified DE mutation factor\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced a dynamic inertia weight strategy and modified DE mutation factor to enhance convergence speed.", "configspace": "", "generation": 10, "fitness": 0.27543107706027375, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.275 with standard deviation 0.032. And the mean value of best solutions found was 0.007 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.2698161182160622, 0.31706811342228525, 0.23940899954247385], "final_y": [0.0006434546339695983, 0.0028010444959953532, 0.01733502640544668]}, "mutation_prompt": null}
{"id": "5effba22-9d38-4622-928f-255974b44768", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Changed from 0.4 to a dynamic range for F\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced the DE mutation factor adaptation to improve exploration.", "configspace": "", "generation": 11, "fitness": 0.33177488429172913, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.332 with standard deviation 0.027. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.3332168002306989, 0.29801967091404, 0.36408818173044843], "final_y": [0.000756089370622271, 0.001872405225360899, 0.0007725402611016861]}, "mutation_prompt": null}
{"id": "c90b5e6d-a87b-48ec-80dd-4248a39bb0f0", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + 0.5 * (self.global_best_score / (np.min(self.personal_best_scores) + 1e-10))  # Dynamic inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Incorporated dynamic inertia weight adjustment based on current exploitation and exploration balance.", "configspace": "", "generation": 12, "fitness": 0.22281456914920297, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.223 with standard deviation 0.011. And the mean value of best solutions found was 0.079 (0. is the best) with standard deviation 0.036.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.2234419187000083, 0.23617002937530907, 0.2088317593722916], "final_y": [0.06710009133120577, 0.042915446431761, 0.1279052073223784]}, "mutation_prompt": null}
{"id": "48050891-ecb3-486e-a656-1303ae2dd94b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + (0.9 - 0.5) * np.exp(-evals / (0.1 * self.budget))  # Changed from 0.4 to 0.5\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced global best update mechanism by slightly increasing the exploration factor in PSO.", "configspace": "", "generation": 13, "fitness": 0.2872321370797672, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.287 with standard deviation 0.005. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.2928315616297964, 0.28757661803690115, 0.2812882315726041], "final_y": [0.0009762892867548705, 0.0034161475598417624, 0.0010189213572509507]}, "mutation_prompt": null}
{"id": "d443b7e1-bc1a-40a3-b376-3b7de16ff774", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.normal(0.5, 0.3)  # Gaussian perturbation for F\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Utilized Gaussian perturbations in DE mutation to enhance local search capabilities.", "configspace": "", "generation": 14, "fitness": 0.33162616755009405, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.332 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.3374679202462847, 0.3506619066221438, 0.3067486757818537], "final_y": [7.97108330460381e-05, 0.00012721484692397136, 0.0007875794926715575]}, "mutation_prompt": null}
{"id": "2c2c80f4-1381-406e-a92e-f54c9ea2dfb6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + np.random.rand() * (0.9 - 0.4)  # Stochastic inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced stochastic inertia weight in PSO for better balance between exploration and exploitation.", "configspace": "", "generation": 15, "fitness": 0.2914447871234944, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.291 with standard deviation 0.001. And the mean value of best solutions found was 0.008 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.2904618599972384, 0.29191636499622486, 0.29195613637702], "final_y": [0.010867824168361274, 0.00705514951312785, 0.005278621160763959]}, "mutation_prompt": null}
{"id": "eda8252f-22db-48a0-bb27-d4409d0bf3e6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * (1 + np.cos(np.pi * evals / self.budget)) / 2  # Dynamically adjusted inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced exploration by dynamically adjusting the inertia weight using a cosine function.", "configspace": "", "generation": 16, "fitness": 0.24490934064624595, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.245 with standard deviation 0.005. And the mean value of best solutions found was 0.010 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.2494659946829324, 0.24749040371399522, 0.23777162354181025], "final_y": [0.012919999586802393, 0.005768197766022725, 0.012279003384879526]}, "mutation_prompt": null}
{"id": "7500f3c0-25f8-401f-a672-649a0189258d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.8 + 0.2 * np.cos(np.pi * evals / self.budget)  # Adaptive factor F\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced DE mutation strategy by adjusting factor F adaptively for improved convergence.", "configspace": "", "generation": 17, "fitness": 0.3242976493124075, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.324 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.3375080326781099, 0.29833296482131166, 0.337051950437801], "final_y": [0.00019832277192947123, 0.0010278204366409394, 0.00022423121378734352]}, "mutation_prompt": null}
{"id": "79331a34-4e83-4945-8fb1-195e56768595", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * (1 - evals / self.budget)  # Annealing strategy for F\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Improved exploration using annealing strategy for mutation factor in DE.", "configspace": "", "generation": 18, "fitness": 0.31936657909686755, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.319 with standard deviation 0.012. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.3032719048309539, 0.3333132101727192, 0.3215146222869295], "final_y": [0.00116587993952667, 0.0007750045395242213, 0.0008852544459477448]}, "mutation_prompt": null}
{"id": "7a7e033a-af00-4fbe-b556-9f25cc97718f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.9 - (0.5 * (evals / self.budget))  # Adaptive inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + np.random.rand() * 0.5  # Adjusted mutation factor\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced exploitation by introducing an adaptive inertia weight strategy in PSO and varying DE's mutation factor.", "configspace": "", "generation": 19, "fitness": 0.21788191338184762, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.218 with standard deviation 0.013. And the mean value of best solutions found was 0.028 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.2236614037403758, 0.19976353451828788, 0.2302208018868792], "final_y": [0.02307104765628084, 0.01982302386096728, 0.04118927363698276]}, "mutation_prompt": null}
{"id": "1c227beb-0862-45d8-a9e9-ef3b038534dc", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + (0.9 - 0.5) * np.exp(-evals / (0.1 * self.budget))  # Adjusted inertia weight decay rate\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced exploration by fine-tuning the inertia weight decay rate in PSO update.", "configspace": "", "generation": 20, "fitness": 0.2872321370797672, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.287 with standard deviation 0.005. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.2928315616297964, 0.28757661803690115, 0.2812882315726041], "final_y": [0.0009762892867548705, 0.0034161475598417624, 0.0010189213572509507]}, "mutation_prompt": null}
{"id": "33e5b281-3d4c-43a3-8c3d-4deb4fb37946", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.cos(evals / self.budget * np.pi)  # Adjusted inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced exploration by adjusting PSO's inertia weight dynamically based on cosine function.", "configspace": "", "generation": 21, "fitness": 0.2817042631854995, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.282 with standard deviation 0.018. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.3064860506030812, 0.2701434069570844, 0.268483331996333], "final_y": [0.00013538899285573799, 0.0014674587762381463, 0.0008593380677951699]}, "mutation_prompt": null}
{"id": "21e7ee07-03bd-4b14-b97f-2ca1f474fa65", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.9 - (0.5 * evals / self.budget)  # Changed PSO inertia weight decay\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Optimized PSO inertia weight decay for better convergence.", "configspace": "", "generation": 22, "fitness": 0.24149967966368657, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.241 with standard deviation 0.002. And the mean value of best solutions found was 0.013 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.23972661346613022, 0.24075060943919613, 0.24402181608573337], "final_y": [0.011825655378665702, 0.011945698019679096, 0.015032001059173832]}, "mutation_prompt": null}
{"id": "49ec729e-8604-4cb7-b924-f97f4726efb4", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * (1 - (evals / self.budget) ** 0.5)  # Non-linear inertia weight decay\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced exploration by using adaptive inertia weight decaying non-linearly in PSO.", "configspace": "", "generation": 23, "fitness": 0.2741064995729882, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.274 with standard deviation 0.013. And the mean value of best solutions found was 0.005 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.2912071412429619, 0.2591739653422843, 0.2719383921337185], "final_y": [0.0018126686868455088, 0.010576157025912794, 0.0028956661315823885]}, "mutation_prompt": null}
{"id": "37535fdc-2329-4d46-85b2-3b79d5fa6888", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.2  # Modified line for enhanced exploitation\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced exploitation by modifying velocity update to prioritize personal best over global best.", "configspace": "", "generation": 24, "fitness": 0.324912785058983, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.325 with standard deviation 0.007. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.3343192285297768, 0.32102729491958626, 0.319391831727586], "final_y": [0.00020027809802102247, 0.0006343445551885576, 0.00018927086709110495]}, "mutation_prompt": null}
{"id": "c7980326-b934-4840-afee-01e936f9688d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + (0.9 - 0.5) * np.cos(evals / (0.1 * self.budget) * np.pi)  # Modified line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced PSO inertia weight dynamics to improve convergence speed.", "configspace": "", "generation": 25, "fitness": 0.3202000051286756, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.320 with standard deviation 0.026. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.35325215843762514, 0.31727840180412004, 0.2900694551442816], "final_y": [0.0003340283793115273, 0.00020365951341414336, 0.001975487431048036]}, "mutation_prompt": null}
{"id": "1c6c5167-5aea-4079-84aa-c26a949d7209", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.9 - (0.9 - 0.4) * (evals / self.budget)  # Dynamic inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced dynamic inertia weight scaling in PSO to balance exploration and exploitation.", "configspace": "", "generation": 26, "fitness": 0.24149967966368657, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.241 with standard deviation 0.002. And the mean value of best solutions found was 0.013 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.23972661346613022, 0.24075060943919613, 0.24402181608573337], "final_y": [0.011825655378665702, 0.011945698019679096, 0.015032001059173832]}, "mutation_prompt": null}
{"id": "b8686272-89a5-400f-a5c3-ee66a030cf82", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.abs(np.sin(evals / (0.1 * self.budget)))  # Chaotic inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced diversity by introducing chaotic inertia weight in the velocity update.", "configspace": "", "generation": 27, "fitness": 0.24928418093026705, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.249 with standard deviation 0.007. And the mean value of best solutions found was 0.025 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.2533610163464898, 0.25514380093967437, 0.239347725504637], "final_y": [0.021717274731789436, 0.025162940603420753, 0.02682908478906765]}, "mutation_prompt": null}
{"id": "5d6d28b7-f14b-47c9-82cd-2bfa9eb2dfc6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.9 - (0.5 * (evals / self.budget))  # Adaptive inertia weight decay\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced an adaptive inertia weight decay in PSO for improved convergence.", "configspace": "", "generation": 28, "fitness": 0.24149967966368657, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.241 with standard deviation 0.002. And the mean value of best solutions found was 0.013 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.23972661346613022, 0.24075060943919613, 0.24402181608573337], "final_y": [0.011825655378665702, 0.011945698019679096, 0.015032001059173832]}, "mutation_prompt": null}
{"id": "85b14ed0-86fd-4478-8ee0-9c4f058faa12", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles) * 1.1)  # Slightly adjusted scaling factor\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced the velocity update formula in PSO to improve convergence speed.", "configspace": "", "generation": 29, "fitness": 0.28971273647069234, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.290 with standard deviation 0.009. And the mean value of best solutions found was 0.003 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.2999442351084656, 0.2907514048959917, 0.2784425694076197], "final_y": [0.0031717728396853198, 0.001494941046690897, 0.005032378251014412]}, "mutation_prompt": null}
{"id": "9271e7a8-54b8-4777-b232-e6bc2f1fef5c", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.6 + 0.4  # Adjusted mutation factor range\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Adjusted DE mutation factor range to enhance exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": 0.3339361905938971, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.334 with standard deviation 0.023. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.3185984482487625, 0.31671062027042296, 0.3664995032625059], "final_y": [0.0007952020042616648, 0.0001536102704485518, 0.0008095630713392904]}, "mutation_prompt": null}
{"id": "3704ed48-bafd-4cf6-8c1c-8adbc065657f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + 0.5 * np.sin(evals / self.budget * np.pi)  # Dynamically adjust c1\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced exploration by dynamically adjusting PSO's cognitive and social parameters.", "configspace": "", "generation": 31, "fitness": 0.31659661112560844, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.317 with standard deviation 0.010. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.3308046044990758, 0.31309084739781134, 0.3058943814799382], "final_y": [0.00026226444468319376, 0.0007085777398213184, 0.0008688667852362863]}, "mutation_prompt": null}
{"id": "81b5250c-340c-4866-8865-bc8921f767a0", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.9 - (0.5 * evals / self.budget)  # Adaptive inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced adaptive inertia weight in PSO to enhance convergence speed.", "configspace": "", "generation": 32, "fitness": 0.24149967966368657, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.241 with standard deviation 0.002. And the mean value of best solutions found was 0.013 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.23972661346613022, 0.24075060943919613, 0.24402181608573337], "final_y": [0.011825655378665702, 0.011945698019679096, 0.015032001059173832]}, "mutation_prompt": null}
{"id": "59a63354-28fd-4395-b065-05f2c2ca6de9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c) + 0.5 * (self.global_best_position - a), lb, ub)  # Enhanced mutation\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced mutation strategy in DE by incorporating a weighted difference for improved exploration.", "configspace": "", "generation": 33, "fitness": 0.332512285536902, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.333 with standard deviation 0.006. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.33527540620380325, 0.32382205839160094, 0.3384393920153017], "final_y": [0.0003980269743806708, 0.0009865200091918034, 0.0003589382135577503]}, "mutation_prompt": null}
{"id": "cbd14ef0-f856-49df-8d98-c13ae3f295ea", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.7 + 0.3  # Adjusted scaling factor\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Adjusted the scaling factor F in DE to improve convergence speed.", "configspace": "", "generation": 34, "fitness": 0.3235080795121984, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.324 with standard deviation 0.029. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.32299843713891996, 0.28782730353766806, 0.3596984978600072], "final_y": [0.00046541520039022053, 0.00193139618952198, 0.00028963352641350477]}, "mutation_prompt": null}
{"id": "5daa1c04-c6ea-4992-9af9-293b7bafd43d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.5 - 0.4) * np.exp(-evals / (0.1 * self.budget))  # Adjusted decay\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Adjusted the inertia weight decay strategy to improve convergence stability.", "configspace": "", "generation": 35, "fitness": 0.3368400279823646, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.337 with standard deviation 0.012. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.35219424547325584, 0.3343263231167104, 0.32399951535712757], "final_y": [0.00023829506697502624, 0.00023439511390083563, 0.00022219161989946683]}, "mutation_prompt": null}
{"id": "63db6f79-8ca8-45ea-be78-98d3494cccff", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.9 - (0.5 * evals / self.budget)  # Dynamic inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Implemented dynamic strategy for inertia weight to enhance convergence speed in PSO updates.", "configspace": "", "generation": 36, "fitness": 0.24149967966368657, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.241 with standard deviation 0.002. And the mean value of best solutions found was 0.013 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.23972661346613022, 0.24075060943919613, 0.24402181608573337], "final_y": [0.011825655378665702, 0.011945698019679096, 0.015032001059173832]}, "mutation_prompt": null}
{"id": "c1846b49-eb44-4852-adfb-33ee40ed0836", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.05 * self.budget))  # Adjusted exploration weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Refined the PSO update rule to enhance exploration by adjusting the velocity update weight dynamically.", "configspace": "", "generation": 37, "fitness": 0.32372965510099766, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.324 with standard deviation 0.016. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.34395100540181367, 0.32365227357878745, 0.3035856863223919], "final_y": [0.00028889914667806966, 0.0003671996912789296, 0.0014884448182333337]}, "mutation_prompt": null}
{"id": "990a96f0-9a83-4467-9ee3-13c3e2af8fda", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + 0.4 * np.cos(evals / self.budget * np.pi)  # Dynamically adjust inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced exploration by dynamically adjusting the inertia weight `w` in PSO based on a cosine function.", "configspace": "", "generation": 38, "fitness": 0.2794197323618418, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.279 with standard deviation 0.010. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.2932444431270842, 0.26944778533478386, 0.27556696862365737], "final_y": [0.00041639925607134644, 0.0004587958444083013, 0.002140870483784555]}, "mutation_prompt": null}
{"id": "4c9239f3-9a97-4f47-9755-84af022ae237", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.4 + np.random.rand() * 0.6  # Self-adaptive mutation factor\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Implemented self-adaptive mutation factor in DE for dynamic balance of exploration and exploitation.", "configspace": "", "generation": 39, "fitness": 0.3339361905938971, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.334 with standard deviation 0.023. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.3185984482487625, 0.31671062027042296, 0.3664995032625059], "final_y": [0.0007952020042616648, 0.0001536102704485518, 0.0008095630713392904]}, "mutation_prompt": null}
{"id": "02565a5f-28cd-42df-8654-51b09838fe5d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.1 * np.sin(2 * evals / self.budget * np.pi)  # Adjusted adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Adjusted the adaptive crossover rate formula for better convergence over the budget.", "configspace": "", "generation": 40, "fitness": 0.3360089841423606, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.336 with standard deviation 0.016. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.3355716720138444, 0.31603684235229745, 0.35641843806093976], "final_y": [0.00029975330293733634, 0.0014838450958879576, 0.00029027007657817904]}, "mutation_prompt": null}
{"id": "43b4f157-9e98-4e02-91c3-adfd784fdeda", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * (1 - evals / self.budget)  # Dynamic weight decay\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced a dynamic weight decay strategy in PSO to enhance convergence speed.", "configspace": "", "generation": 41, "fitness": 0.24149967966368657, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.241 with standard deviation 0.002. And the mean value of best solutions found was 0.013 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.23972661346613022, 0.24075060943919613, 0.24402181608573337], "final_y": [0.011825655378665702, 0.011945698019679096, 0.015032001059170573]}, "mutation_prompt": null}
{"id": "8a245a7b-65c1-4970-8e9c-28e1615e56e4", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.sin(evals / self.budget * np.pi)  # Oscillatory inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced an oscillatory inertia weight in PSO to improve exploration and exploitation balance.", "configspace": "", "generation": 42, "fitness": 0.23299335360026419, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.233 with standard deviation 0.014. And the mean value of best solutions found was 0.047 (0. is the best) with standard deviation 0.031.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.2407326457778577, 0.2139506935424551, 0.24429672148047976], "final_y": [0.033264382907779756, 0.09089031090298733, 0.01834099177869898]}, "mutation_prompt": null}
{"id": "4696dde5-5fd8-4d1f-b3b6-76fc67e37305", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.7 + (0.9 - 0.7) * np.exp(-evals / (0.1 * self.budget))  # Adjusted inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = (w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.particles) +\n                               c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced exploration by adjusting the PSO inertia weight dynamically over time.", "configspace": "", "generation": 43, "fitness": 0.24267808541539612, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.243 with standard deviation 0.007. And the mean value of best solutions found was 0.030 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.2457167907031328, 0.23280203908322894, 0.2495154264598266], "final_y": [0.01725747453461276, 0.03090559120817846, 0.04076841505961281]}, "mutation_prompt": null}
{"id": "59b5bf1f-2376-4bc0-a11f-5fa61e48b6cc", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced exploration by optimizing velocity update formula in the PSO component.", "configspace": "", "generation": 44, "fitness": 0.3509384353501363, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.351 with standard deviation 0.004. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a2aa5911-3438-4b5a-ad6f-50e0a848554d", "metadata": {"aucs": [0.35135031061315736, 0.34601104794494086, 0.35545394749231074], "final_y": [5.533016296049926e-05, 0.00010174135830251884, 0.00017987521440344443]}, "mutation_prompt": null}
{"id": "e3bd2502-3a3a-45fa-8c05-b150455730f0", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + 0.4 * np.cos(evals / self.budget * np.pi)  # Dynamic inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced a dynamic inertia weight adjustment in the PSO component to improve balance between exploration and exploitation.", "configspace": "", "generation": 45, "fitness": 0.281071217845008, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.281 with standard deviation 0.004. And the mean value of best solutions found was 0.003 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "59b5bf1f-2376-4bc0-a11f-5fa61e48b6cc", "metadata": {"aucs": [0.28410424797140976, 0.27577809012720034, 0.2833313154364139], "final_y": [0.005302280858530019, 0.0017034633326423645, 0.002994073195407818]}, "mutation_prompt": null}
{"id": "382fab9d-be71-4b4d-9355-8b4314ac85d9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.9 - ((0.9 - 0.4) * (evals / self.budget))  # Modified line for adaptive inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced adaptive inertia weight in PSO for improved exploration and exploitation balance.", "configspace": "", "generation": 46, "fitness": 0.27090881571106556, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.271 with standard deviation 0.004. And the mean value of best solutions found was 0.004 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "59b5bf1f-2376-4bc0-a11f-5fa61e48b6cc", "metadata": {"aucs": [0.2659970917585357, 0.2757299238145442, 0.27099943156011674], "final_y": [0.004844184458439389, 0.0035826473040495004, 0.004877032602630933]}, "mutation_prompt": null}
{"id": "0736c804-2ee6-4b9a-852b-991c45e50578", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + (0.9 - 0.5) * np.exp(-evals / (0.08 * self.budget))  # Modified inertia weight decay\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Fine-tuned the inertia weight decay function in the PSO component for better exploration-exploitation balance.", "configspace": "", "generation": 47, "fitness": 0.32401469642528885, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.324 with standard deviation 0.011. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "59b5bf1f-2376-4bc0-a11f-5fa61e48b6cc", "metadata": {"aucs": [0.3276247581515638, 0.3354758426278628, 0.30894348849643993], "final_y": [0.00015967083297848132, 0.0003041362581997214, 0.0006148343543923756]}, "mutation_prompt": null}
{"id": "560f334c-46b1-44a9-bcc3-f53634dfaaac", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.9 - (0.5 * evals / self.budget)  # Changed line: Time-varying inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduce a time-varying inertia weight to balance exploration and exploitation in the PSO component.", "configspace": "", "generation": 48, "fitness": 0.27090881571106556, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.271 with standard deviation 0.004. And the mean value of best solutions found was 0.004 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "59b5bf1f-2376-4bc0-a11f-5fa61e48b6cc", "metadata": {"aucs": [0.2659970917585357, 0.2757299238145442, 0.27099943156011674], "final_y": [0.004844184458439389, 0.0035826473040495004, 0.004877032602630933]}, "mutation_prompt": null}
{"id": "b29d91e5-7d77-436a-857f-1e3dbde54bf1", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.max(self.personal_best_scores))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced adaptive inertia weight adjustment in PSO for improved convergence speed and accuracy.", "configspace": "", "generation": 49, "fitness": 0.3901580137602885, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.390 with standard deviation 0.010. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "59b5bf1f-2376-4bc0-a11f-5fa61e48b6cc", "metadata": {"aucs": [0.3995507929354798, 0.3763667938830222, 0.39455645446236365], "final_y": [4.572709990329169e-05, 5.509062825699706e-05, 1.2198289605081904e-05]}, "mutation_prompt": null}
{"id": "4d14bfa7-987b-481b-a9a4-6fa312d20698", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            std_dev = np.std(self.personal_best_scores)\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (1.0 - std_dev / np.max(self.personal_best_scores))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced PSO inertia weight adaptation based on standard deviation of personal best scores to balance exploration and exploitation.", "configspace": "", "generation": 50, "fitness": 0.3749171924677192, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.375 with standard deviation 0.015. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b29d91e5-7d77-436a-857f-1e3dbde54bf1", "metadata": {"aucs": [0.39594471437595513, 0.36041836777178426, 0.36838849525541817], "final_y": [2.9105322810662048e-05, 0.00016018152131304356, 0.0001405395997156401]}, "mutation_prompt": null}
{"id": "3ada0aef-9767-4556-838d-f57c6ce4950f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.max(self.personal_best_scores))\n            w += 0.1 * np.sin(evals / self.budget * np.pi)  # Dynamic oscillation added\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced PSO inertia adjustment by incorporating dynamic oscillation to adaptively balance exploration and exploitation.", "configspace": "", "generation": 51, "fitness": 0.34552736590140576, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.346 with standard deviation 0.013. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b29d91e5-7d77-436a-857f-1e3dbde54bf1", "metadata": {"aucs": [0.3628103704651803, 0.331306501316148, 0.34246522592288897], "final_y": [0.00016387533277737465, 0.00038837268804291236, 0.00023418420643779556]}, "mutation_prompt": null}
{"id": "421a5302-e0a8-4564-8220-7abb8df0543b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced adaptive inertia weight adjustment in PSO for even better convergence speed and accuracy.", "configspace": "", "generation": 52, "fitness": 0.3903077272787323, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.390 with standard deviation 0.004. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b29d91e5-7d77-436a-857f-1e3dbde54bf1", "metadata": {"aucs": [0.3852680853070447, 0.39067488721801447, 0.39498020931113764], "final_y": [7.518986939496658e-06, 3.78345647947761e-05, 4.288343815729123e-05]}, "mutation_prompt": null}
{"id": "1ff41c76-a775-4ca8-a7d9-fd06c4eefe92", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.9 + 0.5  # Slightly increased F\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced a slightly more aggressive DE mutation strategy by increasing the weight factor `F` to improve exploration.", "configspace": "", "generation": 53, "fitness": 0.3731522407244529, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.373 with standard deviation 0.004. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "421a5302-e0a8-4564-8220-7abb8df0543b", "metadata": {"aucs": [0.3784824129392619, 0.37118562259290644, 0.36978868664119036], "final_y": [0.00012015066758767142, 5.854200283016004e-05, 8.133085068095939e-05]}, "mutation_prompt": null}
{"id": "8c61f198-ba63-4322-80f6-a92bbf1ae174", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * (0.9 + 0.1 * np.cos(evals / self.budget * np.pi))  # Changed line\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Implement an adaptive velocity scaling factor in PSO for improved solution exploration and exploitation balance.", "configspace": "", "generation": 54, "fitness": 0.36640587606411995, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.366 with standard deviation 0.020. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "421a5302-e0a8-4564-8220-7abb8df0543b", "metadata": {"aucs": [0.39341406329662454, 0.3598110073885036, 0.34599255750723157], "final_y": [4.3460733229037315e-05, 5.2079289094688313e-05, 9.891785611666255e-05]}, "mutation_prompt": null}
{"id": "a28c3083-d29a-4a6d-b8f9-d9743908faf9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.2 * (1 - evals / self.budget)  # Adjusted line\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introducing linear decay in the mutation factor for more diverse exploration and exploitation balance in HybridPSO_DE.", "configspace": "", "generation": 55, "fitness": 0.3629819834691858, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.363 with standard deviation 0.007. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "421a5302-e0a8-4564-8220-7abb8df0543b", "metadata": {"aucs": [0.36739089972704464, 0.3528149059160688, 0.36874014476444406], "final_y": [7.86907243435956e-05, 2.395797996448009e-05, 5.104791752345646e-05]}, "mutation_prompt": null}
{"id": "217dcb42-c2ae-4df9-a1ce-5f2ff4b473db", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (1.0 - np.std(self.personal_best_scores))  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhance convergence by introducing a dynamic inertia weight decay based on the standard deviation of the personal best scores.", "configspace": "", "generation": 56, "fitness": 0.29115313501046863, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.291 with standard deviation 0.012. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "421a5302-e0a8-4564-8220-7abb8df0543b", "metadata": {"aucs": [0.29820906588700735, 0.30038391309127344, 0.27486642605312506], "final_y": [0.0002378666382583207, 0.00017195037534290528, 0.0007468135833428894]}, "mutation_prompt": null}
{"id": "faa1bf41-240a-4aa1-b6ca-a8a01f62f478", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))\n            c1 = 1.5 + np.random.rand() * (0.5 - 0.25 * (evals / self.budget)) # Adjusted line\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduce a dynamic personal learning coefficient in PSO for improved exploration and exploitation balance.", "configspace": "", "generation": 57, "fitness": 0.3661862879432398, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.366 with standard deviation 0.015. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "421a5302-e0a8-4564-8220-7abb8df0543b", "metadata": {"aucs": [0.3738398796999214, 0.34513399486613217, 0.3795849892636659], "final_y": [5.280507826654688e-05, 4.407198137417837e-05, 7.530380699367395e-05]}, "mutation_prompt": null}
{"id": "d040b7a7-bb61-4df0-8874-d24642826949", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (1 - self.global_best_score / np.mean(self.personal_best_scores))  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Refinement of the PSO's inertia weight formula for enhanced global and local balance.", "configspace": "", "generation": 58, "fitness": 0.35536610065516455, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.355 with standard deviation 0.007. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "421a5302-e0a8-4564-8220-7abb8df0543b", "metadata": {"aucs": [0.3601832007562966, 0.34495146408179633, 0.36096363712740065], "final_y": [0.0001371828532122315, 5.6794233463092444e-05, 0.00015724484814129655]}, "mutation_prompt": null}
{"id": "867884dc-7712-4317-a8ec-545ebc177740", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.velocities *= 0.98  # Introduced velocity damping\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced velocity damping to improve convergence stability and control in HybridPSO_DE.", "configspace": "", "generation": 59, "fitness": 0.36765216490511504, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.368 with standard deviation 0.007. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "421a5302-e0a8-4564-8220-7abb8df0543b", "metadata": {"aucs": [0.35814827512583836, 0.37376905791056403, 0.3710391616789428], "final_y": [0.0001359289295808987, 6.29578570698535e-05, 5.966432329254185e-05]}, "mutation_prompt": null}
{"id": "e45ea119-f528-4771-ad16-3bf42327f9c2", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.08 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced PSO and DE with improved adaptive weighting for faster convergence.", "configspace": "", "generation": 60, "fitness": 0.36524627028922846, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.365 with standard deviation 0.009. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "421a5302-e0a8-4564-8220-7abb8df0543b", "metadata": {"aucs": [0.37619134303653734, 0.3542153122996775, 0.36533215553147047], "final_y": [2.060477778203159e-05, 6.575650906377715e-05, 5.922716162754038e-05]}, "mutation_prompt": null}
{"id": "88df6203-92da-4074-8725-a1429cf4942c", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.9 + 0.5  # Adjusted line\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Improved exploitation of DE mutation by increasing the scale factor F for better convergence.", "configspace": "", "generation": 61, "fitness": 0.3731522407244529, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.373 with standard deviation 0.004. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "421a5302-e0a8-4564-8220-7abb8df0543b", "metadata": {"aucs": [0.3784824129392619, 0.37118562259290644, 0.36978868664119036], "final_y": [0.00012015066758767142, 5.854200283016004e-05, 8.133085068095939e-05]}, "mutation_prompt": null}
{"id": "2bc87e5f-9706-4802-962a-94a335e43449", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9 + np.random.rand(self.pop_size, self.dim) * 0.01\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced stochastic perturbation in velocity update for enhanced exploration in Hybrid PSO-DE.", "configspace": "", "generation": 62, "fitness": 0.29642773561293856, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.296 with standard deviation 0.006. And the mean value of best solutions found was 0.011 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "421a5302-e0a8-4564-8220-7abb8df0543b", "metadata": {"aucs": [0.29799079028542597, 0.3032600353848125, 0.2880323811685772], "final_y": [0.011981985485715307, 0.006496914060504865, 0.01551363598770546]}, "mutation_prompt": null}
{"id": "ed274c32-336b-4d6f-9aa0-97fe15c6aafe", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + np.random.rand() * (0.8 - 0.5)  # Adjusted line: dynamic scaling factor\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced dynamic scaling factor in DE mutation to enhance exploration and exploitation balance.", "configspace": "", "generation": 63, "fitness": 0.3626764273921029, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.363 with standard deviation 0.011. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "421a5302-e0a8-4564-8220-7abb8df0543b", "metadata": {"aucs": [0.3550826174011249, 0.3547621329159951, 0.37818453185918877], "final_y": [1.593034188608637e-05, 9.450848171580815e-05, 1.976264061562737e-05]}, "mutation_prompt": null}
{"id": "8bc48135-c2c5-4e53-9ad9-aa94ff8071bb", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.05 * self.budget))  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Refined adaptive inertia weight calculation for quicker convergence in particle swarm optimization.", "configspace": "", "generation": 64, "fitness": 0.3422219058769503, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.342 with standard deviation 0.015. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "421a5302-e0a8-4564-8220-7abb8df0543b", "metadata": {"aucs": [0.36028648210310266, 0.3419963198801279, 0.32438291564762034], "final_y": [7.628627004479819e-05, 0.00013288116041441393, 6.706140945193918e-05]}, "mutation_prompt": null}
{"id": "1c76afd6-9f6c-4002-8958-3042185455c7", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.05 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Improved exploration-exploitation balance by dynamically adjusting the inertia weight based on performance.", "configspace": "", "generation": 65, "fitness": 0.36199073176717617, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.362 with standard deviation 0.006. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "421a5302-e0a8-4564-8220-7abb8df0543b", "metadata": {"aucs": [0.36561075114509134, 0.3529183648896723, 0.3674430792667648], "final_y": [8.318739927028128e-05, 6.96191353756053e-05, 7.018353281287896e-05]}, "mutation_prompt": null}
{"id": "37c1a8c4-4201-4738-9528-3c09c1161e48", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.6  # Adjust global learning factor\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Slightly adjust the global learning factor to explore more diverse regions in the search space.", "configspace": "", "generation": 66, "fitness": 0.3784377671066503, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.378 with standard deviation 0.016. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "421a5302-e0a8-4564-8220-7abb8df0543b", "metadata": {"aucs": [0.40047895733333094, 0.3734964140404472, 0.36133792994617264], "final_y": [6.975736067875926e-05, 1.1415902379264263e-05, 5.170683480821111e-05]}, "mutation_prompt": null}
{"id": "7bda49cb-c794-4a9d-a5b4-12378aace2dc", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 1.0  # Modified scaling factor\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Slightly increased the particle velocity scaling factor to enhance exploration capabilities.", "configspace": "", "generation": 67, "fitness": 0.36397405673369415, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.364 with standard deviation 0.006. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "421a5302-e0a8-4564-8220-7abb8df0543b", "metadata": {"aucs": [0.37279532990827025, 0.35742680036147445, 0.3617000399313376], "final_y": [0.000196444563409344, 0.00010121891028195065, 8.01699338985384e-05]}, "mutation_prompt": null}
{"id": "98c58f26-aa54-42db-b0bc-9d172e6f29a6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)  # Changed line\n                a, b, c = self.particles[idxs]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced dynamic particle selection for DE mutation to enhance diversity and exploration.", "configspace": "", "generation": 68, "fitness": 0.3596951822294587, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.360 with standard deviation 0.004. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "421a5302-e0a8-4564-8220-7abb8df0543b", "metadata": {"aucs": [0.3599636437349013, 0.3540901549258678, 0.36503174802760685], "final_y": [6.308816070673231e-05, 3.4990895966617855e-05, 4.683037859800167e-05]}, "mutation_prompt": null}
{"id": "98d1d682-92cc-4965-a308-6c65d80c85c9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * (1 + np.sin(np.pi * evals / self.budget)) / 2  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Use sinusoidal function in inertia weight for balanced exploration and exploitation.", "configspace": "", "generation": 69, "fitness": 0.2640381901103994, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.264 with standard deviation 0.010. And the mean value of best solutions found was 0.018 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "421a5302-e0a8-4564-8220-7abb8df0543b", "metadata": {"aucs": [0.2523719982663377, 0.2768821308309729, 0.26286044123388763], "final_y": [0.019180891120235723, 0.018504067611598164, 0.017067298752954645]}, "mutation_prompt": null}
{"id": "e0ba07f7-1b62-4901-b247-852691c9b6b9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + (0.9 - 0.5) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.rand() * 0.8 + 0.4\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Refinement of the PSO velocity update formula to improve convergence by slightly altering the inertia weight calculation.", "configspace": "", "generation": 70, "fitness": 0.3336827545249716, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.334 with standard deviation 0.021. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "421a5302-e0a8-4564-8220-7abb8df0543b", "metadata": {"aucs": [0.3046162393517552, 0.34289406512866827, 0.35353795909449115], "final_y": [0.000967806705659579, 0.0005227216795156491, 0.0002040624117168839]}, "mutation_prompt": null}
{"id": "eeee1402-d765-472e-97e3-43a5906ab859", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.sin(evals / self.budget * np.pi)  # Adaptive F\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced an adaptive differential evolution scaling factor for improved balance between exploration and exploitation.", "configspace": "", "generation": 71, "fitness": 0.39751591124834834, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.398 with standard deviation 0.026. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "421a5302-e0a8-4564-8220-7abb8df0543b", "metadata": {"aucs": [0.43397581937285146, 0.3769784720554631, 0.38159344231673054], "final_y": [2.5021085988136956e-05, 4.8181722708444554e-05, 6.250880817708787e-05]}, "mutation_prompt": null}
{"id": "ce960e74-c1ee-4a34-a259-25f3784bdd4e", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.9 - 0.5 * (evals / self.budget)  # Dynamic inertia weight decay\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.sin(evals / self.budget * np.pi)\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.7 + 0.3 * (1 - np.cos(evals / self.budget * np.pi))  # Adaptive crossover\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced convergence by introducing a dynamic inertia weight decay and adaptive crossover strategy for improved exploration-exploitation balance in HybridPSO_DE.", "configspace": "", "generation": 72, "fitness": 0.24133467306917047, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.241 with standard deviation 0.016. And the mean value of best solutions found was 0.013 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.23673085971742958, 0.26314896107615604, 0.22412419841392583], "final_y": [0.00662548491456736, 0.015091754065743524, 0.017856367467706167]}, "mutation_prompt": null}
{"id": "60fd0f30-3b65-4d38-aa23-56b639bda8db", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.9 - 0.5 * (evals / self.budget)  # Adjusted line for time-varying inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.sin(evals / self.budget * np.pi)  # Adaptive F\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n            # Dynamic population size adjustment\n            self.pop_size = max(5, int(self.pop_size * 0.99))  # Adjusted line\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced exploration with time-varying inertia weight and dynamic population size adjustment.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (19,2) (20,2) ').", "error": "ValueError('operands could not be broadcast together with shapes (19,2) (20,2) ')", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {}, "mutation_prompt": null}
{"id": "019012f8-80cc-4119-b23f-46d47e4ad6bf", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        stagnation_counter = 0  # New variable to track stagnation\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n                    stagnation_counter = 0  # Reset stagnation counter when improvement is found\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update with adaptive inertia\n            w = 0.5 + (0.9 - 0.5) * np.cos(evals / (0.3 * self.budget) * np.pi)  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * self.velocities + \\\n                              c1 * r1 * (self.personal_best_positions - self.particles) + \\\n                              c2 * r2 * (self.global_best_position - self.particles)\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover with dynamic mutation strategy\n            F_base = 0.5 + 0.5 * np.cos(evals / self.budget * np.pi)  # Adjusted line\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = F_base if stagnation_counter < 5 else 0.9  # Adaptive F based on stagnation\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.7 + 0.3 * np.sin(evals / self.budget * np.pi)  # Adjusted line\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n                    stagnation_counter = 0  # Reset stagnation counter when improvement is found\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                stagnation_counter += 1  # Increment stagnation counter if no improvement\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced exploration-exploitation balance with adaptive inertia weight and dynamic mutation strategy.", "configspace": "", "generation": 74, "fitness": 0.3163694231210744, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.316 with standard deviation 0.028. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.3530026892987512, 0.3095161652977634, 0.28658941476670863], "final_y": [6.496341449469822e-05, 0.0006738760100083382, 0.0002888434114479437]}, "mutation_prompt": null}
{"id": "b61b4451-9b65-4848-af59-879b446b1e10", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))\n            # Updated by varying acceleration coefficients based on variance\n            c1 = 1.5 + np.random.rand() * 0.5 * (1 - np.var(self.personal_best_scores) / np.max(self.personal_best_scores))\n            c2 = 1.5 + np.random.rand() * 0.5 * (np.var(self.personal_best_scores) / np.max(self.personal_best_scores))\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.sin(evals / self.budget * np.pi)\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced the exploration-exploitation balance by incorporating dynamic particle acceleration coefficients based on performance variance.", "configspace": "", "generation": 75, "fitness": 0.3458328019199725, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.346 with standard deviation 0.003. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.3501039246025327, 0.341950815680519, 0.34544366547686567], "final_y": [0.00011854797048178257, 5.2883741457556494e-05, 0.00015163362645009785]}, "mutation_prompt": null}
{"id": "c7dea934-40d3-4580-a6c3-84b87ddc6549", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.min(self.personal_best_scores))  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.3 * np.sin(evals / self.budget * np.pi)  # Adjusted F\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.85 + 0.2 * np.cos(evals / self.budget * np.pi)  # Adjusted crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced the balance between exploration and exploitation with adaptive inertia and dynamic crossover in a hybrid PSO-DE framework.", "configspace": "", "generation": 76, "fitness": 0.32155161362920925, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.322 with standard deviation 0.010. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.32593345729584156, 0.33139989509867207, 0.30732148849311414], "final_y": [0.0006572845584170556, 0.00016644833691074982, 0.0005489063853664333]}, "mutation_prompt": null}
{"id": "cd4ec841-c558-4052-90bf-fcce8626e1c8", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            diversity = np.std(self.particles, axis=0).mean()  # New line\n            w = 0.5 + 0.4 * np.exp(-diversity / (0.1 * self.budget))  # Modified line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.sin(evals / self.budget * np.pi)\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.7 + 0.3 * diversity  # Modified line\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced exploration-exploitation balance by introducing dynamic inertia weights and crossover rates based on population diversity.", "configspace": "", "generation": 77, "fitness": 0.22356367251266962, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.224 with standard deviation 0.018. And the mean value of best solutions found was 0.103 (0. is the best) with standard deviation 0.067.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.22515589202071817, 0.20062490085938778, 0.2449102246579029], "final_y": [0.09175779539529462, 0.19045018184454743, 0.026969843425214697]}, "mutation_prompt": null}
{"id": "4fe27401-26e3-42b7-972e-355cb4c542ca", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget))\n            c1 = 1.5 + (2.5 - 1.5) * (1 - evals / self.budget)  # Time-varying c1\n            c2 = 1.5 + (2.5 - 1.5) * (evals / self.budget)  # Time-varying c2\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.sin(evals / self.budget * np.pi)\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.1 * (1 - np.cos(evals / self.budget * np.pi))  # Dynamic crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduce time-varying acceleration coefficients and a dynamic crossover rate for enhanced adaptability.", "configspace": "", "generation": 78, "fitness": 0.3395742916587796, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.340 with standard deviation 0.011. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.33696655852066315, 0.32805031879841107, 0.35370599765726474], "final_y": [0.00010651019466765088, 6.430545949194993e-05, 2.1854734856444438e-05]}, "mutation_prompt": null}
{"id": "e880d745-213d-4ee1-ae32-c1fa5e0c187f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w_max = 0.9\n            w_min = 0.4\n            w = w_max - (w_max - w_min) * (evals / self.budget)  # Changed line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * self.velocities + \\\n                              c1 * r1 * (self.personal_best_positions - self.particles) + \\\n                              c2 * r2 * (self.global_best_position - self.particles)\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.sin((evals / self.budget) * 2 * np.pi)  # Changed line\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced exploration by introducing a time-varying inertia weight and adaptive scaling factor in the mutation operation.", "configspace": "", "generation": 79, "fitness": 0.22156863684947437, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.222 with standard deviation 0.010. And the mean value of best solutions found was 0.040 (0. is the best) with standard deviation 0.021.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.21209363155541283, 0.2354113319751202, 0.21720094701789006], "final_y": [0.021303864497455128, 0.06960416264491782, 0.028268432288970115]}, "mutation_prompt": null}
{"id": "066c2b6e-4f61-4a27-b5fe-0a82c9980f5a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5 + np.random.rand() * 0.5  # Changed line\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.sin(evals / self.budget * np.pi)\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced a dynamic learning strategy for particle velocities to enhance convergence speed and precision.", "configspace": "", "generation": 80, "fitness": 0.34196935590702715, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.342 with standard deviation 0.009. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.3532953068040622, 0.34086699060629844, 0.33174577031072083], "final_y": [7.429917049845619e-05, 0.0004901856866907816, 0.00013186016219784126]}, "mutation_prompt": null}
{"id": "39a2ccfd-4dfd-4083-ba18-631dc7833ee0", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n            \n            # Random perturbation for diversity\n            if evals < self.budget:\n                perturbation_chance = 0.1 * (1 - evals / self.budget)\n                perturbation = np.random.rand(self.pop_size, self.dim) < perturbation_chance\n                self.particles += np.random.normal(0, 0.1, size=self.particles.shape) * perturbation\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.sin(evals / self.budget * np.pi)  # Adaptive F\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Added particle diversity through random perturbations to prevent premature convergence.", "configspace": "", "generation": 81, "fitness": 0.32455723773431294, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.325 with standard deviation 0.019. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.29708240031102884, 0.3389586787040455, 0.33763063418786454], "final_y": [0.0009276698006144782, 0.0008770651222215345, 0.00034820716561173316]}, "mutation_prompt": null}
{"id": "e5240468-ded8-44c0-9fa6-8fd54dea7067", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * ((self.budget - evals) / self.budget) ** 2  # Nonlinear decay for inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.sin(evals / self.budget * np.pi)  # Adaptive F\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced a nonlinear inertia weight adjustment mechanism in the PSO update to enhance convergence dynamics.", "configspace": "", "generation": 82, "fitness": 0.2666624429108807, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.267 with standard deviation 0.081. And the mean value of best solutions found was 0.422 (0. is the best) with standard deviation 0.596.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.1535242955306525, 0.311983856861347, 0.3344791763406426], "final_y": [1.2643083072927157, 0.0010060144165798708, 0.0008471137406742373]}, "mutation_prompt": null}
{"id": "e00b98dd-9dfc-4948-bdc5-68bc0daa44e7", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + (0.9 - 0.5) * np.cos(evals / (0.1 * self.budget) * np.pi / 2)  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.4 * np.cos(evals / self.budget * np.pi)  # Adaptive F\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Refined particle velocity update using adaptive inertia weight and enhanced DE mutation strategy with dynamic scaling factor.", "configspace": "", "generation": 83, "fitness": 0.28477299160136665, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.285 with standard deviation 0.001. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.28555491367884445, 0.28523181071789017, 0.2835322504073653], "final_y": [0.000537914141143152, 0.0022426217706257735, 0.0017464380678739264]}, "mutation_prompt": null}
{"id": "8232bd21-2c9c-4643-a6ac-0bdad42eb8ce", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            diversity = np.std(self.particles, axis=0).mean() / (ub - lb).mean()  # Diversity measure added\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores)) * (1 + diversity)  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.sin(evals / self.budget * np.pi)  # Adaptive F\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced balance in exploration and exploitation by introducing adaptive inertia weight and population diversity control.", "configspace": "", "generation": 84, "fitness": 0.36141449489243155, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.361 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.35345572884629584, 0.35858262439150335, 0.3722051314394954], "final_y": [0.00011697401398311134, 2.9102488563759568e-05, 4.63601667554535e-05]}, "mutation_prompt": null}
{"id": "ab987d5f-fa1e-41f9-8e43-a9aeba196f73", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.9 - (0.5 * evals / self.budget)  # Dynamic inertia weight adjustment\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.sin(evals / self.budget * np.pi)  # Adaptive F\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                # Gaussian mutation operator\n                mutation_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                mutation_vector = np.clip(mutation_vector, lb, ub)\n\n                trial_score = func(mutation_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = mutation_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = mutation_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Incorporate a dynamic inertia weight adjustment and a Gaussian mutation operator to enhance exploration capabilities and convergence speed of the hybrid PSO-DE algorithm.", "configspace": "", "generation": 85, "fitness": 0.24631416906937773, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.246 with standard deviation 0.021. And the mean value of best solutions found was 0.009 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.26188228561038285, 0.26055922705480483, 0.21650099454294547], "final_y": [0.008060324471743804, 0.009639590046507007, 0.009080291567324001]}, "mutation_prompt": null}
{"id": "583dcd34-133f-4199-9a61-4860ae5eda1f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        successful_updates = 0  # New variable to track successful score updates\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n                    successful_updates += 1  # Increment on successful update\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * (successful_updates / self.pop_size)  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.sin(evals / self.budget * np.pi)  # Adaptive F\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced variable inertia weight adjustment based on success ratio for enhanced convergence in HybridPSO_DE.", "configspace": "", "generation": 86, "fitness": 0.1838456109947724, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.184 with standard deviation 0.028. And the mean value of best solutions found was 0.679 (0. is the best) with standard deviation 0.432.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.2203137783209842, 0.17952690859062337, 0.15169614607270965], "final_y": [0.25346114780778667, 0.5120203574024446, 1.272376824803241]}, "mutation_prompt": null}
{"id": "19f6e0fa-f298-4c0b-8984-f4e70a5d7b99", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            population_diversity = np.std(self.particles)\n            w = 0.4 + (0.9 - 0.4) * (population_diversity / (np.max(self.particles) - np.min(self.particles)))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles))\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.sin(evals / self.budget * np.pi) + 0.2 * (population_diversity / np.mean(self.personal_best_scores))\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced a dynamic inertia weight for PSO based on the diversity of the population and enhanced DE mutation strategy for improved exploration.", "configspace": "", "generation": 87, "fitness": 0.2859226611566234, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.286 with standard deviation 0.010. And the mean value of best solutions found was 0.008 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.28288564176791064, 0.27566694969410477, 0.29921539200785485], "final_y": [0.005857904171326353, 0.009219274337896885, 0.00766970284830769]}, "mutation_prompt": null}
{"id": "b2689efd-32f0-485a-b949-5ed142d8bb0d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + (0.9 - 0.5) * np.cos(evals / (0.1 * self.budget) * np.pi)  # Adjusted line for adaptivity\n            c1 = 1.5 + 0.1 * np.sin(evals / self.budget * np.pi)  # Adjusted line for adaptive learning rate\n            c2 = 1.5 + 0.1 * np.cos(evals / self.budget * np.pi)  # Adjusted line for adaptive learning rate\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adjusted line for adaptive scaling factor\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.cos(evals / self.budget * np.pi)  # Adjusted line for crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced adaptive learning rates for PSO and DE to enhance convergence and balance exploration-exploitation dynamically.", "configspace": "", "generation": 88, "fitness": 0.2999829836141881, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.300 with standard deviation 0.012. And the mean value of best solutions found was 0.003 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.31750973672499994, 0.2929260453547693, 0.2895131687627951], "final_y": [0.0028076363893529814, 0.002497536146490213, 0.00380539204112521]}, "mutation_prompt": null}
{"id": "d7db80ea-7355-4695-99aa-3f7cca4230b5", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + (0.7 - 0.4) * np.exp(-evals / (0.15 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))  # Adjusted line\n            c1 = 1.6 + np.random.rand() * 0.4  # Adjusted line\n            c2 = 1.8  # Adjusted line\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adjusted line\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.85 + 0.15 * np.sin(evals / self.budget * np.pi)  # Adjusted line\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced adaptive control strategies for better exploration and exploitation balancing in PSO and DE components.", "configspace": "", "generation": 89, "fitness": 0.31821396197225765, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.318 with standard deviation 0.015. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.3370149021337737, 0.3164321765664567, 0.30119480721654257], "final_y": [7.04171635894137e-05, 0.0001953700096954536, 0.00032207070004942645]}, "mutation_prompt": null}
{"id": "b14c9020-b91e-4545-ad97-b63e0a07435d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.05 * self.budget))  # Adaptive inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.8  # Adjusted damping factor\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.abs(np.sin(evals / self.budget * np.pi))  # More dynamic F\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.1 * np.sin(evals / self.budget * np.pi)  # Slightly reduced crossover rate variance\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Improved convergence through adaptive parameter scaling and dynamic population adjustment.", "configspace": "", "generation": 90, "fitness": 0.3635152270973953, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.364 with standard deviation 0.009. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.36415780897899686, 0.3736366721961347, 0.3527512001170543], "final_y": [9.28364919987907e-05, 2.4409243206905586e-05, 1.501366605637202e-05]}, "mutation_prompt": null}
{"id": "e9fe00a8-e1da-445e-87e6-1c3308e45594", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.9 - (0.5 * evals / self.budget)  # Dynamic inertia weight updated\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * self.velocities + \\\n                              c1 * r1 * (self.personal_best_positions - self.particles) + \\\n                              c2 * r2 * (self.global_best_position - self.particles)\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.cos(evals / self.budget * np.pi)  # Adaptive F updated\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced HybridPSO_DE by introducing dynamic inertia weight for PSO and adaptive mutation strategies for DE to boost exploration and exploitation balance.", "configspace": "", "generation": 91, "fitness": 0.22242196884446894, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.222 with standard deviation 0.019. And the mean value of best solutions found was 0.008 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.21354012797319333, 0.20451455697459564, 0.24921122158561781], "final_y": [0.0076444422058940765, 0.010697831304065203, 0.006233057317308262]}, "mutation_prompt": null}
{"id": "517971bf-1586-4e08-bdcd-9fed2f30a023", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.random.rand()  # Stochastic inertia weight\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.sin(evals / self.budget * np.pi)  # Adaptive F\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.cos(evals / self.budget * np.pi)  # Enhanced crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced a stochastic inertia weight and enhanced trial vector selection in DE for improved exploration.", "configspace": "", "generation": 92, "fitness": 0.27377051548636205, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.274 with standard deviation 0.012. And the mean value of best solutions found was 0.008 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.25669047832130387, 0.2840711923447926, 0.2805498757929896], "final_y": [0.011516417054563789, 0.004855352989448343, 0.006596027744917516]}, "mutation_prompt": null}
{"id": "d894d2bd-f43c-422b-992c-20807da330ee", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            # Dynamic population scaling\n            dynamic_pop_size = int(self.pop_size * (1 - evals / self.budget)) + 1\n            for i in range(min(dynamic_pop_size, self.pop_size)):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.sin(evals / self.budget * np.pi)\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Introduced dynamic population size scaling based on convergence rate to enhance exploration and exploitation balance.", "configspace": "", "generation": 93, "fitness": 0.36638928271719456, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.366 with standard deviation 0.030. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.32726988100206156, 0.3717738331594497, 0.4001241339900723], "final_y": [6.258239746765497e-05, 6.665867108148327e-05, 7.449580588636087e-05]}, "mutation_prompt": null}
{"id": "ae7d957a-b4c1-4243-8847-60cd4469b6a6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                F = 0.5 + 0.3 * np.sin(evals / self.budget * np.pi)\n                mutant_vector = np.clip(self.particles[a] + F * (self.particles[b] - self.global_best_position), lb, ub)  # Used global best\n                crossover_rate = 0.7 + 0.3 * (1 - self.personal_best_scores[i] / self.global_best_score)  # Dynamic crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced exploration by adjusting the DE mutation strategy based on the global best and adding a dynamic crossover rate influenced by the personal best scores.", "configspace": "", "generation": 94, "fitness": 0.31324060523726266, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.313 with standard deviation 0.077. And the mean value of best solutions found was 0.071 (0. is the best) with standard deviation 0.100.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.20404747689392, 0.36895245005827404, 0.366721888759594], "final_y": [0.21321758791919165, 3.0066464797072168e-05, 8.13581426110111e-05]}, "mutation_prompt": null}
{"id": "5ed39cb3-4876-4517-8c9e-c9331ac9215c", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.5 + (0.9 - 0.5) * np.cos(evals / (0.1 * self.budget) * np.pi)  # Changed line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.sin(evals / self.budget * np.pi) \n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.cos(evals / self.budget * np.pi)  # Changed line\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n            # Dynamic population size adjustment\n            if evals % (self.budget // 10) == 0:  # Changed line\n                self.pop_size = max(10, int(self.pop_size * 0.95))  # Changed line\n                self.particles = self.particles[:self.pop_size]  # Changed line\n                self.velocities = self.velocities[:self.pop_size]  # Changed line\n                self.personal_best_positions = self.personal_best_positions[:self.pop_size]  # Changed line\n                self.personal_best_scores = self.personal_best_scores[:self.pop_size]  # Changed line\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced the exploration-exploitation balance by introducing an adaptive inertia weight and dynamic population size adjustment.", "configspace": "", "generation": 95, "fitness": 0.3025473779036037, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.303 with standard deviation 0.017. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.3136160811971289, 0.31520399888787876, 0.27882205362580337], "final_y": [0.0004568809488474516, 0.0009832091118643863, 0.0012772770683087064]}, "mutation_prompt": null}
{"id": "8b452778-f93a-43fa-8741-85eb1f4f716c", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * np.exp(-evals / (0.1 * self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.cos(evals / self.budget * np.pi)  # Adjusted F\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Adjusted DE mutation strategy using a dynamic scaling factor based on convergence rate.", "configspace": "", "generation": 96, "fitness": 0.32481472235278713, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.325 with standard deviation 0.013. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.3410725383951486, 0.3085794565338712, 0.3247921721293415], "final_y": [0.00022864310945241452, 0.00034902986660434004, 0.00023678187512566771]}, "mutation_prompt": null}
{"id": "a18e741d-95b2-4e0e-94bf-6b286d30a4a1", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.3 + (0.9 - 0.3) * (1 - evals / self.budget)  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.sin(evals / self.budget * np.pi)  # Adjusted line\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.7 + 0.3 * np.sin(evals / self.budget * np.pi)  # Adjusted line\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Improved exploration and exploitation balance by dynamically adjusting the inertia weight and adaptive mutation parameters.", "configspace": "", "generation": 97, "fitness": 0.2706120191664418, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.271 with standard deviation 0.011. And the mean value of best solutions found was 0.004 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.2621913746511514, 0.263167739744659, 0.2864769431035149], "final_y": [0.005860332610966393, 0.003711554395192196, 0.0029347955880989285]}, "mutation_prompt": null}
{"id": "32b5258c-8a25-4d07-9c51-9b3e6543a1fd", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            diversity = np.std(self.particles, axis=0).mean()\n            w = 0.5 + (0.9 - 0.5) * (diversity / (self.budget / evals + 1))  # Adjusted line\n            c1 = 1.5 + np.random.rand() * 0.5\n            c2 = 1.5\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.sin(evals / self.budget * np.pi)  # Adaptive F\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                diversity_factor = np.std(self.particles, axis=0).mean() / (self.budget / evals + 1)\n                crossover_rate = 0.9 - 0.2 * diversity_factor  # Adjusted line\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Improved convergence by introducing adaptive inertia and crossover strategies based on population diversity.", "configspace": "", "generation": 98, "fitness": 0.1905613763174365, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.191 with standard deviation 0.005. And the mean value of best solutions found was 0.487 (0. is the best) with standard deviation 0.073.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.19260533668491409, 0.19476378799721183, 0.18431500427018355], "final_y": [0.5125490622577348, 0.3874647233716081, 0.5612702576570543]}, "mutation_prompt": null}
{"id": "bb3974ad-6654-4554-b621-ccba170d6d99", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.particles = np.random.rand(self.pop_size, dim)\n        self.velocities = np.random.rand(self.pop_size, dim) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.bounds = None\n\n    def _initialize(self, lb, ub):\n        self.particles = lb + (ub - lb) * np.random.rand(self.pop_size, self.dim)\n        self.velocities = (ub - lb) * (np.random.rand(self.pop_size, self.dim) - 0.5) * 0.1\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.pop_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self._initialize(lb, ub)\n        \n        evals = 0\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                if evals >= self.budget:\n                    break\n                current_position = self.particles[i]\n                score = func(current_position)\n                evals += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = current_position\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = current_position\n\n            # PSO Update\n            w = 0.4 + (0.9 - 0.4) * (1 - (evals / self.budget)) * (self.global_best_score / np.mean(self.personal_best_scores))  # Adjusted line\n            c1 = 1.5 + 0.5 * np.sin(evals / self.budget * np.pi)  # Adjusted line\n            c2 = 1.5 + 0.5 * np.cos(evals / self.budget * np.pi)  # Adjusted line\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.velocities = w * (self.velocities + \n                                 c1 * r1 * (self.personal_best_positions - self.particles) +\n                                 c2 * r2 * (self.global_best_position - self.particles)) * 0.9\n            self.particles = self.particles + self.velocities\n            self.particles = np.clip(self.particles, lb, ub)\n\n            # DE Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.sin(evals / self.budget * np.pi)  # Adaptive F\n                mutant_vector = np.clip(a + F * (b - c), lb, ub)\n\n                crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Adaptive crossover rate\n                random_vector = np.random.rand(self.dim)\n                trial_vector = np.where(random_vector < crossover_rate, mutant_vector, self.particles[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Enhanced adaptive PSO-DE with time-varying control parameters for improved exploration-exploitation balance.", "configspace": "", "generation": 99, "fitness": 0.3346708543638752, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.335 with standard deviation 0.035. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "eeee1402-d765-472e-97e3-43a5906ab859", "metadata": {"aucs": [0.31158969417934845, 0.3836541589502078, 0.3087687099620694], "final_y": [0.0007293336921340864, 0.00010119893001503817, 0.0008064808656970196]}, "mutation_prompt": null}
