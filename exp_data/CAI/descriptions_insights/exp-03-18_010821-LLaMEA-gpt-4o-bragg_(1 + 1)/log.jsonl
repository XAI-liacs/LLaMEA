{"id": "541a83a8-b7b9-4751-960c-5bbbed7a152f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, func.bounds.lb, func.bounds.ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        if func(trial_vector) < func(target_vector):\n            return trial_vector\n        else:\n            return target_vector\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                # Dynamic parameter adjustment based on diversity\n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.1)\n                    else:\n                        self.mutation_factor = max(0.5, self.mutation_factor - 0.1)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm with dynamic parameter tuning and diversity control to efficiently explore the search space and converge on optimum solutions.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 194, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 288, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"/home/ian/LLaMEA/benchmarks/tuto_global_optimization_photonics/exp_photonic.py\", line 149, in evaluatePhotonic\n    algorithm(problem)\n  File \"<string>\", line 44, in __call__\n  File \"<string>\", line 19, in mutate\nNameError: name 'func' is not defined\n.", "error": "NameError(\"name 'func' is not defined\")Traceback (most recent call last):\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 194, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ian/LLaMEA/./llamea/llamea.py\", line 288, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"/home/ian/LLaMEA/benchmarks/tuto_global_optimization_photonics/exp_photonic.py\", line 149, in evaluatePhotonic\n    algorithm(problem)\n  File \"<string>\", line 44, in __call__\n  File \"<string>\", line 19, in mutate\nNameError: name 'func' is not defined\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "7d5f833a-df08-4eed-97fd-2656a580981f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        if func(trial_vector) < func(target_vector):\n            return trial_vector\n        else:\n            return target_vector\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                # Dynamic parameter adjustment based on diversity\n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.1)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)  # Adjust crossover rate\n                    else:\n                        self.mutation_factor = max(0.5, self.mutation_factor - 0.1)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Modified the adaptive differential evolution algorithm to fix the mutation function's scope and improve convergence by adjusting the crossover rate dynamically based on diversity.", "configspace": "", "generation": 1, "fitness": 0.6462391799177454, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.646 with standard deviation 0.026. And the mean value of best solutions found was 0.261 (0. is the best) with standard deviation 0.017.", "error": "", "parent_id": "541a83a8-b7b9-4751-960c-5bbbed7a152f", "metadata": {"aucs": [0.669647631611005, 0.6589885639502544, 0.6100813441919766], "final_y": [0.26323741301164016, 0.2805137374880142, 0.23805692367705245]}, "mutation_prompt": null}
{"id": "bacb5cca-12ae-4670-94d4-146a6b34be1a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        if func(trial_vector) < func(target_vector):\n            return trial_vector\n        else:\n            return target_vector\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                # Dynamic parameter adjustment based on diversity\n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.1)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.5, self.mutation_factor - 0.1)\n                    # Adjust mutation factor based on performance range\n                    performance_range = np.ptp([func(ind) for ind in self.population])\n                    if performance_range < 0.2:\n                        self.mutation_factor *= 0.9\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduced adaptive mutation factor adjustment based on population performance range to enhance convergence.", "configspace": "", "generation": 2, "fitness": 0.6276135659105929, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.628 with standard deviation 0.037. And the mean value of best solutions found was 0.294 (0. is the best) with standard deviation 0.026.", "error": "", "parent_id": "7d5f833a-df08-4eed-97fd-2656a580981f", "metadata": {"aucs": [0.6555041228785654, 0.65205229030887, 0.5752842845443433], "final_y": [0.26323741301164016, 0.29122154909230413, 0.32757439253674325]}, "mutation_prompt": null}
{"id": "759d44f4-a35b-4e91-98a7-a7e6fc67b283", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        # Multi-strategy mutation\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        if func(trial_vector) < func(target_vector):\n            return trial_vector\n        else:\n            return target_vector\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                # Dynamic parameter adjustment based on diversity\n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.1)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.5, self.mutation_factor - 0.1)\n                \n                # Adaptive population resizing\n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduced multi-strategy differential mutation and adaptive population resizing to enhance exploration-exploitation balance while optimizing convergence.", "configspace": "", "generation": 3, "fitness": 0.6701043722284122, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.670 with standard deviation 0.039. And the mean value of best solutions found was 0.254 (0. is the best) with standard deviation 0.025.", "error": "", "parent_id": "7d5f833a-df08-4eed-97fd-2656a580981f", "metadata": {"aucs": [0.617538250223934, 0.7118451076288965, 0.6809297588324061], "final_y": [0.2858874140175872, 0.22658484054658867, 0.2481825852275541]}, "mutation_prompt": null}
{"id": "6bfc96c9-43ee-4198-b0c0-32a3042fed9f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        if func(trial_vector) < func(target_vector):\n            return trial_vector\n        else:\n            return target_vector\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)  # Increased mutation factor adjustment\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)  # Adjust mutation factor reduction\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                # Reinitialize if diversity is too low\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduced diversity-sustaining strategies with adaptive mutation factor scaling and population reinitialization to enhance convergence efficiency.", "configspace": "", "generation": 4, "fitness": 0.6744633611275942, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.674 with standard deviation 0.020. And the mean value of best solutions found was 0.237 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "759d44f4-a35b-4e91-98a7-a7e6fc67b283", "metadata": {"aucs": [0.6522866174566233, 0.6708526952625383, 0.700250770663621], "final_y": [0.24125339626741038, 0.24359178140584836, 0.22495552060796453]}, "mutation_prompt": null}
{"id": "5f7543eb-3019-46b0-9ce5-81d6bb923bf0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        if func(trial_vector) < func(target_vector):\n            return trial_vector\n        else:\n            return target_vector\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)\n                        \n                # Periodic elite preservation\n                if evaluations % (self.population_size * 3) == 0:\n                    best = min(self.population, key=func)\n                    self.population[0] = best\n\n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced convergence by incorporating a dynamic selection pressure mechanism and improving diversity with periodic elite preservation strategy.", "configspace": "", "generation": 5, "fitness": 0.6562130424081282, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.656 with standard deviation 0.043. And the mean value of best solutions found was 0.258 (0. is the best) with standard deviation 0.032.", "error": "", "parent_id": "6bfc96c9-43ee-4198-b0c0-32a3042fed9f", "metadata": {"aucs": [0.6212478638435036, 0.6302744117662906, 0.7171168516145902], "final_y": [0.26299264957407464, 0.29390145966336945, 0.21683430124035163]}, "mutation_prompt": null}
{"id": "c05b1e66-7817-445d-b6ca-8af76916cde5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        # Weighted selection based on performance\n        alpha = 0.5\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)  # Increased mutation factor adjustment\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)  # Adjust mutation factor reduction\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                # Reinitialize if diversity is too low\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced selection strategy by introducing a weighted selection mechanism using a weighted sum of the trial and target vectors based on their performance.", "configspace": "", "generation": 6, "fitness": 0.9032413676041561, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.903 with standard deviation 0.018. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "6bfc96c9-43ee-4198-b0c0-32a3042fed9f", "metadata": {"aucs": [0.8785404583052018, 0.9116461372593601, 0.9195375072479066], "final_y": [0.17480875522251604, 0.16897285100433235, 0.1669338060148854]}, "mutation_prompt": null}
{"id": "5a74f1ce-dd0f-46a7-b09f-eb276fd82407", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity = np.std(self.population)\n        dynamic_factor = 0.5 + (0.5 * (diversity / (diversity + 1)))  # Dynamic scaling adjustment\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + dynamic_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + dynamic_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 0.5\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Refinement in mutation strategy by introducing dynamic scaling factor adjustment based on population diversity to enhance exploration and exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.8070058856994126, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.807 with standard deviation 0.024. And the mean value of best solutions found was 0.203 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "c05b1e66-7817-445d-b6ca-8af76916cde5", "metadata": {"aucs": [0.7922621170471051, 0.7880481590612671, 0.8407073809898652], "final_y": [0.2042780473359157, 0.2122682495636652, 0.19123909290301944]}, "mutation_prompt": null}
{"id": "82b48f86-6f64-4bd6-ad5f-afe9a19a357f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        # Enhanced mutation strategy\n        mutant_vector += 0.1 * np.random.randn(self.dim)\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 0.5\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                        self.base_population_factor = max(15, self.base_population_factor + 1)  # Adaptive population growth\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Improved mutation strategy and adaptive parameter tuning to enhance solution exploration and convergence.", "configspace": "", "generation": 8, "fitness": 0.8913642445170297, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.891 with standard deviation 0.026. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "c05b1e66-7817-445d-b6ca-8af76916cde5", "metadata": {"aucs": [0.8918225086611726, 0.859098214107027, 0.9231720107828891], "final_y": [0.16845746103895975, 0.17326981437749234, 0.1687391826353999]}, "mutation_prompt": null}
{"id": "e8551b31-a9b2-408f-aead-f7616af0384d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        # Weighted selection based on performance\n        alpha = 0.5\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)  # Increased mutation factor adjustment\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)  # Adjust mutation factor reduction\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)  # Adaptive crossover adjustment\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                # Reinitialize if diversity is too low\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive crossover rate adjustment based on performance variance to improve diversity and convergence.", "configspace": "", "generation": 9, "fitness": 0.9065984831307384, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.907 with standard deviation 0.006. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c05b1e66-7817-445d-b6ca-8af76916cde5", "metadata": {"aucs": [0.902393495251411, 0.915545477642364, 0.9018564764984405], "final_y": [0.16724919991016207, 0.16764655510675375, 0.16684457120443508]}, "mutation_prompt": null}
{"id": "c6112f36-a447-4eb5-bff6-c6c30262970b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 0.5\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.1)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.15)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.03)\n                    \n                    if evaluations % (self.population_size * 3) == 0:\n                        old_population_size = self.population_size\n                        self.population_size = min(self.base_population_factor * self.dim, self.population_size + 2)\n                        if self.population_size > old_population_size:\n                            self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (self.population_size - old_population_size, self.dim))))\n\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic population resizing and strategy adaptation based on optimization progress.", "configspace": "", "generation": 10, "fitness": 0.8989355573843142, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.899 with standard deviation 0.007. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "e8551b31-a9b2-408f-aead-f7616af0384d", "metadata": {"aucs": [0.8908224108634692, 0.9079296348624843, 0.8980546264269891], "final_y": [0.16712355051862748, 0.16839836559646715, 0.16890136070291206]}, "mutation_prompt": null}
{"id": "0a1003a6-72e1-4e62-90f9-b6c5b7c53246", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        diversity = np.std(self.population)\n        adaptive_cr = self.crossover_rate + 0.1 * (1 - diversity)  # Adjust crossover with diversity influence\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < adaptive_cr else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 0.5\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                diversity = np.std(self.population) \n                self.mutation_factor = 0.5 + 0.2 * diversity  # Adaptive mutation factor\n\n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    if diversity < 0.1:\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n\n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhance mutation and crossover dynamics with fitness diversity influence to improve search exploration and exploitation balance.", "configspace": "", "generation": 11, "fitness": 0.4940133776288304, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.494 with standard deviation 0.005. And the mean value of best solutions found was 0.409 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "e8551b31-a9b2-408f-aead-f7616af0384d", "metadata": {"aucs": [0.4951124699835643, 0.48799130626851117, 0.4989363566344157], "final_y": [0.4073425911909888, 0.41379549904142665, 0.4051421831226424]}, "mutation_prompt": null}
{"id": "5b0019c7-a6d8-463a-98c5-7c1e1345c632", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 0.5\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.15:  # Increase diversity threshold\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim + 2, self.population_size + 1)  # Dynamic resizing\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic population resizing and refined diversity threshold for enhanced exploration.", "configspace": "", "generation": 12, "fitness": 0.9054602655440084, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.905 with standard deviation 0.004. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e8551b31-a9b2-408f-aead-f7616af0384d", "metadata": {"aucs": [0.8997200081620387, 0.9088298193146152, 0.9078309691553715], "final_y": [0.16812437325066099, 0.1675263533677691, 0.16708963280295142]}, "mutation_prompt": null}
{"id": "19a247ac-6f84-4817-a0f7-7cf95e2ef46f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() < 0.3:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 0.5\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.15)  # Reduced mutation factor adjustment\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.04)  # Slightly reduced adaptive crossover adjustment\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Adjust mutation strategy via dynamic adjustment based on performance variance to improve convergence.", "configspace": "", "generation": 13, "fitness": 0.890171927287252, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.890 with standard deviation 0.018. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "e8551b31-a9b2-408f-aead-f7616af0384d", "metadata": {"aucs": [0.8662638628274756, 0.8955402317135602, 0.9087116873207203], "final_y": [0.1761076419853549, 0.16933782134788, 0.16597470208770748]}, "mutation_prompt": null}
{"id": "559b1f6f-5a3b-4082-94a8-79f06429a474", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        # Weighted selection based on performance\n        alpha = 0.5\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.2:  # Adjusted diversity threshold\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.12)  # Modified mutation factor adjustment\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.04)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.15)  # Adjust mutation factor reduction\n                        self.crossover_rate = max(0.5, self.crossover_rate - 0.04)  # Adaptive crossover adjustment\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                # Reinitialize if diversity is too low\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.08:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Refine diversity control and adaptive mutation strategy to enhance convergence efficiency and solution quality.", "configspace": "", "generation": 14, "fitness": 0.9049679486507776, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.905 with standard deviation 0.016. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "e8551b31-a9b2-408f-aead-f7616af0384d", "metadata": {"aucs": [0.8848321880806271, 0.9243399370098809, 0.9057317208618249], "final_y": [0.1717576817649905, 0.16748904886513039, 0.16811308784881207]}, "mutation_prompt": null}
{"id": "882593a7-6921-4189-84f9-2f27e03277b7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        # Weighted selection based on performance\n        alpha = 0.5\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                        self.population_size = min(self.base_population_factor * self.dim, self.population_size + 5) # Increased population adjustment\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                # Reinitialize if diversity is too low\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive population size adjustment based on diversity to enhance exploration and exploitation balance.", "configspace": "", "generation": 15, "fitness": 0.9065984831307384, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.907 with standard deviation 0.006. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e8551b31-a9b2-408f-aead-f7616af0384d", "metadata": {"aucs": [0.902393495251411, 0.915545477642364, 0.9018564764984405], "final_y": [0.16724919991016207, 0.16764655510675375, 0.16684457120443508]}, "mutation_prompt": null}
{"id": "22dbb5b5-61cc-4306-89a9-42f1a9209f32", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        if np.random.rand() < 0.3:  # Add dynamic mutation strategy\n            d = np.random.choice(indices)\n            mutant_vector += self.mutation_factor * (self.population[d] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 0.5\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim * 2, self.population_size + 1)  # Increase potential max size\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic population resizing and adaptive mutation strategy to enhance exploration and exploitation balance.", "configspace": "", "generation": 16, "fitness": 0.8343983745031555, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.834 with standard deviation 0.014. And the mean value of best solutions found was 0.184 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "e8551b31-a9b2-408f-aead-f7616af0384d", "metadata": {"aucs": [0.8519593628287706, 0.8188234165349425, 0.8324123441457536], "final_y": [0.17855475261937603, 0.17363544594990876, 0.19849471401498398]}, "mutation_prompt": null}
{"id": "558b516b-d913-4b57-867c-34a86a5b62bf", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        # Weighted selection based on performance\n        alpha = 0.5\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)  # Increased mutation factor adjustment\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)  # Adjust mutation factor reduction\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)  # Adaptive crossover adjustment\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                # Reinitialize if diversity is too low\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.mutation_factor = 0.5  # Dynamic reset of mutation factor\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic mutation factor adaptation based on population diversity for improved exploration.", "configspace": "", "generation": 17, "fitness": 0.9065984831307384, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.907 with standard deviation 0.006. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e8551b31-a9b2-408f-aead-f7616af0384d", "metadata": {"aucs": [0.902393495251411, 0.915545477642364, 0.9018564764984405], "final_y": [0.16724919991016207, 0.16764655510675375, 0.16684457120443508]}, "mutation_prompt": null}
{"id": "4c0cf8df-b7ea-4a0b-90c1-7e5ff8cc9da4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        scale_factor = np.random.uniform(0.4, 0.9)  # Line 1: Introduce dynamic scaling\n        mutant_vector = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        # Line 2: Introduce stochastic selection\n        if trial_score < target_score or np.random.rand() < 0.1:\n            return trial_vector\n        else:\n            return target_vector\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by introducing dynamic mutation scaling and stochastic selection to improve diversity and solution quality.", "configspace": "", "generation": 18, "fitness": 0.6419974568604232, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.642 with standard deviation 0.047. And the mean value of best solutions found was 0.295 (0. is the best) with standard deviation 0.037.", "error": "", "parent_id": "e8551b31-a9b2-408f-aead-f7616af0384d", "metadata": {"aucs": [0.6410854478109322, 0.700319338469444, 0.5845875843008934], "final_y": [0.3038206905046271, 0.2467912126451225, 0.33506495499429567]}, "mutation_prompt": null}
{"id": "502f5934-4bd4-4d52-9b96-9191c12ed9fe", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        # Weighted selection based on performance\n        alpha = 0.5\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.1 + 0.05)  # Adjusted mutation factor increment\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                # Reinitialize if diversity is too low\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic scaling of mutation factor based on population diversity to enhance convergence adaptability.", "configspace": "", "generation": 19, "fitness": 0.9065984831307384, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.907 with standard deviation 0.006. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e8551b31-a9b2-408f-aead-f7616af0384d", "metadata": {"aucs": [0.902393495251411, 0.915545477642364, 0.9018564764984405], "final_y": [0.16724919991016207, 0.16764655510675375, 0.16684457120443508]}, "mutation_prompt": null}
{"id": "c8fceaa4-4d99-4bd2-9c1f-3f08147c45ea", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.elite_ratio = 0.1  # Introduce elitism\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        return trial_vector if trial_score < target_score else target_vector\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    new_individuals = int(self.elite_ratio * self.population_size)  # Increase diversity\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (new_individuals, self.dim))))  \n\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    elite_count = int(self.elite_ratio * self.population_size)\n                    elites = sorted(self.population, key=func)[:elite_count]  # Preserve elite individuals\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n                    self.population[:elite_count] = elites  # Reinsert elites\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce elitism and enhanced diversity management to boost convergence in adaptive differential evolution.", "configspace": "", "generation": 20, "fitness": 0.6626531021621702, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.663 with standard deviation 0.017. And the mean value of best solutions found was 0.245 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "e8551b31-a9b2-408f-aead-f7616af0384d", "metadata": {"aucs": [0.6866937295920066, 0.6539928980611991, 0.647272678833305], "final_y": [0.2395781873957591, 0.25721033362038925, 0.23820978539984095]}, "mutation_prompt": null}
{"id": "4e4a7c0f-b1bc-4744-ae2d-fa55da056e0c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)  # Increased mutation factor adjustment\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)  # Adjust mutation factor reduction\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)  # Adaptive crossover adjustment\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                # Reinitialize if diversity is too low\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhance solution by introducing a dynamic weighting factor during selection based on relative trial and target scores.", "configspace": "", "generation": 21, "fitness": 0.9112734122653695, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.911 with standard deviation 0.004. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "e8551b31-a9b2-408f-aead-f7616af0384d", "metadata": {"aucs": [0.908924838320445, 0.9165378802437105, 0.9083575182319529], "final_y": [0.16891440510756006, 0.1666191472698474, 0.1693892145397058]}, "mutation_prompt": null}
{"id": "1c9d07c4-2c58-4be0-abd8-a00d255991c4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(0.9, self.mutation_factor + 0.2)\n                        self.crossover_rate = min(0.95, self.crossover_rate + 0.1)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.15)\n                        self.crossover_rate = max(0.5, self.crossover_rate - 0.1)\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Improve solution exploration by introducing dynamic adaption of mutation and crossover rates based on population diversity and evaluation stages.", "configspace": "", "generation": 22, "fitness": 0.9058642814153411, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.906 with standard deviation 0.001. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "4e4a7c0f-b1bc-4744-ae2d-fa55da056e0c", "metadata": {"aucs": [0.906579015182953, 0.9057038279019128, 0.9053100011611577], "final_y": [0.16827761988198353, 0.16861418065655376, 0.16580775279757487]}, "mutation_prompt": null}
{"id": "fa380335-4e16-457f-b52b-af36175e0cd2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n        prev_best = None\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n\n                current_best = min(self.population, key=func)\n                if prev_best is not None and evaluations % (self.population_size * 2) == 0:\n                    if np.isclose(func(current_best), func(prev_best), atol=0.01):\n                        self.population_size = max(self.base_population_factor * self.dim // 2, self.population_size - 1)\n                        self.population = self.population[:self.population_size]\n                    else:\n                        self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                        self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n                prev_best = current_best\n                \n                if evaluations % (self.population_size * 2) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)  # Increased mutation factor adjustment\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)  # Adjust mutation factor reduction\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)  # Adaptive crossover adjustment\n                    \n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive population scaling based on convergence rate to improve exploration and exploitation balance.", "configspace": "", "generation": 23, "fitness": 0.5580683674945152, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.558 with standard deviation 0.032. And the mean value of best solutions found was 0.331 (0. is the best) with standard deviation 0.033.", "error": "", "parent_id": "4e4a7c0f-b1bc-4744-ae2d-fa55da056e0c", "metadata": {"aucs": [0.6010387651963859, 0.5229728193841259, 0.5501935179030335], "final_y": [0.2845888971332312, 0.34505189062939556, 0.36245336952229723]}, "mutation_prompt": null}
{"id": "a87865f3-c4db-476e-b1da-64a2b6cf6726", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n        previous_best_score = np.inf\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                current_best_score = func(min(self.population, key=func))\n                if current_best_score < previous_best_score:\n                    self.mutation_factor = max(0.4, self.mutation_factor - 0.1)  # Adjust mutation factor reduction\n                previous_best_score = current_best_score\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)  # Increased mutation factor adjustment\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)  # Adjust mutation factor reduction\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)  # Adaptive crossover adjustment\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                # Reinitialize if diversity is too low\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Dynamically adjust the mutation factor based on improvement rate to enhance convergence speed and precision.", "configspace": "", "generation": 24, "fitness": 0.5181158554041577, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.518 with standard deviation 0.012. And the mean value of best solutions found was 0.369 (0. is the best) with standard deviation 0.027.", "error": "", "parent_id": "4e4a7c0f-b1bc-4744-ae2d-fa55da056e0c", "metadata": {"aucs": [0.5013224974427604, 0.5299757130639235, 0.5230493557057891], "final_y": [0.39450038877600513, 0.3311072925900842, 0.3804921270553695]}, "mutation_prompt": null}
{"id": "336e2311-d0d1-4da1-b819-a788b8565081", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)  # Increased mutation factor adjustment\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)  # Adjust mutation factor reduction\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)  # Adaptive crossover adjustment\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                # Reinitialize if diversity is too low with a probabilistic component\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05 and np.random.rand() < 0.5:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a probabilistic component to population reinitialization to maintain diversity and enhance exploration.", "configspace": "", "generation": 25, "fitness": 0.9112734122653695, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.911 with standard deviation 0.004. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "4e4a7c0f-b1bc-4744-ae2d-fa55da056e0c", "metadata": {"aucs": [0.908924838320445, 0.9165378802437105, 0.9083575182319529], "final_y": [0.16891440510756006, 0.1666191472698474, 0.1693892145397058]}, "mutation_prompt": null}
{"id": "8e59b78b-2a38-4e87-9b66-5ed93b012e94", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  \n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n        previous_min_score = None\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n\n                current_min_score = min(self.population, key=func)\n                if previous_min_score is not None:\n                    convergence_rate = np.abs(func(current_min_score) - func(previous_min_score))\n                    if convergence_rate < 0.001:  # Adaptive adjustment based on convergence\n                        self.population_size = max(2, self.population_size - 1)\n                    else:\n                        self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n\n                previous_min_score = current_min_score\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduces an adaptive population size adjustment based on convergence rate to enhance exploration-exploitation balance.", "configspace": "", "generation": 26, "fitness": 0.5915217559530667, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.592 with standard deviation 0.016. And the mean value of best solutions found was 0.333 (0. is the best) with standard deviation 0.020.", "error": "", "parent_id": "4e4a7c0f-b1bc-4744-ae2d-fa55da056e0c", "metadata": {"aucs": [0.5823689250536674, 0.5777037240799677, 0.6144926187255646], "final_y": [0.3453516588029474, 0.34728634811840786, 0.3049128560280072]}, "mutation_prompt": null}
{"id": "8a55c1c6-75ee-4516-85cf-84ae9df2d627", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity = np.std(self.population)  # Calculate diversity\n        adaptive_mutation_factor = min(1.0, self.mutation_factor + 0.1 * diversity)  # Adaptive mutation factor\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + adaptive_mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + adaptive_mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)  # Increased mutation factor adjustment\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)  # Adjust mutation factor reduction\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)  # Adaptive crossover adjustment\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                # Reinitialize if diversity is too low\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation based on population diversity to enhance exploration and convergence rates.", "configspace": "", "generation": 27, "fitness": 0.8348399561770342, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.835 with standard deviation 0.023. And the mean value of best solutions found was 0.186 (0. is the best) with standard deviation 0.008.", "error": "", "parent_id": "4e4a7c0f-b1bc-4744-ae2d-fa55da056e0c", "metadata": {"aucs": [0.8372592937024635, 0.8060458198384651, 0.861214754990174], "final_y": [0.17755792217520028, 0.19698636560440674, 0.18447497102730281]}, "mutation_prompt": null}
{"id": "7946ab0b-1098-4f06-a338-5ebc9acc5306", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n\n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n\n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n\n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                # Reinitialize if diversity is too low\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive control for mutation and crossover based on population diversity and performance.", "configspace": "", "generation": 28, "fitness": 0.88067469785902, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.881 with standard deviation 0.012. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "4e4a7c0f-b1bc-4744-ae2d-fa55da056e0c", "metadata": {"aucs": [0.8971665167837277, 0.8711643832985735, 0.8736931934947587], "final_y": [0.16652208031629268, 0.17589584520930146, 0.16826694427563027]}, "mutation_prompt": null}
{"id": "73e86c81-76be-46d9-89e3-6db6acd77665", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.20)  # Increased mutation factor adjustment\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.07)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)  # Adjust mutation factor reduction\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)  # Adaptive crossover adjustment\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                # Reinitialize if diversity is too low\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Improve adaptive mutation and crossover adjustment based on diversity metrics to increase exploration.", "configspace": "", "generation": 29, "fitness": 0.9112734122653695, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.911 with standard deviation 0.004. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "4e4a7c0f-b1bc-4744-ae2d-fa55da056e0c", "metadata": {"aucs": [0.908924838320445, 0.9165378802437105, 0.9083575182319529], "final_y": [0.16891440510756006, 0.1666191472698474, 0.1693892145397058]}, "mutation_prompt": null}
{"id": "4d282361-97ea-476f-b38b-0a2d81839122", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.best_solution = None  # Track the best solution found\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.best_solution = min(self.population, key=func)  # Initialize best solution\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        if trial_score < target_score:\n            self.best_solution = trial_vector if func(trial_vector) < func(self.best_solution) else self.best_solution  # Update best solution\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)  # Increased mutation factor adjustment\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)  # Adjust mutation factor reduction\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)  # Adaptive crossover adjustment\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                # Reinitialize if diversity is too low\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population + [self.best_solution], key=func)", "name": "AdaptiveDifferentialEvolution", "description": "A refined adaptive strategy by incorporating success-based parameter adaptation and introducing a semi-elitist approach to enhance exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "4e4a7c0f-b1bc-4744-ae2d-fa55da056e0c", "metadata": {}, "mutation_prompt": null}
{"id": "ee79cb00-3b74-41f4-95f6-88cc952d2cf6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.1)  # Adjusted crossover increment\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                # Reinitialize if diversity is too low\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhance selection strategy by dynamically adjusting crossover rate based on trial and target diversity.", "configspace": "", "generation": 31, "fitness": 0.9112734122653695, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.911 with standard deviation 0.004. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "4e4a7c0f-b1bc-4744-ae2d-fa55da056e0c", "metadata": {"aucs": [0.908924838320445, 0.9165378802437105, 0.9083575182319529], "final_y": [0.16891440510756006, 0.1666191472698474, 0.1693892145397058]}, "mutation_prompt": null}
{"id": "9ba9983b-b20d-4854-b9d8-bfbcecc26856", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n\n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n\n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n                # Probabilistic migration for top individuals\n                if np.random.rand() < 0.1:\n                    top_indices = np.argsort([func(ind) for ind in self.population])[:5]\n                    self.population[np.random.choice(range(self.population_size), 1)] = self.population[np.random.choice(top_indices, 1)]\n                    \n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce probabilistic migration of top individuals to enhance exploration and exploitation balance.", "configspace": "", "generation": 32, "fitness": 0.7631335728124897, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.763 with standard deviation 0.076. And the mean value of best solutions found was 0.200 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "4e4a7c0f-b1bc-4744-ae2d-fa55da056e0c", "metadata": {"aucs": [0.6623312736328425, 0.7822911413770468, 0.8447783034275796], "final_y": [0.2098358563863052, 0.20250353667286403, 0.18628428598085967]}, "mutation_prompt": null}
{"id": "1d1d60d1-f9fb-4b8e-8f5b-2501ee06f9f7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.elite = None  # Track the elite solution\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.elite = self.population[0]\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        result = trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n        elite_score = func(self.elite)\n        if trial_score < elite_score:\n            self.elite = trial_vector  # Update elite if trial is better\n        return result\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)  # Increased mutation factor adjustment\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.2)  # Adjust mutation factor reduction\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)  # Adaptive crossover adjustment\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                # Reinitialize if diversity is too low\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population + [self.elite], key=func)  # Include elite in final evaluation", "name": "AdaptiveDifferentialEvolution", "description": "Introduced an elite preservation mechanism to retain and exploit top-performing solutions during adaptation.", "configspace": "", "generation": 33, "fitness": 0.8753310441511415, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.875 with standard deviation 0.003. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "4e4a7c0f-b1bc-4744-ae2d-fa55da056e0c", "metadata": {"aucs": [0.8737401318199581, 0.8799929115580315, 0.8722600890754348], "final_y": [0.17315433264108138, 0.16888922944556706, 0.17187194144955298]}, "mutation_prompt": null}
{"id": "4c8f9ea5-0d5b-4e3e-907e-624423b279ba", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)  # Increased mutation factor adjustment\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)  # Adjust mutation factor reduction\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)  # Adaptive crossover adjustment\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                # Reinitialize if diversity is too low\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a check to reduce mutation factors slightly more aggressively when diversity is low, aiming to enhance convergence. ", "configspace": "", "generation": 34, "fitness": 0.9167308292059877, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.917 with standard deviation 0.004. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4e4a7c0f-b1bc-4744-ae2d-fa55da056e0c", "metadata": {"aucs": [0.9154691722334902, 0.9223598787032583, 0.9123634366812148], "final_y": [0.16768864492134583, 0.16769780931174305, 0.1686049113370679]}, "mutation_prompt": null}
{"id": "f4f2f099-f977-4e7d-9b1e-e088e883dd69", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.10)  # Slightly reduced mutation factor adjustment\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.02)  # Slightly reduced increase rate\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.15)  # Smaller decrease step\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.02)  # Smaller decrease step\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                # Reinitialize if diversity is too low\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Improved Diversity Management for Enhanced Convergence.", "configspace": "", "generation": 35, "fitness": 0.913795454711073, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.914 with standard deviation 0.002. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4c8f9ea5-0d5b-4e3e-907e-624423b279ba", "metadata": {"aucs": [0.9160024219681453, 0.9124273454056073, 0.9129565967594666], "final_y": [0.16848016500469032, 0.16828527142428584, 0.16903708334284595]}, "mutation_prompt": null}
{"id": "9f5e3db0-7d3c-4f31-9e95-36bd9b8943c9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.elite_size = max(1, int(0.05 * self.population_size))  # Add elite size\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n        elite_population = []\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)  # Increased mutation factor adjustment\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)  # Adjust mutation factor reduction\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)  # Adaptive crossover adjustment\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                # Reinitialize if diversity is too low\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n            # Elite strategy: retain top solutions\n            elite_population = sorted(self.population, key=func)[:self.elite_size]\n            self.population[:self.elite_size] = elite_population\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a gradually increasing elitism strategy to improve solution retention and convergence speed.", "configspace": "", "generation": 36, "fitness": 0.8935012285040539, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.894 with standard deviation 0.008. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "4c8f9ea5-0d5b-4e3e-907e-624423b279ba", "metadata": {"aucs": [0.8903484716669285, 0.9042997342537682, 0.8858554795914646], "final_y": [0.16862983440094625, 0.16652189812435247, 0.16963324198424845]}, "mutation_prompt": null}
{"id": "6955847a-b2f1-4893-b18a-1e670d4d1e5a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.12:  # Changed from 0.1 to 0.12\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)  # Increased mutation factor adjustment\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)  # Adjust mutation factor reduction\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)  # Adaptive crossover adjustment\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                # Reinitialize if diversity is too low\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhance population diversity handling by adjusting the criteria for mutation factor increase.", "configspace": "", "generation": 37, "fitness": 0.9167308292059877, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.917 with standard deviation 0.004. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4c8f9ea5-0d5b-4e3e-907e-624423b279ba", "metadata": {"aucs": [0.9154691722334902, 0.9223598787032583, 0.9123634366812148], "final_y": [0.16768864492134583, 0.16769780931174305, 0.1686049113370679]}, "mutation_prompt": null}
{"id": "f7ea65c8-0591-43a4-a60f-fbaee34b82b7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.1)  # Fine-tune mutation factor increment\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.02)  # Fine-tune crossover rate increment\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.1)  # Fine-tune mutation factor decrement\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.02)  # Fine-tune crossover rate decrement\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptive strategies by adjusting mutation and crossover rates more precisely based on population diversity.", "configspace": "", "generation": 38, "fitness": 0.914222764570996, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.914 with standard deviation 0.007. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "4c8f9ea5-0d5b-4e3e-907e-624423b279ba", "metadata": {"aucs": [0.917008079246449, 0.9213010276860993, 0.9043591867804398], "final_y": [0.16710018704219487, 0.16764171306572506, 0.16974611670411877]}, "mutation_prompt": null}
{"id": "aaf96fae-2f5c-4fbd-b074-eae05b3ba8a7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                # Introduce partial reinitialization when diversity is critically low\n                if diversity < 0.05 and evaluations % (self.population_size * 5) == 0:\n                    num_reinit = self.population_size // 3\n                    self.population[:num_reinit] = np.random.uniform(func.bounds.lb, func.bounds.ub, (num_reinit, self.dim))\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a diversity-based restart mechanism to reinitialize part of the population when diversity is critically low to enhance exploration.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'diversity' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'diversity' referenced before assignment\")", "parent_id": "4c8f9ea5-0d5b-4e3e-907e-624423b279ba", "metadata": {}, "mutation_prompt": null}
{"id": "a54f3ea3-5e19-416d-8b3a-952890def3fe", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:  # Slightly more aggressive reduction\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.25)  \n                        self.crossover_rate = max(0.5, self.crossover_rate - 0.1)  \n                    \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 10) == 0 and diversity < 0.05:\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by dynamically adjusting mutation and crossover factors based on solution quality.", "configspace": "", "generation": 40, "fitness": 0.8998462172335328, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.900 with standard deviation 0.008. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "4c8f9ea5-0d5b-4e3e-907e-624423b279ba", "metadata": {"aucs": [0.8952868453111468, 0.9107955272058403, 0.8934562791836113], "final_y": [0.169226777696306, 0.1670877949650148, 0.16886150563693192]}, "mutation_prompt": null}
{"id": "75f78050-5250-458b-a816-ae7d778c251b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a strategic diversity boost mechanism to periodically inject random vectors and balance exploration and exploitation.", "configspace": "", "generation": 41, "fitness": 0.9185982639868561, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.919 with standard deviation 0.005. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "4c8f9ea5-0d5b-4e3e-907e-624423b279ba", "metadata": {"aucs": [0.9145733566360507, 0.9250997878530695, 0.9161216474714482], "final_y": [0.16708764755847694, 0.16682394112166288, 0.16645728506213275]}, "mutation_prompt": null}
{"id": "06dbecf1-1652-43c6-b107-59fb10bc9bc8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0 and np.random.rand() < 0.75:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Utilize adaptive probability for strategic diversity boosts to enhance global exploration.", "configspace": "", "generation": 42, "fitness": 0.9171397510222764, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.917 with standard deviation 0.004. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "75f78050-5250-458b-a816-ae7d778c251b", "metadata": {"aucs": [0.9123723781010947, 0.9219316630494648, 0.9171152119162698], "final_y": [0.16827562111527872, 0.16769707681113133, 0.1657050928261784]}, "mutation_prompt": null}
{"id": "bad5bf9b-5eca-4537-a450-394539463f0c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        best = np.argmin([func(ind) for ind in self.population])  # New\n        mutant_vector = self.population[best] + self.mutation_factor * (self.population[a] - self.population[b])  # New\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by incorporating differential mutation strategies and adaptive parameter tuning based on feedback.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "75f78050-5250-458b-a816-ae7d778c251b", "metadata": {}, "mutation_prompt": null}
{"id": "6bbb3ce8-1e05-4ed9-b21b-cb9ffed03073", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n        success_count = 0  # Track successful trial vectors\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                if func(trial_vector) < func(self.population[i]):\n                    success_count += 1  # Increment success count if trial is better\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n\n                if (evaluations % (self.population_size * 2)) == 0:\n                    success_rate = success_count / (self.population_size * 2)\n                    success_count = 0  # Reset success count\n                    if success_rate > 0.2:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.05)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.05)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce self-adaptive mutation and crossover rates based on historical performance to enhance adaptive evolution.", "configspace": "", "generation": 44, "fitness": 0.8449567555236693, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.845 with standard deviation 0.010. And the mean value of best solutions found was 0.173 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "75f78050-5250-458b-a816-ae7d778c251b", "metadata": {"aucs": [0.8381978246237554, 0.859087181295388, 0.8375852606518647], "final_y": [0.17835795534413912, 0.1738448977888446, 0.16760893040037494]}, "mutation_prompt": null}
{"id": "9275c26c-568e-46b0-8412-a44934997f60", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 12  # Change 1: Adjusted base population factor\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.stagnation_counter = 0  # Change 2: Introduced stagnation counter\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        if trial_score < target_score:\n            self.stagnation_counter = 0  # Reset stagnation counter\n            return trial_vector\n        else:\n            self.stagnation_counter += 1  # Increment stagnation counter\n            return (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n\n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n\n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.1)  # Change 3: Adjusted mutation increment\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.03)  # Change 4: Adjusted crossover increment\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.15)  # Change 5: Adjusted mutation decrement\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.03)  # Change 6: Adjusted crossover decrement\n\n                if evaluations % (self.population_size * 5) == 0:\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if self.stagnation_counter > (self.population_size * 0.5):  # Change 7: Stagnation-based strategy\n                    self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.population_size, self.dim))\n                    self.stagnation_counter = 0  # Reset stagnation counter after boost\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptive diversity management by dynamically adjusting mutation and crossover rates based on population convergence trends.", "configspace": "", "generation": 45, "fitness": 0.866200396598375, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.866 with standard deviation 0.010. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "75f78050-5250-458b-a816-ae7d778c251b", "metadata": {"aucs": [0.852362096669806, 0.8722980827653688, 0.8739410103599499], "final_y": [0.17040172311252066, 0.17092245049398191, 0.16689164611396556]}, "mutation_prompt": null}
{"id": "9df8fe3c-d40d-4191-8773-d587ef4f162c", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity_term = np.std(self.population, axis=0)\n        mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c] + diversity_term)\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        return np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, target_vector)\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        return trial_vector if trial_score < target_score else target_vector\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if evaluations % (self.population_size * 2) == 0:\n                    diversity = np.std(self.population)\n                    self.mutation_factor = min(1.0, 0.4 * np.exp(-diversity) + 0.1)\n                    if diversity < 0.1:\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.1)\n                    else:\n                        self.crossover_rate = max(0.5, self.crossover_rate - 0.1)\n                \n                if evaluations % (self.population_size * 5) == 0:\n                    self.mutation_factor = max(0.3, self.mutation_factor - 0.15)\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n                \n                if evaluations % (self.population_size * 3) == 0:\n                    self.population[np.random.choice(self.population_size, size=3, replace=False)] = np.random.uniform(func.bounds.lb, func.bounds.ub, (3, self.dim))\n\n        return min(self.population, key=func)", "name": "EnhancedDifferentialEvolution", "description": "Integrate dynamic parameter tuning based on population diversity and strategic migration to optimize solution quality and convergence speed.", "configspace": "", "generation": 46, "fitness": 0.7464577080129163, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.746 with standard deviation 0.019. And the mean value of best solutions found was 0.215 (0. is the best) with standard deviation 0.021.", "error": "", "parent_id": "75f78050-5250-458b-a816-ae7d778c251b", "metadata": {"aucs": [0.7465988697565278, 0.7232292748099779, 0.7695449794722435], "final_y": [0.19931043714658947, 0.2447777004513919, 0.200752256249493]}, "mutation_prompt": null}
{"id": "3900723b-33e2-4f7b-8904-dba833dd9c3a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        # Modified line for better convergence\n        return alpha * trial_vector + (1 - alpha) * target_vector\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhance selection by introducing weighted trial and target vectors for improved convergence.", "configspace": "", "generation": 47, "fitness": 0.8936555104406457, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.894 with standard deviation 0.022. And the mean value of best solutions found was 0.187 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "75f78050-5250-458b-a816-ae7d778c251b", "metadata": {"aucs": [0.910234055188756, 0.8624083578738535, 0.9083241182593276], "final_y": [0.1832978658779013, 0.19938349435986247, 0.1791508570324858]}, "mutation_prompt": null}
{"id": "866e4df7-a673-4844-baff-385051ea8b5e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:  # Gradient-based local search\n                    best_idx = np.argmin([func(ind) for ind in self.population])\n                    gradient = np.random.normal(size=self.dim)\n                    self.population[best_idx] += 0.01 * gradient\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a gradient-based local search step to refine the best solutions periodically and enhance convergence.", "configspace": "", "generation": 48, "fitness": 0.9054908616037047, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.905 with standard deviation 0.002. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "75f78050-5250-458b-a816-ae7d778c251b", "metadata": {"aucs": [0.9027532357345449, 0.9062347208004697, 0.9074846282760997], "final_y": [0.16839943625948617, 0.16716882310753622, 0.167766942667813]}, "mutation_prompt": null}
{"id": "fec40298-a8da-4a9b-848f-bc6e96ac17c6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    fitness_var = np.var([func(ind) for ind in self.population])\n                    scale_factor = 1 + fitness_var / (1 + fitness_var)\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = scale_factor * random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Refine the strategic diversity boost mechanism by incorporating adaptive random vector scaling based on fitness variance.", "configspace": "", "generation": 49, "fitness": 0.9163450628368329, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.916 with standard deviation 0.005. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "75f78050-5250-458b-a816-ae7d778c251b", "metadata": {"aucs": [0.911756397700957, 0.922686231486938, 0.9145925593226039], "final_y": [0.1680365501116955, 0.16646563985736185, 0.1665456268309985]}, "mutation_prompt": null}
{"id": "3df456c7-faec-4c10-9852-b5752541d463", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.learning_rate = 0.1  # New adaptive learning rate\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        \n        # Multi-strategy mutation approach\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        \n        mutant_vector += self.learning_rate * (self.population.mean(axis=0) - self.population[target_idx])  # Adaptive component\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    self.learning_rate *= 1.1 if diversity < 0.1 else 0.9  # Adaptive learning rate adjustment\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence via adaptive learning rates and multi-strategy mutation for improved exploration-exploitation balance.", "configspace": "", "generation": 50, "fitness": 0.9178125545335288, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.918 with standard deviation 0.009. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "75f78050-5250-458b-a816-ae7d778c251b", "metadata": {"aucs": [0.9044063334175013, 0.9243094321197537, 0.9247218980633314], "final_y": [0.17056588296165487, 0.16808073989030137, 0.17106577967377712]}, "mutation_prompt": null}
{"id": "4e30363c-aa9f-4b35-93b8-476b7da9f647", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors * np.random.rand(self.dim, self.dim)  # Modified line\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhance diversity by introducing an adaptive strategy for injecting random vectors based on population convergence.", "configspace": "", "generation": 51, "fitness": 0.9141496730613526, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.914 with standard deviation 0.003. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "75f78050-5250-458b-a816-ae7d778c251b", "metadata": {"aucs": [0.9131950675238095, 0.9185153833530777, 0.9107385683071709], "final_y": [0.1666216270732429, 0.16709766062571874, 0.16682280274631667]}, "mutation_prompt": null}
{"id": "005e8a72-f9e3-4a21-a8c8-47b86cbfadb2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() > 0.5:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  \n        # Penalty factor for trial solutions farther from the known best\n        penalty_factor = 1.0 + 0.1 * np.linalg.norm(trial_vector - target_vector)\n        trial_score *= penalty_factor\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0: \n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhance trial selection by incorporating a penalty factor for solutions farther from the known best to improve convergence speed.", "configspace": "", "generation": 52, "fitness": 0.8936555104406457, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.894 with standard deviation 0.022. And the mean value of best solutions found was 0.187 (0. is the best) with standard deviation 0.009.", "error": "", "parent_id": "75f78050-5250-458b-a816-ae7d778c251b", "metadata": {"aucs": [0.910234055188756, 0.8624083578738535, 0.9083241182593276], "final_y": [0.1832978658779013, 0.19938349435986247, 0.1791508570324858]}, "mutation_prompt": null}
{"id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhance the mutation strategy by incorporating a weighted average approach for selecting base vectors, improving convergence and diversity balance.", "configspace": "", "generation": 53, "fitness": 0.9277912610657658, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.928 with standard deviation 0.004. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "75f78050-5250-458b-a816-ae7d778c251b", "metadata": {"aucs": [0.926841663866006, 0.9336849899458128, 0.9228471293854783], "final_y": [0.17136180472664142, 0.16900287996093633, 0.16758438599255998]}, "mutation_prompt": null}
{"id": "8148f3f9-846f-43f6-b6e2-e7352aec1a4a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:  # Re-evaluation mechanism added\n                    re_eval_indices = np.random.choice(self.population_size, self.dim, replace=False)\n                    for idx in re_eval_indices:\n                        self.population[idx] = self.selection(idx, self.population[idx], func)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate a strategic re-evaluation mechanism by selectively re-evaluating a portion of population members to enhance exploration and convergence adaptability.", "configspace": "", "generation": 54, "fitness": 0.9263991565573462, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.926 with standard deviation 0.006. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {"aucs": [0.9223682582814828, 0.9349714713200801, 0.9218577400704756], "final_y": [0.16963361422323475, 0.16781967196252778, 0.16828877268859233]}, "mutation_prompt": null}
{"id": "f964d5c0-5b3c-4d2a-bf5f-4ac2a41fc940", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    self.mutation_factor = max(0.3, min(1.0, diversity * self.mutation_factor))  # Modified line\n                    if diversity < 0.1:\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation adjustments based on population diversity to enhance convergence efficiency.", "configspace": "", "generation": 55, "fitness": 0.8767106600529391, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.877 with standard deviation 0.021. And the mean value of best solutions found was 0.177 (0. is the best) with standard deviation 0.005.", "error": "", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {"aucs": [0.8754154022107582, 0.9032172249422635, 0.8514993530057956], "final_y": [0.17881113073911248, 0.1706823621430804, 0.18193933437345466]}, "mutation_prompt": null}
{"id": "9dca5e37-6e5f-4794-a4d2-b865ff71ba86", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                # Adjust mutation factor based on iteration count\n                self.mutation_factor = 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a novel convergence acceleration mechanism by dynamically adjusting the mutation factor based on the iteration count.", "configspace": "", "generation": 56, "fitness": 0.8882595400451504, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.888 with standard deviation 0.020. And the mean value of best solutions found was 0.173 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {"aucs": [0.8793575566275579, 0.8688380569866511, 0.9165830065212421], "final_y": [0.17475944459338033, 0.1757693934375475, 0.1688025709106028]}, "mutation_prompt": null}
{"id": "823ca092-1712-40f4-8899-4e376d938248", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n                \n                if evaluations % (self.population_size * 5) == 0:\n                    self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.base_population_factor * self.dim, self.dim))  # Random reset of the population\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive control to mutation factor and crossover rate based on population diversity to enhance algorithm convergence.", "configspace": "", "generation": 57, "fitness": 0.8888012822799661, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.889 with standard deviation 0.018. And the mean value of best solutions found was 0.183 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {"aucs": [0.9055201890309976, 0.89653619995399, 0.8643474578549107], "final_y": [0.18011857710290025, 0.18444535236043036, 0.18336305364277006]}, "mutation_prompt": null}
{"id": "0168238a-77ab-4e3a-8c98-4621eca7b2a3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c]) \n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        scaling_factor = 1 + 0.2 * np.abs(trial_score - target_score)  # Modified line\n        alpha = 1 / (1 + np.exp(scaling_factor * (trial_score - target_score)))  # Modified line\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic fitness-scaling mechanism to improve the robustness and adaptability of the selection process.", "configspace": "", "generation": 58, "fitness": 0.9275317689059698, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.928 with standard deviation 0.004. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {"aucs": [0.9238356555037693, 0.9334287203374351, 0.925330930876705], "final_y": [0.1712799195818443, 0.16906066840660705, 0.16794585324545397]}, "mutation_prompt": null}
{"id": "13b0e1d9-0b53-4d99-967f-d9e13edeb200", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n                # Adaptive crossover adjustment based on diversity\n                self.crossover_rate = 0.4 + (0.3 * diversity)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive crossover rate adjustment based on diversity for better exploration-exploitation balance.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'diversity' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'diversity' referenced before assignment\")", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {}, "mutation_prompt": null}
{"id": "c655913b-5cf0-4ae7-b1a9-b96a70ec4afc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])\n        mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n\n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n\n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n\n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation and crossover rates based on population diversity to enhance exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": 0.9277266449662509, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.928 with standard deviation 0.001. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {"aucs": [0.9277586700665049, 0.9265085148929848, 0.928912749939263], "final_y": [0.17132211654416185, 0.16891230852437966, 0.16895160560673106]}, "mutation_prompt": null}
{"id": "9f59db9a-2651-456a-9368-df00044c203d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n\n                # Change made here for adaptive mutation factor\n                if evaluations % (self.population_size * 2) == 0:\n                    diversity = np.std(self.population)\n                    average_fitness = np.mean([func(ind) for ind in self.population])\n                    self.mutation_factor = 0.5 + 0.3 * diversity / average_fitness\n\n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce an adaptive mutation factor by incorporating fitness diversity to dynamically adjust exploration and exploitation balance.", "configspace": "", "generation": 61, "fitness": 0.8037097788687372, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.804 with standard deviation 0.017. And the mean value of best solutions found was 0.227 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {"aucs": [0.8246443455025024, 0.8026552772217481, 0.7838297138819611], "final_y": [0.21767922298046494, 0.22843498572307575, 0.23434266655959957]}, "mutation_prompt": null}
{"id": "4a3cd7a0-2657-459a-bb60-7a5011b1b9cd", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    self.mutation_factor = max(0.3, min(1.0, self.mutation_factor + (0.15 if diversity < 0.1 else -0.2)))  # Modified line\n                    self.crossover_rate = max(0.6, min(1.0, self.crossover_rate + (0.05 if diversity < 0.1 else -0.05)))  # Modified line\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive scaling factors to mutation and crossover rates using diversity metrics to enhance convergence.", "configspace": "", "generation": 62, "fitness": 0.9277912610657658, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.928 with standard deviation 0.004. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {"aucs": [0.926841663866006, 0.9336849899458128, 0.9228471293854783], "final_y": [0.17136180472664142, 0.16900287996093633, 0.16758438599255998]}, "mutation_prompt": null}
{"id": "0432027f-b100-40de-bfc6-39820fff8264", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                self.mutation_factor *= 1 - (evaluations / self.budget)**2  # Non-linear scaling\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce non-linear scaling to the mutation factor for adaptive exploration and exploitation balance.", "configspace": "", "generation": 63, "fitness": 0.9106714774187487, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.911 with standard deviation 0.009. And the mean value of best solutions found was 0.176 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {"aucs": [0.9192088703899817, 0.8982588760963686, 0.9145466857698956], "final_y": [0.1744056552614267, 0.17934516643626075, 0.17382357080609512]}, "mutation_prompt": null}
{"id": "844b78c5-8a30-4c59-ae6d-57301919673f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        diversity_factor = np.std(self.population) / (np.std(self.population) + 1e-10)  # New diversity factor\n        alpha = (1 / (1 + np.exp(trial_score - target_score))) * diversity_factor  # Updated line\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhance selection by adapting trial vector acceptance based on diversity-driven weighting.", "configspace": "", "generation": 64, "fitness": 0.927791261065638, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.928 with standard deviation 0.004. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {"aucs": [0.9268416638660072, 0.9336849899454118, 0.9228471293854951], "final_y": [0.17136180472665719, 0.1690028799611062, 0.16758438599258507]}, "mutation_prompt": null}
{"id": "e24421d0-40f2-4f67-bd39-753fda9cb09f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c] + np.random.uniform(-0.1, 0.1, self.dim))  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce strategic diversity through random perturbation of the base vector, enhancing exploration capabilities.", "configspace": "", "generation": 65, "fitness": 0.9147012322697643, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.915 with standard deviation 0.018. And the mean value of best solutions found was 0.173 (0. is the best) with standard deviation 0.004.", "error": "", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {"aucs": [0.9097551283871226, 0.8958406222253079, 0.9385079461968625], "final_y": [0.17684490656418628, 0.1756878529150333, 0.16747610740135355]}, "mutation_prompt": null}
{"id": "e141c7f8-3eed-404d-84b1-2afbbccf61ba", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.15)  # Line modified for better balance\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introducing dynamic mutation factor adjustments by incorporating population diversity feedback to enhance convergence and exploration balance.", "configspace": "", "generation": 66, "fitness": 0.9240084697879882, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.924 with standard deviation 0.004. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {"aucs": [0.9219443756674309, 0.9291290016255315, 0.9209520320710024], "final_y": [0.17220905076998683, 0.17055979935148446, 0.16771484436519302]}, "mutation_prompt": null}
{"id": "c88feb44-7002-416a-8b42-4eb0448274b7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05 + 0.05 * (1 - diversity))  # Adjusted line\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic crossover rate adjustment based on the diversity of the population to enhance convergence and solution quality.", "configspace": "", "generation": 67, "fitness": 0.9277912610657658, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.928 with standard deviation 0.004. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {"aucs": [0.926841663866006, 0.9336849899458128, 0.9228471293854783], "final_y": [0.17136180472664142, 0.16900287996093633, 0.16758438599255998]}, "mutation_prompt": null}
{"id": "24b0548a-d426-4266-90d2-7c22b9738ce2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n                \n                # Dynamic reset of mutation factor if no improvement detected\n                if evaluations % (self.population_size * 10) == 0 and not np.any([func(ind) < func(self.population[0]) for ind in self.population[1:]]):\n                    self.mutation_factor = 0.5  # Reset to initial value\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Utilize a dynamic mutation factor reset mechanism to enhance convergence by preventing premature stagnation.", "configspace": "", "generation": 68, "fitness": 0.9273428000498208, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.927 with standard deviation 0.005. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {"aucs": [0.926841663866006, 0.9332816254361747, 0.9219051108472819], "final_y": [0.17136180472664142, 0.16900287996093633, 0.16758438599255998]}, "mutation_prompt": null}
{"id": "29213422-3cc9-4aa4-847b-b87311e10eed", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n\n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n                \n                if evaluations % (self.population_size * 5) == 0:\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n                \n            # Adjust mutation factor based on diversity of top solutions\n            top_solutions = np.array(sorted(self.population, key=func)[:int(0.1 * self.population_size)])\n            top_diversity = np.std(top_solutions)\n            self.mutation_factor = np.clip(self.mutation_factor + 0.1 * (0.1 - top_diversity), 0.3, 1.0)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Integrate adaptive selection pressure by dynamically adjusting the mutation factor based on the diversity of top solutions, enhancing convergence speed and solution quality.", "configspace": "", "generation": 69, "fitness": 0.9082559365591104, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.908 with standard deviation 0.022. And the mean value of best solutions found was 0.174 (0. is the best) with standard deviation 0.007.", "error": "", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {"aucs": [0.8778243676454973, 0.9255616726179762, 0.9213817694138577], "final_y": [0.1847761241617797, 0.16987286460496664, 0.16853666568792092]}, "mutation_prompt": null}
{"id": "e94f6bfd-b211-4ccc-b190-0db98e640dc3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])\n        dynamic_mutation_factor = 0.5 + 0.5 * np.random.rand()  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + dynamic_mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + dynamic_mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        if np.random.rand() < 0.3:  # Modified line\n            crossover_vector = 0.5 * (crossover_vector + mutant_vector)  # Modified line\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by adaptive mutation factor and selective hybridization during crossover.", "configspace": "", "generation": 70, "fitness": 0.9068360645765591, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.907 with standard deviation 0.014. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {"aucs": [0.9010215778930373, 0.8931407336165688, 0.9263458822200711], "final_y": [0.16847023927414084, 0.16764301370393675, 0.17081932502544506]}, "mutation_prompt": null}
{"id": "ad3c47f0-db8b-481b-a94e-cba13da953c4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n                \n            # Retain top solutions to improve convergence\n            self.population = sorted(self.population, key=func)[:self.population_size]\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce elite selection by retaining the best solutions from the current population to enhance convergence and solution quality.", "configspace": "", "generation": 71, "fitness": 0.8934835419365696, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.893 with standard deviation 0.016. And the mean value of best solutions found was 0.177 (0. is the best) with standard deviation 0.006.", "error": "", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {"aucs": [0.9119011453863692, 0.8724847923805209, 0.8960646880428188], "final_y": [0.174781576167918, 0.18585181330504663, 0.17174090048703472]}, "mutation_prompt": null}
{"id": "40ae0b79-e316-496c-b960-4ea9748c08ea", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 10) == 0:  # Reset mutation factor every 10 cycles\n                    self.mutation_factor = 0.5\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a periodic mutation rate reset to improve exploration during stagnation phases.", "configspace": "", "generation": 72, "fitness": 0.926769136887934, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.927 with standard deviation 0.004. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {"aucs": [0.926841663866006, 0.9317160958256556, 0.9217496509721408], "final_y": [0.17136180472664142, 0.16906003016480697, 0.16782380125540097]}, "mutation_prompt": null}
{"id": "cdc9f384-c7c5-43da-b96b-86bebed40a68", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])  # Modified line\n        diversity = np.std(self.population)\n        dynamic_mutation_factor = self.mutation_factor + (0.1 * (1 - diversity))  # Change made here: adaptive mutation\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + dynamic_mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + dynamic_mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation strategy dynamically adjusted based on population diversity to improve convergence performance.", "configspace": "", "generation": 73, "fitness": 0.6033053172595106, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.603 with standard deviation 0.066. And the mean value of best solutions found was 0.307 (0. is the best) with standard deviation 0.046.", "error": "", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {"aucs": [0.6214128132667989, 0.5155403494852694, 0.6729627890264636], "final_y": [0.3153579071430196, 0.35885293602380985, 0.24764097795830442]}, "mutation_prompt": null}
{"id": "84f258fd-f9bd-485c-acd7-750f0b732ab5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15 * (0.1 / diversity))  # Adjusted line\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic adaptive mechanism to adjust mutation factor based on population diversity metrics to enhance exploration-exploitation balance.", "configspace": "", "generation": 74, "fitness": 0.9277912610657658, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.928 with standard deviation 0.004. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {"aucs": [0.926841663866006, 0.9336849899458128, 0.9228471293854783], "final_y": [0.17136180472664142, 0.16900287996093633, 0.16758438599255998]}, "mutation_prompt": null}
{"id": "6c4cb6ee-06a8-4b8a-a907-dfd03f932eb8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c, d = np.random.choice(indices, 4, replace=False)  # Added one more vector for dynamic blending\n        base_vector = (0.4 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c] + 0.1 * self.population[d])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by enhancing the base vector selection through a weighted dynamic blend of more parent vectors for improved exploratory capability.", "configspace": "", "generation": 75, "fitness": 0.9115917932205783, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.912 with standard deviation 0.012. And the mean value of best solutions found was 0.173 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {"aucs": [0.9079585135243975, 0.898472073166228, 0.9283447929711094], "final_y": [0.1748335231847058, 0.17567335940181683, 0.1685254876311001]}, "mutation_prompt": null}
{"id": "0d61cd6c-a068-4ca4-b08f-bfa8d4558ba4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:  # New line for dynamic crossover rate adjustment\n                    self.crossover_rate = np.clip(diversity / 0.1, 0.5, 0.9)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic crossover rate adjustment based on the diversity of the population to enhance exploration and exploitation balance.", "configspace": "", "generation": 76, "fitness": 0.9347779252139027, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.935 with standard deviation 0.005. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "0a15e8ed-12da-44b4-9cd2-beb32d6abf26", "metadata": {"aucs": [0.9407736803763531, 0.9359194353828539, 0.9276406598825007], "final_y": [0.16771824018878911, 0.16871633918778872, 0.16949517160797456]}, "mutation_prompt": null}
{"id": "e790c3c1-51ad-4309-b315-7ac3c5143c1a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:\n                    self.crossover_rate = np.clip(diversity / 0.1, 0.5, 0.9)\n                    self.mutation_factor = np.clip(np.var(self.population) / 0.1, 0.3, 1.0)  # Changed this line\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic crossover rate adjustment based on the diversity of the population to enhance exploration and exploitation balance, with an adaptive mutation factor influenced by population variance.", "configspace": "", "generation": 77, "fitness": 0.9248076779801445, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.925 with standard deviation 0.002. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "0d61cd6c-a068-4ca4-b08f-bfa8d4558ba4", "metadata": {"aucs": [0.9265929329107784, 0.926535747163484, 0.9212943538661712], "final_y": [0.168031281688939, 0.16785067965764644, 0.1666077535101529]}, "mutation_prompt": null}
{"id": "81cebb19-f027-4f73-a50b-44438a82e568", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])  \n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  \n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    fitness_variance = np.var([func(ind) for ind in self.population])  # New calculation for fitness variance\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15 * (1.0 - fitness_variance))  # Adjusted line\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  \n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:  \n                    self.crossover_rate = np.clip(diversity / 0.1, 0.5, 0.9)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce strategic mutation factor adjustment based on population fitness variance to enhance convergence.", "configspace": "", "generation": 78, "fitness": 0.9293921425831143, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.929 with standard deviation 0.006. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "0d61cd6c-a068-4ca4-b08f-bfa8d4558ba4", "metadata": {"aucs": [0.9356263232750884, 0.9305145263179324, 0.9220355781563222], "final_y": [0.16830823381482107, 0.16953942673332967, 0.1698812169244207]}, "mutation_prompt": null}
{"id": "934e6643-05c9-4810-a6eb-84d403994087", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:  # New line for dynamic crossover rate adjustment\n                    self.crossover_rate = np.clip(diversity / 0.1, 0.5, 0.9)\n                    \n                if evaluations % (self.population_size * 6) == 0 and np.random.rand() < 0.5:  # Probabilistic elite re-initialization\n                    best_idx = np.argmin([func(ind) for ind in self.population])\n                    self.population[best_idx] = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration dynamics by introducing probabilistic elite re-initialization to prevent stagnation.", "configspace": "", "generation": 79, "fitness": 0.9347469824350738, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.935 with standard deviation 0.005. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "0d61cd6c-a068-4ca4-b08f-bfa8d4558ba4", "metadata": {"aucs": [0.9397648735951829, 0.9358685298491728, 0.9286075438608656], "final_y": [0.1690714396971158, 0.16846719057558934, 0.16824654341019796]}, "mutation_prompt": null}
{"id": "54553976-964e-406f-a4bc-925f28d6e524", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:  # New line for dynamic crossover rate adjustment\n                    self.crossover_rate = np.clip(diversity / 0.1, 0.5, 0.9)\n\n                if diversity < 0.05:  # New aggressive mutation strategy\n                    self.mutation_factor = min(1.0, self.mutation_factor + 0.3)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a more aggressive mutation strategy when population diversity is low to improve convergence speed.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'diversity' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'diversity' referenced before assignment\")", "parent_id": "0d61cd6c-a068-4ca4-b08f-bfa8d4558ba4", "metadata": {}, "mutation_prompt": null}
{"id": "d990e74a-3e21-4bf0-a3d7-98f81338122c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n\n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    fitness_variance = np.var([func(ind) for ind in self.population])  # New line for fitness variance\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n\n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:\n                    self.crossover_rate = np.clip(fitness_variance / 0.1, 0.5, 0.9)  # Modified line\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune the mutation factor and crossover rate adaptation based on the population's fitness variance to better balance exploration and exploitation.", "configspace": "", "generation": 81, "fitness": 0.9189775976067885, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.919 with standard deviation 0.007. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "0d61cd6c-a068-4ca4-b08f-bfa8d4558ba4", "metadata": {"aucs": [0.9095903417585012, 0.9257289951919572, 0.9216134558699072], "final_y": [0.174231569229653, 0.17035076361542945, 0.16873514224880315]}, "mutation_prompt": null}
{"id": "7fcd3ce9-4166-40f6-9e2a-84a1e86780fd", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:  # New line for dynamic crossover rate adjustment\n                    self.crossover_rate = np.clip(diversity / 0.1, 0.5, 0.9)\n\n                # New line for re-introducing diversity\n                if evaluations % (self.population_size * 6) == 0:\n                    removed_idx = np.random.choice(self.population_size, self.dim // 2, replace=False)\n                    self.population[removed_idx] = np.random.uniform(func.bounds.lb, func.bounds.ub, (len(removed_idx), self.dim))\n                    \n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce strategic re-introduction of removed individuals to enhance diversity and prevent premature convergence.", "configspace": "", "generation": 82, "fitness": 0.9311655059846865, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.931 with standard deviation 0.004. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "0d61cd6c-a068-4ca4-b08f-bfa8d4558ba4", "metadata": {"aucs": [0.9362232999860642, 0.9265122147783712, 0.9307610031896243], "final_y": [0.16868836076297222, 0.17072330287329684, 0.16813971133103633]}, "mutation_prompt": null}
{"id": "9081b01e-5d9f-4587-bfa8-9a74e6fc9a11", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.best_score = float('inf')  # New line\n        self.stagnation_counter_limit = 10  # New line\n        self.stagnation_counter = 0  # New line\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        if trial_score < self.best_score:  # New line\n            self.best_score = trial_score  # New line\n            self.stagnation_counter = 0  # New line\n        else:\n            self.stagnation_counter += 1  # New line\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if self.stagnation_counter > self.stagnation_counter_limit:  # New line\n                    self.initialize_population(func.bounds.lb, func.bounds.ub)  # New line\n                    self.stagnation_counter = 0  # New line\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:\n                    self.crossover_rate = np.clip(diversity / 0.1, 0.5, 0.9)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration and convergence by introducing a strategic reset mechanism based on population stagnation to avoid local optima.", "configspace": "", "generation": 83, "fitness": 0.754463584325903, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.754 with standard deviation 0.025. And the mean value of best solutions found was 0.231 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "0d61cd6c-a068-4ca4-b08f-bfa8d4558ba4", "metadata": {"aucs": [0.7443425657073375, 0.7302744572783118, 0.7887737299920599], "final_y": [0.2231738149066358, 0.24565483409810385, 0.22282983932831846]}, "mutation_prompt": null}
{"id": "f9fdcaf3-55b7-42cb-b1c5-a0703d0cd45d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])\n        diversity = np.std(self.population)  # Calculate diversity\n        dynamic_mutation_factor = np.clip(self.mutation_factor + diversity * 0.2, 0.3, 1.0)  # Adjust mutation factor\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + dynamic_mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + dynamic_mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:\n                    self.crossover_rate = np.clip(diversity / 0.1, 0.5, 0.9)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhance mutation strategy by dynamically adjusting mutation factor based on population diversity.", "configspace": "", "generation": 84, "fitness": 0.894742114118975, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.895 with standard deviation 0.010. And the mean value of best solutions found was 0.169 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "0d61cd6c-a068-4ca4-b08f-bfa8d4558ba4", "metadata": {"aucs": [0.8861301023772371, 0.9091352872651876, 0.8889609527144999], "final_y": [0.16641731613266653, 0.17135399686420627, 0.17035139689416567]}, "mutation_prompt": null}
{"id": "36011402-2695-4fcd-880d-85eab06e623b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                # Adjust mutation factor periodically based on evaluation progress\n                self.mutation_factor = 0.3 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:  # New line for dynamic crossover rate adjustment\n                    self.crossover_rate = np.clip(diversity / 0.1, 0.5, 0.9)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce cyclical adjustment of the mutation factor based on evaluation progress to enhance global search capability.", "configspace": "", "generation": 85, "fitness": 0.9401217343325242, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.940 with standard deviation 0.012. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "0d61cd6c-a068-4ca4-b08f-bfa8d4558ba4", "metadata": {"aucs": [0.9471930246022062, 0.9229970190745351, 0.9501751593208315], "final_y": [0.1668464457905957, 0.1682327415860132, 0.16616119220746361]}, "mutation_prompt": null}
{"id": "1483161b-7f71-4ea8-a819-a8d3cf040c40", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                # Adjust mutation factor periodically based on evaluation progress\n                self.mutation_factor = 0.3 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.1)  # Adjusted change\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:  # New line for dynamic crossover rate adjustment\n                    self.crossover_rate = np.clip(diversity / 0.1, 0.5, 0.9)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce an adaptive mutation factor adjustment in response to diversity levels to balance exploration and exploitation.", "configspace": "", "generation": 86, "fitness": 0.9401217343325242, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.940 with standard deviation 0.012. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "36011402-2695-4fcd-880d-85eab06e623b", "metadata": {"aucs": [0.9471930246022062, 0.9229970190745351, 0.9501751593208315], "final_y": [0.1668464457905957, 0.1682327415860132, 0.16616119220746361]}, "mutation_prompt": null}
{"id": "01a468f2-6b5e-499f-ab41-180b3cf109ef", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.5 * self.population[a] + 0.3 * self.population[b] + 0.2 * self.population[c])\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        blend_factor = 0.6  # New blend factor for weighted average\n        return trial_vector if trial_score < target_score else (blend_factor * trial_vector + (1 - blend_factor) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                self.mutation_factor = 0.3 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:\n                    self.crossover_rate = np.clip(diversity / 0.1, 0.5, 0.9)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhance trial vector selection by incorporating a weighted average blend between trial and target vectors.", "configspace": "", "generation": 87, "fitness": 0.9321841978566617, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.932 with standard deviation 0.013. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "36011402-2695-4fcd-880d-85eab06e623b", "metadata": {"aucs": [0.9398504154086416, 0.9142211187722723, 0.9424810593890716], "final_y": [0.16798626501046587, 0.16795027624279402, 0.1666772566665935]}, "mutation_prompt": null}
{"id": "395f40f9-1f58-4a02-9c91-05de845698de", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.4 * self.population[a] + 0.3 * self.population[b] + 0.3 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                # Adjust mutation factor periodically based on evaluation progress\n                self.mutation_factor = 0.3 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:  # New line for dynamic crossover rate adjustment\n                    self.crossover_rate = np.clip(diversity / 0.1, 0.5, 0.9)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Adjusted base vector composition for improved balance in exploration and exploitation.", "configspace": "", "generation": 88, "fitness": 0.9540676864570755, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.954 with standard deviation 0.012. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "36011402-2695-4fcd-880d-85eab06e623b", "metadata": {"aucs": [0.9563557368033689, 0.9382383124236807, 0.9676090101441769], "final_y": [0.1666739249137641, 0.16864891480986366, 0.16595740395223957]}, "mutation_prompt": null}
{"id": "914a61c9-4d7f-4526-9996-85f5187f1ba5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.4 * self.population[a] + 0.3 * self.population[b] + 0.3 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                # Adjust mutation factor periodically based on evaluation progress\n                self.mutation_factor = 0.3 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:  # New line for dynamic crossover rate adjustment\n                    self.crossover_rate = np.clip(diversity / 0.1, 0.5, 0.9)\n\n                if evaluations % (self.population_size * 6) == 0 and diversity < 0.05:  # New line for adaptive scaling\n                    self.population_size = max(self.base_population_factor, self.population_size - self.base_population_factor // 2)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduced adaptive population scaling based on early convergence detection to enhance performance.", "configspace": "", "generation": 89, "fitness": 0.9540676864570755, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.954 with standard deviation 0.012. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "395f40f9-1f58-4a02-9c91-05de845698de", "metadata": {"aucs": [0.9563557368033689, 0.9382383124236807, 0.9676090101441769], "final_y": [0.1666739249137641, 0.16864891480986366, 0.16595740395223957]}, "mutation_prompt": null}
{"id": "f949f342-18d0-4334-ac10-dafe7981fcb3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.4 * self.population[a] + 0.3 * self.population[b] + 0.3 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                # Adjust mutation factor periodically based on evaluation progress\n                self.mutation_factor = 0.3 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:\n                    self.crossover_rate = np.clip(diversity / 0.1, 0.55, 0.9)  # Adjusted crossover rate range\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Intelligent adjustment of crossover rate using periodic diversity feedback for enhanced solution exploration.", "configspace": "", "generation": 90, "fitness": 0.9540676864570755, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.954 with standard deviation 0.012. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "395f40f9-1f58-4a02-9c91-05de845698de", "metadata": {"aucs": [0.9563557368033689, 0.9382383124236807, 0.9676090101441769], "final_y": [0.1666739249137641, 0.16864891480986366, 0.16595740395223957]}, "mutation_prompt": null}
{"id": "375fd4d5-f781-4c11-b113-fe3086deb29b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.4 * self.population[a] + 0.3 * self.population[b] + 0.3 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                # Adjust mutation factor periodically based on evaluation progress\n                self.mutation_factor = 0.3 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:  # New line for dynamic crossover rate adjustment\n                    self.crossover_rate = np.clip(diversity / 0.1, 0.5, 0.9)\n\n                if evaluations % (self.population_size * 6) == 0:  # Periodically preserve best individual\n                    best_vector = min(self.population, key=func)\n                    self.population[0] = best_vector\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Improved diversity management by introducing periodic elite individual preservation to maintain high-quality solutions.", "configspace": "", "generation": 91, "fitness": 0.953882455343086, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.954 with standard deviation 0.012. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "395f40f9-1f58-4a02-9c91-05de845698de", "metadata": {"aucs": [0.9551964198830274, 0.9389122010874925, 0.9675387450587379], "final_y": [0.16678410367910002, 0.16761147818290578, 0.16594041400411264]}, "mutation_prompt": null}
{"id": "99b811e7-d648-4e6d-953c-4a3139cc4a3a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.4 * self.population[a] + 0.3 * self.population[b] + 0.3 * self.population[c]) \n        mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                self.mutation_factor = 0.35 + 0.25 * np.sin(2 * np.pi * evaluations / self.budget)\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.15:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.1)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.03)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.15)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.03)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:\n                    self.crossover_rate = np.clip(diversity / 0.15, 0.55, 0.85)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced exploration with dynamic adaptive adjustments for mutation and crossover rates.", "configspace": "", "generation": 92, "fitness": 0.9319937399745867, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.932 with standard deviation 0.006. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "395f40f9-1f58-4a02-9c91-05de845698de", "metadata": {"aucs": [0.9377362169396624, 0.9345997363539905, 0.9236452666301069], "final_y": [0.17117122705674837, 0.1676367303272216, 0.17181672480065702]}, "mutation_prompt": null}
{"id": "78e1ca76-cd0d-45e0-8dcb-b3dac7b0b6ce", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.4 * self.population[a] + 0.3 * self.population[b] + 0.3 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                # Adjust mutation factor periodically based on evaluation progress\n                self.mutation_factor = 0.3 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:  # New line for dynamic crossover rate adjustment\n                    self.crossover_rate = np.clip(diversity / 0.1, 0.3, 0.9)  # Changed line\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a learning rate to adjust the crossover rate dynamically for enhancing convergence.", "configspace": "", "generation": 93, "fitness": 0.9540676864570755, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.954 with standard deviation 0.012. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "395f40f9-1f58-4a02-9c91-05de845698de", "metadata": {"aucs": [0.9563557368033689, 0.9382383124236807, 0.9676090101441769], "final_y": [0.1666739249137641, 0.16864891480986366, 0.16595740395223957]}, "mutation_prompt": null}
{"id": "8bd5a089-c576-4f0d-8f78-870b5c77593d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.4 * self.population[a] + 0.3 * self.population[b] + 0.3 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                # Adjust mutation factor periodically based on evaluation progress\n                self.mutation_factor = 0.3 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:  # New strategic diversity boost\n                    random_vectors = np.random.uniform(func.bounds.lb - 0.1 * (func.bounds.ub - func.bounds.lb),\n                                                       func.bounds.ub + 0.1 * (func.bounds.ub - func.bounds.lb), (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:  # New line for dynamic crossover rate adjustment\n                    self.crossover_rate = np.clip(diversity / 0.1, 0.5, 0.9)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced diversity boost by increasing random perturbations in the population.", "configspace": "", "generation": 94, "fitness": 0.9537365194532551, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.954 with standard deviation 0.013. And the mean value of best solutions found was 0.167 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "395f40f9-1f58-4a02-9c91-05de845698de", "metadata": {"aucs": [0.9565815710739454, 0.9367557393054639, 0.9678722479803562], "final_y": [0.16710047469733702, 0.16905266519957107, 0.16573714322970245]}, "mutation_prompt": null}
{"id": "82185ef6-549a-4762-b5e7-e074901496c7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.4 * self.population[a] + 0.3 * self.population[b] + 0.3 * self.population[c])\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                self.mutation_factor = 0.3 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n                \n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.1:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 4) == 0:\n                    self.population_size = min(self.base_population_factor * self.dim, self.population_size + 1)\n                    self.population = np.vstack((self.population, np.random.uniform(func.bounds.lb, func.bounds.ub, (1, self.dim))))\n\n                if evaluations % (self.population_size * 5) == 0:\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[:self.dim] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:\n                    self.crossover_rate = np.clip(diversity / 0.1, 0.5, 0.9)\n\n            if evaluations % (self.population_size * 7) == 0:  # Introducing random restarts\n                self.initialize_population(func.bounds.lb, func.bounds.ub)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Introducing random restarts to improve exploration and escape local optima.", "configspace": "", "generation": 95, "fitness": 0.9431860041924865, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.943 with standard deviation 0.020. And the mean value of best solutions found was 0.171 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "395f40f9-1f58-4a02-9c91-05de845698de", "metadata": {"aucs": [0.9466491146016484, 0.9172878355844415, 0.9656210623913697], "final_y": [0.1728015657055808, 0.1735506929452556, 0.1672737067802873]}, "mutation_prompt": null}
{"id": "26d26f29-0656-4e15-8c24-daee0581bdb2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.4 * self.population[a] + 0.3 * self.population[b] + 0.3 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                # Adjust mutation factor periodically based on evaluation progress\n                self.mutation_factor = 0.3 + 0.25 * np.sin(2 * np.pi * evaluations / self.budget)  # Changed line\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n\n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.15:  # Changed line\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                # Inject new random individuals occasionally\n                if evaluations % (self.population_size * 10) == 0:  # Changed line\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[-self.dim:] = random_vectors  # Changed line\n\n                if evaluations % (self.population_size * 3) == 0:  # New line for dynamic crossover rate adjustment\n                    self.crossover_rate = np.clip(diversity / 0.1, 0.5, 0.9)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced diversity control and adaptive mutation for improved convergence.", "configspace": "", "generation": 96, "fitness": 0.9543716286395632, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.954 with standard deviation 0.011. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "395f40f9-1f58-4a02-9c91-05de845698de", "metadata": {"aucs": [0.9593933760001311, 0.9392465237361018, 0.9644749861824566], "final_y": [0.16741454881761864, 0.16986878024363172, 0.16661447922662986]}, "mutation_prompt": null}
{"id": "8570fa78-ffd4-418c-88b8-74436263d5bd", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.4 * self.population[a] + 0.3 * self.population[b] + 0.3 * self.population[c])\n        \n        # Hybrid mutation strategy\n        if np.random.rand() < 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[a] - self.population[b])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        \n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                # Periodic adjustment of mutation factor with a new strategy\n                self.mutation_factor = 0.3 + 0.25 * np.cos(2 * np.pi * evaluations / self.budget)\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n\n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.15:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 10) == 0:\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[-self.dim:] = random_vectors\n\n                if evaluations % (self.population_size * 3) == 0:\n                    self.crossover_rate = np.clip(diversity / 0.1, 0.5, 0.9)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Hybrid mutation strategies with adaptive parameters to enhance diversity and convergence.", "configspace": "", "generation": 97, "fitness": 0.9233398973598649, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.923 with standard deviation 0.014. And the mean value of best solutions found was 0.170 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "26d26f29-0656-4e15-8c24-daee0581bdb2", "metadata": {"aucs": [0.9399755755967768, 0.9068044096282322, 0.9232397068545856], "final_y": [0.16731566597995395, 0.17003951810133, 0.1720855128069283]}, "mutation_prompt": null}
{"id": "f834b5f3-6891-414e-bd9f-a33998cf1727", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.4 * self.population[a] + 0.3 * self.population[b] + 0.3 * self.population[c])\n        # Increased diversity in mutation by adding a random factor\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c]) + 0.1 * np.random.randn(self.dim)\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx]) + 0.1 * np.random.randn(self.dim)\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                self.mutation_factor = 0.3 + 0.25 * np.sin(2 * np.pi * evaluations / self.budget)\n\n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n\n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n\n                # Adaptively adjust mutation and crossover rates based on diversity\n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.15:\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                if evaluations % (self.population_size * 10) == 0:\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[-self.dim:] = random_vectors\n\n                self.crossover_rate = np.clip(diversity / 0.1, 0.5, 0.9)\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Improved mutation diversity and adaptive crossover for enhanced performance in variable dimension challenges.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'diversity' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'diversity' referenced before assignment\")", "parent_id": "26d26f29-0656-4e15-8c24-daee0581bdb2", "metadata": {}, "mutation_prompt": null}
{"id": "3c8c56c3-0689-48bf-970e-6472408b55ee", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_factor = 10\n        self.population_size = self.base_population_factor * dim\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, target_idx, lb, ub):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        base_vector = (0.4 * self.population[a] + 0.3 * self.population[b] + 0.3 * self.population[c])  # Modified line\n        if np.random.rand() > 0.5:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[c])\n        else:\n            mutant_vector = base_vector + self.mutation_factor * (self.population[b] - self.population[target_idx])\n        return np.clip(mutant_vector, lb, ub)\n\n    def crossover(self, target_vector, mutant_vector):\n        crossover_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.crossover_rate else target_vector[i]\n            for i in range(self.dim)\n        ])\n        return crossover_vector\n\n    def selection(self, target_idx, trial_vector, func):\n        target_vector = self.population[target_idx]\n        trial_score = func(trial_vector)\n        target_score = func(target_vector)\n        alpha = 1 / (1 + np.exp(trial_score - target_score))  # Dynamic weighting based on scores\n        return trial_vector if trial_score < target_score else (alpha * trial_vector + (1 - alpha) * target_vector)\n\n    def __call__(self, func):\n        self.initialize_population(func.bounds.lb, func.bounds.ub)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                # Adjust mutation factor periodically based on evaluation progress\n                self.mutation_factor = 0.3 + 0.25 * np.sin(2 * np.pi * evaluations / self.budget)  # Changed line\n                \n                mutant_vector = self.mutate(i, func.bounds.lb, func.bounds.ub)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                self.population[i] = self.selection(i, trial_vector, func)\n                evaluations += 1\n\n                if (evaluations % (self.population_size * 2)) == 0:\n                    diversity = np.std(self.population)\n                    if diversity < 0.15:  # Changed line\n                        self.mutation_factor = min(1.0, self.mutation_factor + 0.15)\n                        self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n                    else:\n                        self.mutation_factor = max(0.3, self.mutation_factor - 0.2)\n                        self.crossover_rate = max(0.6, self.crossover_rate - 0.05)\n                \n                # Inject new random individuals occasionally\n                if evaluations % (self.population_size * 10) == 0:  # Changed line\n                    random_vectors = np.random.uniform(func.bounds.lb, func.bounds.ub, (self.dim, self.dim))\n                    self.population[-self.dim:] = random_vectors  # Changed line\n                \n                # Slightly adjust dynamic crossover rate based on diversity\n                if evaluations % (self.population_size * 3) == 0:  # Changed line\n                    self.crossover_rate = np.clip(diversity / 0.2, 0.5, 0.9)  # Changed line\n\n        return min(self.population, key=func)", "name": "AdaptiveDifferentialEvolution", "description": "Slightly adjust the crossover rate dynamics based on population diversity for enhanced exploration and exploitation balance.", "configspace": "", "generation": 99, "fitness": 0.9543716286395632, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.954 with standard deviation 0.011. And the mean value of best solutions found was 0.168 (0. is the best) with standard deviation 0.001.", "error": "", "parent_id": "26d26f29-0656-4e15-8c24-daee0581bdb2", "metadata": {"aucs": [0.9593933760001311, 0.9392465237361018, 0.9644749861824566], "final_y": [0.16741454881761864, 0.16986878024363172, 0.16661447922662986]}, "mutation_prompt": null}
