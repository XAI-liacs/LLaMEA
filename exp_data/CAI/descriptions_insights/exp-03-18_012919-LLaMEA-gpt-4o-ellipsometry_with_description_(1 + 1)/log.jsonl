{"id": "fc34f5bd-043c-40e1-aef1-d139635cbfe3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            trial_solution = best_solution + np.random.uniform(-1, 1, self.dim) * (ub - lb) * \\\n                             np.random.uniform(0.05, 0.2)\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "The algorithm combines the exploratory power of a random walk with adaptive differential scaling strategies to efficiently navigate the search space and refine solutions.", "configspace": "", "generation": 0, "fitness": 0.249790812615128, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.250 with standard deviation 0.008. And the mean value of best solutions found was 0.106 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": null, "metadata": {"aucs": [0.25195217672316417, 0.25834931174126385, 0.23907094938095597], "final_y": [0.13050641862124077, 0.09218839076639117, 0.0943692905024889]}, "mutation_prompt": null}
{"id": "8cfa5593-765a-4bea-bd3e-6830cdc18395", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget)\n            if np.random.rand() < 0.1:  # 10% chance for global exploration\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce a dynamic scaling factor based on evaluation progress and incorporate a small probability of global exploration to enhance convergence and avoid local optima.", "configspace": "", "generation": 1, "fitness": 0.2504375964923852, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.250 with standard deviation 0.008. And the mean value of best solutions found was 0.005 (0. is the best) with standard deviation 0.003.", "error": "", "parent_id": "fc34f5bd-043c-40e1-aef1-d139635cbfe3", "metadata": {"aucs": [0.2605763977228509, 0.24228299945723353, 0.24845339229707109], "final_y": [0.0036262598222203614, 0.00898367204022192, 0.0018372989088071424]}, "mutation_prompt": null}
{"id": "b5783cfb-5ec9-44b0-94e2-814d6867b1db", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget)\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)  # New line\n            if np.random.rand() < 0.15:  # Changed from 0.1 to 0.15\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor  # Modified line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce a dynamic inertia weight and adaptive mutation factor to balance exploration and exploitation, improving convergence speed and solution quality.", "configspace": "", "generation": 2, "fitness": 0.3056773081009247, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.306 with standard deviation 0.019. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "8cfa5593-765a-4bea-bd3e-6830cdc18395", "metadata": {"aucs": [0.32991963878858066, 0.304120076354256, 0.2829922091599374], "final_y": [0.0015924992724814684, 0.005047593837986818, 0.0006038840454873686]}, "mutation_prompt": null}
{"id": "802b4601-d59e-4f0c-86fc-91300c9fb71d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.25) * (1 - evaluations / self.budget)  # Adjusted upper limit\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                perturbation = np.random.normal(0, 0.1, self.dim)  # New line for Gaussian perturbation\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor + perturbation\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce dynamic exploration factor adjustment and enhance solution refinement using random Gaussian perturbation.", "configspace": "", "generation": 3, "fitness": 0.27240395123559796, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.272 with standard deviation 0.028. And the mean value of best solutions found was 0.036 (0. is the best) with standard deviation 0.032.", "error": "", "parent_id": "b5783cfb-5ec9-44b0-94e2-814d6867b1db", "metadata": {"aucs": [0.3094505257690725, 0.2655214455685282, 0.24223988236919325], "final_y": [0.00885809563057967, 0.018954015175489065, 0.08096061253359946]}, "mutation_prompt": null}
{"id": "3d220014-b8db-4523-99b4-f9200000c830", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        def levy_flight(Lambda):\n            sigma = (np.math.gamma(1 + Lambda) * np.sin(np.pi * Lambda / 2) /\n                     (np.math.gamma((1 + Lambda) / 2) * Lambda * 2 ** ((Lambda - 1) / 2))) ** (1 / Lambda)\n            u = np.random.normal(0, sigma, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.abs(v) ** (1 / Lambda)\n            return 0.01 * step  # Small scaling factor\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.3) * (1 - evaluations / self.budget)  # Changed exploration range\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim) + levy_flight(1.5)  # Levy flight step\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration by introducing a stochastic levy flight step, and refine the adaptive mutation factor for better convergence.", "configspace": "", "generation": 4, "fitness": 0.271611947478802, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.272 with standard deviation 0.007. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "b5783cfb-5ec9-44b0-94e2-814d6867b1db", "metadata": {"aucs": [0.2691865333151985, 0.26491788566021635, 0.2807314234609912], "final_y": [0.0001667993478435302, 0.00437397949660532, 0.001155660409110231]}, "mutation_prompt": null}
{"id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2  # Modified line\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)  # New line\n            if np.random.rand() < 0.15:  # Changed from 0.1 to 0.15\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor  # Modified line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Implement a dynamic exploration factor adjustment to improve solution discovery by gradually decreasing randomness.", "configspace": "", "generation": 5, "fitness": 0.34686963027995604, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.347 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "b5783cfb-5ec9-44b0-94e2-814d6867b1db", "metadata": {"aucs": [0.33485245721123735, 0.3529350603077426, 0.35282137332088814], "final_y": [2.4341930938906698e-05, 0.00027647873181912454, 0.00016709361471107354]}, "mutation_prompt": null}
{"id": "129dacb7-141c-49f2-b26e-ee25c06d4fb7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_exploration_factor = 0.1  # New line\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            self.memory_exploration_factor = (self.memory_exploration_factor + np.random.uniform(0.05, 0.15)) / 2  # Modified line\n            exploration_factor = self.memory_exploration_factor * (1 - evaluations / self.budget) ** 2  # Modified line\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)  \n            if np.random.rand() < 0.15:  \n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance solution refinement by incorporating a memory-based adjustment mechanism for exploration factor.", "configspace": "", "generation": 6, "fitness": 0.3381783563990246, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.338 with standard deviation 0.008. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "metadata": {"aucs": [0.32686530072775766, 0.3451383448898262, 0.34253142357948985], "final_y": [0.0002530144586748067, 0.00017769161427315803, 0.0012013277291476438]}, "mutation_prompt": null}
{"id": "6df4c1e2-673a-4ceb-acba-2a9de20e8ca3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                gaussian_noise = np.random.normal(0, 0.1, self.dim)  # New line\n                trial_solution = best_solution + inertia_weight * (np.random.uniform(-1, 1, self.dim) + gaussian_noise) * (ub - lb) * exploration_factor  # Modified line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance the exploration phase by introducing adaptive Gaussian noise to improve solution discovery.", "configspace": "", "generation": 7, "fitness": 0.3286517946695915, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.329 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "metadata": {"aucs": [0.3391498585875735, 0.3188271504852218, 0.32797837493597914], "final_y": [4.729762796506504e-06, 0.00011701860434630446, 5.791759538264903e-05]}, "mutation_prompt": null}
{"id": "829e10c6-ef58-4fe2-bf31-856b92866954", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget)  # Changed this line\n            inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)\n            mutation_scale = 0.5 + 0.4 * np.random.rand()  # New line\n            if np.random.rand() < 0.2:  # Changed from 0.15 to 0.2\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-mutation_scale, mutation_scale, self.dim) * (ub - lb) * exploration_factor  # Changed this line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            # Changed comparison for more robustness\n            if trial_value < best_value - 1e-8:  # Changed this line\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution\n\n# Usage:\n# optimizer = AdaptiveDifferentialRandomWalk(budget, dim)\n# best_solution = optimizer(func)", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance the exploration mechanism with adaptive mutation scaling and improved solution comparison.", "configspace": "", "generation": 8, "fitness": 0.30056829716413996, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.301 with standard deviation 0.007. And the mean value of best solutions found was 0.002 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "metadata": {"aucs": [0.29977363888797826, 0.2921037241490696, 0.3098275284553721], "final_y": [0.00256990834367748, 0.001490067651989829, 0.002420438456763865]}, "mutation_prompt": null}
{"id": "19eb4e0e-4f81-4349-a3b9-1a053dd47d27", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.25) * (1 - evaluations / self.budget) ** 2  # Modified line\n            inertia_weight = 0.95 - 0.85 * (evaluations / self.budget)  # Modified line\n            if np.random.rand() < 0.2:  # Modified from 0.15 to 0.2\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration by fine-tuning the inertia weight decay and adjusting random trial solutions frequency.", "configspace": "", "generation": 9, "fitness": 0.32065142771368876, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.321 with standard deviation 0.002. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "metadata": {"aucs": [0.32328992894214026, 0.3188227837724109, 0.3198415704265152], "final_y": [6.522590474725796e-05, 1.579944823480418e-05, 2.630123607231089e-06]}, "mutation_prompt": null}
{"id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))  # Modified line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0  # New line\n            else:\n                no_improvement_counter += 1  # New line\n                if no_improvement_counter > self.budget * 0.05:  # New line\n                    trial_solution = np.random.uniform(lb, ub, self.dim)  # New line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Refine adaptive exploration by introducing exponential decay for inertia weight and include stagnation detection to enhance convergence.", "configspace": "", "generation": 10, "fitness": 0.5150631111444585, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.515 with standard deviation 0.007. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "61a2a98a-fcb9-4cfc-ae66-fd44bf5800b4", "metadata": {"aucs": [0.5222295232298514, 0.5047869359451109, 0.5181728742584133], "final_y": [7.131117500644502e-09, 1.520615306043773e-08, 5.099616967036962e-08]}, "mutation_prompt": null}
{"id": "2518d2ce-53b8-40c4-9a3e-d96b4193f4ed", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                step_size = np.random.uniform(0.003, 0.3)  # Modified line\n                trial_solution = best_solution + step_size * np.random.standard_cauchy(size=self.dim)  # Modified line\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * (0.05 + evaluations / (20 * self.budget)):  # Modified line\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n                    no_improvement_counter = 0  # Modified line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce Lévy flight for enhanced exploration and use adaptive convergence threshold to improve solution refinement.", "configspace": "", "generation": 11, "fitness": 0.5053773906711073, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.505 with standard deviation 0.009. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.5061981569151427, 0.5160695510357441, 0.493864464062435], "final_y": [2.2541932054288706e-08, 4.036392389606195e-07, 2.8205947327085635e-08]}, "mutation_prompt": null}
{"id": "95bc09fd-3da7-462d-923c-93ceb5ce38eb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n        improvement_rate = 1.0  # New line\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2 * improvement_rate  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n                improvement_rate = 1.1  # New line\n            else:\n                no_improvement_counter += 1\n                improvement_rate = 0.9  # New line\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Integrate adaptive step size control by dynamically adjusting the exploration factor based on improvement rate.", "configspace": "", "generation": 12, "fitness": 0.505240866632117, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.505 with standard deviation 0.012. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.5166450008743909, 0.4890504239981849, 0.5100271750237753], "final_y": [1.5430677278259767e-08, 2.9745038573610435e-08, 2.644328597011707e-09]}, "mutation_prompt": null}
{"id": "fcf8c9e8-ae4a-4818-9ec8-be120b13029a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - no_improvement_counter / (0.1 * self.budget)) ** 2  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance convergence by dynamically adjusting the exploration factor based on recent improvements.", "configspace": "", "generation": 13, "fitness": 0.45708733945397323, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.457 with standard deviation 0.007. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.46577775463553206, 0.4499143177511018, 0.4555699459752858], "final_y": [3.1372414081306642e-06, 1.1076129116780685e-05, 1.2157530781760706e-05]}, "mutation_prompt": null}
{"id": "0c18b58d-27e5-4997-87de-c200a3ef857d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * ((ub - lb) / (1 + evaluations))  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget)) \n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:  \n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce adaptive scaling for exploration factor to balance exploration and exploitation dynamically.", "configspace": "", "generation": 14, "fitness": 0.14448629400369584, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.017. And the mean value of best solutions found was 1.718 (0. is the best) with standard deviation 0.630.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.14621223413562656, 0.16396051318883265, 0.1232861346866283], "final_y": [1.5374396726547344, 1.0523358413848003, 2.563843998093371]}, "mutation_prompt": null}
{"id": "72569226-fdf4-4e08-91aa-71922a9782ae", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            mutation_factor = 0.5 * np.exp(-0.01 * evaluations)  # Changed line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor + mutation_factor * np.random.uniform(-1, 1, self.dim)  # Changed line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    best_solution = np.random.uniform(lb, ub, self.dim)  # Changed line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration by introducing a decaying mutation factor and reboot mechanism to escape local minima.  ", "configspace": "", "generation": 15, "fitness": 0.22904227657977524, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.229 with standard deviation 0.015. And the mean value of best solutions found was 0.202 (0. is the best) with standard deviation 0.099.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.2493432558615546, 0.21330523020441594, 0.22447834367335517], "final_y": [0.11885751644548463, 0.34147365731822166, 0.14538910547630413]}, "mutation_prompt": null}
{"id": "9ffe9d10-ce2b-4368-99cc-6bb806a9aa14", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n        population = [best_solution]\n\n        while evaluations < self.budget:\n            diversity = np.std(population, axis=0).mean() / (ub - lb).mean()  # New line\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget)) * (1 + diversity)  # Modified line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n                population.append(trial_solution)  # New line\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n                    if no_improvement_counter > self.budget * 0.1:  # New line\n                        best_solution = np.random.uniform(lb, ub, self.dim)  # New line\n                        best_value = func(best_solution)  # New line\n                        population = [best_solution]  # New line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce adaptive scaling based on population diversity and dynamic parameter restart for escaping local optima.", "configspace": "", "generation": 16, "fitness": 0.40919437747727433, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.409 with standard deviation 0.078. And the mean value of best solutions found was 0.013 (0. is the best) with standard deviation 0.018.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.48635534152295845, 0.30314628505990193, 0.43808150584896266], "final_y": [9.487221649981798e-06, 0.0377067573332952, 0.00024607824801346686]}, "mutation_prompt": null}
{"id": "f01f9d90-9663-435a-9a5c-2f13f1eccaee", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.sin(evaluations * np.pi / self.budget) * 0.15  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration efficiency by incorporating a dynamic exploration factor based on a sinusoidal function.", "configspace": "", "generation": 17, "fitness": 0.41268370970694024, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.413 with standard deviation 0.024. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.3854300213195686, 0.44284871860378927, 0.4097723891974627], "final_y": [8.401736731398042e-06, 7.94411259505668e-06, 5.640253963144227e-06]}, "mutation_prompt": null}
{"id": "b8ffb1fc-4e11-4f40-8c46-94f7e80d1834", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 3  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce a decreasing random exploration factor to enhance global exploration at early stages and controlled convergence later.", "configspace": "", "generation": 18, "fitness": 0.4097527502298046, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.410 with standard deviation 0.138. And the mean value of best solutions found was 0.053 (0. is the best) with standard deviation 0.075.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.499807548033389, 0.5150379692634579, 0.21441273339256695], "final_y": [1.3285870562760348e-06, 4.8310136880412875e-09, 0.15869471584341868]}, "mutation_prompt": null}
{"id": "6d9f3c64-cc03-47ee-9902-91dacdbd2609", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - (evaluations / self.budget) ** 2)  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    best_solution = np.random.uniform(lb, ub, self.dim)  # Modified line\n                    no_improvement_counter = 0  # Modified line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Incorporate adaptive exploration factor decay and strategic restart to enhance convergence.", "configspace": "", "generation": 19, "fitness": 0.23758244734162323, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.238 with standard deviation 0.018. And the mean value of best solutions found was 0.205 (0. is the best) with standard deviation 0.081.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.2215638984942937, 0.22899967959056422, 0.26218376394001175], "final_y": [0.2850462957894389, 0.23563583276830147, 0.09413719694693959]}, "mutation_prompt": null}
{"id": "7f2acffb-364d-42a3-865d-d77040a2935c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n        dynamic_threshold = self.budget * 0.05  # Dynamic threshold\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.3) * (1 - evaluations / self.budget)  # Changed line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))  # Changed line\n            if np.random.rand() < 0.2:  # Changed line\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                learning_rate = np.random.uniform(0.1, 0.5)  # New line\n                trial_solution = best_solution + learning_rate * inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n                dynamic_threshold = max(dynamic_threshold * 0.9, 1)  # New line\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > dynamic_threshold:  # Changed line\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n                    dynamic_threshold = min(dynamic_threshold * 1.1, self.budget * 0.1)  # New line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Implement a self-adaptive learning rate for exploring solutions and use a dynamic threshold for stagnation detection to improve convergence efficiency.", "configspace": "", "generation": 20, "fitness": 0.29801078723167157, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.298 with standard deviation 0.242. And the mean value of best solutions found was 1.463 (0. is the best) with standard deviation 1.237.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.11010422418265675, 0.640400116728572, 0.1435280207837859], "final_y": [3.0260652084061648, 1.9332107143213226e-07, 1.361608163262353]}, "mutation_prompt": null}
{"id": "fdcb6b72-3787-4356-a190-efd18d260ad0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n        previous_best_value = best_value  # New line\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** (2 - 2 * (best_value - previous_best_value))  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                previous_best_value = best_value  # New line\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n                    previous_best_value = best_value  # New line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Improve convergence by introducing dynamic exploration scaling and a reset mechanism based on fitness diversity.", "configspace": "", "generation": 21, "fitness": 0.49735078620610995, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.497 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.5007563838341096, 0.505245008818821, 0.48605096596539943], "final_y": [2.8237616791785664e-09, 2.60369187986894e-07, 3.6056111087377932e-09]}, "mutation_prompt": null}
{"id": "25d589dd-4842-495a-b29b-b39fde5bb7a4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            scaling_factor = 1 + 0.5 * np.sin(evaluations / (0.1 * self.budget))  # Modified line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor * scaling_factor  # Adjusted line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce a dynamic scaling factor for exploration to balance exploration and exploitation during optimization.", "configspace": "", "generation": 22, "fitness": 0.3731993921426399, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.373 with standard deviation 0.092. And the mean value of best solutions found was 0.012 (0. is the best) with standard deviation 0.011.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.2868473192130835, 0.5008843874265316, 0.3318664697883046], "final_y": [0.027198887433621456, 2.507440630051122e-07, 0.007302505280815829]}, "mutation_prompt": null}
{"id": "e15f290c-2493-4487-83cc-1b536b7d140c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n        recent_improvements = []\n\n        while evaluations < self.budget:\n            if len(recent_improvements) > 10:\n                recent_improvements.pop(0)\n            avg_improvement = np.mean(recent_improvements) if recent_improvements else 0\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - avg_improvement)  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))  # Modified line\n\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                recent_improvements.append(best_value - trial_value)  # New line\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance rapid convergence by dynamically adjusting exploration factor and inertia based on the mean improvement in the last few evaluations.", "configspace": "", "generation": 23, "fitness": 0.3711784883840113, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.371 with standard deviation 0.190. And the mean value of best solutions found was 0.203 (0. is the best) with standard deviation 0.282.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.6228598532696658, 0.3276467941952801, 0.1630288176870881], "final_y": [1.502380903412633e-09, 0.007607399426650663, 0.6017978217088665]}, "mutation_prompt": null}
{"id": "17b3951a-5ded-4f24-8609-27f51314b014", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                adaptive_intensity = 1 - (best_value / (best_value + 1))  # Modified line\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-adaptive_intensity, adaptive_intensity, self.dim) * (ub - lb) * exploration_factor  # Modified line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration with adaptive mutation intensity based on progress while maintaining constrained randomness.", "configspace": "", "generation": 24, "fitness": 0.5059467942623428, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.506 with standard deviation 0.011. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.5211639723637413, 0.4967927042348277, 0.49988370618845934], "final_y": [4.383731454943937e-09, 1.8480749231284197e-08, 8.605570262307141e-09]}, "mutation_prompt": null}
{"id": "03ba3c37-8cbe-4889-8d27-9dcdcd4d91c0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n        dynamic_scaling_factor = 0.1 + 0.4 * np.random.rand()  # New line\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))  # Modified line\n            if np.random.rand() < 0.2:  # Modified line\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + dynamic_scaling_factor * inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor  # Modified line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n                dynamic_scaling_factor = min(dynamic_scaling_factor + 0.01, 0.5)  # New line\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n                    dynamic_scaling_factor = max(dynamic_scaling_factor - 0.02, 0.1)  # New line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration-exploitation balance through adaptive random walks and dynamic parameter updates for improved convergence.", "configspace": "", "generation": 25, "fitness": 0.44981753055757046, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.450 with standard deviation 0.184. And the mean value of best solutions found was 0.010 (0. is the best) with standard deviation 0.010.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.2980638792070821, 0.34287319557900975, 0.7085155168866195], "final_y": [0.024103563128780387, 0.0057907162297658465, 5.059524038139668e-14]}, "mutation_prompt": null}
{"id": "8b00afda-9205-4ec3-b755-7716ecf1d3eb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            # Modified line\n            exploration_factor = (0.05 + (0.15 * (best_value / (func(best_solution) + 1e-9)))) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Integrate a dynamic exploration factor based on the quality of previous solutions, allowing adaptive focus shifts between exploration and exploitation.", "configspace": "", "generation": 26, "fitness": 0.2963538115277224, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.296 with standard deviation 0.005. And the mean value of best solutions found was 0.003 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.30112797449757245, 0.2991901256968986, 0.28874333438869604], "final_y": [0.002457486834677807, 0.0030263748042583813, 0.002596651743502215]}, "mutation_prompt": null}
{"id": "7bdbf19a-6d3e-4300-8a00-e46f3cdd5bce", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.sin(evaluations / (0.1 * self.budget))  # Modified line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration by introducing a deterministic oscillating inertia weight to improve convergence. ", "configspace": "", "generation": 27, "fitness": 0.3585737110278741, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.359 with standard deviation 0.018. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.38368395962340984, 0.34597934393371177, 0.34605782952650066], "final_y": [1.7999647032895786e-05, 1.5191348441467264e-05, 2.4610248953807425e-05]}, "mutation_prompt": null}
{"id": "558f9708-055b-4a4c-a476-36f209d3861b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-(evaluations + no_improvement_counter) / (0.1 * self.budget))  # Modified line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0  # New line\n            else:\n                no_improvement_counter += 1  # New line\n                if no_improvement_counter > self.budget * 0.05:  # New line\n                    trial_solution = np.random.uniform(lb, ub, self.dim)  # New line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce adaptive inertia weight scaling based on evaluation success for refined exploration-exploitation balance.", "configspace": "", "generation": 28, "fitness": 0.47486435796208787, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.475 with standard deviation 0.019. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.49463101899264006, 0.4487161544848216, 0.4812459004088018], "final_y": [1.4198260914672852e-08, 1.379027512613822e-07, 1.1876904676355395e-07]}, "mutation_prompt": null}
{"id": "dbd918c0-c06a-4968-9560-10134d404954", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n        last_improvement_evaluation = 0  # New line\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                adaptive_factor = 1 - (evaluations - last_improvement_evaluation) / self.budget  # New line\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-adaptive_factor, adaptive_factor, self.dim) * (ub - lb) * exploration_factor  # Modified line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n                last_improvement_evaluation = evaluations  # New line\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Integrate an adaptive mutation scale informed by recent improvements to strike a balance between exploration and exploitation.", "configspace": "", "generation": 29, "fitness": 0.4944258012497265, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.494 with standard deviation 0.006. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.5019566367568247, 0.49453953216380153, 0.4867812348285535], "final_y": [2.3175886272373184e-08, 3.2629342710352975e-07, 1.2215059085224505e-06]}, "mutation_prompt": null}
{"id": "e1464835-7992-48d3-8646-c310298de162", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))  # Modified line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0  # New line\n            else:\n                no_improvement_counter += 1  # New line\n                if no_improvement_counter > self.budget * 0.05:  # New line\n                    trial_solution = np.random.uniform(lb, ub, self.dim)  # New line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration by increasing inertia weight decay rate to improve convergence speed.", "configspace": "", "generation": 30, "fitness": 0.6768330622273506, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.677 with standard deviation 0.006. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "29950bfd-fd28-45a5-a2ea-6d37d51aa2ce", "metadata": {"aucs": [0.6701243290195373, 0.6755940459582971, 0.6847808117042173], "final_y": [2.740464543386915e-11, 1.4100523715001754e-12, 1.9548542141563514e-11]}, "mutation_prompt": null}
{"id": "3614daf6-8e42-4469-b02a-c17c625d7974", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.05 + 0.15 * np.sin(evaluations / self.budget * np.pi)) * (1 - evaluations / self.budget) ** 2  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce a dynamic exploration factor to adaptively balance exploration and exploitation during optimization.", "configspace": "", "generation": 31, "fitness": 0.26962123761432094, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.270 with standard deviation 0.066. And the mean value of best solutions found was 0.158 (0. is the best) with standard deviation 0.190.", "error": "", "parent_id": "e1464835-7992-48d3-8646-c310298de162", "metadata": {"aucs": [0.2536097470606946, 0.19789474988016909, 0.35735921590209907], "final_y": [0.041947953656659945, 0.42537785760172947, 0.005767117598795978]}, "mutation_prompt": null}
{"id": "d2d5caec-992c-418b-98f2-b938da0cdadb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2 - 0.1 * (evaluations / self.budget)) * (1 - evaluations / self.budget) ** 2  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Incorporate a noise reduction strategy by adaptively decreasing exploration factor variance to improve convergence stability.", "configspace": "", "generation": 32, "fitness": 0.6608262741570325, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.661 with standard deviation 0.009. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e1464835-7992-48d3-8646-c310298de162", "metadata": {"aucs": [0.6673901204686429, 0.6475831251970386, 0.6675055768054161], "final_y": [1.1569785016363641e-12, 1.0838927342689632e-12, 8.303154986554471e-13]}, "mutation_prompt": null}
{"id": "b6283637-8071-44ce-8688-1d78cff72271", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            improvement_rate = 1 - no_improvement_counter / self.budget  # New line\n            exploration_factor = np.random.uniform(0.05, 0.2) * improvement_rate * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce a dynamic exploration factor based on the best solution's improvement rate to balance exploration and exploitation.", "configspace": "", "generation": 33, "fitness": 0.667448941262136, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.667 with standard deviation 0.014. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e1464835-7992-48d3-8646-c310298de162", "metadata": {"aucs": [0.6703841818986894, 0.6826081607454878, 0.6493544811422307], "final_y": [7.646580124772227e-13, 9.164735602109173e-13, 7.504708890860979e-10]}, "mutation_prompt": null}
{"id": "2df1994d-e442-4e7a-bd66-9aca5fd9dc34", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))\n            mutation_scale = 0.8 + 0.2 * np.sin(evaluations * np.pi / self.budget)  # Modified line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * mutation_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    best_solution = np.random.uniform(lb, ub, self.dim)  # Modified line\n                    best_value = func(best_solution)  # Modified line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce dynamic mutation scale and adaptive restart mechanism to refine exploration-exploitation balance.", "configspace": "", "generation": 34, "fitness": 0.2913796297766729, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.291 with standard deviation 0.098. And the mean value of best solutions found was 0.142 (0. is the best) with standard deviation 0.119.", "error": "", "parent_id": "e1464835-7992-48d3-8646-c310298de162", "metadata": {"aucs": [0.4284637679507356, 0.2078037408780713, 0.23787138050121182], "final_y": [0.0011720932267978669, 0.29274509194039844, 0.13232139512778215]}, "mutation_prompt": null}
{"id": "cec19897-aaca-4764-b6c2-7f4d490e454a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - (evaluations / self.budget) ** 2)  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))\n            mutation_scale = 1 - evaluations / self.budget  # New line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor * mutation_scale  # Modified line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce adaptive mutation scaling based on evaluation progress to balance exploration and exploitation.", "configspace": "", "generation": 35, "fitness": 0.6510142213209814, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.651 with standard deviation 0.029. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e1464835-7992-48d3-8646-c310298de162", "metadata": {"aucs": [0.6681141998046511, 0.6745493465100822, 0.610379117648211], "final_y": [3.6622481549525806e-12, 1.6963284503564416e-10, 2.657322772649187e-07]}, "mutation_prompt": null}
{"id": "e197e218-d0cb-4c4e-8855-9f3e356b55ef", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2.5  # Modified line\n            inertia_weight = 0.8 * np.exp(-evaluations / (0.05 * self.budget))  # Modified line\n            if np.random.rand() < 0.15 + 0.1 * (no_improvement_counter / self.budget):  # Modified line\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce dynamic exploration scaling and adaptive reinitialization to enhance search diversity.", "configspace": "", "generation": 36, "fitness": 0.6578303004143328, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.658 with standard deviation 0.012. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e1464835-7992-48d3-8646-c310298de162", "metadata": {"aucs": [0.6735892214522483, 0.6456206418332594, 0.6542810379574906], "final_y": [1.5040962966952513e-11, 4.201546434185854e-12, 3.919314629157855e-09]}, "mutation_prompt": null}
{"id": "1304aa5c-5a40-4964-8198-8d555fe54a15", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))  # Modified line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution + 0.1 * (best_solution - trial_solution), lb, ub)  # Changed line\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0  # New line\n            else:\n                no_improvement_counter += 1  # New line\n                if no_improvement_counter > self.budget * 0.05:  # New line\n                    trial_solution = np.random.uniform(lb, ub, self.dim)  # New line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce adaptive boundary nudging for trial solutions to enhance local exploitation. ", "configspace": "", "generation": 37, "fitness": 0.4236428022302703, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.424 with standard deviation 0.211. And the mean value of best solutions found was 0.184 (0. is the best) with standard deviation 0.259.", "error": "", "parent_id": "e1464835-7992-48d3-8646-c310298de162", "metadata": {"aucs": [0.38746963523376565, 0.6979535604197591, 0.18550521103728623], "final_y": [0.0031496399935871653, 1.0065136958469769e-13, 0.5501518853813114]}, "mutation_prompt": null}
{"id": "b3353eee-31fb-4d7e-bca0-9e8a32473002", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = best_solution + np.random.uniform(-1, 1, self.dim) * np.exp(-evaluations / self.budget)  # Changed line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Incorporate adaptive mutation scaling to improve exploration during stagnation.", "configspace": "", "generation": 38, "fitness": 0.6737768097990946, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.674 with standard deviation 0.005. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e1464835-7992-48d3-8646-c310298de162", "metadata": {"aucs": [0.675029512220851, 0.6794397891201063, 0.6668611280563266], "final_y": [2.8557386621887683e-11, 1.830888629253611e-12, 3.4258890976362224e-10]}, "mutation_prompt": null}
{"id": "973eb1d8-74fe-468a-9237-a11933f6d125", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.04:  # Modified line\n                    best_solution = np.random.uniform(lb, ub, self.dim)  # Modified line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce adaptive random restarts to enhance exploitation when no improvement is detected over a defined period.", "configspace": "", "generation": 39, "fitness": 0.2989725930358878, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.299 with standard deviation 0.097. And the mean value of best solutions found was 0.268 (0. is the best) with standard deviation 0.366.", "error": "", "parent_id": "e1464835-7992-48d3-8646-c310298de162", "metadata": {"aucs": [0.33910244299417314, 0.16570604138756007, 0.39210929472593026], "final_y": [0.014735189430410653, 0.785795343122104, 0.003025413609218705]}, "mutation_prompt": null}
{"id": "7ad065de-e7ee-43dc-9888-936761638065", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))\n            mutation_intensity = 0.5 + 0.5 * (no_improvement_counter / (0.1 * self.budget))  # Modified line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor * mutation_intensity  # Modified line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce adaptive mutation intensity based on improvement stagnation to enhance diversity and convergence.", "configspace": "", "generation": 40, "fitness": 0.5303098958763255, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.530 with standard deviation 0.231. And the mean value of best solutions found was 0.111 (0. is the best) with standard deviation 0.157.", "error": "", "parent_id": "e1464835-7992-48d3-8646-c310298de162", "metadata": {"aucs": [0.6873972765622787, 0.6998901192560056, 0.20364229181069227], "final_y": [1.0080333007159418e-12, 5.186113611233361e-12, 0.33270991520188226]}, "mutation_prompt": null}
{"id": "e4300d60-1d47-4e8c-a29b-861f0088fdff", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations**2 / self.budget**2)  # Changed line\n            inertia_weight = 0.8 * np.exp(-evaluations / (0.05 * self.budget)) + 0.1  # Changed line\n            if np.random.rand() < 0.15 + 0.1 * (evaluations / self.budget):  # Changed line\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce dynamic exploration scaling and adaptive inertia weight to balance exploration and exploitation.", "configspace": "", "generation": 41, "fitness": 0.35067246584531037, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.351 with standard deviation 0.021. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e1464835-7992-48d3-8646-c310298de162", "metadata": {"aucs": [0.3248226549904676, 0.35078930077989434, 0.3764054417655692], "final_y": [0.0013701718866644859, 0.0014406190984738937, 0.0011722433663271142]}, "mutation_prompt": null}
{"id": "6fdd8d28-558f-4140-b506-d4e362745371", "solution": "import numpy as np\n\nclass AdaptiveGradientBasedRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))\n            gradient_estimate = np.random.normal(0, 1, self.dim) * exploration_factor  # New line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * gradient_estimate * (ub - lb)  # Updated line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    best_solution += np.random.normal(0, 0.1, self.dim) * exploration_factor  # Modified line\n\n        return best_solution", "name": "AdaptiveGradientBasedRandomWalk", "description": "Adaptive Gradient-Based Random Walk leverages gradient information to refine the search process and enhance convergence efficiency.", "configspace": "", "generation": 42, "fitness": 0.32858377280614715, "feedback": "The algorithm AdaptiveGradientBasedRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.329 with standard deviation 0.033. And the mean value of best solutions found was 0.030 (0. is the best) with standard deviation 0.023.", "error": "", "parent_id": "e1464835-7992-48d3-8646-c310298de162", "metadata": {"aucs": [0.32509342022515975, 0.28992428811011783, 0.37073361008316386], "final_y": [0.022212873866172836, 0.06054905203902108, 0.0069254318256189926]}, "mutation_prompt": null}
{"id": "5088594d-7d97-49d4-a19b-103dfbfdbc50", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.2) * (1 - evaluations / self.budget) ** 1.5  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.1:  # Modified line\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce dynamic adjustment of exploration factor for improved balance between exploration and exploitation.", "configspace": "", "generation": 43, "fitness": 0.47402954894848004, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.474 with standard deviation 0.233. And the mean value of best solutions found was 0.460 (0. is the best) with standard deviation 0.650.", "error": "", "parent_id": "e1464835-7992-48d3-8646-c310298de162", "metadata": {"aucs": [0.6228287856634191, 0.6540749687042742, 0.1451848924777468], "final_y": [1.5971375563218855e-11, 1.1994951297204583e-10, 1.379886824666755]}, "mutation_prompt": null}
{"id": "9424a556-06e7-4c23-b77e-d4ad46765dd7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.25) * (1 - evaluations / self.budget) ** 2  # Modified line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.04 * self.budget))  # Modified line\n            if np.random.rand() < 0.15 + (0.1 * (evaluations / self.budget)):  # Modified line\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce dynamic boundary adjustments and enhanced randomization to improve convergence and diversity.", "configspace": "", "generation": 44, "fitness": 0.6634901541305472, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.663 with standard deviation 0.084. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e1464835-7992-48d3-8646-c310298de162", "metadata": {"aucs": [0.7273934584154218, 0.718960730391186, 0.5441162735850339], "final_y": [4.869855699592233e-13, 6.788018955904032e-14, 1.4977657810994438e-05]}, "mutation_prompt": null}
{"id": "627d2c83-9f9d-42f2-a172-c6a789c18e4a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.3) * (1 - evaluations / self.budget)  # Changed line\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.1 * self.budget))  # Modified line\n            mutation_factor = np.random.uniform(0.6, 0.9)  # New line\n            if np.random.rand() < 0.2:  # Modified line\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                random_vector = np.random.uniform(-1, 1, self.dim)  # New line\n                trial_solution = best_solution + mutation_factor * inertia_weight * random_vector * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce adaptive mutation and dynamic exploration based on performance to improve convergence and solution diversity.", "configspace": "", "generation": 45, "fitness": 0.3838708809347713, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.384 with standard deviation 0.017. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e1464835-7992-48d3-8646-c310298de162", "metadata": {"aucs": [0.3867182500909885, 0.4030398485254514, 0.3618545441878741], "final_y": [6.971426408859183e-06, 4.475216110769689e-06, 2.681036840406479e-05]}, "mutation_prompt": null}
{"id": "00ed8454-06ce-4b82-830b-6f8ff5e3304f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            # Introduced sinusoidal function for dynamic exploration_factor adjustment\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))  # Modified line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0  # New line\n            else:\n                no_improvement_counter += 1  # New line\n                if no_improvement_counter > self.budget * 0.05:  # New line\n                    trial_solution = np.random.uniform(lb, ub, self.dim)  # New line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce adaptive exploration and exploitation trade-off by dynamically adjusting exploration_factor using a sinusoidal function.", "configspace": "", "generation": 46, "fitness": 0.6835446278218028, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.684 with standard deviation 0.014. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "e1464835-7992-48d3-8646-c310298de162", "metadata": {"aucs": [0.6632583760472703, 0.6921555489993988, 0.6952199584187393], "final_y": [5.099351475809707e-13, 2.321405690865751e-12, 9.770667992754671e-14]}, "mutation_prompt": null}
{"id": "c9580c0e-5844-445d-9b12-ae53c9457f95", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))\n            dynamic_scale = np.random.normal(0, 1, self.dim)  # New line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * dynamic_scale * (ub - lb) * exploration_factor  # Modified line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n                    no_improvement_counter = 0  # New line\n                if evaluations % (self.budget // 10) == 0:  # New line\n                    best_solution = np.random.uniform(lb, ub, self.dim)  # New line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Adaptive Random Walk with Dynamic Neighborhood Scaling and Periodic Restart.", "configspace": "", "generation": 47, "fitness": 0.26416598276597075, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.264 with standard deviation 0.081. And the mean value of best solutions found was 0.244 (0. is the best) with standard deviation 0.178.", "error": "", "parent_id": "00ed8454-06ce-4b82-830b-6f8ff5e3304f", "metadata": {"aucs": [0.1983498400790532, 0.2161421330799449, 0.3780059751389141], "final_y": [0.4288472057698166, 0.3003092313485227, 0.0039695176109365155]}, "mutation_prompt": null}
{"id": "5dd66713-1738-4904-bc1b-30e40504b624", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))\n            \n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                levy_flight = np.random.standard_cauchy(self.dim) * exploration_factor  # Changed line\n                trial_solution = best_solution + inertia_weight * levy_flight * (ub - lb)  # Changed line\n            \n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    best_solution += np.random.standard_normal(self.dim) * 0.1 * (ub - lb)  # Changed line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance convergence by incorporating an adaptive local search mechanism based on Levy flights.", "configspace": "", "generation": 48, "fitness": 0.2735070866984876, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.274 with standard deviation 0.076. And the mean value of best solutions found was 0.276 (0. is the best) with standard deviation 0.356.", "error": "", "parent_id": "00ed8454-06ce-4b82-830b-6f8ff5e3304f", "metadata": {"aucs": [0.364154048021069, 0.2787246220556645, 0.17764259001872929], "final_y": [0.003279978946586198, 0.04645440919040245, 0.778736528048956]}, "mutation_prompt": null}
{"id": "4de40658-6fcb-4a10-a314-dfe7324b5877", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget)) * (0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget))  # Modified line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance local search adaptability by introducing a decay factor for the inertia weight.", "configspace": "", "generation": 49, "fitness": 0.6785883195276553, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.679 with standard deviation 0.031. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "00ed8454-06ce-4b82-830b-6f8ff5e3304f", "metadata": {"aucs": [0.6369521318141269, 0.7119220850807566, 0.6868907416880823], "final_y": [1.0709921337474873e-07, 2.0741756839669925e-11, 2.8995335313858346e-13]}, "mutation_prompt": null}
{"id": "8e77f449-7622-4188-8901-ce0a711de9d4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.5 + 0.4 * np.random.rand()  # Changed line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:\n                    best_solution = np.random.uniform(lb, ub, self.dim)  # Changed line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance adaptive exploration by employing a stochastic inertia weight and random solution reset upon stagnation.", "configspace": "", "generation": 50, "fitness": 0.22655975147744445, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.227 with standard deviation 0.011. And the mean value of best solutions found was 0.137 (0. is the best) with standard deviation 0.059.", "error": "", "parent_id": "00ed8454-06ce-4b82-830b-6f8ff5e3304f", "metadata": {"aucs": [0.21538178957187426, 0.22225616302800733, 0.24204130183245176], "final_y": [0.053954976457119254, 0.18650356349060668, 0.17128878370400913]}, "mutation_prompt": null}
{"id": "bb34e9e0-2d8c-4dd6-b5b7-f77871b5b8ea", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            # Introduced sinusoidal function for dynamic exploration_factor adjustment\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget) * np.random.rand()) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = 0.9 * np.exp(-evaluations / (0.05 * self.budget))  # Modified line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0  # New line\n            else:\n                no_improvement_counter += 1  # New line\n                if no_improvement_counter > self.budget * 0.05:  # New line\n                    trial_solution = np.random.uniform(lb, ub, self.dim)  # New line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration by applying a randomized sinusoidal factor to trial solution adjustments.", "configspace": "", "generation": 51, "fitness": 0.528842458354759, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.529 with standard deviation 0.214. And the mean value of best solutions found was 0.059 (0. is the best) with standard deviation 0.084.", "error": "", "parent_id": "00ed8454-06ce-4b82-830b-6f8ff5e3304f", "metadata": {"aucs": [0.6891293935593341, 0.22637894936877123, 0.6710190321361713], "final_y": [1.4127784921037382e-12, 0.17786951653464178, 1.1891840641238844e-13]}, "mutation_prompt": null}
{"id": "79fcb44d-d558-42f3-bc91-5b2c1bddf4db", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))  # Changed line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:  # Changed line\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce adaptive mutation by dynamically scaling with a time-dependent factor and adjust the condition for random restart.", "configspace": "", "generation": 52, "fitness": 0.699556730630443, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.700 with standard deviation 0.004. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "00ed8454-06ce-4b82-830b-6f8ff5e3304f", "metadata": {"aucs": [0.6965483656197833, 0.6968948552442045, 0.7052269710273413], "final_y": [7.2298437283995644e-12, 2.8601845877711224e-12, 2.8204811022058893e-11]}, "mutation_prompt": null}
{"id": "6d19947f-ea8b-4158-bdb6-b13ebdd82b43", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < exploration_factor:  # Changed line\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce time-dependent exploration factor for enhanced adaptive mutation.", "configspace": "", "generation": 53, "fitness": 0.6939917070582924, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.694 with standard deviation 0.014. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "79fcb44d-d558-42f3-bc91-5b2c1bddf4db", "metadata": {"aucs": [0.6991423053774968, 0.7074413831499402, 0.6753914326474403], "final_y": [1.455702422081886e-11, 1.4647634018899143e-12, 5.72719478458815e-13]}, "mutation_prompt": null}
{"id": "2ba9d9da-648f-4e06-b453-4f36620ea6fb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * (1 - evaluations / self.budget) ** 2\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < (0.15 * (1 + 0.618)):  # Changed line\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance the exploration by introducing a dynamic exploration factor adjustment based on the golden ratio.", "configspace": "", "generation": 54, "fitness": 0.654908823674214, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.655 with standard deviation 0.011. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "79fcb44d-d558-42f3-bc91-5b2c1bddf4db", "metadata": {"aucs": [0.6422950644732384, 0.6693673485459068, 0.6530640580034968], "final_y": [5.118554992201039e-09, 2.2212899186943357e-08, 3.7032764003973136e-08]}, "mutation_prompt": null}
{"id": "a9c9cad4-833b-4422-bab8-bcf5fe6fad5f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))  # Changed line\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance convergence by adjusting the exploration factor with an exponential decay based on evaluations.", "configspace": "", "generation": 55, "fitness": 0.7486715662598024, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.749 with standard deviation 0.004. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "79fcb44d-d558-42f3-bc91-5b2c1bddf4db", "metadata": {"aucs": [0.750639606496598, 0.752371442057566, 0.743003650225243], "final_y": [2.23525061004245e-09, 1.3080673263130257e-13, 1.4536920377194212e-09]}, "mutation_prompt": null}
{"id": "5faa170c-4bb9-4454-8f76-74f3c3b73b30", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            temperature = max(0.01, 1 - evaluations / self.budget)  # Changed line\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * temperature  # Changed line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    best_solution = np.random.uniform(lb, ub, self.dim)  # Changed line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Integrate simulated annealing-inspired temperature decay to balance exploration and exploitation dynamically.", "configspace": "", "generation": 56, "fitness": 0.4045288991757247, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.405 with standard deviation 0.129. And the mean value of best solutions found was 0.083 (0. is the best) with standard deviation 0.117.", "error": "", "parent_id": "a9c9cad4-833b-4422-bab8-bcf5fe6fad5f", "metadata": {"aucs": [0.2276790695689599, 0.5294603810688475, 0.4564472468893668], "final_y": [0.24857222677166974, 2.8252244173581236e-05, 0.00020649768352111168]}, "mutation_prompt": null}
{"id": "13752ecf-5ec6-4256-80db-5abd2abf4a7d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))  # Changed line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Refine exploration dynamics by adjusting the inertia weight to balance exploration and exploitation based on the progress.", "configspace": "", "generation": 57, "fitness": 0.661982436738112, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.662 with standard deviation 0.012. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a9c9cad4-833b-4422-bab8-bcf5fe6fad5f", "metadata": {"aucs": [0.6521744596911299, 0.6555397221507365, 0.6782331283724696], "final_y": [4.183901206966364e-09, 2.078464337489544e-09, 2.9912582682311663e-09]}, "mutation_prompt": null}
{"id": "1b441122-d931-4c1e-82be-a73696c7b4f4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            mutation_factor = 0.5 + (evaluations / self.budget) * 0.5  # Changed line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor * mutation_factor  # Changed line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce a dynamic mutation factor that adapts based on the number of evaluations to enhance exploration-exploitation balance.", "configspace": "", "generation": 58, "fitness": 0.27103982427559403, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.271 with standard deviation 0.157. And the mean value of best solutions found was 0.688 (0. is the best) with standard deviation 0.489.", "error": "", "parent_id": "a9c9cad4-833b-4422-bab8-bcf5fe6fad5f", "metadata": {"aucs": [0.4936782945596977, 0.15919862145378483, 0.16024255681329957], "final_y": [0.00022538009225711816, 1.0891546535404808, 0.9756271390564124]}, "mutation_prompt": null}
{"id": "53e4030d-07d9-404e-84bc-70f3e61d57c3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = ((0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) + np.random.normal(0, 0.05)) * np.exp(-evaluations / (0.05 * self.budget))  # Changed line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce diversity by adjusting the inertia weight dynamically with a Gaussian perturbation based on evaluations.", "configspace": "", "generation": 59, "fitness": 0.34773282570229963, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.348 with standard deviation 0.278. And the mean value of best solutions found was 0.915 (0. is the best) with standard deviation 0.837.", "error": "", "parent_id": "a9c9cad4-833b-4422-bab8-bcf5fe6fad5f", "metadata": {"aucs": [0.13057946311708313, 0.17250504017442336, 0.7401139738153925], "final_y": [2.02354305649898, 0.7200028355364331, 1.5751516856955352e-13]}, "mutation_prompt": null}
{"id": "883f271f-c217-4bf4-af3f-3aec3a7f3ec2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(10 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))  # Changed line\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                trial_solution = best_solution + inertia_weight * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce cyclic variation in the inertia weight to enhance convergence by improving exploration and exploitation balance during optimization.", "configspace": "", "generation": 60, "fitness": 0.2197765526328679, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.220 with standard deviation 0.059. And the mean value of best solutions found was 0.454 (0. is the best) with standard deviation 0.338.", "error": "", "parent_id": "a9c9cad4-833b-4422-bab8-bcf5fe6fad5f", "metadata": {"aucs": [0.16234614474267384, 0.1958532981427945, 0.3011302150131354], "final_y": [0.861720607529904, 0.4654688350436909, 0.0335110717996002]}, "mutation_prompt": null}
{"id": "07f09d8e-b894-4190-88ca-ba2290b7e31a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.06))  # Changed line\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor  # Changed line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce adaptive movement by scaling inertia weight based on improvement trend.", "configspace": "", "generation": 61, "fitness": 0.762661697899501, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.763 with standard deviation 0.017. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "a9c9cad4-833b-4422-bab8-bcf5fe6fad5f", "metadata": {"aucs": [0.786537009190484, 0.754244234702635, 0.7472038498053839], "final_y": [2.3023076865573615e-09, 5.791023132185947e-14, 8.92351345775586e-14]}, "mutation_prompt": null}
{"id": "3f6d32af-2989-4011-b884-4762038b1034", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            random_prob = 0.1 + 0.05 * np.sin(2 * np.pi * evaluations / self.budget)  # Changed line\n            if np.random.rand() < random_prob:  # Changed line\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.06))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance adaptive exploration by dynamically adjusting the random trial probability to improve search diversification.", "configspace": "", "generation": 62, "fitness": 0.7544454384644627, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.754 with standard deviation 0.006. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "07f09d8e-b894-4190-88ca-ba2290b7e31a", "metadata": {"aucs": [0.7616409865956275, 0.7542137065965727, 0.7474816222011881], "final_y": [2.4664037433981906e-13, 2.327622073147857e-13, 5.939460476555027e-14]}, "mutation_prompt": null}
{"id": "13cc9f08-07de-4752-8329-be7349d1d6fd", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            reinit_prob = 0.15 + 0.1 * (no_improvement_counter / (self.budget * 0.06))  # Changed line\n            if np.random.rand() < reinit_prob:  # Changed line\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.06))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce adaptive exploration by dynamically adjusting the probability of random reinitialization based on performance trends.", "configspace": "", "generation": 63, "fitness": 0.7524120228638039, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.752 with standard deviation 0.003. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "07f09d8e-b894-4190-88ca-ba2290b7e31a", "metadata": {"aucs": [0.7552239761111628, 0.754244234702635, 0.7477678577776142], "final_y": [6.321219473255886e-09, 1.925117054746762e-13, 9.153189452750227e-10]}, "mutation_prompt": null}
{"id": "d86d9eb7-158e-43e7-bbfe-dbc3718f0780", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n        recent_improvement = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-recent_improvement / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.06))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n                recent_improvement += 1\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce dynamic adjustment of exploration factor based on recent improvements in solution quality to enhance search efficiency.", "configspace": "", "generation": 64, "fitness": 0.6639913509182818, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.664 with standard deviation 0.016. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "07f09d8e-b894-4190-88ca-ba2290b7e31a", "metadata": {"aucs": [0.6859324562589446, 0.6579020402336642, 0.6481395562622365], "final_y": [3.850138274822731e-10, 4.574034277016157e-10, 1.7907639354667288e-10]}, "mutation_prompt": null}
{"id": "98f00abe-6990-46da-a97d-fb79eadec37b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n        momentum = np.zeros(self.dim)  # Added line\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.06))\n                momentum = inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor + 0.1 * momentum  # Changed line\n                trial_solution = best_solution + momentum  # Changed line\n                \n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Integrate a dynamic momentum term to enhance convergence speed by increasing adaptability in solution updates.", "configspace": "", "generation": 65, "fitness": 0.7503342063967708, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.750 with standard deviation 0.016. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "07f09d8e-b894-4190-88ca-ba2290b7e31a", "metadata": {"aucs": [0.7285453049576397, 0.758660538546243, 0.7637967756864299], "final_y": [1.6336156478303397e-08, 9.88727943387371e-14, 8.673683449457779e-14]}, "mutation_prompt": null}
{"id": "1444b75c-2985-4bd5-af1c-126afda7b496", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.06))\n                # Changed line for adaptive mutation\n                trial_solution = best_solution + (inertia_weight * improvement_scale + 0.05 * np.sin(evaluations / self.budget * np.pi)) * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce adaptive mutation based on the rate of improvement to enhance exploration.", "configspace": "", "generation": 66, "fitness": 0.20176940964741072, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.202 with standard deviation 0.079. And the mean value of best solutions found was 0.991 (0. is the best) with standard deviation 0.957.", "error": "", "parent_id": "07f09d8e-b894-4190-88ca-ba2290b7e31a", "metadata": {"aucs": [0.30812751973058683, 0.1770763942968432, 0.12010431491480211], "final_y": [0.016739092940910884, 0.664775615355031, 2.2917175566372427]}, "mutation_prompt": null}
{"id": "cd863da7-31a3-46bd-80e5-e348a0b3d235", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            # Adjusted exploration factor calculation\n            improvement_rate = max(0, (self.budget * 0.06 - no_improvement_counter) / (self.budget * 0.06))\n            exploration_factor = (0.1 + 0.1 * improvement_rate * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.06))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce dynamic adjustment of exploration factor based on improvement rate to balance exploration-exploitation trade-off.", "configspace": "", "generation": 67, "fitness": 0.7562615440329189, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.756 with standard deviation 0.004. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "07f09d8e-b894-4190-88ca-ba2290b7e31a", "metadata": {"aucs": [0.7607190628900655, 0.7572431898450337, 0.7508223793636571], "final_y": [1.2041004692402054e-13, 1.196496813491032e-13, 2.1157967596001074e-13]}, "mutation_prompt": null}
{"id": "6fbd3a2d-7975-4b40-82a9-18b577853fe4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            # Changed line - use a chaotic map for exploration factor\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget)) * (1 + 0.5 * np.sin(evaluations)) \n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.06))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance diversity by introducing chaotic map-based exploration during early iterations.", "configspace": "", "generation": 68, "fitness": 0.7551957717789236, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.755 with standard deviation 0.005. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "07f09d8e-b894-4190-88ca-ba2290b7e31a", "metadata": {"aucs": [0.7486508882986582, 0.7563209989496128, 0.7606154280884996], "final_y": [1.0824995312771372e-13, 5.6278472547611197e-14, 1.1401720283978486e-13]}, "mutation_prompt": null}
{"id": "86a363fb-b0cd-4886-a155-afc8cc81ac61", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.06))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n            \n            if evaluations % (self.budget // 10) == 0:  # Changed line\n                best_solution = np.random.uniform(lb, ub, self.dim)  # Changed line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce periodic resetting of the best solution to mitigate premature convergence and explore new regions.", "configspace": "", "generation": 69, "fitness": 0.16225759058413272, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.162 with standard deviation 0.034. And the mean value of best solutions found was 0.720 (0. is the best) with standard deviation 0.316.", "error": "", "parent_id": "07f09d8e-b894-4190-88ca-ba2290b7e31a", "metadata": {"aucs": [0.15207409610993616, 0.12726318914078316, 0.20743548650167887], "final_y": [1.0652469403236648, 0.7942517291486975, 0.3013838234297672]}, "mutation_prompt": null}
{"id": "895421ce-7961-4ca8-9edd-14aecfd79520", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.2 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))  # Changed line\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.06))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration by introducing a dynamic, budget-scaled exploration factor for diverse solution sampling.", "configspace": "", "generation": 70, "fitness": 0.7456523837108567, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.746 with standard deviation 0.003. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "07f09d8e-b894-4190-88ca-ba2290b7e31a", "metadata": {"aucs": [0.7422024268045373, 0.7485132430063464, 0.7462414813216867], "final_y": [1.5762541996355114e-13, 8.102497332861847e-14, 9.039027676393575e-14]}, "mutation_prompt": null}
{"id": "29af487b-25d9-490d-a76a-5b33b6fd8b8c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.15:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.06)) \n                randomness_adjustment = np.random.normal(0, 0.1, self.dim)  # Changed line\n                trial_solution = best_solution + inertia_weight * improvement_scale * (1 + randomness_adjustment) * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor  # Changed line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhance exploration by dynamically adjusting randomness based on performance improvement and improving search space diversity.", "configspace": "", "generation": 71, "fitness": 0.7546619630865483, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.755 with standard deviation 0.006. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "07f09d8e-b894-4190-88ca-ba2290b7e31a", "metadata": {"aucs": [0.7512141127751504, 0.7637014382979543, 0.7490703381865402], "final_y": [6.63068227042496e-14, 1.9303329554477927e-13, 1.0762829452439704e-13]}, "mutation_prompt": null}
{"id": "c95e62ac-68c2-4644-bcce-995d87cf4575", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.10:  # Changed line\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.05))  # Changed line\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhancing selective exploration by introducing a dynamic adaptation of trial solution generation based on recent improvement trends.", "configspace": "", "generation": 72, "fitness": 0.7656503295066913, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.766 with standard deviation 0.008. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "07f09d8e-b894-4190-88ca-ba2290b7e31a", "metadata": {"aucs": [0.7558063113168878, 0.7754989019042877, 0.7656457752988987], "final_y": [8.642667958196474e-14, 1.392884027295479e-13, 1.2210362479759591e-13]}, "mutation_prompt": null}
{"id": "4fe9c7ff-a0a2-4449-82fd-b35ead017806", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.15 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))  # Changed line\n            inertia_weight = (0.85 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))  # Changed line\n            if np.random.rand() < 0.10:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.05))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introducing a refined adaptive mechanism to adjust exploration and inertia weights based on dynamic feedback from the optimization process.", "configspace": "", "generation": 73, "fitness": 0.7545174086658161, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.755 with standard deviation 0.005. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c95e62ac-68c2-4644-bcce-995d87cf4575", "metadata": {"aucs": [0.7539097811049522, 0.748357689111897, 0.7612847557805988], "final_y": [5.91078293105034e-14, 9.324935608336991e-09, 9.411079345631612e-14]}, "mutation_prompt": null}
{"id": "7a3da61e-dfdd-49cf-a9c7-abdc0dbc788c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.08 * self.budget))  # Changed line\n            if np.random.rand() < 0.15:  # Changed line\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.05))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Refine the exploration strategy by adjusting the inertia weight decay rate and random exploration probability for improved convergence.", "configspace": "", "generation": 74, "fitness": 0.6687220458807305, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.669 with standard deviation 0.027. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c95e62ac-68c2-4644-bcce-995d87cf4575", "metadata": {"aucs": [0.6322965100569797, 0.6792810182056996, 0.6945886093795118], "final_y": [2.944973032538666e-08, 2.4395637080359607e-11, 1.3946749855550477e-10]}, "mutation_prompt": null}
{"id": "11daa237-9156-45c2-9c8e-cabc232ffd64", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.cos(7 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))  # Changed line\n            inertia_weight = (0.9 + 0.1 * np.sin(6 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))  # Changed line\n            if np.random.rand() < 0.15:  # Changed line\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.08))  # Changed line\n                vector_scale = np.random.uniform(0.8, 1.2, self.dim)  # Changed line\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor * vector_scale  # Changed line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introducing probabilistic vector scaling and dynamic convergence acceleration to enhance solution refinement and global exploration balance.", "configspace": "", "generation": 75, "fitness": 0.44961757240103034, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.450 with standard deviation 0.104. And the mean value of best solutions found was 0.010 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "c95e62ac-68c2-4644-bcce-995d87cf4575", "metadata": {"aucs": [0.3049545266055187, 0.5469563054339777, 0.4969418851635947], "final_y": [0.02966470923959146, 3.2549900766557856e-05, 8.279527959204964e-05]}, "mutation_prompt": null}
{"id": "95a6177f-230c-4132-bbde-b3f208577c7c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            step_size = 0.5 * np.random.rand() + 0.5  # Changed line\n            if np.random.rand() < 0.10:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.05))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor * step_size  # Changed line\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n                    if np.random.rand() < 0.2:  # Changed line\n                        best_solution = trial_solution  # Changed line\n                        best_value = func(best_solution)  # Changed line\n                        no_improvement_counter = 0  # Changed line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduces adaptive step size control and stochastic restarts to enhance convergence rates.", "configspace": "", "generation": 76, "fitness": 0.3693260664767628, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.369 with standard deviation 0.296. And the mean value of best solutions found was 0.750 (0. is the best) with standard deviation 0.672.", "error": "", "parent_id": "c95e62ac-68c2-4644-bcce-995d87cf4575", "metadata": {"aucs": [0.18078097992276942, 0.13995245333562023, 0.7872447661718989], "final_y": [0.6178355369245544, 1.6311842520285451, 1.5916119602746012e-13]}, "mutation_prompt": null}
{"id": "98e15ffc-3b8b-47d0-9f91-331a37bf6557", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.10:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.05))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            \n            if evaluations % (self.budget // 10) == 0:  # Changed line\n                trial_solution = np.random.uniform(lb, ub, self.dim)  # Changed line\n            \n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introducing periodic full random reinitialization to escape local optima and enhance convergence.", "configspace": "", "generation": 77, "fitness": 0.463081256065813, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.463 with standard deviation 0.245. And the mean value of best solutions found was 0.229 (0. is the best) with standard deviation 0.324.", "error": "", "parent_id": "c95e62ac-68c2-4644-bcce-995d87cf4575", "metadata": {"aucs": [0.17516738723279446, 0.7742822302776642, 0.43979415068698047], "final_y": [0.6870277407701912, 1.870703728814474e-13, 0.0009619314688344081]}, "mutation_prompt": null}
{"id": "de221d07-6f45-4f20-93de-702bd76afde6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.15:  # Changed line\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.05))\n                dynamic_mutation = np.random.normal(0, 1, self.dim)  # Changed line\n                trial_solution = best_solution + inertia_weight * improvement_scale * dynamic_mutation * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introducing a dynamic mutation strategy to balance exploration and exploitation more effectively.", "configspace": "", "generation": 78, "fitness": 0.7623155903561437, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.762 with standard deviation 0.007. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c95e62ac-68c2-4644-bcce-995d87cf4575", "metadata": {"aucs": [0.7592183016050672, 0.7719483010815786, 0.7557801683817854], "final_y": [1.1322380686592395e-13, 2.1203775350098998e-13, 5.281186019575572e-09]}, "mutation_prompt": null}
{"id": "7c46fcf5-520e-46ec-8ccc-650988e7a282", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.15 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))  # Changed line\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.15:  # Changed line\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.05))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:  # Changed line\n                    best_solution = np.random.uniform(lb, ub, self.dim)  # Changed line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhancing exploration and convergence by introducing a dynamic improvement-triggered restart mechanism.", "configspace": "", "generation": 79, "fitness": 0.454249280727313, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.454 with standard deviation 0.218. And the mean value of best solutions found was 0.249 (0. is the best) with standard deviation 0.352.", "error": "", "parent_id": "c95e62ac-68c2-4644-bcce-995d87cf4575", "metadata": {"aucs": [0.4840516064464502, 0.7055960022272976, 0.17310023350819115], "final_y": [0.00020406065572312998, 1.8588671873610349e-07, 0.7468777535712167]}, "mutation_prompt": null}
{"id": "c3b95604-c932-4e60-950f-61cd6fbb940d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.15 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))  # Changed line\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.10:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.05))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Refined differential exploration by dynamically adjusting exploration factors to improve convergence.", "configspace": "", "generation": 80, "fitness": 0.7474444341397799, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.747 with standard deviation 0.005. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c95e62ac-68c2-4644-bcce-995d87cf4575", "metadata": {"aucs": [0.7416361138588704, 0.7461589579364105, 0.7545382306240589], "final_y": [7.514415883044178e-14, 1.6994918249328874e-13, 1.3134874072956948e-13]}, "mutation_prompt": null}
{"id": "630ca8ce-5b67-48c4-b696-df729df2b33f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.10 + 0.05 * np.sin(2 * np.pi * evaluations / self.budget):  # Changed line\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.05))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introducing adaptive randomization into exploration for enhancing convergence efficiency.", "configspace": "", "generation": 81, "fitness": 0.6522992604179663, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.652 with standard deviation 0.145. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c95e62ac-68c2-4644-bcce-995d87cf4575", "metadata": {"aucs": [0.44688434584566317, 0.7546889856282178, 0.7553244497800178], "final_y": [0.0005299430155742187, 1.7431214756954055e-13, 1.347019156285016e-12]}, "mutation_prompt": null}
{"id": "89cb0416-6f96-4742-b2da-ea344c6e0e58", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.10:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.05))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = best_solution + np.random.uniform(-0.05, 0.05, self.dim) * (ub - lb)  # Changed line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Improve search efficiency by incorporating a local search step around the best known solution when stagnation is detected.", "configspace": "", "generation": 82, "fitness": 0.5779616965046285, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.578 with standard deviation 0.290. And the mean value of best solutions found was 0.302 (0. is the best) with standard deviation 0.427.", "error": "", "parent_id": "c95e62ac-68c2-4644-bcce-995d87cf4575", "metadata": {"aucs": [0.1673069806334796, 0.7816945024093886, 0.7848836064710171], "final_y": [0.9064541839127329, 1.0174209829675261e-13, 6.180545059880967e-14]}, "mutation_prompt": null}
{"id": "67e9851c-b7d5-4808-a81f-c4e072ce7622", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n        \n        # Change 1: Initial performance diversity calculation\n        performance_diversity = np.std([func(np.random.uniform(lb, ub, self.dim)) for _ in range(5)])\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.10:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.05))\n                # Change 2: Adaptive mutation scaling using performance diversity\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-performance_diversity, performance_diversity, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n                # Update performance diversity\n                performance_diversity = np.std([func(np.random.uniform(lb, ub, self.dim)) for _ in range(5)])\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introducing adaptive mutation scaling based on performance diversity to enhance exploration while maintaining convergence stability.", "configspace": "", "generation": 83, "fitness": 0.545739363063285, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.546 with standard deviation 0.059. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c95e62ac-68c2-4644-bcce-995d87cf4575", "metadata": {"aucs": [0.46800698795317675, 0.5599079068063062, 0.609303194430372], "final_y": [2.1501774775458265e-07, 7.966140247978976e-10, 2.1474090840485438e-11]}, "mutation_prompt": null}
{"id": "9c761908-22ba-4186-b52a-6ed844ca9875", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.10:  # Changed line\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.05))  # Changed line\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06 or evaluations % (self.budget // 10) == 0:  # Reset periodically\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introducing a periodic reset mechanism to enhance exploration and avoid local minima entrapment.", "configspace": "", "generation": 84, "fitness": 0.17098764232883182, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.171 with standard deviation 0.065. And the mean value of best solutions found was 1.562 (0. is the best) with standard deviation 1.110.", "error": "", "parent_id": "c95e62ac-68c2-4644-bcce-995d87cf4575", "metadata": {"aucs": [0.1326671712025418, 0.1171640920814534, 0.2631316637025003], "final_y": [1.8531934477831573, 2.7524520876398695, 0.0807377890324379]}, "mutation_prompt": null}
{"id": "d63bfbac-aafa-4536-860f-2d9fc2e8ed9b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.10:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.05))\n                noise = np.random.normal(0, 0.01, self.dim)  # Changed line\n                trial_solution = best_solution + inertia_weight * improvement_scale * (np.random.uniform(-1, 1, self.dim) + noise) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introducing stochastic noise in selective exploration to enhance diversity and reduce premature convergence.", "configspace": "", "generation": 85, "fitness": 0.7591443654486544, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.759 with standard deviation 0.012. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c95e62ac-68c2-4644-bcce-995d87cf4575", "metadata": {"aucs": [0.7420875853048388, 0.7685612405249791, 0.7667842705161451], "final_y": [3.5172373902266103e-11, 1.5491639727839156e-13, 2.443644623990642e-13]}, "mutation_prompt": null}
{"id": "ce292212-76a1-46ee-9852-a3f2894258fb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initial population-based approach\n        population_size = 5\n        population = [np.random.uniform(lb, ub, self.dim) for _ in range(population_size)]\n        fitness_values = [func(individual) for individual in population]\n        best_index = np.argmin(fitness_values)\n        best_solution = population[best_index]\n        best_value = fitness_values[best_index]\n        evaluations = population_size\n        no_improvement_counter = 0\n        \n        while evaluations < self.budget:\n            # Adaptive exploration factor\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * (0.5 + 0.5 * (best_value / max(fitness_values))) * np.exp(-evaluations / (0.1 * self.budget))\n            # Fitness-based dynamic inertia\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * (1 - (best_value - min(fitness_values)) / (max(fitness_values) - min(fitness_values) + 1e-9)) * np.exp(-evaluations / (0.05 * self.budget))\n            \n            for i in range(population_size):\n                if np.random.rand() < 0.10:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n                else:\n                    improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.05))\n                    trial_solution = population[i] + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n                trial_solution = np.clip(trial_solution, lb, ub)\n                trial_value = func(trial_solution)\n                evaluations += 1\n\n                if trial_value < fitness_values[i]:\n                    population[i] = trial_solution\n                    fitness_values[i] = trial_value\n                    if trial_value < best_value:\n                        best_solution = trial_solution\n                        best_value = trial_value\n                        no_improvement_counter = 0\n                else:\n                    no_improvement_counter += 1\n                    if no_improvement_counter > self.budget * 0.06:\n                        population[i] = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Integrating adaptive population scaling and fitness-based dynamic inertia to refine exploration and convergence.", "configspace": "", "generation": 86, "fitness": 0.13094369339809986, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.131 with standard deviation 0.003. And the mean value of best solutions found was 1.609 (0. is the best) with standard deviation 0.236.", "error": "", "parent_id": "c95e62ac-68c2-4644-bcce-995d87cf4575", "metadata": {"aucs": [0.13452106204458214, 0.12842529602270247, 0.12988472212701496], "final_y": [1.8471005487166356, 1.288263673529827, 1.6929843131870557]}, "mutation_prompt": null}
{"id": "bb9deee1-4840-465c-adb9-e362c515a122", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.10: \n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.05))\n                if np.random.rand() > 0.5:  # Changed line\n                    inertia_weight *= 1.2  # Changed line\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    if np.random.rand() > 0.7:  # Changed line\n                        best_solution = np.random.uniform(lb, ub, self.dim)  # Changed line\n                    no_improvement_counter = 0  # Changed line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introducing adaptive inertia weight modulation and restart strategy to enhance search space exploration.", "configspace": "", "generation": 87, "fitness": 0.5368469197180267, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.537 with standard deviation 0.296. And the mean value of best solutions found was 0.858 (0. is the best) with standard deviation 1.213.", "error": "", "parent_id": "c95e62ac-68c2-4644-bcce-995d87cf4575", "metadata": {"aucs": [0.7236424006579179, 0.7679542523804602, 0.11894410611570183], "final_y": [2.036114878779305e-07, 1.4530339921522884e-13, 2.573441859486305]}, "mutation_prompt": null}
{"id": "ab6fec96-d776-4660-a315-de88b3519fae", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.10:  # Changed line\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = 1 - (no_improvement_counter / (self.budget * 0.05))  # Changed line\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim) + np.random.normal(0, 0.01, self.dim)  # Changed line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introducing a slight random perturbation to trial solutions if no improvement is observed for a while, enhancing exploration.", "configspace": "", "generation": 88, "fitness": 0.505036854016811, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.505 with standard deviation 0.262. And the mean value of best solutions found was 0.341 (0. is the best) with standard deviation 0.482.", "error": "", "parent_id": "c95e62ac-68c2-4644-bcce-995d87cf4575", "metadata": {"aucs": [0.5714236140913523, 0.7881260001061239, 0.1555609478529567], "final_y": [1.9567132054435493e-05, 9.554780200623355e-11, 1.0215209277432638]}, "mutation_prompt": null}
{"id": "bce301e0-e06e-40f2-8590-1fb845474cef", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            if np.random.rand() < 0.10:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = max(0.5, 1 - (no_improvement_counter / (self.budget * 0.05)))  # Changed line\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Refining solution update strategy by adjusting improvement scale weight to dynamically respond to prolonged stagnation periods. ", "configspace": "", "generation": 89, "fitness": 0.7671192009772634, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.767 with standard deviation 0.012. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "c95e62ac-68c2-4644-bcce-995d87cf4575", "metadata": {"aucs": [0.7813027473012448, 0.7689632104196836, 0.7510916452108616], "final_y": [1.7271123678930962e-13, 2.0568302409823994e-13, 9.659442485127304e-14]}, "mutation_prompt": null}
{"id": "d3b2b9d1-448f-48b1-813c-09434d0c46f2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n        successful_updates = 0\n        \n        while evaluations < self.budget:\n            success_ratio = successful_updates / evaluations if evaluations > 0 else 0\n            exploration_factor = (0.1 + 0.1 * np.sin(5 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))\n            inertia_weight = (0.8 + 0.1 * np.cos(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))\n            exploration_factor *= (1 + success_ratio)  # Change 1\n            inertia_weight *= (1 + success_ratio)  # Change 2\n            \n            if np.random.rand() < 0.10:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = max(0.5, 1 - (no_improvement_counter / (self.budget * 0.05)))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n                successful_updates += 1  # Change 3\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n        \n        # Removed unnecessary line (Change 4)\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce adaptive exploration and inertia weight tuning based on success ratio to enhance convergence robustness and efficiency.", "configspace": "", "generation": 90, "fitness": 0.4370382054667256, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.437 with standard deviation 0.216. And the mean value of best solutions found was 0.112 (0. is the best) with standard deviation 0.157.", "error": "", "parent_id": "bce301e0-e06e-40f2-8590-1fb845474cef", "metadata": {"aucs": [0.7233424736755567, 0.38504392589617376, 0.20272821682844633], "final_y": [3.4589729340397236e-13, 0.0028809990211955063, 0.3335893409238071]}, "mutation_prompt": null}
{"id": "d6490d1d-faf1-4d16-ac03-819532bbb46e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = np.random.uniform(0.05, 0.15) * np.exp(-evaluations / (0.1 * self.budget))  # Changed line\n            inertia_weight = np.random.uniform(0.7, 0.9) * np.exp(-evaluations / (0.05 * self.budget))  # Changed line\n            if np.random.rand() < 0.10:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = max(0.5, 1 - (no_improvement_counter / (self.budget * 0.05)))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Introduce dynamic adjustment of both exploration factor and inertia weight to enhance adaptability to the problem landscape.", "configspace": "", "generation": 91, "fitness": 0.1411934542431019, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.141 with standard deviation 0.021. And the mean value of best solutions found was 1.379 (0. is the best) with standard deviation 0.427.", "error": "", "parent_id": "bce301e0-e06e-40f2-8590-1fb845474cef", "metadata": {"aucs": [0.11907240645013095, 0.16991890844607682, 0.13458904783309789], "final_y": [1.7080826385819368, 0.7760348123271359, 1.6542311541642303]}, "mutation_prompt": null}
{"id": "89f0b971-8b2d-45fc-bca7-e08e003cced9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.15 + 0.1 * np.sin(6 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.08 * self.budget))  # Changed line\n            inertia_weight = (0.9 + 0.1 * np.cos(3 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.04 * self.budget))  # Changed line\n            if np.random.rand() < 0.10:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = max(0.5, 1 - (no_improvement_counter / (self.budget * 0.05)))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Improved solution update by dynamically adjusting the inertia weight and exploration factor to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 92, "fitness": 0.7940425248936464, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.794 with standard deviation 0.004. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "bce301e0-e06e-40f2-8590-1fb845474cef", "metadata": {"aucs": [0.7892044071075462, 0.7949390958268354, 0.7979840717465569], "final_y": [0.0, 0.0, 0.0]}, "mutation_prompt": null}
{"id": "587d588c-e711-438e-9e1c-09b08d24a94a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.15 + 0.1 * np.sin(6 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.08 * self.budget))\n            inertia_weight = (0.9 + 0.1 * np.cos(3 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.04 * self.budget))\n            if np.random.rand() < 0.10:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = max(0.5, 1 - (no_improvement_counter / (self.budget * 0.05)))\n                random_scaling = np.random.rand(self.dim)  # Changed line\n                trial_solution = best_solution + inertia_weight * improvement_scale * random_scaling * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Integrate adaptive random walk scaling for more efficient exploration during optimization.", "configspace": "", "generation": 93, "fitness": 0.13232421727754304, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.132 with standard deviation 0.007. And the mean value of best solutions found was 1.250 (0. is the best) with standard deviation 0.873.", "error": "", "parent_id": "89f0b971-8b2d-45fc-bca7-e08e003cced9", "metadata": {"aucs": [0.14030668678462932, 0.1322910372222471, 0.12437492782575266], "final_y": [0.5514243786527673, 0.7172517004972623, 2.480270531560925]}, "mutation_prompt": null}
{"id": "f8b3a075-4c42-4a0e-8fa3-2fc7b3da058f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.15 + 0.1 * np.sin(6 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))  # Changed line\n            inertia_weight = (0.9 + 0.1 * np.cos(3 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.04 * self.budget))\n            if np.random.rand() < 0.10:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = max(0.5, 1 - (no_improvement_counter / (self.budget * 0.05)))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhanced exploration by modifying exploration factor to balance exploration and exploitation effectively.", "configspace": "", "generation": 94, "fitness": 0.7798032705617516, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.780 with standard deviation 0.003. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "89f0b971-8b2d-45fc-bca7-e08e003cced9", "metadata": {"aucs": [0.7835508499453367, 0.7777760520615669, 0.7780829096783513], "final_y": [2.8414551360601765e-14, 0.0, 0.0]}, "mutation_prompt": null}
{"id": "2a90ec59-13c5-4774-be2e-15fdb4f920c6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.15 + 0.1 * np.sin(6 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.08 * self.budget))\n            inertia_weight = (0.9 + 0.1 * np.cos(3 * np.pi * evaluations / self.budget)) * np.exp(-evaluations**2 / (0.04 * self.budget**2))  # Changed line\n            if np.random.rand() < 0.10:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = max(0.5, 1 - (no_improvement_counter / (self.budget * 0.05)))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhanced exploration by adjusting the inertia weight decay function for improved convergence.", "configspace": "", "generation": 95, "fitness": 0.6794864019716425, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.679 with standard deviation 0.010. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "89f0b971-8b2d-45fc-bca7-e08e003cced9", "metadata": {"aucs": [0.6721002520442075, 0.6935031440974778, 0.6728558097732422], "final_y": [1.306784708452881e-12, 6.861688032495142e-12, 1.1416787485287541e-13]}, "mutation_prompt": null}
{"id": "f93f2c0f-97a4-46a9-9658-5ae8af634b6b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.12 + 0.08 * np.sin(4 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))  # Changed line\n            inertia_weight = (0.85 + 0.15 * np.cos(2 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.05 * self.budget))  # Changed line\n            if np.random.rand() < 0.10:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = max(0.5, 1 - (no_improvement_counter / (self.budget * 0.05)))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhanced exploration and exploitation balance by modifying dynamic parameter update strategies for improved convergence.", "configspace": "", "generation": 96, "fitness": 0.35870461412655796, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.359 with standard deviation 0.203. And the mean value of best solutions found was 0.179 (0. is the best) with standard deviation 0.134.", "error": "", "parent_id": "89f0b971-8b2d-45fc-bca7-e08e003cced9", "metadata": {"aucs": [0.22353585123410513, 0.2075197293993306, 0.6450582617462381], "final_y": [0.2154463612448892, 0.3219614199953958, 8.027840018375423e-07]}, "mutation_prompt": null}
{"id": "2d889f06-ff98-4f6e-97c7-4885d1d5c7a7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.15 + 0.1 * np.sin(6 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.08 * self.budget))  \n            inertia_weight = (0.5 + 0.4 * np.cos(3 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.04 * self.budget))  # Changed line\n            if np.random.rand() < 0.10:\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = max(0.5, 1 - (no_improvement_counter / (self.budget * 0.05)))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhanced solution exploration by modifying the inertia weight update mechanism to improve convergence behavior.", "configspace": "", "generation": 97, "fitness": 0.6665990077663161, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.667 with standard deviation 0.204. And the mean value of best solutions found was 0.001 (0. is the best) with standard deviation 0.002.", "error": "", "parent_id": "89f0b971-8b2d-45fc-bca7-e08e003cced9", "metadata": {"aucs": [0.378520726872972, 0.8148364201049675, 0.806439876321009], "final_y": [0.004309464906363033, 0.0, 5.0277499146345894e-14]}, "mutation_prompt": null}
{"id": "3db8e2a2-4ac1-456b-99fc-741f95d08e5f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.2 + 0.05 * np.sin(6 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.1 * self.budget))  # Changed line\n            inertia_weight = (0.85 + 0.15 * np.cos(3 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.06 * self.budget))  # Changed line\n            if np.random.rand() < 0.15:  # Changed line\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = max(0.6, 1 - (no_improvement_counter / (self.budget * 0.05)))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.05:  # Changed line\n                    best_solution = np.random.uniform(lb, ub, self.dim)  # Changed line\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhanced the exploration-exploitation balance and incorporated a random reset mechanism to prevent local optima stagnation.", "configspace": "", "generation": 98, "fitness": 0.39966324348838866, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.400 with standard deviation 0.088. And the mean value of best solutions found was 0.013 (0. is the best) with standard deviation 0.014.", "error": "", "parent_id": "89f0b971-8b2d-45fc-bca7-e08e003cced9", "metadata": {"aucs": [0.36583889780722545, 0.3123249567587205, 0.52082587589922], "final_y": [0.00712673352373991, 0.032043606575121446, 4.8498832729473744e-05]}, "mutation_prompt": null}
{"id": "8c5b14f5-e0d0-45c3-8725-6ad80b41b73c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialRandomWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = np.random.uniform(lb, ub, self.dim)\n        best_value = func(best_solution)\n        evaluations = 1\n        no_improvement_counter = 0\n\n        while evaluations < self.budget:\n            exploration_factor = (0.15 + 0.1 * np.sin(6 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.08 * self.budget))\n            inertia_weight = (0.9 + 0.1 * np.cos(3 * np.pi * evaluations / self.budget)) * np.exp(-evaluations / (0.04 * self.budget))\n            if np.random.rand() < (0.10 + 0.10 * (no_improvement_counter / (self.budget * 0.06))):  # Changed line\n                trial_solution = np.random.uniform(lb, ub, self.dim)\n            else:\n                improvement_scale = max(0.5, 1 - (no_improvement_counter / (self.budget * 0.05)))\n                trial_solution = best_solution + inertia_weight * improvement_scale * np.random.uniform(-1, 1, self.dim) * (ub - lb) * exploration_factor\n            trial_solution = np.clip(trial_solution, lb, ub)\n            trial_value = func(trial_solution)\n            evaluations += 1\n\n            if trial_value < best_value:\n                best_solution = trial_solution\n                best_value = trial_value\n                no_improvement_counter = 0\n            else:\n                no_improvement_counter += 1\n                if no_improvement_counter > self.budget * 0.06:\n                    trial_solution = np.random.uniform(lb, ub, self.dim)\n\n        return best_solution", "name": "AdaptiveDifferentialRandomWalk", "description": "Enhanced solution exploration by modifying the probability of global random jumps to adaptively increase exploration during stagnation.", "configspace": "", "generation": 99, "fitness": 0.7997550830383696, "feedback": "The algorithm AdaptiveDifferentialRandomWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.800 with standard deviation 0.007. And the mean value of best solutions found was 0.000 (0. is the best) with standard deviation 0.000.", "error": "", "parent_id": "89f0b971-8b2d-45fc-bca7-e08e003cced9", "metadata": {"aucs": [0.7971657693245378, 0.7930393703535191, 0.809060109437052], "final_y": [0.0, 0.0, 0.0]}, "mutation_prompt": null}
